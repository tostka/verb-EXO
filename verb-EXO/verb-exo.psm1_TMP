# verb-exo.psm1


  <#
  .SYNOPSIS
  verb-EXO - Powershell Exchange Online generic functions module
  .NOTES
  Version     : 7.1.1.0
  Author      : Todd Kadrie
  Website     :	https://www.toddomation.com
  Twitter     :	@tostka
  CreatedDate : 3/3/2020
  FileName    : verb-EXO.psm1
  License     : MIT
  Copyright   : (c) 3/3/2020 Todd Kadrie
  Github      : https://github.com/tostka
  REVISIONS
  * 4:38 PM 3/16/2020 public cleanup
  * 8:45 AM 3/3/2020 1.0.0.0 public cleanup
  * 9:52 PM 1/16/2020 cleanup
  * 11:36 AM 12/30/2019 ran vsc alias-expan
  * 10:55 AM 12/6/2019 Connect-EXO:added suffix to TitleBar tag for non-TOR tenants, also config'd a central tab vari
  * 5:14 PM 11/27/2019 repl $MFA code with get-TenantMFARequirement
  * 1:07 PM 11/25/2019 added 3-letter alias variants for connect & reconnect
  # 9:57 AM 11/20/2019 added Credential param to reconnect, with passthru.
  # 1:26 PM 11/19/2019 added MFA detection fr infastrings .ps1 globals
  * 10:10 AM 6/20/2019 added local $rgxExoPsHostName, swapped dxo to use the vari, added showdebug to rxo & cxo, added $pltPSS wplat dump to the import-pssession cmd block
  * 1:02 PM 11/7/2018 added Disconnect-PssBroken
  * 2:55 PM 10/11/2018 connect-exo: added pre sleep skip on tryno 1
  # 9:24 PM 7/16/2018 broad cleanup & tightening
  # 9:04 PM 7/11/2018 synced to tsksid-incl-ServerApp.ps1
  .DESCRIPTION
  verb-EXO - Powershell Exchange Online generic functions module
  .LINK
  https://github.com/tostka/verb-EXO
  #>


    $script:ModuleRoot = $PSScriptRoot ;
    $script:ModuleVersion = (Import-PowerShellDataFile -Path (get-childitem $script:moduleroot\*.psd1).fullname).moduleversion ;
    $runningInVsCode = $env:TERM_PROGRAM -eq 'vscode' ;

#*======v FUNCTIONS v======




#*------v add-EXOLicense.ps1 v------
function add-EXOLicense {
    <#
    .SYNOPSIS
    remove-EXOLicense.ps1 - Add a temporary o365 license from specified AADUser account. Returns updated MSOLUser object to pipeline.
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-07-13
    FileName    : add-EXOLicense.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell, ExchangeOnline, AzureAD, License
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 3:14 PM 5/30/2023 updated CBH; udpt CBH; consold 222+223 into 1 line; add pswl compliance; expanded demos ; rem'd unused
    * 3:52 PM 5/23/2023 implemented @rxo @rxoc split, (silence all connectivity, non-silent feedback of functions); flipped all r|cxo to @pltrxoC, and left all function calls as @pltrxo; generic'd the meta vari name ; general cleanup rem'd; added expanded licname to echo ; 
    * 4:11 PM 5/22/2023 flipped all lic status testing to use of test-exoislicensed ; logic fixes
    * 9:49 AM 5/19/2023 trimmed rem's; ++ adv func/pipeline supp ; shifted usr reso into thge process loop ; rem'd unused $TenantShortName; wrapped plts ; 
        rem'd END transcript stop - these are util functions: connectivity; transcription & control of logging should occur in the calling script/func, not the stripped down leaf function.
    * 3:37 PM 5/17/2023 added pltRXO support; replaced hard-coded LicenseSkuIds w dyn LicenseSkuKeys pulled from global Meta. Updated UserRole validator to modern; 
        added AADUser detect, deprected MSolUser; stripped out all logging & fancy connectivity, the pltRXO support provides enough to chain through existing creds ; 
        removed dangling xow support
    * 4:01 PM 4/19/2023 roughed in, untested EOM310 updates: pasted in generic services block, sub'd -exo -> -xo. No further testing.
    * 2:54 PM 12/21/2022 tested through non-debug of shared, no-add lic mbx ;  more recent retooling for EXOv2/MFA support/Loss of MSONLINE/MSOL module support/cmdlets around AADU status and licensure.
    * 2:29 PM 8/12/2022 sync'd back to last _func.ps1 chgs as well ; fixed inacc warning, when lic's all burned (was echo'ing failure to update usageloc, not lic fail).
    * 5:17 PM 3/23/2022 more retooling to remove msonline module dependance, and shift to AzureAD (crappy implementation GraphAPI) module
    * 1:50 PM 3/23/2022 hunting the VerbosePreference toggle midway through, found 2 more verbose tests lacking leading verbose = $($VerbosePreference -eq "Continue"); prefixed examples with PS>
    * 5:00 PM 3/22/2022 extensive rewrite: Sec mandate to disable all basic auth == complete loss of the long-standing MS MSOnline powershell module:
        net effect: have to reimplement & rewraite all verb-MsolNoun cmdlet calls into
        the new AzureAD module's equivelents (which fail to match msol cmdlets names,
        parameters, or even the data returned, and property names)
        - had to write 3 new functions, ground up, to reimplement loss of the 1-liner Set-MsolUserLicense cmdlet functions:
        - wrote verb-aad: add-AADUserLicense()
        - wrote verb-aad: remove-AADUserLicense()
        - wrote verb-aad: set-AADUserUsageLocation()
        - wrote verb-aad: get-AADlicensePlanList, to workaround loss of useful sku reporting from the prior equiv msol sku cmdlet (new output is unformatted json [facepalm])
        - rewrote most of the license testing & handling code in this verb-exo:Add-EXOLicense() (roughly 11:20am 3/21/2022 to 5:03 PM 3/22/2022, and I still have a verbose state bug to workout on this script).
    * 11:51 AM 3/2 1/2022 update: because *any* licenes, including worthless FLOWFREE, toggles IsLicensed:$true, logic below fails to detect the lack of an EXO lic.
    Have to splice over from get-mailboxuserStatus, that evaluates existing aaduser/msolu licenses against the ones that actually support a UserMailbox type.
    * 12:57 PM 1/31/2022 addded -ea 0 to gv PassStatus_$($tenorg) (spurious error suppress)
    * 2:14 PM 1/18/2022 updated Example 1 to include echo of the returned msolu.licenses value.
    * 12:08 PM 1/11/2022 ren add-EXOLicenseTemp -> add-EXOLicense ; add
    $XXXMETA.o365LicSkuExStd == EXCHANGESTANDARD (Office 365 Exchange Online Only
    ,commonly used for App Access) & stick in front of $LicenseSkuIds,
    $XXXMETA.o365LicSkuExStd; added examples with explicit cmdlines for the adds;
    spliced over UsageLocation test/assert code from add-o365license.
    * 1:34 PM 1/5/2022 init
    .DESCRIPTION
    remove-EXOLicense.ps1 - Add a temporary o365 license from specified AADUser account. Returns updated MSOLUser object to pipeline.
    .PARAMETER Ticket
    Ticket Number [-Ticket '999999']
    .PARAMETER TenOrg
    TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']
    .PARAMETER  users
    Array of UserPrincipalNames (or MSOLUser objects) to have a temporary Exchange License applied
    .PARAMETER LicenseSkuKeys
    Array, in preference order, of XXXMeta global value LicenseSkuKey names (resolves SKUId from TenOrg global Meta vari ; first working lic assignment, will be applied)[-LicenseSkuIds 'o365LicSkuExStd','o365LicSkuF1']
    .PARAMETER LicenseSkuIds
    Optional Array, in preference order, of LicenseSkuID (e.g. TenantName:SPE_F1) to be added, runs list until first sucess (default process is to dynamically resolve id's from Meta LicenseSkuKeys specifications)[-LicenseSkuIds @(`$XXXMETA.o365LicSkuExStd,`$XXXMETA.o365LicSkuF1)]
    .PARAMETER Force
    switch to override normal 'skipped' license application to existing Mailbox (needed for licensed-Shared, or upgraded existing lic).
    .PARAMETER UserRole
    Credential User Role spec (SID|CSID|UID|B2BI|CSVC)[-UserRole SID]
    .PARAMETER Credential
    Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]
    .PARAMETER silent
    Switch to specify suppression of all but warn/error echos.(unimplemented, here for cross-compat)
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER outObject
    switch to return a system.object summary to the pipeline[-outObject]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Microsoft.Online.Administration.User
    Returns updated MSOLUser object to pipeline
    .EXAMPLE
    PS> add-EXOLicense -users 'Test@domain.com','Test2@domain.com' -Ticket 999999 -Credential $pltrxo.Credential ; 
    Process an array of users, with default 'hunting' -LicenseSkuIds array.
    .EXAMPLE
    PS> $whatif = $false ;
    PS> $target = '999998,TestSharedMbxConversion@toro.com' ;
    PS> pushd;
    PS> $prpADU1 = 'UserPrincipalName','DisplayName',@{Name='IsLicensed'; Expression={[boolean]($_.AssignedLicenses.count -gt 0) }}  ;
    PS> $prpADU2 = @{Name='Licenses';Expression={($_ | Get-AzureADUserLicenseDetail).SkuPartNumber -join ','}} ;
    PS> if($target.contains(',')){
    PS>     $ticket,$trcp = $target.split(',') ;
    PS>     $pltAxLic = [ordered]@{
    PS>         users = $trcp ;
    PS>         ticket = $ticket ;
    PS>         whatif = $($whatif) ;
    PS>         Verbose = $false ;
    PS>         Credential  =  $credO365TORSIDCBA ;
    PS>         silent = $false ;
    PS>     } ;
    PS>     $smsg = "add-EXOLicense w`n$(($pltAxLic|out-string).trim())" ;
    PS>     if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    PS>     $updatedAadu = add-EXOLicense @pltAxLic ;
    PS>     write-verbose "re -refresh AADU" ;
    PS>     $updatedAadu  = get-AzureAdUser -obj $updatedAadu.UserPrincipalName ;
    PS>     $smsg = "UpdatedAadu: w`n$(($updatedAadu| ft -auto $prpADU1 |out-string).trim())" ;
    PS>     $smsg += "`n:$(($updatedAadu| fl $prpADU2 |out-string).trim())" ;
    PS>     write-host -foregroundcolor green $smsg ;
    PS> } else { write-warning "`$target does *not* contain comma delimited ticket,UPN string!"} ;    
    Fancier variant of above, with more post-confirm reporting
    .EXAMPLE
    PS> add-EXOLicense -users 'Test@domain.com' -LicenseSkuIds $XXXMETA.o365LicSkuExStd -ticket TICKETNUMBER;
    add an explicitly specified lic to a user (in this case, using the LicenseSku for EXCHANGESTANDARD, as stored in a global variable)
    .EXAMPLE
    PS> add-EXOLicense -users 'Test@domain.com' -LicenseSkuIds $XXXMETA.o365LicSkuF1 -ticket TICKETNUMBER;
    add an explicitly specified lic to a user (in this case, using the LicenseSku for SPE_F1 - web-only o365 - lic as stored in a global variable)
    .EXAMPLE
    PS> add-EXOLicense -users 'Test@domain.com' -LicenseSkuIds $XXXMETA.o365LicSkuE3 -ticket TICKETNUMBER ;
    add an explicitly specified lic to a user (in this case, using the LicenseSku for ENTERPRISEPACK - E3 o365 - lic as stored in a global variable)
    .EXAMPLE
    PS> add-EXOLicense -users 'Test@domain.com' -LicenseSkuIds 'TENANTNAME:EXCHANGESTANDARD' -ticket TICKETNUMBER ;
    add an explicitly specified lic to a user by specifying the Tenant-specific LicenseSkuID directly
    .EXAMPLE
    PS> add-EXOLicense -users 'Test@domain.com' -LicenseSkuIds @('TENANTNAME:EXCHANGESTANDARD',$XXXMETA.o365LicSkuF1) -ticket TICKETNUMBER ;
    Explicitly specify a preference order array of Tenant-specific LicenseSkuIDs (one string, another pulleed from Meta global vari; attempted in order until first success)
    .EXAMPLE
    PS> add-o365License -users $Aaduser.UserprincipalName -ticket TICKETNUMBER ;
    add-o365License compatibility option
    .LINK
    https://github.com/tostka/verb-exo
    #>
    # migr to verb-exo, pull the dupe spec...
    #Requires -Modules AzureAD, MSOnline, ExchangeOnlineManagement, verb-AAD, verb-Auth, verb-IO, verb-logging, verb-Mods, verb-Text
    #Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\s\regex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    #[Alias('add-o365License')]
    PARAM(
        [Parameter(Position=0,Mandatory=$False,ValueFromPipeline=$true,HelpMessage="Array of UserPrincipalNames (or AzureADUser objects) to have a temporary Exchange License applied")]
            #[ValidateNotNullOrEmpty()]
            #[Alias('ALIAS1', 'ALIAS2')]
            #[ValidatePattern("^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$")]
            [array]$users,
        [Parameter(Mandatory=$True,HelpMessage="Ticket Number [-Ticket '999999']")]
            [string]$Ticket,
        [Parameter(,HelpMessage="Array, in preference order, of XXXMeta global value LicenseSkuKey names (resolves SKUId from TenOrg global Meta vari ; first working lic assignment, will be applied)[-LicenseSkuIds 'o365LicSkuExStd','o365LicSkuF1']")]
            [ValidateNotNullOrEmpty()]
            [array]$LicenseSkuKeys=@('o365LicSkuExStd','o365LicSkuF1','o365LicSkuE3'),
        [Parameter(,HelpMessage="Optional Array, in preference order, of LicenseSkuID (e.g. TenantName:SPE_F1) to be added, runs list until first sucess (default process is to dynamically resolve id's from Meta LicenseSkuKeys specifications)[-LicenseSkuIds @(`$XXXMETA.o365LicSkuExStd,`$XXXMETA.o365LicSkuF1)]")]
            #[ValidateNotNullOrEmpty()]
            [array]$LicenseSkuIds = @(), 
        [Parameter(HelpMessage="switch to override normal 'skipped' license application to existing Mailbox (needed for licensed-Shared, or upgraded existing lic).[-Force]")]
            [switch] $Force,
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
            [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
            [switch] $useEXOv2=$true,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ; 
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ; 
                return $true ; 
            })]
            [string[]]$UserRole = @('SID','CSVC'),
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent,
        [Parameter(HelpMessage="switch to show extended debugging output [-showdebug]")]
            # included solely for backward compatibility with add-o365License()
            [switch] $showDebug,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
            [switch] $whatIf
    ) ;
    BEGIN{
        #region CONSTANTS-AND-ENVIRO #*======v CONSTANTS-AND-ENVIRO v======
        # function self-name (equiv to script's: $MyInvocation.MyCommand.Path) ;
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        # Get parameters this function was invoked with
        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
        $smsg = "(ParameterSetName $($PSCmdlet.ParameterSetName) is in effect)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        if(-not $rgxEmailAddr){ $rgxEmailAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$"}

        # recycling the inbound above into next call in the chain
        # downstream commands
        $pltRXO = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
        } ;
        if((gcm Reconnect-EXO).Parameters.keys -contains 'silent'){
            $pltRxo.add('Silent',$silent) ;
        } ;
        # default connectivity cmds - force silent false
        $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$true) ;
        if((gcm Reconnect-EXO).Parameters.keys -notcontains 'silent'){ $pltRxo.remove('Silent') } ; 

        #[array]$LicenseSkuIds = @() ; # moved to param , to permit direct lic spec when using indep of formal scripts
        if(-not $LicenseSkuIds){
            $smsg = "Retrieve & build LicenseSkuIDS from global Meta vari" ;  
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            $LicenseSkuKeys | foreach-object { $LicenseSkuIds += @((get-variable -name "$($tenorg)META").value[$_]) } ; 
        } else { 
            $smsg = "Explicit -LicenseSkuIds specified, using those licenses (in preference order)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            $LicenseSkuKeys = $LicenseSkuIds
        } ;

        $smsg = $sBnr="`n#*======v $(${CmdletName}) : v======" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        $admin = "$env:username" ;

        # check if using Pipeline input or explicit params:
        if ($PSCmdlet.MyInvocation.ExpectingInput) {
            $smsg = "Data received from pipeline input: '$($InputObject)'" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } else {
            # doesn't actually return an obj in the echo
            #$smsg = "Data received from parameter input: '$($InputObject)'" ;
            #if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            #else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ;

    } ;  # BEGIN-E
    PROCESS{
        
        $ttl = ($users|measure).count ; $Procd=0 ;
        [array]$Rpt =@() ;
        
        foreach ($usr in $users){

            switch($usr.GetType().FullName){
                'Microsoft.Online.Administration.User' {
                    #$smsg = "(-user:MsolU detected:$($usr.userprincipalname), extracting the UPN...)" ;
                    $smsg = "MSOLUSER OBJECT IS NO LONGER SUPPORTED BY THIS FUNCTION!" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $usr = $usr.userprincipalname ;
                } ;
                'Microsoft.Open.AzureAD.Model.User' {
                    $smsg = "(-user:AzureADU detected)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $usr = $usr.userprincipalname ;
                } ;
                'System.String'{
                    $smsg = "(-user:string detected)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    if($usr -match $rgxEmailAddress){

                        $smsg = "(-user:EmailAddress/UPN detected:$($usr))" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $usr = $usr ;
                    } else {
                        $smsg = "-Users: Unable to recognize either an AzureAD user object, or a UPN string, from the specified input:`n$($usr)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        break ; 
                    } ; 
                }
                default{
                    $smsg = "Unrecognized format for -User:$($usr)!. Please specify either a user UPN, or pass a full MsolUser object." ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Break ;
                }
            } ;
            
            $tUPN=$usr ;
            #$LicenseSkuIds=$XXXMETA.o365LicSkuF1; # dyn from global XXXmeta
            $error.clear() ;
            TRY {

                $Exit = 0 ;
                Do {
                    Try {
                        connect-aad @pltRXOC ; 
                        $AADUser=$null ;
                        #$TenantShortName = ((Get-AzureADTenantDetail).verifieddomains |?{$_._default}).name.split('.')[0] ;
                        $pltGAADU=[ordered]@{ 
                            ObjectId = $tUPN ;
                            ErrorAction = 'STOP' ;
                            verbose = $($VerbosePreference -eq "Continue") ;
                        } ;
                        $AADUser = Get-AzureADUser @pltGAADU ;
                        $Exit = $Retries ;
                    } CATCH {
                        Start-Sleep -Seconds $RetrySleep ;
                        $Exit ++ ;
                        $smsg = "Failed to exec cmd because: $($Error[0])" ;
                        $smsg += "`nTry #: $Exit" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        If ($Exit -eq $Retries) {
                            $smsg =  "Unable to exec cmd!" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ;
                        Continue ;
                    }  ;
                } Until ($Exit -eq $Retries) ;

                # confirm/set UsageLoc (reqd for updates)
                if (-not $AADUser.UsageLocation) {
                    $smsg = "AADUser: MISSING USAGELOCATION, FORCING" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $spltSAADUUL = [ordered]@{
                        Users = $AADUser.UserPrincipalName ;
                        UsageLocation = "US" ;
                        whatif = $($whatif) ;
                        Credential = $pltRXO.Credential ;
                        verbose = $pltRXO.verbose  ;
                        silent = $false ;
                    } ;
                    $smsg = "set-AADUserUsageLocationw`n$(($spltSAADUUL|out-string).trim())" ;
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                    $bRet = set-AADUserUsageLocation @spltSAADUUL ;
                    if($bRet.Success){
                        $smsg = "set-AADUserUsageLocation updated UsageLocation:$($bRet.AzureADuser.UsageLocation)" ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        # update the local AADUser to reflect the updated AADU returned
                        $AADUser = $bRet.AzureADuser ;
                        #$Report.FixedUsageLocation = $true ;
                    } else {
                        $smsg = "set-AADUserUsageLocation: FAILED TO UPDATE USAGELOCATION!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #$Report.FixedUsageLocation = $false ;
                        if(-not $whatif){
                            BREAK;
                        }
                    } ;
                } ;
                #

                # if lic'd and has a mailbox, shouldn't need a new license
                # w shift from msol -> aad, $aadU doesn 't even *have* an islicensed property! Have to interpolate:
                # nope!: IsLicensed:true, even if nothing but FLOWFREE is set. Worthless, for determining why there's no mailbox.
                # have to splice over the full exolic-testing code from verb-ex2010:get-mailboxUserStatus():

                # 8:44 AM 12/21/2022 no, use the verb-EXO:test-EXOIsLicensed(): test-EXOIsLicensed -User $AADUser -verbose
                $IsExoLicensed = test-EXOIsLicensed -User $AADUser -Credential:$pltRXO.Credential -verbose:$pltRXO.verbose -silent:$pltRXO.silent ;
                $pltGLPList=[ordered]@{ 
                    TenOrg= $TenOrg;
                    verbose=$($VerbosePreference -eq "Continue") ;
                    credential= $pltRXO.credential ;
                    silent = $false ; 
                } ;
                $smsg = "$($tenorg):get-AADlicensePlanList wn$(($pltGLPList|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $skus = $null ;
                $skus = get-AADlicensePlanList @pltGLPList ;

                $ombx = get-xomailbox -id $AADUser.UserPrincipalName -ea continue  ;
                $ombx = $ombx | ?{$_ -is [System.Management.Automation.PSObject]} # filtering any aberrant obj returned (legacy of prior problematic xow reliance to work around hybrid stepable pipeline bug)
                $AADLicDetails = get-AADUserLicenseDetails -UPNs $AADUser.userprincipalname -Credential:$pltRXO.Credential -verbose:$pltRXO.verbose -silent:$pltRXO.silent ; 
                $smsg = "`nExisting Mbx:`n$(($ombx | ft -a 'RecipientType','RecipientTypeDetails'|out-string).trim())" ;
                if($AADLicDetails){
                    $smsg += "`n`$AADLicDetails`n$(($AADLicDetails|out-string).trim())" ;
                } else { 
                    $smsg += "`n`$AADLicDetails:(empty return)" ;
                } ; 
                if($ombx.RecipientTypeDetails -eq 'SharedMailbox'){
                    $smsg += "`nSharedMailbox does not *require* a license" ;
                } ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                #if( -not($Force) -AND $ombx){
                <#if( -not($Force) -AND ($ombx.RecipientTypeDetails -eq 'SharedMailbox') ){
                    $smsg += "`n -- SKIPPING EXO-RELATED LICENSE ADD! --" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                } else
                #>
                if( (-not $IsExoLicensed) -OR ($Force) ){
                    # not supported on aadu: defer to: verb-AAD:test-AADUserIsLicensed(): $isLicensed = test-AADUserIsLicensed -user $AzureADUser -verbose
                    if($IsAADIsLicensed = test-AADUserIsLicensed -user $AADUser -Verbose:($VerbosePreference -eq 'Continue')){
                        # has a bozo lic that doesn't support a mailbox
                        $smsg = "AADUser:$($tUPN):  isLicensed (has some form of license added), but has *NO* EXO UserMailbox-supporting license!" ;
                        $smsg += "`n(or is being -Force upgraded to an elevated license)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $smsg="confirmed $($AADUser.UserPrincipalName):is unlicensed/underlicensed" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    # 9:55 AM 11/15/2019 per BB: apply a license, and notify lic staff to record
                    
                    # Set-AzureADUserLicense  vers
                    $pltALic=[ordered]@{
                        UserPrincipalName=$AADUser.userprincipalname ;
                         AssignedLicenses=$null ;
                    } ;

                    foreach($LicenseSkuId in $LicenseSkuIds){
                        if( $LicenseSkuId.contains(':') ){
                            $LicenseSkuId = $LicenseSkuId.split(':')[1] ;
                            # need the skuid, not the name, could pull another licplan list indexedonName, but can also post-filter the hashtable, and get it.
                            $LicenseSkuId = ($skus.values | ?{$_.SkuPartNumber -eq $LicenseSkuId}).skuid ;
                        } ;
                        #$smsg = "(attempting license:$($LicenseSkuId)...)" ;
                        $smsg = "(attempting license:$(($skus.values | ?{$_.Skuid -eq $LicenseSkuId}).SkuPartNumber):$($LicenseSkuId)...)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        $pltAAADUL=[ordered]@{
                            Users=$AADUser.UserPrincipalName ;
                            skuid=$LicenseSkuId ;
                            Credential = $pltRXO.Credential ; 
                            verbose = $pltRXO.verbose  ; 
                            silent = $false ; 
                            erroraction = 'STOP' ;
                            whatif = $($whatif) ;
                        } ;
                        $smsg = "add-AADUserLicense w`n$(($pltAAADUL|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        $bRet = add-AADUserLicense @pltAAADUL ;
                        if($bRet.Success){
                            $smsg = "add-AADUserLicense added  Licenses:$($bRet.AddedLicense)" ;
                            # $AADUser.AssignedLicenses.skuid
                            $smsg += "`n$(($AADUser.AssignedLicenses.skuid|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            $smsg = "Detailed Return:`n$(($bRet|out-string).trim())" ;
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            BREAK ; # abort further loops if one successfully applied
                        } elseif($whatif){
                            $smsg = "(whatif pass, exec skipped), " ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } elseif( -not [boolean]($bRet.AddedLicenses)){
                            # failed add
                            $smsg = "Failed Lic Add:$($LicenseSkuId) (exhausted units?, moving on to next if avail...)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Continue ;
                        } else {
                            $smsg = "add-AADUserLicense : UNAVAIL LIC UNIT, OR FAILED TO UPDATE USAGELOCATION!" ;
                            $smsg += "`n$(($bRet|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #$Report.FixedUsageLocation = $false ;
                            if(-not $whatif){
                                BREAK;
                            }
                        } ;

                    } ;  # loop-E $LicenseSkuIds

                };  # if-E $ombx
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                $smsg += "`n$($ErrTrapd.Exception.Message)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                BREAK ;
            } ; 
            if(!$whatif){
                $smsg = "dawdling until License reinflates mbx..." ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $1F=$false ;
                Do {
                    if($1F){Sleep -s 30} ;
                    write-host "." -NoNewLine ;
                    $1F=$true ;
                } Until ($ombx = get-xomailbox -id $AADUser.userprincipalname -EA 0) ; # capture return (prevent from dropping into pipe)
                # get-xomailbox returns: System.Management.Automation.PSObject; not a real Mailbox object class
                $ombx = $ombx | ?{$_ -is [System.Management.Automation.PSObject]} ; # looks like an attempt to filter just the mailbox out of the pipeline return
                $smsg = "xo Mailbox confirmed!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;

            # return $AADUser to pipeline if populated
            $smsg = "refresh updated AADUser:" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

            $pltGAADU.ObjectId = $AADUser.UserPrincipalName ;
            TRY {
                $AADUser = Get-AzureADUser @pltGAADU ;
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                $smsg += "`n$($ErrTrapd.Exception.Message)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                BREAK ;
            } ; 

            $smsg = "Return updated AADUser to pipeline" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            $AADUser | write-output ;

            $smsg =  $sBnr.replace('=v','=^').replace('v=','^=') ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; # ($usr in $users)

    } # PROC-E
    END{

    } ;
 }

#*------^ add-EXOLicense.ps1 ^------


#*------v check-EXOLegalHold.ps1 v------
Function check-EXOLegalHold {
    <#
    .SYNOPSIS
    check-EXOLegalHold - check passed in EXO mailbox object for Legal Hold status
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 12:36 PM 11/6/2020
    FileName    :
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,Legal
    REVISIONS   :
    * 2:40 PM 12/10/2021 more cleanup 
    * 11:23 AM 9/16/2021 string
    * 8:24 AM 8/27/2021 cleanedup 
    * 1:23 PM 5/14/2021 init version, roughed in, completely untested (was prev a largely unmodified dupe of disconnect-exo)
    .DESCRIPTION
    check-EXOLegalHold - check passed in EXO mailbox object for Legal Hold status
    
    # chk mbx-level holds
      Rxo ; 
      +[SIDS]::[PS]:C:\u\w\e\scripts$ get-exomailbox USERUPN | FL LitigationHoldEnabled,InPlaceHolds
      LitigationHoldEnabled : False
      InPlaceHolds          : {}
      # expand per arti
      +[SIDS]::[PS]:C:\u\w\e\scripts$ get-exomailbox USERUPN  | Select-Object -ExpandProperty InPlaceHolds
      # nothing

      # check for org hold
      +[SIDS]::[PS]:C:\u\w\e\scripts$ Get-exoOrganizationConfig | FL InPlaceHolds
      InPlaceHolds : {}
      # expand spec
      +[SIDS]::[PS]:C:\u\w\e\scripts$ Get-exoOrganizationConfig | select -expand InPlaceHolds
      # nothing
      # check compliancetaghold (per above)
      +[SIDS]::[PS]:C:\u\w\e\scripts$ get-exomailbox USERUPN  |FL ComplianceTagHoldApplied
      ComplianceTagHoldApplied : False

      No holds above.

      # eDiscovery holds – appears to require the GUID from one of the blank values above.(can't check)
      If had it, my run on the details would be:
      connect-ccms ; 
      $CaseHold = Get-ccCaseHoldPolicy <hold GUID without prefix> ; 
      Get-ccComplianceCase $CaseHold.CaseId | FL Name ; 
      $CaseHold | FL Name,ExchangeLocation ; 
      Get-exoMailboxSearch -InPlaceHoldIdentity <hold GUID> | FL Name,SourceMailboxes
      # check RetentionCompliancePolicy
      Get-ccRetentionCompliancePolicy <hold GUID without prefix or suffix> -DistributionDetail  | FL Name,*Location

      # check compliancetaghold in mbx:
      +[SIDS]::[PS]:C:\u\w\e\scripts$ get-exomailbox USERUPN  |FL ComplianceTagHoldApplied
      ComplianceTagHoldApplied : False

      Erm, did anyone *read* the following on holds in the above article?:
      This appears to be *routine* behavior per section…

        Managing mailboxes on delay hold  - https://docs.microsoft.com/en-us/microsoft-365/compliance/identify-a-hold-on-an-exchange-online-mailbox?view=o365-worldwide#managing-mailboxes-on-delay-hold
 
        After any type of hold is removed from a mailbox, a delay hold is applied. This means that the actual removal of the hold is delayed for 30 days to prevent data from being permanently deleted (purged) from the mailbox. This gives admins an opportunity to search for or recover mailbox items that will be purged after a hold is removed. A delay hold is placed on a mailbox the next time the Managed Folder Assistant processes the mailbox and detects that a hold was removed. Specifically, a delay hold is applied to a mailbox when the Managed Folder Assistant sets one of the following mailbox properties to True:
                · DelayHoldApplied: This property applies to email-related content (generated by people using Outlook and Outlook on the web) that's stored in a user's mailbox.
                · DelayReleaseHoldApplied: This property applies to cloud-based content (generated by non-Outlook apps such as Microsoft Teams, Microsoft Forms, and Microsoft Yammer) that's stored in a user's mailbox. Cloud data generated by a Microsoft app is typically stored in a hidden folder in a user's mailbox.
        When a delay hold is placed on the mailbox (when either of the previous properties is set to True), the mailbox is still considered to be on hold for an unlimited hold duration, as if the mailbox was on Litigation Hold. After 30 days, the delay hold expires, and Microsoft 365 will automatically attempt to remove the delay hold (by setting the DelayHoldApplied or DelayReleaseHoldApplied property to False) so that the hold is removed. After either of these properties are set to False, the corresponding items that are marked for removal are purged the next time the mailbox is processed by the Managed Folder Assistant.
        To view the values for the DelayHoldApplied and DelayReleaseHoldApplied properties for a mailbox, run the following command in Exchange Online PowerShell.

      # checking the above:
      +[SIDS]::[PS]:C:\u\w\e\scripts$ get-exomailbox USERUPN  | FL *HoldApplied*
      ComplianceTagHoldApplied : False
      DelayHoldApplied         : True
      DelayReleaseHoldApplied  : True
      
    .PARAMETER  ProxyEnabled
    Use Proxy-Aware SessionOption settings [-ProxyEnabled]
    .PARAMETER  CommandPrefix
    [verb]-PREFIX[command] PREFIX string for clearly marking cmdlets sourced in this connection [-CommandPrefix tag]
    .PARAMETER  Credential
    Credential to use for this connection [-credential 'SOMEACCT@DOMAIN.COM']
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    check-EXOLegalHold
    Connect using defaults, and leverage any pre-set $global:credo365TORSID variable
    .EXAMPLE
    check-EXOLegalHold -CommandPrefix exo -credential (Get-Credential -credential user@domain.com)  ;
    Connect an explicit credential, and use 'exolab' as the cmdlet prefix
    .EXAMPLE
    $cred = get-credential -credential $o365_Torolab_SIDUpn ;
    check-EXOLegalHold -credential $cred ;
    Pass in a prefab credential object (useful for auto-shifting to MFA - the function will autoresolve MFA reqs based on the cred domain)
    .LINK
    https://social.technet.microsoft.com/Forums/msonline/en-US/f3292898-9b8c-482a-86f0-3caccc0bd3e5/exchange-powershell-monitoring-remote-sessions?forum=onlineservicesexchange
    .LINK
    https://github.com/JeremyTBradshaw
    #>
    ##Requires -Modules ActiveDirectory,verb-Auth,verb-IO,verb-Mods,verb-Text,verb-Network,verb-AAD,verb-ADMS,verb-Ex2010,verb-logging

    [CmdletBinding()]
    PARAM(
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="EXO Mailbox identifier[-mailbox 'xxx']")]
        [ValidateNotNullOrEmpty()]$Mailbox,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2
    ) ;
    BEGIN {
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        # shifting from ps1 to a function: need updates self-name:
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        #-=-=configure EXO EMS aliases to cover useEXOv2 requirements-=-=-=-=-=-=
        # have to preconnect, as it gcm's the targets
        if ($script:useEXOv2) { reconnect-eXO2 }
        else { reconnect-EXO } ;
        # in this case, we need an alias for EXO, and non-alias for EXOP
        [array]$cmdletMaps = 'ps1GetxRcp;get-exorecipient;','ps1GetxMbx;get-exomailbox;','ps1SetxMbx;Set-exoMailbox;','ps1GetxUser;get-exoUser;',
            'ps1SetxCalProc;set-exoCalendarprocessing;','ps1GetxCalProc;get-exoCalendarprocessing;','ps1GetxMbxFldrPerm;get-exoMailboxfolderpermission;',
            'ps1GetxAccDom;Get-exoAcceptedDomain;','ps1GetxRetPol;Get-exoRetentionPolicy','ps1GetxDistGrp;get-exoDistributionGroup;',
            'ps1GetxDistGrpMbr;get-exoDistributionGroupmember;','ps1GetxMsgTrc;get-exoMessageTrace;','ps1GetxMsgTrcDtl;get-exoMessageTraceDetail;',
            'ps1GetxMbxFldrStats;get-exoMailboxfolderStatistics','ps1GetxMContact;Get-exomailcontact;','ps1SetxMContact;Set-exomailcontact;',
            'ps1NewxMContact;New-exomailcontact;' ,'ps1TestxMapi;Test-exoMAPIConnectivity','ps1GetxOrgCfg;Get-exoOrganizationConfig' ;
        foreach($cmdletMap in $cmdletMaps){
            if($script:useEXOv2){
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1].replace('-exo','-xo') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
            } else {
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;                
                write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
            } ;
        } ;
    
        # shifting from ps1 to a function: need updates self-name:
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;

        #$sBnr="#*======v START PASS:$($ScriptBaseName) v======" ; 
        $sBnr="#*======v START PASS:$(${CmdletName}) v======" ; 
        $smsg= $sBnr ;   
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        # Clear error variable
        $Error.Clear() ;
        

    } ;  # BEGIN-E
    PROCESS {
        $error.clear() ;
        TRY {
            $objReturn=[ordered]@{
                Held=$false ; 
                LitigationHoldEnabled=$null ; 
                InPlaceHolds =$null ; 
                ComplianceTagHoldApplied =$null ; 
                DelayHoldApplied =$null ; 
                DelayReleaseHoldApplied =$null ; 
                OrgInPlaceHolds =$null ; 
            } ; 
            $xmbx = ps1GetxMbx -id $Mailbox -ea STOP; 
            $xOrgCfgInPlaceHolds = ps1GetxOrgCfg -ea STOP | select -expand InPlaceHolds
            if($xmbx.LitigationHoldEnabled){
                $objReturn.Held=$true ;
                $objReturn.LitigationHoldEnabled = $xmbx.LitigationHoldEnabled;
            } ; 
            if($xmbx.ComplianceTagHoldApplied){
                $objReturn.Held=$true ;
                $objReturn.ComplianceTagHoldApplied = $xmbx.ComplianceTagHoldApplied;
            } ; 
            if($xmbx.DelayHoldApplied){
                $objReturn.Held=$true ;
                $objReturn.DelayHoldApplied = $xmbx.DelayHoldApplied;
            } ; 
            if($xmbx.DelayReleaseHoldApplied){
                $objReturn.Held=$true ;
                $objReturn.DelayReleaseHoldApplied = $xmbx.DelayReleaseHoldApplied;
            } ; 
            # checking orgs: Get-exoOrganizationConfig | FL InPlaceHolds
            # reportedly expanding InPlaceHolds will return a list of mbxs, but I can't find an example of the actual return, to try to test for it.
            if(xOrgCfgInPlaceHolds){
                $objReturn.Held=$true ;
                $objReturn.OrgInPlaceHolds = $xOrgCfgInPlaceHolds;
                $smsg = "$(${CmdletName}):detected $((get-alias ps1GetxOrgCfg).definition).OrgInPlaceHolds`nbut the function is not currently written to *expand and compare* the value contents`n(requires a code update to properly work with the sample returned)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 

        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ; 
    } ;  # PROC-E
    END {
        $objReturn | write-output ; 
    } ;  # END-E
}

#*------^ check-EXOLegalHold.ps1 ^------


#*------v Connect-ExchangeOnlineTargetedPurge.ps1 v------
function Connect-ExchangeOnlineTargetedPurge {
<#
.SYNOPSIS
Connect-ExchangeOnlineTargetedPurge.ps1 - Tweaked version of the Exchangeonline module:connect-ExchangeOnline(), uses variant RemoveExistingPSSession() - RemoveExistingPSSessionTargeted - to avoid purging CCMW sessions on connect. Intent is to permit *concurrent* EXO & CCMS sessions.
.NOTES
Version     : 1.0.0
Author      : Todd Kadrie
Website     :	http://www.toddomation.com
Twitter     :	@tostka / http://twitter.com/tostka
CreatedDate : 20201109-0833AM
FileName    : Connect-ExchangeOnlineTargetedPurge.ps1
License     : [none specified]
Copyright   : [none specified]
Github      : https://github.com/tostka/verb-XXX
Tags        : Powershell
AddedCredit : Microsoft (edited version of published commands in the module)
AddedWebsite:	https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
REVISIONS
* 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
# 8:34 AM 3/31/2021 added verbose suppress to all import-mods
* 8:34 AM 11/9/2020 init
.DESCRIPTION
Connect-ExchangeOnlineTargetedPurge.ps1 - Tweaked version of the Exchangeonline module:connect-ExchangeOnline(), uses variant RemoveExistingPSSession() to avoid purging CCMW sessions on connect. Intent is to permit *concurrent* EXO & CCMS sessions.
.PARAMETER ConnectionUri
Connection Uri for the Remote PowerShell endpoint
.PARAMETER AzureADAuthorizationEndpointUri = '',
Azure AD Authorization endpoint Uri that can issue the OAuth2 access tokens
.PARAMETER ExchangeEnvironmentName = 'O365Default',
Exchange Environment name
.PARAMETER PSSessionOption
PowerShell session options to be used when opening the Remote PowerShell session
.PARAMETER BypassMailboxAnchoring
Switch to bypass use of mailbox anchoring hint.
.PARAMETER DelegatedOrganization
Delegated Organization Name
.PARAMETER Prefix
Prefix 
.PARAMETER ShowBanner
Show Banner of Exchange cmdlets Mapping and recent updates
.PARAMETER ShowDebug
Parameter to display Debugging messages [-ShowDebug switch]
.INPUTS
None. Does not accepted piped input.
.OUTPUTS
None. Returns no objects or output.
.EXAMPLE
.EXAMPLE
.LINK
https://github.com/tostka/verb-EXO
.LINK
https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
#>
    [CmdletBinding()]
    param(

        # Connection Uri for the Remote PowerShell endpoint
        [string] $ConnectionUri = '',

        # Azure AD Authorization endpoint Uri that can issue the OAuth2 access tokens
        [string] $AzureADAuthorizationEndpointUri = '',

        # Exchange Environment name
        [Microsoft.Exchange.Management.RestApiClient.ExchangeEnvironment] $ExchangeEnvironmentName = 'O365Default',

        # PowerShell session options to be used when opening the Remote PowerShell session
        [System.Management.Automation.Remoting.PSSessionOption] $PSSessionOption = $null,

        # Switch to bypass use of mailbox anchoring hint.
        [switch] $BypassMailboxAnchoring = $false,

        # Delegated Organization Name
        [string] $DelegatedOrganization = '',

        # Prefix 
        [string] $Prefix = '',

        # Show Banner of Exchange cmdlets Mapping and recent updates
        [switch] $ShowBanner = $true
    )
    DynamicParam
    {
        if (($isCloudShell = IsCloudShellEnvironment) -eq $false)
        {
            $attributes = New-Object System.Management.Automation.ParameterAttribute
            $attributes.Mandatory = $false

            $attributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $attributeCollection.Add($attributes)

            # User Principal Name or email address of the user
            $UserPrincipalName = New-Object System.Management.Automation.RuntimeDefinedParameter('UserPrincipalName', [string], $attributeCollection)
            $UserPrincipalName.Value = ''

            # User Credential to Logon
            $Credential = New-Object System.Management.Automation.RuntimeDefinedParameter('Credential', [System.Management.Automation.PSCredential], $attributeCollection)
            $Credential.Value = $null

            # Switch to collect telemetry on command execution. 
            $EnableErrorReporting = New-Object System.Management.Automation.RuntimeDefinedParameter('EnableErrorReporting', [switch], $attributeCollection)
            $EnableErrorReporting.Value = $false
            
            # Where to store EXO command telemetry data. By default telemetry is stored in the directory "%TEMP%/EXOTelemetry" in the file : EXOCmdletTelemetry-yyyymmdd-hhmmss.csv.
            $LogDirectoryPath = New-Object System.Management.Automation.RuntimeDefinedParameter('LogDirectoryPath', [string], $attributeCollection)
            $LogDirectoryPath.Value = ''

            # Create a new attribute and valiate set against the LogLevel
            $LogLevelAttribute = New-Object System.Management.Automation.ParameterAttribute
            $LogLevelAttribute.Mandatory = $false
            $LogLevelAttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $LogLevelAttributeCollection.Add($LogLevelAttribute)
            $LogLevelList = @([Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::Default, [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel]::All)
            $ValidateSet = New-Object System.Management.Automation.ValidateSetAttribute($LogLevelList)
            $LogLevel = New-Object System.Management.Automation.RuntimeDefinedParameter('LogLevel', [Microsoft.Online.CSE.RestApiPowerShellModule.Instrumentation.LogLevel], $LogLevelAttributeCollection)
            $LogLevel.Attributes.Add($ValidateSet)

# EXO params start

            # Switch to track perfomance 
            $TrackPerformance = New-Object System.Management.Automation.RuntimeDefinedParameter('TrackPerformance', [bool], $attributeCollection)
            $TrackPerformance.Value = $false

            # Flag to enable or disable showing the number of objects written
            $ShowProgress = New-Object System.Management.Automation.RuntimeDefinedParameter('ShowProgress', [bool], $attributeCollection)
            $ShowProgress.Value = $false

            # Switch to enable/disable Multi-threading in the EXO cmdlets
            $UseMultithreading = New-Object System.Management.Automation.RuntimeDefinedParameter('UseMultithreading', [bool], $attributeCollection)
            $UseMultithreading.Value = $true

            # Pagesize Param
            $PageSize = New-Object System.Management.Automation.RuntimeDefinedParameter('PageSize', [uint32], $attributeCollection)
            $PageSize.Value = 1000

# EXO params end
            $paramDictionary = New-object System.Management.Automation.RuntimeDefinedParameterDictionary
            $paramDictionary.Add('UserPrincipalName', $UserPrincipalName)
            $paramDictionary.Add('Credential', $Credential)
            $paramDictionary.Add('EnableErrorReporting', $EnableErrorReporting)
            $paramDictionary.Add('LogDirectoryPath', $LogDirectoryPath)
            $paramDictionary.Add('LogLevel', $LogLevel)
            $paramDictionary.Add('TrackPerformance', $TrackPerformance)
            $paramDictionary.Add('ShowProgress', $ShowProgress)
            $paramDictionary.Add('UseMultithreading', $UseMultithreading)
            $paramDictionary.Add('PageSize', $PageSize)
            return $paramDictionary
        }
        else
        {
            $attributes = New-Object System.Management.Automation.ParameterAttribute
            $attributes.Mandatory = $false

            $attributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $attributeCollection.Add($attributes)

            # Switch to MSI auth 
            $Device = New-Object System.Management.Automation.RuntimeDefinedParameter('Device', [switch], $attributeCollection)
            $Device.Value = $false

            $paramDictionary = New-object System.Management.Automation.RuntimeDefinedParameterDictionary
            $paramDictionary.Add('Device', $Device)
            return $paramDictionary
        }
    }
    BEGIN {
        # TSK:add a BEGIN block & stick THE ExchangOnlineManagement.psm1 'above-the mods' variable/load specs in here, with tests added
        # Import the REST module so that the EXO* cmdlets are present before Connect-ExchangeOnline in the powershell instance.
        
        # defer to verb-text if avail
        if(-not(get-command test-uri -ea 0)){
          function Test-Uri {
              [CmdletBinding()]
              [OutputType([bool])]
              Param
              (
                  # Uri to be validated
                  [Parameter(Mandatory=$true, ValueFromPipelineByPropertyName=$true, Position=0)]
                  [string]
                  $UriString
              )
              [Uri]$uri = $UriString -as [Uri]
              $uri.AbsoluteUri -ne $null -and $uri.Scheme -eq 'https'
            }
        } ;
        
        
        if(-not($ExchangeOnlineMgmtPath)){
            $EOMgmtModulePath = split-path (get-module ExchangeOnlineManagement -list | sort version | select -last 1 ).Path ; 
        } ; 
        if(!$RestModule){$RestModule = "Microsoft.Exchange.Management.RestApiClient.dll"} ;
        # $PSScriptRoot will be the verb-EXO path, not the EXOMgmt module have to dyn locate it
        if(!$RestModulePath){
            #$RestModulePath = [System.IO.Path]::Combine($PSScriptRoot, $RestModule)
            $RestModulePath = [System.IO.Path]::Combine($EOMgmtModulePath, $RestModule)
        } ;
        # paths to proper Module path: Name lists as: Microsoft.Exchange.Management.RestApiClient
        if(-not(get-module Microsoft.Exchange.Management.RestApiClient)){
            Import-Module $RestModulePath -Verbose:$false ;
        } ;

        if(!$ExoPowershellModule){$ExoPowershellModule = "Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll"} ;
        if(!$ExoPowershellModulePath){
            $ExoPowershellModulePath = [System.IO.Path]::Combine($EOMgmtModulePath, $ExoPowershellModule) ;
        } ;
        # full path: C:\Users\SIDs\Documents\WindowsPowerShell\Modules\ExchangeOnlineManagement\1.0.1\Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll
        # Name: Microsoft.Exchange.Management.ExoPowershellGalleryModule
        if(-not(get-module Microsoft.Exchange.Management.ExoPowershellGalleryModule)){
            Import-Module $ExoPowershellModulePath -verbose:$false ;
        } ; 
    } 
    process {

        # Validate parameters
        if($ConnectionUri -eq 'False'){$ConnectionUri = ''}
        if (($ConnectionUri -ne '') -and (-not (Test-Uri $ConnectionUri)))
        {
            throw "Invalid ConnectionUri parameter '$ConnectionUri'"
        }
        if (($AzureADAuthorizationEndpointUri -ne '') -and (-not (Test-Uri $AzureADAuthorizationEndpointUri)))
        {
            throw "Invalid AzureADAuthorizationEndpointUri parameter '$AzureADAuthorizationEndpointUri'"
        }
        if (($Prefix -ne '') -and ($Prefix -eq 'EXO'))
        {
            throw "Prefix 'EXO' is a reserved Prefix, please use a different prefix."
        }

        if ($ShowBanner -eq $true)
        {
            Print-Details;
        }

        if (($ConnectionUri -ne '') -and ($AzureADAuthorizationEndpointUri -eq ''))
        {
            Write-Host -ForegroundColor Green "Using ConnectionUri:'$ConnectionUri', in the environment:'$ExchangeEnvironmentName'."
        }
        if (($AzureADAuthorizationEndpointUri -ne '') -and ($ConnectionUri -eq ''))
        {
            Write-Host -ForegroundColor Green "Using AzureADAuthorizationEndpointUri:'$AzureADAuthorizationEndpointUri', in the environment:'$ExchangeEnvironmentName'."
        }

        # Keep track of error count at beginning.
        $errorCountAtStart = $global:Error.Count;
        $global:_EXO_TelemetryFilePath = $null;

        try
        {
            # Cleanup old exchange online PSSessions
            #RemoveExistingPSSession
            RemoveExistingPSSessionTargeted

            $ExoPowershellModule = "Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll";
            #$ModulePath = [System.IO.Path]::Combine($PSScriptRoot, $ExoPowershellModule);
            $ModulePath = [System.IO.Path]::Combine($EOMgmtModulePath, $ExoPowershellModule);

            $global:_EXO_ExchangeEnvironmentName = $ExchangeEnvironmentName;
            $global:_EXO_ConnectionUri = $ConnectionUri;
            $global:_EXO_AzureADAuthorizationEndpointUri = $AzureADAuthorizationEndpointUri;
            $global:_EXO_PSSessionOption = $PSSessionOption;
            $global:_EXO_BypassMailboxAnchoring = $BypassMailboxAnchoring;
            $global:_EXO_DelegatedOrganization = $DelegatedOrganization;
            $global:_EXO_Prefix = $Prefix;

            if ($isCloudShell -eq $false)
            {
                $global:_EXO_UserPrincipalName = $UserPrincipalName.Value;
                $global:_EXO_Credential = $Credential.Value;
                $global:_EXO_EnableErrorReporting = $EnableErrorReporting.Value;
            }
            else
            {
                $global:_EXO_Device = $Device.Value;
            }

            Import-Module $ModulePath -Verbose:$false ;

            $global:_EXO_ModulePath = $ModulePath;

            if ($isCloudShell -eq $false)
            {
                $PSSession = New-ExoPSSession -ExchangeEnvironmentName $ExchangeEnvironmentName -ConnectionUri $ConnectionUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -UserPrincipalName $UserPrincipalName.Value -PSSessionOption $PSSessionOption -Credential $Credential.Value -BypassMailboxAnchoring:$BypassMailboxAnchoring -DelegatedOrg $DelegatedOrganization
            }
            else
            {
                $PSSession = New-ExoPSSession -ExchangeEnvironmentName $ExchangeEnvironmentName -ConnectionUri $ConnectionUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -PSSessionOption $PSSessionOption -BypassMailboxAnchoring:$BypassMailboxAnchoring -Device:$Device.Value -DelegatedOrg $DelegatedOrganization
            }

            if ($PSSession -ne $null)
            {
                $PSSessionModuleInfo = Import-PSSession $PSSession -AllowClobber -DisableNameChecking

                # Import the above module globally. This is needed as with using psm1 files, 
                # any module which is dynamically loaded in the nested module does not reflect globally.
                Import-Module $PSSessionModuleInfo.Path -Global -DisableNameChecking -Prefix $Prefix -Verbose:$false ;

                UpdateImplicitRemotingHandler

                # Import the REST module
                $RestPowershellModule = "Microsoft.Exchange.Management.RestApiClient.dll";
                #$RestModulePath = [System.IO.Path]::Combine($PSScriptRoot, $RestPowershellModule);
                $RestModulePath = [System.IO.Path]::Combine($EOMgmtModulePath, $RestPowershellModule);

                Import-Module $RestModulePath -Cmdlet Set-ExoAppSettings -Verbose:$false ;

                # If we are configured to collect telemetry, add telemetry wrappers. 
                if ($EnableErrorReporting.Value -eq $true)
                {
                    $FilePath = Add-EXOClientTelemetryWrapper -Organization (Get-OrgNameFromUPN -UPN $UserPrincipalName.Value) -PSSessionModuleName $PSSessionModuleInfo.Name -LogDirectoryPath $LogDirectoryPath.Value
                    $global:_EXO_TelemetryFilePath = $FilePath[0]
                    Import-Module $FilePath[1] -DisableNameChecking -Verbose:$false

                    Push-EXOTelemetryRecord -TelemetryFilePath $global:_EXO_TelemetryFilePath -CommandName Connect-ExchangeOnlineTargetedPurge -CommandParams $PSCmdlet.MyInvocation.BoundParameters -OrganizationName  $global:_EXO_ExPSTelemetryOrganization -ScriptName $global:_EXO_ExPSTelemetryScriptName  -ScriptExecutionGuid $global:_EXO_ExPSTelemetryScriptExecutionGuid

                    # Set the AppSettings
                    Set-ExoAppSettings -ShowProgress $ShowProgress.Value -PageSize $PageSize.Value -UseMultithreading $UseMultithreading.Value -TrackPerformance $TrackPerformance.Value -ExchangeEnvironmentName $ExchangeEnvironmentName -ConnectionUri $ConnectionUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -EnableErrorReporting $true -LogDirectoryPath $LogDirectoryPath.Value -LogLevel $LogLevel.Value
                }
                else 
                {
                    # Set the AppSettings disabling the logging
                    Set-ExoAppSettings -ShowProgress $ShowProgress.Value -PageSize $PageSize.Value -UseMultithreading $UseMultithreading.Value -TrackPerformance $TrackPerformance.Value -ExchangeEnvironmentName $ExchangeEnvironmentName -ConnectionUri $ConnectionUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -EnableErrorReporting $false
                }
            }
        }
        catch
        {
            # If telemetry is enabled, log errors generated from this cmdlet also. 
            if ($EnableErrorReporting.Value -eq $true)
            {
                $errorCountAtProcessEnd = $global:Error.Count 

                if ($global:_EXO_TelemetryFilePath -eq $null)
                {
                    $global:_EXO_TelemetryFilePath = New-EXOClientTelemetryFilePath -LogDirectoryPath $LogDirectoryPath.Value

                    # Import the REST module
                    $RestPowershellModule = "Microsoft.Exchange.Management.RestApiClient.dll";
                    #$RestModulePath = [System.IO.Path]::Combine($PSScriptRoot, $RestPowershellModule);
                    $RestModulePath = [System.IO.Path]::Combine($EOMgmtModulePath, $RestPowershellModule);
                    Import-Module $RestModulePath -Cmdlet Set-ExoAppSettings -Verbose:$false;

                    # Set the AppSettings
                    Set-ExoAppSettings -ShowProgress $ShowProgress.Value -PageSize $PageSize.Value -UseMultithreading $UseMultithreading.Value -TrackPerformance $TrackPerformance.Value -ExchangeEnvironmentName $ExchangeEnvironmentName -ConnectionUri $ConnectionUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -EnableErrorReporting $true -LogDirectoryPath $LogDirectoryPath.Value -LogLevel $LogLevel.Value
                }

                # Log errors which are encountered during Connect-ExchangeOnlineTargetedPurge execution. 
                Write-Warning("Writing Connect-ExchangeOnlineTargetedPurge error log to " + $global:_EXO_TelemetryFilePath)
                Push-EXOTelemetryRecord -TelemetryFilePath $global:_EXO_TelemetryFilePath -CommandName Connect-ExchangeOnlineTargetedPurge -CommandParams $PSCmdlet.MyInvocation.BoundParameters -OrganizationName  $global:_EXO_ExPSTelemetryOrganization -ScriptName $global:_EXO_ExPSTelemetryScriptName  -ScriptExecutionGuid $global:_EXO_ExPSTelemetryScriptExecutionGuid -ErrorObject $global:Error -ErrorRecordsToConsider ($errorCountAtProcessEnd - $errorCountAtStart) 
            }

            throw $_
        }
    }
}

#*------^ Connect-ExchangeOnlineTargetedPurge.ps1 ^------


#*------v Connect-EXO.ps1 v------
Function Connect-EXO {
    <#
    .SYNOPSIS
    Connect-EXO - Establish connection to Exchange Online (via EXO V2 graph-api module)
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-07-29
    FileName    :
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    REVISIONS   :
    * 1:48 PM 3/1/2024  with v340 support for proper/native S&C conn, I can finally remove the legacy EOM connection bits from this (*substantial* simplification):
        - removed raft of pre EOMv3xx code, basic auth is fully blocked now, independantly, test-EXOv2Connection() got some updates (TenOrg tweak, likewise removed code < EOM3xx support)
    * 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
    * 1:32 PM 5/30/2023 Updates to support either -Credential, or -UserRole + -TenOrg, to support fully portable downstream credentials: 
        - Add -UserRole & explicit -TenOrg params; working. 
        - Drive TenOrg defaulted $global:o365_TenOrgDefault, or on $env:userdomain
        - use the combo thru get-TenantCredential(), then set result to $Credential
        - if using Credential, the above are backed out via get-TenantTag() on the $credential 
        - CBA identifiers are resolve always via $uRoleReturn = resolve-UserNameToUserRole -Credential $Credential ;
    * 2:02 PM 5/25/2023 updated CBH example to reflect use of $pltRXOC std conn splat
    * 1:08 PM 5/23/2023 fixed typo (-eq vs =, dumping $false into pipe)     
    * 4:15 PM 5/22/2023 cleaned cbh ; removed some rem'd 
    * 10:06 AM 5/19/2023 add: code to run resolve-UserNameToUserRole  wi $Credential or $UserPrincipalName; sub'd out direct cert-parsing & value assignements with resolve-UserNameToUserRole outputs; 
    * 3:21 PM 4/25/2023 add CBA CBH demo ; added code to pass through calc'd $CertTag as test-EXOv2Connection() -CertTag (used for validating credential alignment w Tenant)
    * 10:59 AM 4/18/2023 step debugs ; 
    * 10:16 AM 4/18/2023 rem'd out unused $ConnectionUri;$AzureADAuthorizationEndpointUri;$PSSessionOption;$BypassMailboxAnchoring;$DelegatedOrganization;
    rem'd boolean dump into pipeline in END{}
    * 4:08 PM 4/17/2023 ported into connect-exo(), aliased cxo2,connect-exo2 in it.
    * 2:02 PM 4/17/2023 rev: $MinNoWinRMVersion from 2.0.6 => 3.0.0.
    * 2:40 PM 4/5/2023: force the Connect-ExchangeOnline banner hidden:$pltCEO.ShowBanner = $false ;
    * 11:02 AM 4/4/2023 reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not; added support for EMOv3 get-connectioninfo() etc, and differentiate EMOv2 from EMOv3 connections
    * 3:14 pm 3/29/2023: REN'D $modname => $EOMModName
    * 3:59 PM 8/2/2022 got through dbugging EOM v205 SID interactive pass, working ; added Conn-EOM missing -prefix spec; fully works from mybox w v206p6, cEOM connection, with functional prefix.
    * 4:07 PM 7/26/2022 found that MS code doesn't chk for multi vers's installed, when building .dll paths: wrote in code to take highest version.
    * 3:30 PM 7/25/2022 tests against CBA & SID interactive creds on EOM v205, need to debug now against EOM v206p6, to accomodate PSSession-less connect & test code.
    * 10:50 AM 6/27/2022 missing: $rgxCertThumbprint; validated works with userp interactive mfa
    * 3:27 PM 6/24/2022 dbgd through w x10 connected, looks like it properly disconnects and reconnects; shifted valid code into test-EXOv2Connection(); patched in CBA support
    * 11:27 AM 6/7/2022 cbh cleanup
    * 3:54 PM 4/1/2022 add missing $silent param (had support, but no param)
    * 4:10 PM 3/29/2022 finished getting test-EXOToken interaction and EOM module/.dll load code squared up. 
    3:58 PM 3/28/2022 add: DefaultParameterSetName='UPN', avoid: 'Parameter set cannot be resolved using the specified named parameters.'
    - updated module path code, to support new .netcore/.netframework subdir forking of the .dll storage in the EOm module. 
    - all of the write-* to incl wl support. 
    - trying to sort out use of the test-ActiveToken() - wants a new -TokenExpiryTime, in other code in the EOM .psm1 it's called as 
    $hasActiveToken = Test-ActiveToken -TokenExpiryTime $script:PSSession.TokenExpiryTime
    $sessionIsOpened = $script:PSSession.Runspace.RunspaceStateInfo.State -eq 'Opened'
    if (($hasActiveToken -eq $false) -or ($sessionIsOpened -ne $true))
    {
        #If there is no active user token or opened session then ensure that we remove the old session
        $shouldRemoveCurrentSession = $true;
    }
    * 1:24 PM 3/15/2022 moved $minvers to a param: -MinimumVersion
    * 2:40 PM 12/10/2021 more cleanup 
    # 11:23 AM 9/16/2021 string
    # 1:31 PM 7/21/2021 revised Add-PSTitleBar $sTitleBarTag with TenOrg spec (for prompt designators)
    * 11:53 AM 4/2/2021 updated with rlt & recstat support, updated catch blocks
    # 8:34 AM 3/31/2021 added verbose suppress to all import-mods
    * 11:36 AM 3/5/2021 updated colorcode, subed wv -verbose with just write-verbose, added cred.uname echo
    * 1:15 PM 3/1/2021 added org-level color-coded console
    * 8:55 AM 11/11/2020 added fake -Username block, to make -Credential, *also* auto-renew sessions! (above from: https://ingogegenwarth.wordpress.com/2018/02/02/exo-ps-mfa/)
    * 2:01 PM 11/10/2020 swap connect-exo2 to connect-exo2old (uses connect-ExchangeOnline), and ren this "Connect-EXO2A" to connect-exo2 ; fixed get-module tests (sub'd off the .dll from the modname)
    * 9:56 AM 11/10/2020 variant of cxo2, that has direct ported-in low-level code from the ExchangeOnlineManagement:connect-ExchangeOnlin(). debugs functional so far, haven't tested concurrent CCMS + EXO overlap & tokens yet. 
    * 8:30 AM 10/22/2020 ren'd $TentantTag -> $TenOrg, swapped looping meta resolve with 1-liner approach ; added AcceptedDom caching to the middle status test (suppress one more get-exoaccepteddomain call if possible)
    * 4:41 PM 10/8/2020 implemented AcceptedDomain caching, in connect-exo2 to match rxo2
    * 1:18 PM 8/11/2020 fixed typo in *broken *closed varis in use; updated ExoV1 conn filter, to specificly target v1 (old matched v1 & v2) ; trimmed entire rem'd MFA block ; added trailing test-EXOToken confirm
    * 12:57 PM 8/4/2020 sorted ExchangeOnlineMgmt mod issues (splatting wo using splat char), if MS hadn't completely rewritten the access, this rewrite wouldn't have been necessary in the 1st place. I'm not looking forward to the org wide rewrites to recode verb-exoNoun -> verb-xoNoun, to accomodate the breaking-change blocking -Prefix 'exo'. ; # 1:04 PM 8/4/2020 cute: now the above error's stopped occuring on the problem tenant. Can't do further testing of the workaround, unless/until it breaks again ; * 2:39 PM 8/4/2020 fixed -match "^(Session|WinRM)\d*" rgx (lacked ^, mismatched EXOv2 conns)
    * 12:20 PM 7/29/2020 rewrite/port from connect-EXO to replace import-pssession with new connect-ExchangeOnline cmdlet (supports MFA natively) - #127 # *** LEFT OFF HERE 5:01 PM 7/29/2020 *** not sure if it supports allowclobber, if it's actually wrapping pssession, it sure as shit does!
    * 11:21 AM 7/28/2020 added Credential -> AcceptedDomains Tenant validation, also testing existing conn, and skipping reconnect unless unhealthy or wrong tenant to match credential
    * 3:24 PM 7/24/2020 updated to support tenant-alignment & sub'd out showdebug for verbose
    * 7:13 AM 7/22/2020 replaced codeblock w get-TenantTag()
    * 5:12 PM 7/21/2020 added ven supp
    * 11:50 AM 5/27/2020 added alias:cxo win func
    * 8:38 AM 4/17/2020 added a new test of $global:EOLSession, to detect initial cred fail (pw chg, outofdate creds, locked out)
    * 8:45 AM 3/3/2020 public cleanup, refactored Connect-EXO2 for Meta's
    * 9:52 PM 1/16/2020 cleanup
    * 10:55 AM 12/6/2019 Connect-EXO2:added suffix to TitleBar tag for other tenants, also config'd a central tab vari
    * 9:17 AM 12/4/2019 CONSISTENTLY failing to load properly in lab, on lynms6200d - wont' get-module xxxx -listinstalled, even after load, so I rewrote an exemption diverting into the locally installed $env:userprofile\documents\WindowsPowerShell\Modules\exoMFAModule\ copy.
    * 5:14 PM 11/27/2019 repl $MFA code with get-TenantMFARequirement
    * 1:07 PM 11/25/2019 added tenant-specific alias variants for connect & reconnect
    # 1:26 PM 11/19/2019 added MFA detection fr infastrings .ps1 globals, lifted from Jeremy Bradshaw (https://github.com/JeremyTBradshaw)'s Connect-Exchange()
    # 10:35 AM 6/20/2019 added $pltiSess splat dump to the import-pssession cmd block; hard-typed the $Credential [System.Management.Automation.PSCredential]
    # 8:22 AM 11/20/2017 spliced in retry loop into reConnect-EXO2 as well, to avoid using any state testing in scripts, localize it 1x here.
    # 1:49 PM 11/2/2017 coded around non-profile gaps from not having get-admincred() - added the prompt code in to fake it
    # 12:26 PM 9/11/2017 debugged retry - catch doesn't fire properly on new-Pssession, have to test the $error state, to detect auth fails (assuming the bad pw error# is specific). $error test is currently targeting specific error returned on a bad password. Added retry, for when connection won't hold and fails breaks - need to watch out that bad pw doesn't lock out the acct!
    # 12:50 PM 6/2/2017 expanded pshelp, added Examples, cleaned up deadwood
    * # 12:10 PM 3/15/2017 Connect-EXO2 typo, disable prefix auto spec, unless actually blanked. switch ProxyEnabled to non-Mandatory.
    .DESCRIPTION
    Connect-EXO - Establish PSS to EXO V2 Modern Auth
    .PARAMETER  Prefix
    [verb]-PREFIX[command] PREFIX string for clearly marking cmdlets sourced in this connection [-Prefix tag]
    .PARAMETER Credential
    Credential to use for this connection [-credential [credential obj variable]
    .PARAMETER UserPrincipalName
    User Principal Name or email address of the user
    .PARAMETER UserRole
    Credential Optional User Role spec for credential discovery (wo -Credential)(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]
    .PARAMETER TenOrg
    Optional Tenant Tag (wo -Credential)[-TenOrg 'XYZ']
    .PARAMETER ExchangeEnvironmentName
    Exchange Environment name [-ExchangeEnvironmentName 'O365Default']
    .PARAMETER MinimumVersion
    MinimumVersion required for ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']
    .PARAMETER MinNoWinRMVersion
    MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']
    .PARAMETER UseMultithreading
    Switch to enable/disable Multi-threading in the EXO cmdlets
    .PARAMETER ShowProgress
    Flag to enable or disable showing the number of objects written
    .PARAMETER Pagesize
    Pagesize Param
    .PARAMETER silent
    Switch to suppress all non-error echos
    .PARAMETER showDebug
    Debugging Flag [-showDebug]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    PS>  Connect-EXO -cred $credO365TORSID ;
    Connect using defaults, and leverage any pre-set $global:credo365TORSID variable
    .EXAMPLE
    PS>  Connect-EXO -Prefix exolab -credential (Get-Credential -credential user@domain.com)  ;
    Connect an explicit credential, and use 'exolab' as the cmdlet prefix
    .EXAMPLE 
    connect-exo2 -credential $credO365xxxCBA -verbose ; 
    Connect using a CBA credential variable (prestocked from profile automation). Script opens and recycles the cred cert specs emulating the native CBA connection below, but pulling source info from a stored dpapi-encrypted .xml credential file.
    .EXAMPLE
    connect-exo -UserRole SIDCBA -TenOrg ABC -verbose  ; 
    Demo use of UserRole (specifying a CBA variant), AND TenOrg spec, to connect (autoresolves against preconfigured credentials in profile)
    .EXAMPLE
    PS>  $cred = get-credential -credential $o365_Torolab_SIDUpn ;
    PS>  Connect-EXO -credential $cred ;
    Pass in a prefab credential object (useful for auto-shifting to MFA - the function will autoresolve MFA reqs based on the cred domain)
    .EXAMPLE
    PS> $pltRXOC = [ordered]@{
    PS>     Credential = $Credential ;
    PS>     verbose = $($VerbosePreference -eq "Continue")  ;
    PS>     Silent = $silent ; 
    PS> } ;
    PS> if ($script:useEXOv2 -OR $useEXOv2) { Connect-EXO2 @pltRXOC }
    PS> else { Connect-EXO @pltRXOC } ;    
    Splatted example leveraging prefab $pltRXOC splat, derived from local variables & $VerbosePreference value.
    .EXAMPLE
    PS>  $pltCXOCThmb=[ordered]@{
    PS>  	CertificateThumbPrint = $credO365TORSIDCBA.UserName ;
    PS>  	AppID = $credO365TORSIDCBA.GetNetworkCredential().Password ;
    PS>  	Organization = 'TENANTNAME.onmicrosoft.com' ;
    PS>  	Prefix = 'xo' ;
    PS>  	ShowBanner = $false ;
    PS>  };
    PS>  write-host "Connect-ExchangeOnline w $(($pltCXOCThmb|out-string).trim())" ;
    PS>  Connect-ExchangeOnline @pltCXOCThmb ;
    Example of native connect-ExchangeOnline syntax leveraging a CBA certificate stored locally, with AppID and CertificateThumbPrint pulled from a local global-scope credential object (with AppID stored as password & Thumprint as username)
    .LINK
    #>
    [CmdletBinding(DefaultParameterSetName='UPN')]
    [Alias('cxo2','Connect-EXO2' )]
    PARAM(
        # try pulling all the ParameterSetName's - just need to get through it now. - no got through it with a defaultparametersetname (avoids 
        [Parameter(HelpMessage = "[verb]-PREFIX[command] PREFIX string for clearly marking cmdlets sourced in this connection [-Prefix tag]")]
            [string]$Prefix = 'xo',
        [Parameter(ParameterSetName = 'Cred', HelpMessage = "Credential to use for this connection [-credential [credential obj variable]")]
            [System.Management.Automation.PSCredential]$Credential,
            # = $global:credo365TORSID, # defer to TenOrg & UserRole resolution
        [Parameter(ParameterSetName = 'UPN',HelpMessage = "User Principal Name or email address of the user[-UserPrincipalName logon@domain.com]")]
            [string]$UserPrincipalName,
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ; 
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ; 
                return $true ; 
            })]
            [string[]]$UserRole = @('SIDCBA','SID','CSVC'),
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
            [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(HelpMessage = "Exchange Environment name [-ExchangeEnvironmentName 'O365Default']")]
            [Microsoft.Exchange.Management.RestApiClient.ExchangeEnvironment]
            <# error: typedef missing, pre ipmo the mod. 
            Unable to find type [Microsoft.Exchange.Management.RestApiClient.ExchangeEnvironment].
            At D:\scripts\connect-exo2_func.ps1:132 char:9
            +         [Microsoft.Exchange.Management.RestApiClient.ExchangeEnvironm ...
            +         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                + CategoryInfo          : InvalidOperation: (Microsoft.Excha...angeEnvironment:TypeName) [], RuntimeException
                + FullyQualifiedErrorId : TypeNotFound
            #>
            $ExchangeEnvironmentName = 'O365Default',
        [Parameter(HelpMessage = "MinimumVersion required for ExchangeOnlineManagement module (defaults to '2.0.5')[-MinimumVersion '2.0.6']")]
            [version] $MinimumVersion = '2.0.5',
        [Parameter(HelpMessage = "MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']")]
            [version] $MinNoWinRMVersion = '3.0.0',
        [Parameter(HelpMessage = "Switch to enable/disable Multi-threading in the EXO cmdlets [-UseMultithreading]")]
            [switch]$UseMultithreading=$true,
        [Parameter(HelpMessage = "Switch to enable or disable showing the number of objects written (defaults `$true)[-ShowProgress]")]
            [switch]$ShowProgress=$true,
        [Parameter(HelpMessage = "Pagesize Param[-PageSize 500]")]
            [uint32]$PageSize = 1000,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent,
        [Parameter(HelpMessage = "Debugging Flag [-showDebug]")]
            [switch] $showDebug
    ) ;
    BEGIN {
        $verbose = ($VerbosePreference -eq "Continue") ;

        if(-not (gv rgxCertThumbprint -ea 0)){$rgxCertThumbprint = '[0-9a-fA-F]{40}' ; } ;
        if(-not (gv rgxCertFNameSuffix -ea 0)){$rgxCertFNameSuffix = '-([A-Z]{3})$' ; } ; 

        #*------v PSS & GMO VARIS v------
        # move into a param
        #$MinNoWinRMVersion = '3.0.0' ; 
        # get-pssession session varis
        # select key differentiating properties:
        $pssprops = 'Id','ComputerName','ComputerType','State','ConfigurationName','Availability', 
            'Description','Guid','Name','Path','PrivateData','RootModuleModule', 
            @{name='runspace.ConnectionInfo.ConnectionUri';Expression={$_.runspace.ConnectionInfo.ConnectionUri} },  
            @{name='runspace.ConnectionInfo.ComputerName';Expression={$_.runspace.ConnectionInfo.ComputerName} },  
            @{name='runspace.ConnectionInfo.Port';Expression={$_.runspace.ConnectionInfo.Port} },  
            @{name='runspace.ConnectionInfo.AppName';Expression={$_.runspace.ConnectionInfo.AppName} },  
            @{name='runspace.ConnectionInfo.Credentialusername';Expression={$_.runspace.ConnectionInfo.Credential.username} },  
            @{name='runspace.ConnectionInfo.AuthenticationMechanism';Expression={$_.runspace.ConnectionInfo.AuthenticationMechanism } },  
            @{name='runspace.ExpiresOn';Expression={$_.runspace.ExpiresOn} } ; 
        $EOMmodname = 'ExchangeOnlineManagement' ;
        $EXOv1ConfigurationName = $EXOv2ConfigurationName = $EXoPConfigurationName = "Microsoft.Exchange" ;
        if(-not (gv EXOv1ComputerName -ea 0 )){$EXOv1ComputerName = 'ps.outlook.com' };
        if(-not (gv EXOv1runspaceConnectionInfoAppName -ea 0 )){$EXOv1runspaceConnectionInfoAppName = '/PowerShell-LiveID'  };
        if(-not (gv EXOv1runspaceConnectionInfoPort -ea 0 )){$EXOv1runspaceConnectionInfoPort = '443' };

        if(-not (gv EXOv2ComputerName -ea 0 )){$EXOv2ComputerName = 'outlook.office365.com' ;}
        if(-not (gv EXOv2Name -ea 0 )){$EXOv2Name = "ExchangeOnlineInternalSession*" ; }
        if(-not (gv rgxEXoPrunspaceConnectionInfoAppName -ea 0 )){$rgxEXoPrunspaceConnectionInfoAppName = '^/(exadmin|powershell)$'}; 
        if(-not (gv EXoPrunspaceConnectionInfoPort -ea 0 )){$EXoPrunspaceConnectionInfoPort = '80' } ; 
        # gmo varis
        if(-not (gv rgxExoPsHostName -ea 0 )){ $rgxExoPsHostName = "^(ps\.outlook\.com|outlook\.office365\.com)$" } ;
        if(-not (gv rgxEXOv1gmoDescription -ea 0 )){$rgxEXOv1gmoDescription = "^Implicit\sremoting\sfor\shttps://ps\.outlook\.com/PowerShell" }; 
        if(-not (gv EXOv1gmoprivatedataImplicitRemoting -ea 0 )){$EXOv1gmoprivatedataImplicitRemoting = $true };
        if(-not (gv rgxEXOv2gmoDescription -ea 0 )){$rgxEXOv2gmoDescription = "^Implicit\sremoting\sfor\shttps://outlook\.office365\.com/PowerShell" }; 
        if(-not (gv EXOv2gmoprivatedataImplicitRemoting -ea 0 )){$EXOv2gmoprivatedataImplicitRemoting = $true } ;
        if(-not (gv rgxExoPsessionstatemoduleDescription -ea 0 )){$rgxExoPsessionstatemoduleDescription = '/(exadmin|powershell)$' };
        if(-not (gv EXOv2StateOK -ea 0 )){$EXOv2StateOK = 'Opened'} ; 
        if(-not (gv EXOv2AvailabilityOK -ea 0 )){$EXOv2AvailabilityOK = 'Available'} ; 
        if(-not (gv EXOv2RunStateBad -ea 0 )){ $EXOv2RunStateBad = 'Broken'} ;
        if(-not (gv EXOv1GmoFilter -ea 0 )){$EXOv1GmoFilter = 'tmp_*' } ; 
        if(-not (gv EXOv2GmoNoWinRMFilter -ea 0 )){$EXOv2GmoNoWinRMFilter = 'tmpEXO_*' };
        #*------^ END PSS & GMO VARIS ^------

        #*======v FUNCTIONS v======
        if(-not(get-command test-uri -ea 0)){
            #*------v Function Test-Uri v------
            function Test-Uri {
                [CmdletBinding()]
                [OutputType([bool])]
                Param(
                    # Uri to be validated
                    [Parameter(Mandatory=$true, ValueFromPipelineByPropertyName=$true, Position=0)]
                    [string]$UriString
                ) ; 
                [Uri]$uri = $UriString -as [Uri]
                $uri.AbsoluteUri -ne $null -and $uri.Scheme -eq 'https'
            } ; 
            #*------^ END Function Test-Uri ^------
        } ;
        #*======^ END FUNCTIONS ^======

        # disable prefix spec, unless actually blanked (e.g. centrally spec'd in profile).
        if (-not $Prefix) {
            $Prefix = 'xo' ; # 4:31 PM 7/29/2020 MS has RESERVED use of the 'exo' prefix [facepalm]
            $smsg = "(asserting Prefix:$($Prefix)" ;
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ;
        if (($Prefix) -and ($Prefix -eq 'EXO')) {
            throw "Prefix 'EXO' is a reserved Prefix, please use a different prefix."
        }

        <#
        $TenOrg = get-TenantTag -Credential $Credential ;
        if($Credential){
            $uRoleReturn = resolve-UserNameToUserRole -Credential $Credential
        } elseif($UserPrincipalName){
            $uRoleReturn = resolve-UserNameToUserRole -UserName $UserPrincipalName
        } ; 
        if($uRoleReturn.TenOrg){
            $CertTag = $uRoleReturn.TenOrg
        } ; 
        #>

        # transplat fr rxo ---
        if(-not $Credential){
            if($UserRole){
                $smsg = "Using specified -UserRole:$( $UserRole -join ',' )" ;
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else { $UserRole = @('SID','CSVC') } ;
            if($TenOrg){
                $smsg = "Using explicit -TenOrg:$($TenOrg)" ; 
            } else { 
                switch -regex ($env:USERDOMAIN){
                    ([regex]('(' + (( @($TORMeta.legacyDomain,$CMWMeta.legacyDomain)  |foreach-object{[regex]::escape($_)}) -join '|') + ')')).tostring() {$TenOrg = $env:USERDOMAIN.substring(0,3).toupper() } ;
                    $TOLMeta.legacyDomain {$TenOrg = 'TOL' }
                    default {throw "UNRECOGNIZED `$env:USERDOMAIN!:$($env:USERDOMAIN)" ; exit ; } ;
                } ;  
                $smsg = "Imputed `$TenOrg from logged on USERDOMAIN:$($TenOrg)" ;             
            } ; 
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;             
            
            $o365Cred = $null ;
            $pltGTCred=@{TenOrg=$TenOrg ; UserRole= $UserRole; verbose=$($verbose)} ;
            $smsg = "get-TenantCredentials w`n$(($pltGTCred|out-string).trim())" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            $o365Cred = get-TenantCredentials @pltGTCred ;

            if($o365Cred.credType -AND $o365Cred.Cred -AND $o365Cred.Cred.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                $smsg = "(validated `$o365Cred contains .credType:$($o365Cred.credType) & `$o365Cred.Cred.username:$($o365Cred.Cred.username)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $Credential = $o365Cred.Cred ;
            } else { 
                $smsg = "UNABLE TO RESOLVE FUNCTIONAL CredType/UserRole from specified explicit -Credential:$($Credential.username)!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 

                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                break ; 
            } ; 
            
        } else { 
            # test-exotoken only applies if $UseConnEXO  $false
            $TenOrg = get-TenantTag -Credential $Credential ;
        } ;
        # build the cred etc once, for all below:
        $pltCXO=[ordered]@{
            Credential = $Credential ;
            verbose = $($verbose) ; 
            erroraction = 'STOP' ;
        } ;
        if((gcm connect-EXO).Parameters.keys -contains 'silent'){
            $pltCXO.add('Silent',$false) ;
        } ;

        $uRoleReturn = resolve-UserNameToUserRole -Credential $Credential ; 
        if($credential.username -match $rgxCertThumbprint){
            $certTag = $uRoleReturn.TenOrg ; 
        } ; 
        # ---

        $sTitleBarTag = @("EXO2") ;
        $sTitleBarTag += $TenOrg ;

        $MFA = get-TenantMFARequirement -Credential $Credential ;

        # 12:08 PM 8/2/2022 scrap the msal.net material: it's fundementally incompatible with EXO - sure you can pull and auth a token into the PS EXO clientid, but you can't spec a prefix on the returned cmdlets.
        # 4:45 PM 7/7/2022 workaround msal.ps bug: always ipmo it FIRST: "Get-msaltoken : The property 'Authority' cannot be found on this object. Verify that the property exists."

        # * 11:02 AM 4/4/2023 reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not
        #region EOMREV ; #*------v EOMREV Check v------
        #$EOMmodname = 'ExchangeOnlineManagement' ;
        $pltIMod = @{Name = $EOMmodname ; ErrorAction = 'Stop' ; verbose=$false} ;
        # do a gmo first, faster than gmo -list
        if([version]$EOMMv = (Get-Module @pltIMod | sort version | select -last 1 ).version){}
        elseif([version]$EOMMv = (Get-Module -ListAvailable @pltIMod | sort version | select -last 1 ).version){} 
        else { 
            $smsg = "$($EOMmodname) PowerShell v$($MinNoWinRMVersion) module is required, do you want to install it?" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
            else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $bRet=Read-Host "Enter YYY to continue. Anything else will exit"  ; 
            if ($bRet.ToUpper() -eq "YYY") {
                $smsg = "Installing $($EOMmodname) module..." ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Install-Module $EOMmodname -Repository PSGallery -AllowClobber -Force ; 
            } else {
                $smsg = "Please install $($EOMmodname) PowerShell v$($MinNoWinRMVersion)  module." ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                #exit 1
                break ; 
            }  ; 
        } ; 
        $smsg = "Checking for WinRM support in this EOM rev..." 
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        if([version]$EOMMv -ge [version]$MinNoWinRMVersion){
            $MinNoWinRMVersion = $EOMMv.tostring() ;
            $IsNoWinRM = $true ; 
        }elseif([version]$EOMMv -lt [version]$MinimumVersion){
            $smsg = "Installed $($EOMmodname) is v$($MinNoWinRMVersion): This module is obsolete!" ; 
            $smsg += "`nAnd unsupported by this function!" ; 
            $smsg += "`nPlease install $($EOMmodname) PowerShell v$($MinNoWinRMVersion)  module!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            Break ; 
        } else {
            $IsNoWinRM = $false ; 
        } ; 
        [boolean]$UseConnEXO = [boolean]([version]$EOMMv -ge [version]$MinNoWinRMVersion) ; 
        #endregion EOMREV ; #*------^ END EOMREV Check  ^------

        if(-not $UseConnEXO){
            $smsg = "NON-connect-ExchangeOnline() version of ExchangeOnlineManagement installed, update to vers:$($MinNoWinRMVersion) or higher!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            throw $smsg ; 
            break ; 

            # dropping all support/legacy code for EOMv1 (PSSession native-only connections)
            # code below is used *solely* for EOM v205 connections (uses cached creds, integrates Connect-ExchangeOnline underlying commands)
            # EOM -lt 2.0.5preview6 .dll etc loads, from connect-exchangeonline: (should be installed with the above)
            # removed 12:23 PM 3/1/2024
        
        } else { 
            # $UseConnEXO => we're doing native connect-ExchangeOnline connectivity, no PSSession etc
            $smsg = "native connect-ExchangeOnline specified..." ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 

    } ; # BEG-E
    PROCESS {
        $bExistingEXOGood = $false ;
        $certUname = $null ; 

        # Keep track of error count at beginning.
        $errorCountAtStart = $global:Error.Count;
        $global:_EXO_TelemetryFilePath = $null;

        <# EXOv1: fully deprecated 12:24 PM 3/1/2024
        Get-PSSession | fl ConfigurationName,name,state,availability,computername
        -legacy remote-ps New-PSSession results in this PSS:
          ConfigurationName : Microsoft.Exchange
          Name              : WinRM2 (seems to increment)
          State             : Opened
          Availability      : Available
          ComputerName      : ps.outlook.com

        - legacy remote from jumpbox:
        ConfigurationName : Microsoft.Exchange
          Name              : Session6
          State             : Opened
          Availability      : Available
          ComputerName      : ps.outlook.com

        -while a connect-ExchangeOnline (non-MFA, haven't verified) connect results in this PSS:
          ConfigurationName : Microsoft.Exchange
          Name              : ExchangeOnlineInternalSession_4
          State             : Opened
          Availability      : Available
          ComputerName      : outlook.office365.com
        
        #EXOv2 MFA: 4/4/2022
        TokenProvider          : Microsoft.Exchange.Management.AdminApiProvider.Authentication.MSALTokenProvider
        ConnectionUri          : https://outlook.office365.com:443/PowerShell-LiveID?BasicAuthToOAuthConversion=true&HideBannerMessage=true&ConnectionId=c93cad7f-d8f5-4cce-8ac2-24de6c28518e&ClientProcessId=10808&ExoModuleVersion=2.0.5&OSVersion=
                                 Microsoft+Windows+NT+10.0.14393.0&email=s-email%40domain.com
        PSSessionOption        :
        TokenExpiryTime        : 3/29/2022 8:21:45 PM +00:00
        CurrentModuleName      : tmp_j2itmjec.1iw
        State                  : Opened
        IdleTimeout            : 900000
        OutputBufferingMode    : None
        DisconnectedOn         :
        ExpiresOn              :
        ComputerType           : RemoteMachine
        ComputerName           : outlook.office365.com
        ContainerId            :
        VMName                 :
        VMId                   :
        ConfigurationName      : Microsoft.Exchange
        InstanceId             : 7b793cd7-33de-451d-92a3-bdb3e154bd35
        Id                     : 1
        Name                   : ExchangeOnlineInternalSession_1
        Availability           : Available
        ApplicationPrivateData : {SupportedVersions, ImplicitRemoting, PSVersionTable}
        Runspace               : System.Management.Automation.RemoteRunspace

        -CCMS session via Connect-IPPSSession
        ConfigurationName : Microsoft.Exchange
        ComputerName      : nam02b.ps.compliance.protection.outlook.com
        Name              : ExchangeOnlineInternalSession_1
        State             : Opened
        Availability      : Available
        #>

        <# due to bug in ExchangeOnlineManagement (still in v2.0.5)...
            [Issue using ExchangeOnlineManagement v2.0.4 module to connect to Exchange Online remote powershell (EXO) and Exchange On-Prem remote powershell (EXOP) in same powershell window - Microsoft Q&A - docs.microsoft.com/](https://docs.microsoft.com/en-us/answers/questions/451786/issue-using-exchangeonlinemanagement-v204-module-t.html)
            ...we need to detect and pre-disconnect any existing EXoP implicit remoting sessions
            Because EMO is so badly written it can't properly differentiate the ExOP implicit-remote session(s) from it's own *prior*
            implicit-remote session (which is used for all legacy EXO cmdlets, other than the 9 new 'toy' get-exo[noun] graph-api based cmdlets)
            net-result, if you don't pre-disconnect ExOP implicit-remote pss, EMOs import-pssession cmd throws a 'steppable error' error, 
            commonly, in our case, due to a blank -prefix param, lifted off of the prior PSS connect
            triggered in ExchangeOnlineManagement.psm1:ln143 in global:UpdateImplicitRemotingHandler()
            $PSSessionModuleInfo = Import-PSSession $session -AllowClobber -DisableNameChecking -CommandName $script:MyModule.CommandName -FormatTypeName $script:MyModule.FormatTypeName
            throws:
            ```
            Exception calling "GetSteppablePipeline" with "1" argument(s): "Cannot validate argument on parameter 'Prefix'. The argument is null. Provide a valid value for the argument, and then try running the command again."
            At C:\Users\USER\AppData\Local\Temp\2\tmp_jlykdki2.vpm\tmp_jlykdki2.vpm.psm1:29929 char:13
            +             $steppablePipeline = $scriptCmd.GetSteppablePipeline($myI ...
            +             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                + CategoryInfo          : NotSpecified: (:) [], ParentContainsErrorRecordException
                + FullyQualifiedErrorId : CmdletInvocationException
            ```
        #>

        <#
        if(-not $UseConnEXO){
            
            # all the EXOP PsSession hybrid bug conflicts are only nece3ssary with v2.0.5 or less of EMO...

            $bPreExoPPss= $false ;
            $smsg = "NON-connect-ExchangeOnline() version of ExchangeOnlineManagement installed, update to vers:$($MinNoWinRMVersion) or higher!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            throw $smsg ; 
            break ; 
            # removed all legacy code: 12:25 PM 3/1/2024
            
        } else { 
            $smsg = "(native connect-ExchangeOnline specified...)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        }; 
        #>

        # clear any existing legacy EXO sessions:
        # legacy non-OAuth EXOv2 sessions (AKA EXOv1 basic-auth PSsession-based connections) distinguished on the Computername etc
        if ( $pssEXOv1 = Get-PSSession | 
            where-object {$_.ConfigurationName -like $EXOv1ConfigurationName -AND ($_.ComputerName -eq $EXOv1ComputerName) -AND (
                $_.runspace.ConnectionInfo.AppName -eq $EXOv1runspaceConnectionInfoAppName) -AND (
                $_.runspace.ConnectionInfo.Port -eq $EXOv1runspaceConnectionInfoPort) }  ) {
            # ignore state & Avail, close the conflicting legacy conn's
            if ($pssEXOv1.count -gt 0) {
                $smsg = "(closing $($pssEXOv1.count) legacy EXOv1 sessions...)" ;
                if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                for ($index = 0; $index -lt $pssEXOv1.count; $index++) {
                    $session = $pssEXOv1[$index] ;
                    Remove-PSSession -session $session ;
                    $smsg = "Removed the PSSession $($session.Name) connected to $($session.ComputerName)" ;
                    if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                } ;
                $bExistingEXOGood = $false ;
            } ;
        } ;
        #if ( Get-PSSession | where-object { $_.ConfigurationName -like "Microsoft.Exchange" -and $_.Name -like "ExchangeOnlineInternalSession*" -and $_.State -like "*Opened*" -AND ($_.Availability -eq 'Available') } ) {
        # update to *not* tamper with CCMS connects
        #if ( Get-PSSession | where-object { $_.ConfigurationName -like "Microsoft.Exchange" -and $_.Name -like "ExchangeOnlineInternalSession*" -and $_.State -like "*Opened*" -AND ($_.Availability -eq 'Available') -AND ($_.ComputerName -match $rgxExoPsHostName) } ) {
        # simpler - MS uses - very simple detect: 
        # $pssEXOv2 = Get-PSSession | Where-Object {$_.ConfigurationName -like "Microsoft.Exchange" -and $_.Name -like "ExchangeOnlineInternalSession*"} ;
       
        # use test-EXOConnection - cxo2 *only* drives compliant eXOv2 connections, not legacy basicAuth
        #$IsNoWinRM = $false ; 
        # 11:18 AM 4/25/2023 add support for passing calc'd CertTag "Cert FriendlyName Suffix to be used for validating credential alignment(Optional but required for CBA calls)[-CertTag `$certtag]")][string]$CertTag
        if($CertTag -ne $null){
            $smsg = "(specifying detected `$CertTag:$($CertTag))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            $oRet = test-EXOv2Connection -Credential $credential -CertTag $certtag -verbose:$($verbose) ; 
        } else { 
            $oRet = test-EXOv2Connection -Credential $credential -verbose:$($verbose) ; 
        } ; 
        $bExistingEXOGood = $oRet.Valid ; 
        if($oRet.Valid){
            $pssEXOv2 = $oRet.PsSession ; 
            $IsNoWinRM = $oRet.IsNoWinRM ; 
            $smsg = "(Validated EXOv2 Connected to Tenant aligned with specified Credential)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } else { 
            $smsg = "NO VALID EXOV2/3 PSSESSION FOUND! (DISCONNECTING...)"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-host -ForegroundColor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            # capture outlier: shows a session wo the test cmdlet, force reset
            DisConnect-EXO ;
            $bExistingEXOGood = $false ;
        } ;     
    
        if ($bExistingEXOGood -eq $false) {
            # open a new EXOv2 session
            # removed all legacy code: 12:25 PM 3/1/2024
            if(-not $UseConnEXO){
                
                # removed all legacy code: 12:25 PM 3/1/2024

            } else { 
                # $UseConnEXO 
                <#
                ==4:21 PM 6/30/2022: v2.0.6p6 examples
                -------------------------- Example 1 --------------------------
                    Connect-ExchangeOnline -UserPrincipalName chris@contoso.com
                    This example connects to Exchange Online PowerShell using modern authentication, with or without multi-factor authentication (MFA). We
                    aren't using the UseRPSSession parameter, so the connection uses REST and doesn't require Basic authentication to be enabled in WinROM
                    on the local computer. But, only the subset of frequently used REST API parameters are available.
                    -------------------------- Example 2 --------------------------
                    Connect-ExchangeOnline -UserPrincipalName chris@contoso.com -UseRPSSession
                    This example connects to Exchange Online PowerShell using modern authentication, with or without MFA. We're using the UseRPSSession
                    parameter, so the connection requires Basic authentication to be enabled in WinRM on the local computer. But, all Exchange Online
                    PowerShell cmdlets are available using traditional remote PowerShell access.
                    -------------------------- Example 3 --------------------------
                    Connect-ExchangeOnline -AppId <%App_id%> -CertificateFilePath "C:\users\navin\Documents\TestCert.pfx" -Organization
                    "contoso.onmicrosoft.com"
                    This example connects to Exchange Online PowerShell in an unattended scripting scenario using the public key of a certificate.
                    -------------------------- Example 4 --------------------------
                    Connect-ExchangeOnline -AppId <%App_id%> -CertificateThumbprint <%Thumbprint string of certificate%> -Organization
                    "contoso.onmicrosoft.com"
                    This example connects to Exchange Online PowerShell in an unattended scripting scenario using a certificate thumbprint.
                    -------------------------- Example 5 --------------------------
                    Connect-ExchangeOnline -AppId <%App_id%> -Certificate <%X509Certificate2 object%> -Organization "contoso.onmicrosoft.com"
                    This example connects to Exchange Online PowerShell in an unattended scripting scenario using a certificate file. This method is best
                    suited for scenarios where the certificate is stored in remote machines and fetched at runtime. For example, the certificate is stored
                    in the Azure Key Vault.
                    -------------------------- Example 6 --------------------------
                    Connect-ExchangeOnline -Device
                    In PowerShell 7.0.3 or later using the EXO V2 module version 2.0.4 or later, this example connects to Exchange Online PowerShell in
                    interactive scripting scenarios on computers that don't have web browsers.
                    The command returns a URL and unique code that's tied to the session. You need to open the URL in a browser on any computer, and then
                    enter the unique code. After you complete the login in the web browser, the session in the Powershell 7 window is authenticated via
                    the regular Azure AD authentication flow, and the Exchange Online cmdlets are imported after few seconds.
                    -------------------------- Example 7 --------------------------
                    Connect-ExchangeOnline -InlineCredential
                    In PowerShell 7.0.3 or later using the EXO V2 module version 2.0.4 or later, this example connects to Exchange Online PowerShell in
                    interactive scripting scenarios by passing credentials directly in the PowerShell window.
                #>

                $pltCEO=[ordered]@{                    
                    erroraction = 'STOP' ;
                    ShowBanner = $false ; # force the fugly banner hidden
                } ;
                
                # 9:43 AM 8/2/2022 add defaulted prefix spec
                if($Prefix){
                    $smsg = "(adding specified Connect-ExchangeOnline -Prefix:$($Prefix))" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    $pltCEO.add('Prefix',$Prefix) ; 
                } ; 

                if ($MFA) {
                    if($credential.username -match $rgxCertThumbprint){
                        $smsg =  "(UserName:Certificate Thumbprint detected)"
                        if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        # cert CBA non-basic auth
                        <# CertificateThumbPrint = $Credential.UserName ;
	                        AppID = $Credential.GetNetworkCredential().Password ;
	                        Organization = 'TENANTNAME.onmicrosoft.com' ; # org is on $xxxmeta.o365_TenantDomain
                        #>
                        $pltCEO.Add("CertificateThumbPrint", [string]$Credential.UserName);                    
                        $pltCEO.Add("AppID", [string]$Credential.GetNetworkCredential().Password);
                        if($TenDomain = (Get-Variable  -name "$($TenOrg)Meta").value.o365_TenantDomain){
                            $pltCEO.Add("Organization", [string]$TenDomain);
                        } else { 
                            $smsg = "UNABLE TO RESOLVE `$TENORG:$($TenOrg) TO FUNCTIONAL `$$($TenOrg)meta.o365_TenantDomain!" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            throw $smsg ; 
                            Break ; 
                        } ; 
                        <# want the friendlyname to display the cred source in use #$tcert.friendlyname
                        if($tcert = get-childitem -path "Cert:\CurrentUser\My\$($credential.username)"){
                            $certUname = $tcert.friendlyname ; 
                            $certTag = [regex]::match($certUname,$rgxCertFNameSuffix).captures[0].groups[1].value ; 
                            $smsg = "(using CBA:cred:$($certTag):$([string]$tcert.friendlyname))" ; 
                            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        } else { 
                            $smsg = "UNABLE TO RESOLVE `$TENORG:$($TenOrg) TO FUNCTIONAL `$$($TenOrg)meta.o365_TenantDomain!" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            throw $smsg ; 
                            Break ; 
                        } ;
                        #>
                        $certUname = $uRoleReturn.FriendlyName ; 
                        $certTag = $uRoleReturn.TenOrg
                    } else { 
                        # interactive ModernAuth -UserPrincipalName
                        #$pltCXO.Add("UserPrincipalName", [string]$Credential.username);
                        if ($UserPrincipalName) {
                            $pltCEO.Add("UserPrincipalName", [string]$UserPrincipalName);
                            $smsg = "(using cred:$([string]$UserPrincipalName))" ; 
                            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        } elseif ($Credential -AND -not $UserPrincipalName){
                            $pltCEO.Add("UserPrincipalName", [string]$Credential.username);
                            $smsg = "(using cred:$($credential.username))" ; 
                            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        };
                    } 
                } else {
                    # just use the passed $Credential vari
                    #$pltCXO.Add("Credential", [System.Management.Automation.PSCredential]$Credential);
                    $pltCEO.Add("Credential", [System.Management.Automation.PSCredential]$Credential);
                    $smsg = "(using cred:$($credential.username))" ; 
                    if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                } ;

                $smsg = "Connect-ExchangeOnline w`n$(($pltCEO|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                TRY {
                    #Disconnect-ExchangeOnline -confirm:$false ;
                    #Connect-ExchangeOnline @pltCXO ;
                    Connect-ExchangeOnline @pltCEO ;
                    #Add-PSTitleBar $sTitleBarTag ;
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #-=-record a STATUSWARN=-=-=-=-=-=-=
                    $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                    if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                    if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                    #-=-=-=-=-=-=-=-=
                    $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                } ; 
                # -------- $UseConnEXO 
            } ; 
        } ; #  # if-E $bExistingEXOGood
    } ; # PROC-E
    END {
        
        <# 1:10 PM 3/1/2024 there are no more pss's in eom, rem it
        $smsg = "Existing PSSessions:`n$((get-pssession|out-string).trim())" ; 
        if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        #>

        if ($bExistingEXOGood -eq $false) {
            
            # defer into test-EXOv2Connection()
            # 11:18 AM 4/25/2023 add support for passing calc'd CertTag "Cert FriendlyName Suffix to be used for validating credential alignment(Optional but required for CBA calls)[-CertTag `$certtag]")][string]$CertTag
            if($CertTag -ne $null){
                $smsg = "(specifying detected `$CertTag:$($CertTag))" ; 
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $oRet = test-EXOv2Connection -Credential $credential -CertTag $certtag -verbose:$($verbose) ; 
            } else { 
                $oRet = test-EXOv2Connection -Credential $credential -verbose:$($verbose) ; 
            } ; 

            $bExistingEXOGood = $oRet.Valid ;
            if($oRet.Valid){
	            $pssEXOv2 = $oRet.PsSession ;
                $IsNoWinRM = $oRet.IsNoWinRM ; 
	            $smsg = "(Validated EXOv2 Connected to Tenant aligned with specified Credential)`n`$IsNoWinRM:$($IsNoWinRM )" ;
	            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else {
	            $smsg = "NO VALID EXOV2 PSSESSION FOUND! (DISCONNECTING...)"
	            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
	            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
	            # capture outlier: shows a session wo the test cmdlet, force reset
	            DisConnect-EXO ;
	            $bExistingEXOGood = $false ;
            } ;       

        } else {
            if($bPreExoPPss){
                $smsg = "(EMO bug-workaround: reconnecting prior ExOP PssSession,"
                $smsg += "`nreconnect-Ex2010 -Credential $($pltRX10.Credential.username) -verbose:$($VerbosePreference -eq "Continue"))" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                reconnect-Ex2010 -Credential $pltRX10.Credential -verbose:$($VerbosePreference -eq "Continue") ; 
            } ;
        } ; 

        if($VerbosePreference -eq "Continue"){
            # echo Exchange-tied PSS summary
            if($pssEXOP = Get-PSSession | 
                where-object { ($_.ConfigurationName -eq $EXoPConfigurationName) -AND (
                    $_.runspace.ConnectionInfo.AppName -match '^/(exadmin|powershell)$') -AND (
                    $_.runspace.ConnectionInfo.Port -eq '80') } ){
                $smsg = "`nExOP PSSessions:`n$(($pssEXOP | fl $pssprops|out-string).trim())" ; 
            } ;
            if($pssEXOv1 = Get-PSSession | 
                    where-object {$_.ConfigurationName -like $EXOv1ConfigurationName -AND (
                        $_.ComputerName -eq 'ps.outlook.com') -AND ($_.runspace.ConnectionInfo.AppName -eq '/PowerShell-LiveID') -AND (
                        $_.runspace.ConnectionInfo.Port -eq '443') }){
                $smsg += "`n`nEXOv1 PSSessions:`n$(($pssEXOv1 | fl $pssprops|out-string).trim())" ; 
            } ; 
            if($pssEXOv2 = Get-PSSession | 
                    where-object {$_.ConfigurationName -like $EXOv2ConfigurationName -AND (
                        $_.Name -like $EXOv2Name) -AND ($_.ComputerName -eq $EXOv2ComputerName)} ){
                $smsg += "`n`nEXOv2 PSSessions:`n$(($pssEXOv2 | fl $pssprops|out-string).trim())" ; 
            } ;
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            if($bPreExoPPss -AND -not $pssEXOP){
                $smsg = "(EMO bug-workaround: reconnecting prior ExOP PssSession,"
                $smsg += "`nreconnect-Ex2010 -Credential $($pltRX10.Credential.username) -verbose:$($VerbosePreference -eq "Continue"))" ; 
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                reconnect-Ex2010 -Credential $pltRX10.Credential -verbose:$($VerbosePreference -eq "Continue") ; 
            } else { 
                $smsg = "(no bPreExoPPss, no Rx10 conn restore)" ; 
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } ; 

            if($IsNoWinRM -AND ((get-module $EXOv2GmoNoWinRMFilter) -AND (get-module $EOMModName))){
                $smsg = "(native non-WinRM/Non-PSSession-based EXO connection detected." ; 
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } ; 
        } ; 

        # 10:37 AM 4/18/2023: Rem this: Been seldom capturing returns: that's bound to contaiminate pipeline! May have planned to grab and compare, but never really implemented
        #$bExistingEXOGood | write-output ;
        # splice in console color scheming
    }  # END-E
}

#*------^ Connect-EXO.ps1 ^------


#*------v Connect-EXOPSSession.ps1 v------
function Connect-EXOPSSession {
    <#
    .SYNOPSIS
   Connect-EXOPSSession.ps1 - Stripped to basics version of the Exchangeonlinemanagement module:connect-ExchangeOnline(), uses RemoveExistingEXOPSSession (vs RemoveExistingPSSession) to leave CCMS sessions intact, and permit run of concurrent EXO & CCMS sessions
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 20201109-0833AM
    FileName    :Connect-EXOPSSession.ps1
    License     : [none specified]
    Copyright   : [none specified]
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : Microsoft (edited version of published commands in the module)
    AddedWebsite: https://www.powershellgallery.com/packages/CreateExoPsSession/0.1/Content/CreateExoPsSession.psm1
    REVISIONS
    * 3:36 PM 11/9/2020 init debugged to basic function
    .DESCRIPTION
   Connect-EXOPSSession.ps1 - *another* take on a stripped to basics version of the Exchangeonlinemanagement module:connect-ExchangeOnline(), uses RemoveExistingEXOPSSession (vs RemoveExistingPSSession) to leave CCMS sessions intact, and permit run of concurrent EXO & CCMS sessions
    .PARAMETER ConnectionUri
    Connection Uri for the Remote PowerShell endpoint
    .PARAMETER AzureADAuthorizationEndpointUri,
    Azure AD Authorization endpoint Uri that can issue the OAuth2 access tokens
    .PARAMETER ExchangeEnvironmentName = 'O365Default',
    Exchange Environment name
    .PARAMETER PSSessionOption
    PowerShell session options to be used when opening the Remote PowerShell session
    .PARAMETER BypassMailboxAnchoring
    Switch to bypass use of mailbox anchoring hint.
    .PARAMETER DelegatedOrganization
    Delegated Organization Name
    .PARAMETER Prefix
    Command Prefix
    .PARAMETER ShowBanner
    Show Banner of Exchange cmdlets Mapping and recent updates
    .PARAMETER UserPrincipalName
    User Principal Name or email address of the user
    .PARAMETER Credential
    User Credential to Logon
    .PARAMETER EnableErrorReporting
    Switch to collect telemetry on command execution. - NOPE
    .PARAMETER TrackPerformance
    Switch to track perfomance
    .PARAMETER ShowProgress = $false
    Flag to enable or disable showing the number of objects written
    .PARAMETER UseMultithreading
    Switch to enable/disable Multi-threading in the EXO cmdlets
    .PARAMETER Pagesize
    Pagesize Param
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    $PSSession = New-ExoPSSession -ExchangeEnvironmentName $ExchangeEnvironmentName -ConnectionUri $ConnectionUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -UserPrincipalName $UserPrincipalName.Value -PSSessionOption $PSSessionOption -Credential $Credential.Value -BypassMailboxAnchoring:$BypassMailboxAnchoring -DelegatedOrg $DelegatedOrganization
    .EXAMPLE
    connect-exov2Raw -credential $credO365TORSID -prefix xo
    .LINK
    https://github.com/tostka/verb-EXO
    .LINK
    https://www.powershellgallery.com/packages/CreateExoPsSession/0.1/Content/CreateExoPsSession.psm1
    #>

    param(
        # Connection Uri for the Remote PowerShell endpoint
        [string] $ConnectionUri = 'https://outlook.office365.com/PowerShell-LiveId',
        # Azure AD Authorization endpoint Uri that can issue the OAuth2 access tokens
        [string] $AzureADAuthorizationEndpointUri = 'https://login.windows.net/common',
        # User Principal Name or email address of the user
        [string] $UserPrincipalName = '',
        # PowerShell session options to be used when opening the Remote PowerShell session
        [System.Management.Automation.Remoting.PSSessionOption] $PSSessionOption = $null,
        # User Credential to Logon
        [System.Management.Automation.PSCredential] $Credential = $null
    )

    # Validate parameters
    if (-not (Test-Uri $ConnectionUri)){throw "Invalid ConnectionUri parameter '$ConnectionUri'"}
    if (-not (Test-Uri $AzureADAuthorizationEndpointUri)){throw "Invalid AzureADAuthorizationEndpointUri parameter '$AzureADAuthorizationEndpointUri'"}

    try{
        # Cleanup old ps sessions - TSK this is gonna kill EVERYTHING! not good
        Get-PSSession | Remove-PSSession

        # TSK, don't use psscript, pull it dyn from profile
        if(!$PSExoPowershellModuleRoot){$PSExoPowershellModuleRoot = (Get-ChildItem -Path $($env:LOCALAPPDATA+"\Apps\2.0\") -Filter CreateExoPSSession.ps1 -Recurse -ErrorAction SilentlyContinue -Force | Select -Last 1).DirectoryName } ; 
        if(!$ExoPowershellModule){$ExoPowershellModule = "Microsoft.Exchange.Management.ExoPowershellModule.dll"} ; 
        if(!$ExoPowershellModulePath){$ExoPowershellModulePath = [System.IO.Path]::Combine($PSExoPowershellModuleRoot, $ExoPowershellModule)} ; 

        $global:_EXO_ConnectionUri = $ConnectionUri;
        $global:_EXO_AzureADAuthorizationEndpointUri = $AzureADAuthorizationEndpointUri;
        $global:_EXO_UserPrincipalName = $UserPrincipalName;
        $global:_EXO_PSSessionOption = $PSSessionOption;
        $global:_EXO_Credential = $Credential;

        Import-Module $ExoPowershellModulePath -verbose:$false;
        $PSSession = New-ExoPSSession -UserPrincipalName $UserPrincipalName -ConnectionUri $ConnectionUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -PSSessionOption $PSSessionOption -Credential $Credential
    
        if ($PSSession -ne $null)
        {
            Import-PSSession $PSSession -AllowClobber -Prefix $Prefix ;
            UpdateImplicitRemotingHandler
        }
    }catch{
        throw $_
    }
}

#*------^ Connect-EXOPSSession.ps1 ^------


#*------v connect-EXOv2RAW.ps1 v------
function connect-EXOv2RAW {
    <#
    .SYNOPSIS
    Connect-ExchangeOnlineTargetedPurge.ps1 - Stripped to basics version of the Exchangeonlinemanagement module:connect-ExchangeOnline(), uses RemoveExistingEXOPSSession (vs RemoveExistingPSSession) to leave CCMS sessions intact, and permit run of concurrent EXO & CCMS sessions
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 20201109-0833AM
    FileName    : Connect-ExchangeOnlineTargetedPurge.ps1
    License     : [none specified]
    Copyright   : [none specified]
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : Microsoft (edited version of published commands in the module)
    AddedWebsite:	https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
    REVISIONS
    * 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
    # 8:34 AM 3/31/2021 added verbose suppress to all import-mods
    * 3:36 PM 11/9/2020 init debugged to basic function
    .DESCRIPTION
    Connect-ExchangeOnlineTargetedPurge.ps1 - Stripped to basics version of the Exchangeonlinemanagement module:connect-ExchangeOnline(), uses RemoveExistingEXOPSSession (vs RemoveExistingPSSession) to leave CCMS sessions intact, and permit run of concurrent EXO & CCMS sessions
    .PARAMETER ConnectionUri
    Connection Uri for the Remote PowerShell endpoint
    .PARAMETER AzureADAuthorizationEndpointUri,
    Azure AD Authorization endpoint Uri that can issue the OAuth2 access tokens
    .PARAMETER ExchangeEnvironmentName = 'O365Default',
    Exchange Environment name
    .PARAMETER PSSessionOption
    PowerShell session options to be used when opening the Remote PowerShell session
    .PARAMETER BypassMailboxAnchoring
    Switch to bypass use of mailbox anchoring hint.
    .PARAMETER DelegatedOrganization
    Delegated Organization Name
    .PARAMETER Prefix
    Command Prefix
    .PARAMETER ShowBanner
    Show Banner of Exchange cmdlets Mapping and recent updates
    .PARAMETER UserPrincipalName
    User Principal Name or email address of the user
    .PARAMETER Credential
    User Credential to Logon
    .PARAMETER EnableErrorReporting
    Switch to collect telemetry on command execution. - NOPE
    .PARAMETER TrackPerformance
    Switch to track perfomance
    .PARAMETER ShowProgress = $false
    Flag to enable or disable showing the number of objects written
    .PARAMETER UseMultithreading
    Switch to enable/disable Multi-threading in the EXO cmdlets
    .PARAMETER Pagesize
    Pagesize Param
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    $PSSession = New-ExoPSSession -ExchangeEnvironmentName $ExchangeEnvironmentName -ConnectionUri $ConnectionUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -UserPrincipalName $UserPrincipalName.Value -PSSessionOption $PSSessionOption -Credential $Credential.Value -BypassMailboxAnchoring:$BypassMailboxAnchoring -DelegatedOrg $DelegatedOrganization
    .EXAMPLE
    connect-exov2Raw -credential $credO365TORSID -prefix xo
    .LINK
    https://github.com/tostka/verb-EXO
    .LINK
    https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
    #>
    [CmdletBinding()]
    param(
        # stock params
        # Connection Uri for the Remote PowerShell endpoint
        [string] $ConnectionUri,
        # Azure AD Authorization endpoint Uri that can issue the OAuth2 access tokens
        [string] $AzureADAuthorizationEndpointUri,
        # Exchange Environment name
        [Microsoft.Exchange.Management.RestApiClient.ExchangeEnvironment] $ExchangeEnvironmentName = 'O365Default',
        # PowerShell session options to be used when opening the Remote PowerShell session
        [System.Management.Automation.Remoting.PSSessionOption] $PSSessionOption = $null,
        # Switch to bypass use of mailbox anchoring hint.
        [switch] $BypassMailboxAnchoring = $false,
        # Delegated Organization Name
        [string] $DelegatedOrganization,
        # Prefix
        [string] $Prefix,
        # Show Banner of Exchange cmdlets Mapping and recent updates
        [switch] $ShowBanner,

        # add back the dynamic paras as explicit paras:
        # User Principal Name or email address of the user
        [string]$UserPrincipalName,
        # User Credential to Logon
        [System.Management.Automation.PSCredential]$Credential,
        # Switch to collect telemetry on command execution. - NOPE
        #[switch]$EnableErrorReporting
        # Switch to track perfomance
        [switch]$TrackPerformance,
        # Flag to enable or disable showing the number of objects written
        [switch]$ShowProgress,
        # Switch to enable/disable Multi-threading in the EXO cmdlets
        [switch]$UseMultithreading = $true,
        # Pagesize Param
        [uint32]$PageSize = 1000
    )

    # intent is to strip down the ExchangeOnlineManagement module's Connect-ExchangeOnline and distill it into the lowest level non-wrapped commands available

    # drop all the cloudshell support variants
    # just straight path to new-EXOPsSession

    BEGIN {
        # TSK:add a BEGIN block & stick THE ExchangOnlineManagement.psm1 'above-the mods' variable/load specs in here, with tests added
        # Import the REST module so that the EXO* cmdlets are present before Connect-ExchangeOnline in the powershell instance.

        if (-not($ExchangeOnlineMgmtPath)) {
            $EOMgmtModulePath = split-path (get-module ExchangeOnlineManagement -list | sort version | select -last 1 ).Path ;
        } ;
        if (!$RestModule) { $RestModule = "Microsoft.Exchange.Management.RestApiClient.dll" } ;
        # stock uses $PSScriptRoot, which will be the verb-EXO path, not the EXOMgmt module have to dyn locate it
        if (!$RestModulePath) {
            $RestModulePath = [System.IO.Path]::Combine($EOMgmtModulePath, $RestModule)
        } ;
        # paths to proper Module path: Name lists as: Microsoft.Exchange.Management.RestApiClient
        if (-not(get-module Microsoft.Exchange.Management.RestApiClient)) {
            Import-Module $RestModulePath -verbose:$false ;
        } ;

        if (!$ExoPowershellModule) { $ExoPowershellModule = "Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll" } ;
        if (!$ExoPowershellModulePath) {
            $ExoPowershellModulePath = [System.IO.Path]::Combine($EOMgmtModulePath, $ExoPowershellModule) ;
        } ;
        # full path: C:\Users\SIDs\Documents\WindowsPowerShell\Modules\ExchangeOnlineManagement\1.0.1\Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll
        # Name: Microsoft.Exchange.Management.ExoPowershellGalleryModule
        if (-not(get-module Microsoft.Exchange.Management.ExoPowershellGalleryModule)) {
            Import-Module $ExoPowershellModulePath -Verbose:$false ;
        } ;
    }
    PROCESS {
        # Validate parameters
        if (($ConnectionUri) -and (-not (Test-Uri $ConnectionUri))) {
            throw "Invalid ConnectionUri parameter '$ConnectionUri'"
        }
        if (($AzureADAuthorizationEndpointUri) -and (-not (Test-Uri $AzureADAuthorizationEndpointUri))) {
            throw "Invalid AzureADAuthorizationEndpointUri parameter '$AzureADAuthorizationEndpointUri'"
        }
        if (($Prefix) -and ($Prefix -eq 'EXO')) {
            throw "Prefix 'EXO' is a reserved Prefix, please use a different prefix."
        }
        if ($ShowBanner -eq $true) {
            Print-Details;
        }
        if (($ConnectionUri) -and (-not($AzureADAuthorizationEndpointUri))) {
            Write-Host -ForegroundColor Green "Using ConnectionUri:'$ConnectionUri', in the environment:'$ExchangeEnvironmentName'."
        }
        if (($AzureADAuthorizationEndpointUri) -and (-not($ConnectionUri))) {
            Write-Host -ForegroundColor Green "Using AzureADAuthorizationEndpointUri:'$AzureADAuthorizationEndpointUri', in the environment:'$ExchangeEnvironmentName'."
        }
        # Keep track of error count at beginning.
        $errorCountAtStart = $global:Error.Count;
        $global:_EXO_TelemetryFilePath = $null;

        try {
            # Cleanup old exchange online PSSessions
            #RemoveExistingPSSession
            RemoveExistingEXOPSSession
            $ExoPowershellModule = "Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll";
            $ModulePath = [System.IO.Path]::Combine($EOMgmtModulePath, $ExoPowershellModule);
            # stock globals recording the session
            $global:_EXO_ExchangeEnvironmentName = $ExchangeEnvironmentName;
            $global:_EXO_ConnectionUri = $ConnectionUri;
            $global:_EXO_AzureADAuthorizationEndpointUri = $AzureADAuthorizationEndpointUri;
            $global:_EXO_PSSessionOption = $PSSessionOption;
            $global:_EXO_BypassMailboxAnchoring = $BypassMailboxAnchoring;
            $global:_EXO_DelegatedOrganization = $DelegatedOrganization;
            $global:_EXO_Prefix = $Prefix;
            $global:_EXO_UserPrincipalName = $UserPrincipalName;
            $global:_EXO_Credential = $Credential;
            $global:_EXO_EnableErrorReporting = $EnableErrorReporting;
            # import the ExoPowershellModule .dll
            Import-Module $ModulePath -verbose:$false;
            $global:_EXO_ModulePath = $ModulePath;
            # $PSSession = New-ExoPSSession -ExchangeEnvironmentName $ExchangeEnvironmentName -ConnectionUri $ConnectionUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -UserPrincipalName $UserPrincipalName.Value -PSSessionOption $PSSessionOption -Credential $Credential.Value -BypassMailboxAnchoring:$BypassMailboxAnchoring -DelegatedOrg $DelegatedOrganization

            $pltNEXOS = @{
                ExchangeEnvironmentName         = $ExchangeEnvironmentName ;
                ConnectionUri                   = $ConnectionUri ;
                AzureADAuthorizationEndpointUri = $AzureADAuthorizationEndpointUri ;
                UserPrincipalName               = $UserPrincipalName ;
                PSSessionOption                 = $PSSessionOption ;
                Credential                      = $Credential ;
                BypassMailboxAnchoring          = $($BypassMailboxAnchoring) ;
                DelegatedOrg                    = $DelegatedOrganization ;
            }
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):New-ExoPSSession w`n$(($pltNEXOS|out-string).trim())" ;
            $PSSession = New-ExoPSSession @pltNEXOS ;

            if ($PSSession -ne $null ) {
                $PSSessionModuleInfo = Import-PSSession $PSSession -AllowClobber -DisableNameChecking
                $pltIMod=@{Global=$true;DisableNameChecking=$true ; verbose=$false} ; # force verbose off, suppress spam in console
                if($Prefix){
                    $pltIMod.add('Prefix',$CommandPrefix) ;
                } ;
                # Import the above module globally. This is needed as with using psm1 files,
                # any module which is dynamically loaded in the nested module does not reflect globally.
                Import-Module $PSSessionModuleInfo.Path @pltIMod ;
                # haven't checked into what this does
                UpdateImplicitRemotingHandler ;

                # Import the REST module .dll
                $RestPowershellModule = "Microsoft.Exchange.Management.RestApiClient.dll";
                $RestModulePath = [System.IO.Path]::Combine($EOMgmtModulePath, $RestPowershellModule);
                Import-Module $RestModulePath -Cmdlet Set-ExoAppSettings -verbose:$false;

                # Set the AppSettings disabling the logging
                Set-ExoAppSettings -ShowProgress $ShowProgress.Value -PageSize $PageSize.Value -UseMultithreading $UseMultithreading.Value -TrackPerformance $TrackPerformance.Value -ExchangeEnvironmentName $ExchangeEnvironmentName -ConnectionUri $ConnectionUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -EnableErrorReporting $false ;

            }

        } CATCH {
            Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
            Exit #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ;

    }

}

#*------^ connect-EXOv2RAW.ps1 ^------


#*------v Connect-IPPSSessionTargetedPurge.ps1 v------
function Connect-IPPSSessionTargetedPurge{
    <#
    .SYNOPSIS
    Connect-IPPSSessionTargetedPurge.ps1 - localized verb-EXO vers of non-'$global:' funct from ExchangeOnlineManagement. The globals export fine, these don't and appear to need to be loaded manually
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 20201109-0833AM
    FileName    : Connect-IPPSSessionTargetedPurge.ps1
    License     : [none specified]
    Copyright   : [none specified]
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell
    AddedCredit : Microsoft (edited version of published commands in the module)
    AddedWebsite:	https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
    REVISIONS
    * 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
    * 11:38 AM 9/16/2021 string
    * 8:34 AM 11/9/2020 init
    .DESCRIPTION
    Connect-IPPSSessionTargetedPurge.ps1 - Extract organization name from UserPrincipalName ; localized verb-EXO vers of non-'$global:' helper funct from ExchangeOnlineManagement. The globals export fine, these don't and appear to need to be loaded manually
    .PARAMETER ConnectionUri = 'https://ps.compliance.protection.outlook.com/PowerShell-LiveId',
    Connection Uri for the Remote PowerShell endpoint
    .PARAMETER AzureADAuthorizationEndpointUri = 'https://login.windows.net/common',
    Azure AD Authorization endpoint Uri that can issue the OAuth2 access tokens
    .PARAMETER DelegatedOrganization = '',
    Delegated Organization Name
    .PARAMETER PSSessionOption = $null,
    PowerShell session options to be used when opening the Remote PowerShell session
    .PARAMETER BypassMailboxAnchoring = $false
    Switch to bypass use of mailbox anchoring hint.
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    Connect-IPPSSessionTargetedPurge
    Stock call
    .LINK
    https://github.com/tostka/verb-EXO
    .LINK
    https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
    #>
    [CmdletBinding()]
    param(
        # Connection Uri for the Remote PowerShell endpoint
        [string] $ConnectionUri = 'https://ps.compliance.protection.outlook.com/PowerShell-LiveId',

        # Azure AD Authorization endpoint Uri that can issue the OAuth2 access tokens
        [string] $AzureADAuthorizationEndpointUri = 'https://login.windows.net/common',

        # Delegated Organization Name
        [string] $DelegatedOrganization = '',

        # PowerShell session options to be used when opening the Remote PowerShell session
        [System.Management.Automation.Remoting.PSSessionOption] $PSSessionOption = $null,

        # Switch to bypass use of mailbox anchoring hint.
        [switch] $BypassMailboxAnchoring = $false
    )
    DynamicParam
    {
        if (($isCloudShell = IsCloudShellEnvironment) -eq $false)
        {
            $attributes = New-Object System.Management.Automation.ParameterAttribute
            $attributes.Mandatory = $false

            $attributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $attributeCollection.Add($attributes)

            # User Principal Name or email address of the user
            $UserPrincipalName = New-Object System.Management.Automation.RuntimeDefinedParameter('UserPrincipalName', [string], $attributeCollection)
            $UserPrincipalName.Value = ''

            # User Credential to Logon
            $Credential = New-Object System.Management.Automation.RuntimeDefinedParameter('Credential', [System.Management.Automation.PSCredential], $attributeCollection)
            $Credential.Value = $null

            $paramDictionary = New-object System.Management.Automation.RuntimeDefinedParameterDictionary
            $paramDictionary.Add('UserPrincipalName', $UserPrincipalName)
            $paramDictionary.Add('Credential', $Credential)
            return $paramDictionary
        }
        else
        {
            $attributes = New-Object System.Management.Automation.ParameterAttribute
            $attributes.Mandatory = $false

            $attributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $attributeCollection.Add($attributes)

            # Switch to MSI auth 
            $Device = New-Object System.Management.Automation.RuntimeDefinedParameter('Device', [switch], $attributeCollection)
            $Device.Value = $false

            $paramDictionary = New-object System.Management.Automation.RuntimeDefinedParameterDictionary
            $paramDictionary.Add('Device', $Device)
            return $paramDictionary
        }
    }
        BEGIN {
        # TSK:add a BEGIN block & stick THE ExchangOnlineManagement.psm1 'above-the mods' variable/load specs in here, with tests added
        # Import the REST module so that the EXO* cmdlets are present before Connect-ExchangeOnline in the powershell instance.
        
        if(-not($ExchangeOnlineMgmtPath)){
            $EOMgmtModulePath = split-path (get-module ExchangeOnlineManagement -list| sort version | select -last 1 ).Path ; 
        } ; 
        if(!$RestModule){$RestModule = "Microsoft.Exchange.Management.RestApiClient.dll"} ;
        # $PSScriptRoot will be the verb-EXO path, not the EXOMgmt module have to dyn locate it
        if(!$RestModulePath){
            #$RestModulePath = [System.IO.Path]::Combine($PSScriptRoot, $RestModule)
            $RestModulePath = [System.IO.Path]::Combine($EOMgmtModulePath, $RestModule)
        } ;
        # paths to proper Module path: Name lists as: Microsoft.Exchange.Management.RestApiClient
        if(-not(get-module Microsoft.Exchange.Management.RestApiClient)){
            Import-Module $RestModulePath -verbose:$false ;
        } ;

        if(!$ExoPowershellModule){$ExoPowershellModule = "Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll"} ;
        if(!$ExoPowershellModulePath){
            $ExoPowershellModulePath = [System.IO.Path]::Combine($EOMgmtModulePath, $ExoPowershellModule) ;
        } ;
        # full path: C:\Users\LOGON\Documents\WindowsPowerShell\Modules\ExchangeOnlineManagement\1.0.1\Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll
        # Name: Microsoft.Exchange.Management.ExoPowershellGalleryModule
        if(-not(get-module Microsoft.Exchange.Management.ExoPowershellGalleryModule)){
            Import-Module $ExoPowershellModulePath -verbose:$false ;
        } ; 
    } 
    process 
    {
        [string]$newUri = $null;

        if (![string]::IsNullOrWhiteSpace($DelegatedOrganization))
        {
            [UriBuilder] $uriBuilder = New-Object -TypeName UriBuilder -ArgumentList $ConnectionUri;
            [string] $queryToAppend = "DelegatedOrg={0}" -f $DelegatedOrganization;
            if ($uriBuilder.Query -ne $null -and $uriBuilder.Query.Length -gt 0)
            {
                [string] $existingQuery = $uriBuilder.Query.Substring(1);
                $uriBuilder.Query = $existingQuery + "&" + $queryToAppend;
            }
            else
            {
                $uriBuilder.Query = $queryToAppend;
            }

            $newUri = $uriBuilder.ToString();
        }
        else
        {
           $newUri = $ConnectionUri;
        }

        if ($isCloudShell -eq $false)
        {
            Connect-ExchangeOnline -ConnectionUri $newUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -UserPrincipalName $UserPrincipalName.Value -PSSessionOption $PSSessionOption -Credential $Credential.Value -BypassMailboxAnchoring:$BypassMailboxAnchoring -ShowBanner:$false
        }
        else
        {
            Connect-ExchangeOnline -ConnectionUri $newUri -AzureADAuthorizationEndpointUri $AzureADAuthorizationEndpointUri -PSSessionOption $PSSessionOption -BypassMailboxAnchoring:$BypassMailboxAnchoring -Device:$Device.Value -ShowBanner:$false
        }
    }
}

#*------^ Connect-IPPSSessionTargetedPurge.ps1 ^------


#*------v convert-ADUserRecipientTypeRemoteSharedMailbox.ps1 v------
function convert-ADUserRecipientTypeRemoteSharedMailbox{
    <#
    .SYNOPSIS
    Convert the passed-in ADUser object RecipientType to RemoteSharedMailbox (sets ADUser.msExchRecipientTypeDetails:'34359738368' ADUUser.msExchRemoteRecipientType:'100').
    1st half of RemoteUserMailbox conversion to ReomteSharedMailbox (followed by convert-exoMailboxTypeSharedMailbox to convert the EXO mailbox type).
    Traditionally this would be applied to RemoteUserMailbox, but no pre-checking is performed, the update is applied as long as the target settings aren't already in place.
    .NOTES
    Author: Todd Kadrie
    Website:	http://www.toddomation.com
    Twitter:	@tostka, http://twitter.com/tostka
    REVISIONS   :
    * 10:12 AM 5/18/2023 add: adv func beg/proc blocks: full pipeline support ; ren'd mid proc block vari added explicit loop
    * 8:46 AM 5/17/2023 add to vXO; ren'd to convert-ADUserRecipientTypeRemoteSharedMailbox (rmvd _ internal prefix), and aliased orig name(convert-ADUserRecipientType), strongly typed $ADUser as [Microsoft.ActiveDirectory.Management.ADUser]
    * 1:06 PM 8/25/2021 ren convertADUser -> convert-ADUserRecipientType
    # 2:51 PM 12/18/2018 set-adus has functional whatif, moved it into test fire
    # 12:31 PM 10/23/2018 ran full pass live, no unusual errors
    .DESCRIPTION
    Convert the passed-in ADUser object RecipientType to RemoteSharedMailbox (sets ADUser.msExchRecipientTypeDetails:'34359738368' ADUUser.msExchRemoteRecipientType:'100').
    1st half of RemoteUserMailbox conversion to ReomteSharedMailbox (followed by convert-exoMailboxTypeSharedMailbox to convert the EXO mailbox type).
    Traditionally this would be applied to RemoteUserMailbox, but no pre-checking is performed, the update is applied as long as the target settings aren't already in place.

    (does not require passed in Credentials, as all changes are with ActiveDirectory module, which does not support affirmative logon; logon is pickedup from the psdrive AD mapping) 

    .PARAMETER  ADUser
    ADUser object [-ADUser `$ADVariable]
    .PARAMETER Whatif
    Parameter to run a Test no-change pass, and log results [-Whatif switch]
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Returns RemoteMailbox object, or $false on failure.
    .EXAMPLE
    $adu=get-aduser -id $rmbx.DistinguishedName -server $domainController -Properties $adprops -ea 0| select $adprops ;
    $bRet=convert-ADUserRecipientType -ADUser $adu -whatif:$($whatif) -showDebug:$($showdebug) ;
    Convert the passed-in ADUser object RecipientType from RemoteUserMailbox to RemoteSharedMailbox.
    (does not require passed in Credentials, as all changes are with ActiveDirectory module, which does not support affirmative logon; logon is pickedup from the psdrive AD mapping automounted on ActieDirectory module load) 
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    [CmdletBinding()]
    [Alias('convert-ADUserRecipientType')]
    PARAM(
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,HelpMessage="ADUser object [-ADUser `$ADVariable]")]
            [ValidateNotNullOrEmpty()]
            [Microsoft.ActiveDirectory.Management.ADUser]$ADUser,
        [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
            [switch] $showDebug,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
            [switch] $whatIf
    ) # PARAM BLOCK END
    BEGIN {} ;  # BEGIN-E
    PROCESS {
            foreach($ADU in $ADUser) {
            $error.clear() ;
            $Exit = 0 ;
            Do {
                Try {
                    if(!$domaincontroller){$domaincontroller=get-gcfast} ;
                    $adprops="samaccountname","msExchRemoteRecipientType","msExchRecipientDisplayType","msExchRecipientTypeDetails","UserPrincipalName","DistinguishedName" ;
                    $exprops="SamAccountName","RecipientType","RecipientTypeDetails","UserPrincipalName" ;
                    if($ADU){
                        $smsg= "PRE:ADUser`n$(($ADU| format-list $adprops|out-string ).trim())" ; ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        $smsg="PRE:Ex Remotemailbox`n$((Get-RemoteMailbox $ADU.userprincipalname -domaincontroller $domaincontroller| format-list $exprops|out-string ).trim())" ;  ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        if($ADU.msExchRecipientTypeDetails -eq '34359738368' -and $ADU.msExchRemoteRecipientType -eq '100'){
                            $smsg= "PRE:$($ADU.userprincipalname) has already been converted to RemoteSharedMailbox" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } else {
                            $pltSADU=[ordered]@{
                                Identity=$ADU.samaccountname ;
                                Replace=@{msExchRemoteRecipientType=100;msExchRecipientTypeDetails=34359738368}  ;
                                server=$domaincontroller ;
                                whatif=$($whatif) ;
                            } ;
                            $smsg= "Set-aduser with:`n$(($pltSADU|out-string).trim())`n" ;
                            #expand replace values
                            $smsg += "`n$(($pltsadu.replace | fl|out-string).trim())`n" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            Set-ADUser @pltSADU ;
                            if(!$whatif){
                                $smsg= "POST:ADUser`n$((Get-adUser -id $ADU.samaccountname -prop $adprops -server $domaincontroller|fl $adprops | out-string).trim())`n" ;;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                $smsg= "POST:Ex Remotemailbox`n$((Get-RemoteMailbox $ADU.userprincipalname -domaincontroller $domaincontroller| format-list $exprops|out-string ).trim())" ; ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } else {
                                write-host -fore yellow "(whatif detected, skipping update)"
                            } ;
                        } ;
                        $true | write-output ;
                    } else {
                        $smsg="`n:`$tEmlAddr:$($tEmlAddr): not matched against ADUser`n" ;  ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $DoRetries ;
                } Catch {
                    Start-Sleep -Seconds $RetrySleep ;
                    $Exit ++ ;
                    $smsg = "Failed to exec cmd because: $($Error[0])" ;
                    $smsg += "`nTry #: $Exit" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    If ($Exit -eq $DoRetries) {
                        $smsg =  "Unable to exec cmd!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    Continue ;
                }  ;
            } Until ($Exit -eq $DoRetries) ;
        } ;  # loop-E
    } ;  # PROC-E
}

#*------^ convert-ADUserRecipientTypeRemoteSharedMailbox.ps1 ^------


#*------v convert-ADUserRecipientTypeRemoteUserMailbox.ps1 v------
function convert-ADUserRecipientTypeRemoteUserMailbox{
    <#
    .SYNOPSIS
    Convert the passed-in ADUser object RecipientType to RemoteUserMailbox (Sets ADUser.msExchRecipientTypeDetails:'2147483648' & ADUser.msExchRemoteRecipientType:'4')
    1st half of RemoteUserMailbox conversion to ReomteSharedMailbox (followed by convert-exoMailboxTypeUserMailbox to convert the EXO mailbox type).
    Traditionally this would be applied to RemoteSharedMailbox, but no pre-checking is performed, the update is applied as long as the target settings aren't already in place.
    .NOTES
    Author: Todd Kadrie
    Website:	http://www.toddomation.com
    Twitter:	@tostka, http://twitter.com/tostka
    REVISIONS   :
    * 8:46 AM 5/17/2023 add to vXO; ren'd back to convert-ADUserRecipientTypeRemoteUserMailbox (rmvd _ internal prefix), and aliased orig name(revert-ADuserRecipientType);
            strongly typed $ADUser as [Microsoft.ActiveDirectory.Management.ADUser]; updated CBH ; 
    1:08 PM 8/25/2021 ren revertADuser -> _revert-ADuserRecipientType
    # 2:51 PM 12/18/2018 set-adus has functional whatif, moved it into test fire
    # 1:34 PM 12/17/2018 initi vers
    .DESCRIPTION
    Convert the passed-in ADUser object RecipientType to RemoteUserMailbox (Sets ADUser.msExchRecipientTypeDetails:'2147483648' & ADUser.msExchRemoteRecipientType:'4')
    1st half of RemoteUserMailbox conversion to ReomteSharedMailbox (followed by convert-exoMailboxTypeUserMailbox to convert the EXO mailbox type).
    Traditionally this would be applied to RemoteSharedMailbox, but no pre-checking is performed, the update is applied as long as the target settings aren't already in place.

    (does not require passed in Credentials, as all changes are with ActiveDirectory module, which does not support affirmative logon; logon is pickedup from the psdrive AD mapping) 

    .PARAMETER  ADUser
    ADUser object [-ADUser `$ADVariable]
    .PARAMETER Whatif
    Parameter to run a Test no-change pass, and log results [-Whatif switch]
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Returns RemoteMailbox object, or $false on failure.
    .EXAMPLE
    $adu=get-aduser -id $rmbx.DistinguishedName -server $domainController -Properties $adprops -ea 0| select $adprops ;
    $bRet=convert-ADUserRecipientTypeRemoteUserMailbox -ADUser $adu -whatif:$($whatif) -showDebug:$($showdebug) ;
    Convert the passed-in ADUser object RecipientType from RemoteUserMailbox to RemoteSharedMailbox.
    (does not require passed in Credentials, as all changes are with ActiveDirectory module, which does not support affirmative logon; logon is pickedup from the psdrive AD mapping automounted on ActieDirectory module load) 
    .LINK
    #>
    [CmdletBinding()]
    [Alias('revert-ADuserRecipientType')]
    PARAM(
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,HelpMessage="ADUser object [-ADUser `$ADVariable]")]
        [ValidateNotNullOrEmpty()]
        [Microsoft.ActiveDirectory.Management.ADUser]$ADUser,
        [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
            [switch] $showDebug,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
            [switch] $whatIf
    ) # PARAM BLOCK END
    BEGIN {} ;  # BEGIN-E
    PROCESS {
        foreach($ADU in $ADUser) {
            $error.clear() ;
            $Exit = 0 ;
            Do {
                Try {
                    if(!$domaincontroller){$domaincontroller=get-gcfast} ;
                    $adprops="samaccountname","msExchRemoteRecipientType","msExchRecipientDisplayType","msExchRecipientTypeDetails","UserPrincipalName","DistinguishedName" ;
                    $exprops="SamAccountName","RecipientType","RecipientTypeDetails","UserPrincipalName" ;
                    if($ADU){
                        $smsg= "PRE:ADUser`n$(($ADU| format-list $adprops|out-string ).trim())" ; ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $smsg="PRE:Ex Remotemailbox`n$((Get-RemoteMailbox $ADU.userprincipalname -domaincontroller $domaincontroller| format-list $exprops|out-string ).trim())" ;  ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        # convert remoteshared back to remote user:
                        if($ADU.msExchRecipientTypeDetails -eq '2147483648' -and $ADU.msExchRemoteRecipientType -eq '4'){
                            #$smsg= "PRE:$($ADU.userprincipalname) has already been converted to RemoteSharedMailbox" ;
                            $smsg= "PRE:$($ADU.userprincipalname) has already been converted to RemoteUserMailbox" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } else {
                            <# remoteusermbx -> remoteshared
                            $pltSADU=[ordered]@{
                                Identity=$ADU.samaccountname ;
                                Replace=@{msExchRemoteRecipientType=100;msExchRecipientTypeDetails=34359738368}  ;
                                server=$domaincontroller ;
                                whatif=$($whatif) ;
                            } ;
                            #>
                            # remoteshared -> remoteuser
                            $pltSADU=[ordered]@{
                                Identity=$ADU.samaccountname ;
                                Replace=@{msExchRemoteRecipientType=4;msExchRecipientTypeDetails=2147483648}  ;
                                server=$domaincontroller ;
                                #ErrorAction = 'STOP'
                                whatif=$($whatif) ;
                            } ;
                            # whatif=$($whatif) ;

                            $smsg = "Set-aduser with:`n$(($pltSADU|out-string).trim())`n" ;
                            #expand replace values
                            $smsg += "`n$(($pltsadu.replace | fl|out-string).trim())`n" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            Set-ADUser @pltSADU ;
                            if(!$whatif){
                                $smsg= "POST:ADUser`n$((Get-adUser -id $ADU.samaccountname -prop $adprops -server $domaincontroller|fl $adprops | out-string).trim())`n" ;;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                $smsg= "POST:Ex Remotemailbox`n$((Get-RemoteMailbox $ADU.userprincipalname -domaincontroller $domaincontroller| format-list $exprops|out-string ).trim())" ; ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } else { write-host -fore yellow "(whatif detected, skipping update)"} ;
                        } ;
                        $true | write-output ;
                    } else {
                        $smsg="`n:`$tEmlAddr:$($tEmlAddr): not matched against ADUser`n" ;  ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $DoRetries ;
                } Catch {
                    Start-Sleep -Seconds $RetrySleep ;
                    $Exit ++ ;
                    $smsg = "Failed to exec cmd because: $($Error[0])" ;
                    $smsg += "`nTry #: $Exit" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    If ($Exit -eq $DoRetries) {
                        $smsg =  "Unable to exec cmd!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    Continue ;
                }  ;
            } Until ($Exit -eq $DoRetries) ;
        } ;  # loop-E
    } ;  # PROC-E
}

#*------^ convert-ADUserRecipientTypeRemoteUserMailbox.ps1 ^------


#*------v convert-exoMailboxTypeSharedMailbox.ps1 v------
function convert-exoMailboxTypeSharedMailbox{
    <#
    .SYNOPSIS
    convert-exoMailboxTypeSharedMailbox() - Set specified EXO mailbox to Shared ('SharedMailbox) type (part of coordinated on-prem ADUser recipienttype hack to make it work without moving mbxs back onprem to convert).
    .NOTES
    Author: Todd Kadrie
    Website:	http://www.toddomation.com
    Twitter:	@tostka, http://twitter.com/tostka
    REVISIONS   :
    * 8:46 AM 5/17/2023 add to vXO; ren'd to convert-exoMailboxTypeSharedMailbox (rmvd _ internal prefix), and aliased orig name(convert-xoShared), strongly typed $Mailbox as [System.Object] (get-xomailbox returns that type, not a real 'Mailbox' class).
    # 1:09 PM 8/25/2021 ren convertExoShared -> _convert-xoShared
    # 10:00 AM 12/19/2018 revertExoUserMbx : added post confirm echo
    # 12:31 PM 10/23/2018 ran full pass live, no unusual errors
    .DESCRIPTION
    convert-exoMailboxTypeSharedMailbox() - Set specified EXO mailbox to Shared ('SharedMailbox) type (part of coordinated on-prem ADUser recipienttype hack to make it work without moving mbxs back onprem to convert).
    .PARAMETER  Mailbox, EXO Mailbox Object
    EXO Mailbox Object
    .PARAMETER  Credential
    Credential to use for this connection [-credential 'account@domain.com']
    .PARAMETER silent
    Switch to specify suppression of all but warn/error echos.
    .PARAMETER Whatif
    Parameter to run a Test no-change pass, and log results [-Whatif switch]
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Returns RemoteMailbox object, or $false on failure.
    .EXAMPLE
    $ombx = get-xomailbox -id $targUPN -ea stop ;
    $bRet = convert-exoMailboxTypeSharedMailbox -Mailbox $ombx -whatif -showDebug ;
    Pull the target cloud-first EXO mailbox, and pass it as an object in to the convert-exoMailboxTypeSharedMailbox(), with whatif & showdebug
    .LINK
    #>
    [CmdletBinding()]
    [Alias('convert-xoShared')]
    PARAM(
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,HelpMessage="UPN [-upn fname.lname@DOMAIN.COM]")]
            [ValidateNotNullOrEmpty()]
            [System.Object]$Mailbox,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent,
        [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
            [switch] $showDebug,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
        [switch] $whatIf
    ) # PARAM BLOCK END
    BEGIN {
        $exprops="SamAccountName","RecipientType","RecipientTypeDetails","UserPrincipalName" ;
        # recycling the inbound above into next call in the chain
        $pltRXO = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
            silent = $silent ;
        } ;
    } ;  # BEGIN-E
    PROCESS {
        $Error.Clear() ;
        foreach($MBX in $Mailbox) {
            Reconnect-EXO @pltRXO;

            # 2:43 PM 10/11/2018 add precheck
            if($MBX |?{$_.recipienttypedetails -eq 'SharedMailbox'}){
                $smsg= "PRE:$($MBX.userprincipalname) has already been converted to RemoteSharedMailbox" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $pltSxM=[ordered]@{
                    Identity=$MBX.userprincipalname ;
                    Type="Shared" ;
                    whatif=$($whatif) ;
                } ;
                $smsg="set-xomailbox with:`n$(($pltSxM|out-string).trim())`n" ; ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                $Exit = 0 ;
                Do {
                    Try {
                        set-xomailbox @pltSxM ;
                        $Exit = $DoRetries ;
                        $true | write-output ;
                    } Catch {
                        $smsg = "Failed to exec cmd because: $($Error[0])" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Start-Sleep -Seconds $RetrySleep ;
                        $tryNo = 0 ;
                        Reconnect-exo @pltRXO;
                        $Exit ++ ;
                        $smsg = "Try #: $Exit" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        If ($Exit -eq $DoRetries) {
                        $smsg =  "Unable to exec cmd!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                        Continue ;
                    }  ;
                } Until ($Exit -eq $DoRetries) ;

                if(-not $whatif){
                    $smsg = "(waiting for get-xoMailbox to return RecipientTypeDetails -eq 'SharedMailbox')" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $1F=$false ;
                    Do {
                        if($1F){Sleep -s 5} ;
                        write-host "." -NoNewLine ;
                        $1F=$true ;
                        $Exit = 0 ;
                        Do {
                            Try {
                                $pexombx = get-xomailbox -id $pltSxM.identity -ea stop ;
                                $Exit = $DoRetries ;
                            } Catch {
                                $smsg = "Failed to exec cmd because: $($Error[0])" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                Start-Sleep -Seconds $RetrySleep ;
                                $tryNo = 0 ;
                                Reconnect-exo @pltRXO;
                                $Exit ++ ;
                                $smsg = "Try #: $Exit" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                If ($Exit -eq $DoRetries) {
                                    $smsg =  "Unable to exec cmd!" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                } ;
                                Continue ;
                            }  ;
                        } Until ($Exit -eq $DoRetries) ;
                    } Until ($pexombx.RecipientTypeDetails -eq 'SharedMailbox') ;

                    $smsg= "POST:EXO Mailbox`n$(($pexombx| format-list $exprops|out-string ).trim())" ; ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                } else {
                        set-xomailbox @pltSxM ; 
                        $smsg = "(whatif detected, skipping post test)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }  else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;
            } ; # if-E Not Converted test
        } ;  # loop-E
    } ;  # PROC-E
}

#*------^ convert-exoMailboxTypeSharedMailbox.ps1 ^------


#*------v convert-exoMailboxTypeUserMailbox.ps1 v------
function convert-exoMailboxTypeUserMailbox{
    <#
    .SYNOPSIS
    convert-exoMailboxTypeUserMailbox() - Set specified EXO mailbox to Regular ('UserMailbox')
    .NOTES
    Author: Todd Kadrie
    Website:	http://www.toddomation.com
    Twitter:	@tostka, http://twitter.com/tostka
    REVISIONS   :
    * 8:46 AM 5/17/2023 add to vXO; ren'd to convert-exoMailboxTypeSharedMailbox (rmvd _ internal prefix), and aliased orig name(convert-xoShared), strongly typed $Mailbox as [System.Object] (get-xomailbox returns that type, not a real 'Mailbox' class).
    #1:10 PM 8/25/2021 ren revertExoUserMbx -> _revert-xoUserMbx
    # 10:00 AM 12/19/2018 _revert-xoUserMbx: added post confirm echo
    # 3:19 PM 12/17/2018 coding revert
    # 12:31 PM 10/23/2018 ran full pass live, no unusual errors
    .DESCRIPTION
    convert-exoMailboxTypeUserMailbox() - Set specified EXO mailbox to Regular (from Shared) type (part of coordinated on-prem ADUser recipienttype hack to make it work without movnig mbxs back onprem to convert).
    .PARAMETER  Mailbox, EXO Mailbox Object
    EXO Mailbox Object
    .PARAMETER  Credential
    Credential to use for this connection [-credential 'account@domain.com']
    .PARAMETER silent
    Switch to specify suppression of all but warn/error echos.
    .PARAMETER Whatif
    Parameter to run a Test no-change pass, and log results [-Whatif switch]
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Returns RemoteMailbox object, or $false on failure.
    .EXAMPLE
    $ombx = get-xomailbox -id $targUPN -ea stop ;
    $bRet = convert-exoMailboxTypeUserMailbox -Mailbox $ombx -whatif -showDebug ;
    Pull the target cloud-first EXO mailbox, and pass it as an object in to the convert-exoMailboxTypeUserMailbox(), with whatif & showdebug
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    [CmdletBinding()]
    [Alias('revert-xoUserMbx')]
    PARAM(
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="UPN [-upn fname.lname@DOMAIN.COM]")]
        [ValidateNotNullOrEmpty()]
            [System.Object]$Mailbox,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent,
        [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
            [switch] $showDebug,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
            [switch] $whatIf
    ) # PARAM BLOCK END
    BEGIN {
        $exprops="SamAccountName","RecipientType","RecipientTypeDetails","UserPrincipalName" ;
        # recycling the inbound above into next call in the chain
        $pltRXO = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
            silent = $silent ;
        } ;
    } ;  # BEGIN-E
    PROCESS {
        foreach($MBX in $Mailbox){
            $Error.Clear() ;
            Reconnect-EXO @pltRXO;

            # usermailbox -> sharedmailbox
            if($MBX |?{$_.recipienttypedetails -eq 'UserMailbox'}){
                $smsg= "PRE:$($MBX.userprincipalname) has already been converted to RemoteMailbox" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                <# convert TO SHARED
                $pltSADU=[ordered]@{
                    Identity=$MBX.userprincipalname ;
                    Type="Shared" ;
                    whatif=$($whatif) ;
                } ;
                #>
                # convert FROM SHARED
                $pltSxM=[ordered]@{
                    Identity=$MBX.userprincipalname ;
                    Type="Regular" ;
                    whatif=$($whatif) ;
                    ErrorAction = 'STOP' ;
                } ;
                $smsg="set-xomailbox with:`n$(($pltSxM|out-string).trim())`n" ; ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                # 9:48 AM 12/19/2018 move out here, get the whatif confirm
                $Exit = 0 ;
                Do {
                    Try {
                        set-xomailbox @pltSxM ;
                        $Exit = $DoRetries ;
                        $true | write-output ;
                    } Catch {
                        $smsg = "Failed to exec cmd because: $($Error[0])" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Start-Sleep -Seconds $RetrySleep ;
                        $tryNo = 0 ;
                        Reconnect-EXO @pltRXO;
                        $Exit ++ ;
                        $smsg = "Try #: $Exit" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        If ($Exit -eq $DoRetries) {
                        $smsg =  "Unable to exec cmd!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                        Continue ;
                    }  ;
                } Until ($Exit -eq $DoRetries) ;

                if(!$whatif){
                    $smsg = "(waiting for get-xoMailbox to return RecipientTypeDetails -eq 'UserMailbox')" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $1F=$false ;
                    Do {
                        if($1F){Sleep -s 5} ;
                        write-host  "." -NoNewLine ;
                        $1F=$true ;
                        $Exit = 0 ;
                        Do {
                            Try {
                                $pexombx = get-xomailbox -id $pltSxM.identity -ea stop ;
                                $Exit = $DoRetries ;
                            } Catch {
                                $smsg = "Failed to exec cmd because: $($Error[0])" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                Start-Sleep -Seconds $RetrySleep ;
                                $tryNo = 0 ;
                                Reconnect-exo @pltRXO;
                                $Exit ++ ;
                                $smsg = "Try #: $Exit" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                If ($Exit -eq $DoRetries) {
                                    $smsg =  "Unable to exec cmd!" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                } ;
                                Continue ;
                            }  ;
                        } Until ($Exit -eq $DoRetries) ;
                    } Until ($pexombx.RecipientTypeDetails -eq 'UserMailbox') ;

                    $smsg= "POST:EXO Mailbox`n$(($pexombx| format-list $exprops|out-string ).trim())" ; ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                } else { 
                    set-xomailbox @pltSxM ;
                    $smsg = "(whatif detected, skipping post test)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }  else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            
                } ;
            } ;  # if-E Not Converted test
        } ;  # loop-E
    } ;  # PROC-E
}

#*------^ convert-exoMailboxTypeUserMailbox.ps1 ^------


#*------v convert-HistoricalSearchCSV.ps1 v------
function convert-HistoricalSearchCSV {
    <#
    .SYNOPSIS
    convert-HistoricalSearchCSV - Summarize (to XML) or re-expand(to CSV), MS EXO HistoricalSearch csv output files, to permit MessageTrace-style parsing of the output for delivery patterns.
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-04-23
    FileName    : convert-HistoricalSearchCSV.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-EXO
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 1:58 PM 12/15/2021 revised expan code, implemented split MTDetail/MTSummary processing; normalized fieldnames against the MessageTrace output (goal is to make HS look and process more like MT)
    * 1:05 PM 12/14/2021 added full range of Expanded Rpt fields, tweaked the 
        non-recip statuses to look like recips (using primary recip & recipStat for the 
        record) ; fixed defaulted iscsv, modified param pipeline defaults; switched 
        Files from typeless to string[]; found extended gui trace had date fields with 
        diff names, added tests & support to suppress errors. ; updated Catch blocks to 
        curr spec (errors not being echoed). 
    * 11:21 AM 9/15/2021 updated Example to demo pipline-input, and post-processing to group Status (like you could a MessageTrace); added $DotsInterval param.
    * 2:54 PM 4/23/2021 wrote as freestanding .ps1, decided to flip it into func in verb-EXO
    .DESCRIPTION
    convert-HistoricalSearchCSV - Summarize (to XML) or re-expand(to CSV), MS EXO HistoricalSearch csv output files, to permit MessageTrace-style parsing of the output for delivery patterns.
    Issue is that HistoricalSearch csv files summarize a lot of detail from the normal MessageTrace .csv output, into the single Recipient_status field,
    which is a concatonated combo of every recipient, double-hash (##) delimited with the following information per recipient
    <email address>##<status>
    And there can be a series of Status entries logged, for the single email address.

    - If ToXML is chosen, the RecipientAddress & RecipientEvents are nested as an array of CustomObjects in a field named 'RecipientStatuses'
    - If ToCsv is chosen, each transaction is unpacked back into separate 'Status' lines for each RecipientStatus (closer to the way get-MessageTrace returns records)

    The benefit of expanded CSV, over the native HS output, is you can do MessageTrace-like parsing of the results:
    $msgsx = import-csv -path path-to\MTSummary_History-expanded.csv ; 
    $msgsx | group status | ft -auto count,name
    Count Name
    ----- ----
      119 Receive
      117 Deliver
        2 Fail

    .PARAMETER  Files
    Array of HistoricalSearch .csv file paths[-Files c:\pathto\HistSearch.csv]
    .PARAMETER ToXML
    ToXML switch (generates nested summary XML)[-ToXML]
    .PARAMETER ToCSV
    ToCSV switch (Defaults True ; expands transactions into a logged entry per RecipientStatus)[-ToCSV]
    .PARAMETER DoDots
    Use progress dotcrawl over explicit x/y echo.
    .PARAMETER DotsInterval
    Progress dotcrawl interval (dot per every X proceessed, defaults to 3)[-DotsInterval 5]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    outputs .csv or .xml with variant [originalname]-Expanded.[ext] filename of source .csv file.
    System.String is returned (filepath of each converted file)
    .EXAMPLE
    convert-HistoricalSearchCSV -ToXML -Files "C:\usr\work\incid\123456-fname.lname@domain.com-EXOHistSrch,-60D-History,From-ANY@mssociety.org,20210222-0000AM-20210423-0919AM,run-20210423-1007AM.csv" ; 
    Convert a HistoricalSearch .csv report, to XML (with filename:[originalname]-Expanded.xml)
    .EXAMPLE
    $ifile = "C:\pathTo\MTSummary_History.csv" ;
    $ofile = convert-HistoricalSearchCSV -ToCSV -Files $ifile  ; 
    $msgsx = import-csv -path $ofile ; 
    $msgsx | group status | ft -auto count,name
    Convert a HistoricalSearch .csv report, to -expanded.CSV, and then group the Status (as you could a normal MessageTrace). 
    .EXAMPLE
    "HistReport1.csv","HistReport2.csv | convert-HistoricalSearchCSV -ToCSV ; 
    Pipeline convert multiple Hist reort csvs to xxx-expanded.csv files.
    .LINK
    https://github.com/tostka/verb-exo
    .LINK
    https://docs.microsoft.com/en-us/powershell/module/exchange/get-historicalsearch
    .LINK
    https://docs.microsoft.com/en-us/powershell/module/exchange/get-messagetrace
    #>
    #Requires -Version 3
    #[CmdletBinding(DefaultParameterSetName='CSV')]
    [CmdletBinding()]
    PARAM(
        #[Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Array of HistoricalSearch .csv file paths[-Files c:\pathto\HistSearch.csv]")]
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,HelpMessage="Array of HistoricalSearch .csv file paths[-Files c:\pathto\HistSearch.csv]")]
        #[ValidateNotNullOrEmpty()]
        [string[]]$Files,
        [Parameter(ParameterSetName='XML',HelpMessage="ToXML switch (generates nested summary XML)[-ToXML]")]
        [switch] $ToXML,
        [Parameter(ParameterSetName='CSV',HelpMessage="ToCSV switch (expands transactions into a line per RecipientStatus)[-ToCSV]")]
        [switch] $ToCSV,
        [Parameter(HelpMessage="Use progress dotcrawl over explicit x/y echo switch[-DoDots]")]
        [switch]$DoDots=$true, 
        [Parameter(HelpMessage="Progress dotcrawl interval (dot per every X proceessed, defaults to 3)[-DotsInterval 5]")]
        [int]$DotsInterval=3
    ) ;
    $verbose = ($VerbosePreference -eq "Continue") ; 
    $pltXCsv = [ordered]@{
        path = $null ; 
        NoTypeInformation = $true ;
    } ; 
    foreach($file in $files){
        $sBnr="#*======v STATUSMSG: $($file) v======" ; 
        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr)" ;
        
        $error.clear() ;
        TRY {
            $ifile= gci -path $file; 
            write-verbose "(import-csv:$($ifile.fullname))" ; 
            $records = import-csv -path $ifile.fullname -Encoding Unicode ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ; 
        
        <# Recipient_status: The status of the delivery of the message to the recipient. 
        If the message was sent to multiple recipients, it will show all the recipients 
        and the corresponding status for each, in the format: <email address>##<status>.
        For example: 
        ##Receive, Send means the message was received by the service and was sent to the intended destination.
        ##Receive, Fail means the message was received by the service but delivery to the intended destination failed.
        ##Receive, Deliver means the message was received by the service and was delivered to the recipient?s mailbox.
        Multi recipients appear like:
        Fname.Lname@domain.com##Receive, Deliver;Fname.Lname@domain.com##Receive, Deliver;Fname.Lname@domain.com##Receive, Deliver;Fname.Lname@domain.com##Receive, Deliver;Fname.Lname@domain.com##Receive, Deliver;Fname.Lname@domain.com##Receive, Deliver;Fname.Lname@domain.com##Receive, Deliver;Fname.Lname@domain.com##Receive, Deliver
        #>
        $aggreg = @() ; 
        $procd = 0 ; $ttl = (($records|measure).count) ; $ino=0 ; 
        if($DoDots){write-host -foregroundcolor Red "[" -NoNewline } ; 

        $isMTDetail = $false ; 
        # MTSummary has 'origin_timestamp_utc'
        # MTDetail has 'date_time_utc'
        if(($records[0] | gm | ?{$_.membertype -eq 'NoteProperty'}).name -contains 'origin_timestamp_utc'){
            $isMTDetail = $false ;
            $smsg = "(MTSummary csv file detected)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        }elseif(($records[0] | gm | ?{$_.membertype -eq 'NoteProperty'}).name -contains 'date_time_utc'){
            $isMTDetail = $true ;
            $smsg = "(MTDetail 'Extended' csv file detected)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } else { 
            throw "Unable to determine if source is an MTSummary or MTDetail csv!"
            break ; 
        } ;  

        foreach ($record in $records){
            $procd++ ; 
            # echo every $DotsInterval'th record
            if(($procd % $DotsInterval) -eq 0){
                if($DoDots){
                      $ino++ ; 
                      if(($ino % 80) -eq 0){
                        write-host "." ; $ino=0 ;
                      } else {write-host "." -NoNewLine} ;
                } else { 
                    write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):($($procd)/$($ttl)):" ; 
                } ; 
            } ; 
            #write-verbose "$((get-date).ToString('HH:mm:ss')):(record $($procd)/$($ttl)):"  ; 
            $sBnrS="`n#*------v PROCESSING : $($procd)/$($ttl) v------" ; 
            write-verbose "$((get-date).ToString('HH:mm:ss')):$($sBnrS)" ;
            

            <# typical HistoricalSearch csv record & fields:
            origin_timestamp_utc : 2021-03-23T10:00:09.3284899Z
            sender_address       : Fname.Lname@domain.com
            recipient_status     : Fname.Lname@domain.com##Receive, Deliver;"Fname LName<fname.lname"@domain.com##Receive, Fail
            message_subject      : AW: Fwd: SOME SUBJECT 123456 22-03-2021
            total_bytes          : 49790
            message_id           : <PH0PR04MB73657A6BEBB3F89D9F4FC85A8C649@PH0PR04MB7365.namprd04.prod.outlook.com>
            network_message_id   : 81945af2-cab7-45ad-ba23-08d8ede2715d
            original_client_ip   : 123.456.789.012
            directionality       : Originating
            connector_id         : To_DefaultOpportunisticTLS
            delivery_priority    : Normal
            #>
            <# Extended report 8:59 AM 12/14/2021
            date_time_utc             : 2021-11-23T19:49:37.6050000Z
            client_ip                 :
            client_hostname           : CH0PR04MB8081.namprd04.prod.outlook.com
            server_ip                 :
            server_hostname           : BY5PR04MB6279.namprd04.prod.outlook.com
            source_context            : 08D9AE1AA4FEA27C;2021-11-23T19:49:37.215Z;ClientSubmitTime:2021-11-23T19:49:36.380Z
            connector_id              :
            source                    : STOREDRIVER
            event_id                  : DELIVER
            internal_message_id       : 132697
            message_id                : <CH0PR04MB8114A61AF981D65F07EA6A0C8B609@CH0PR04MB8114.namprd04.prod.outlook.com>
            network_message_id        : f955f718-d5ff-40a7-137f-08d9aeba6116
            recipient_address         : recip@domain.com
            recipient_status          :
            total_bytes               : 89464
            recipient_count           : 1
            related_recipient_address :
            reference                 :
            message_subject           : SENDER Last Day Details - List
            sender_address            : SENDER@domain.com
            return_path               : SENDER@domain.com
            message_info              : 2021-11-23T19:49:36.395Z;SRV=CH0PR04MB8114.namprd04.prod.outlook.com:TOTAL-SUB=0.218|SA=0.021|MTSS-PEN=0.197(MTSSD-PEN=0.197(MTSORGC=0.052|MTSSDC=0.073|MTSSDSDM=0.026 (MTSSDSDM-Mailbox Submission Filter
                                        Agent=0.025)|SDSSO-PEN=0.019(SMSC-PEN=0.019)));SRV=CH0PR04MB8081.namprd04.prod.outlook.com:TOTAL-HUB=0.504|SMRI=0.118(RENV=0.036|REOD=0.027|CMSGC=0.052|R-CMSG=0.026(R-CMSGC=0.023(R-HSRR=0.023
                                        )))|CAT=0.297(CATOS=0.068(CATSM=0.068(CATSM-DC Pre Content Filter Agent=0.062))|CATORES=0.187 (CATRS=0.187(CATRS-Transport Rule Agent=0.026(X-ETREX=0.022)|CATRS-DLP Policy Agent=0.043 (X-DLPEX=0.037)|CATRS-DC
                                        Content Filter Agent=0.106))|CATCC=0.024)|D-PEN=0.053(HSDSP=0.052
                                        (HSRR=0.051))|HSDN=0.031;SRV=BY5PR04MB6279.namprd04.prod.outlook.com:TOTAL-DEL=0.501|HSDR=0.113(HSDRR=0.097)|SDD=0.389(SDDPM=0.087(SDDPM-Mailbox Delivery Filter Agent=0.040|SDDPM-Inference Classification
                                        Agent=0.026)|SDDSDMG=0.268(SDDR=0.268)|X-SDDS=0.097)
            directionality            : Originating
            tenant_id                 : 549366ae-e80a-44b9-8adc-52d0c29ba08b
            original_client_ip        : 192.168.1.251
            original_server_ip        : 2603:10b6:610:f9::20
            custom_data               : S:IncludeInSla=True;S:MailboxDatabaseGuid=4ba0d02d-8b59-4bab-80e0-73f70ce64d61;S:ActivityId=77d7390c-af4d-4e43-99c5-aea5e353c61a;S:BCL=0;S:Mailboxes=f5436253-dbf4-428f-bb5c-08944e5f30e9;S:StoreObjectIds=AAAAAN
                                        4COUMvw7VMjllHB1/AorIHANlpuQRlrZxKlXO5Qqnh9vMAAAClXpkAAL34su7JVyNBoQgZmMcaJOoAAu1n1K8AAA==;S:FromEntity=Hosted;S:ToEntity=Hosted;S:P2RecipStat=0.008/9;S:MsgRecipCount=9;S:SubRecipCount=9;S:HttpRequestId=9cfd3b
                                        b0-f5cb-446d-b57e-a73440081811;S:DeliveredViaHttps=True;S:MapiMessageClass=IPM.Note;S:DeliveryLatency=1.207;S:AttachCount=1;S:E2ELatency=1.211;S:DeliveryPriority=Normal;S:PrioritizationReason=EnvelopePriority;
                                        S:AccountForest=NAMPR04A008.PROD.OUTLOOK.COM
            #>
        
            $error.clear() ;
            TRY {
                <# fields from a typical MessageTrace (emulate the same names):
                PSComputerName
                RunspaceId
                PSShowComputerName
                Organization
                MessageId
                Received
                SenderAddress
                RecipientAddress
                Subject
                Status
                ToIP
                FromIP
                Size
                MessageTraceId
                StartDate
                EndDate
                Index
                #>
                
                $TransSummary = [ordered]@{
                    Received=$null ;
                    ReceivedGMT=$null ;
                    SenderAddress=$record.sender_address ;
                    RecipientAddress= $null # $record.recipient_address ; only populated on MTDetail, imputed from recipinet_status for MTSummary
                    Status = $null ; 
                    Subject=$record.message_subject ;
                    Size=$record.total_bytes ;
                    MessageID=$record.message_id ;
                    OriginalClientIP=$record.original_client_ip ;
                    Directionality=$record.directionality ;
                    ConnectorID=$record.connector_id ;
                    DeliveryPriority=$record.delivery_priority ;
                    FromIP = $record.original_client_ip ; 
                    #ToIP = $record. ; 
                } ; 
                
                #if($record.origin_timestamp_utc){
                if( -not $isMTDetail){
                    $TransSummary.Received=([datetime]$record.origin_timestamp_utc).ToLocalTime() ; # converting HistSearch GMT to LocalTime
                    $TransSummary.ReceivedGMT=$record.origin_timestamp_utc ;
                #} elseif($record.date_time_utc){
                } elseif($isMTDetail){
                    $TransSummary.Received=([datetime]$record.date_time_utc).ToLocalTime() ; # converting HistSearch GMT to LocalTime
                    $TransSummary.ReceivedGMT=$record.date_time_utc ;
                    write-verbose "(Expanded Report fields detected, and adding...)" ; 
                    # extended rpts include a raft of extra fields
                    #date_time_utc
                    $TransSummary.ADD('client_ip',$record.client_ip) ;
                    $TransSummary.ADD('client_hostname',$record.client_hostname) ;
                    $TransSummary.ADD('server_ip',$record.server_ip) ;
                    $TransSummary.ADD('server_hostname',$record.server_hostname) ;
                    $TransSummary.ADD('source_context',$record.source_context) ;
                    #$TransSummary.ADD('connector_id',$record.connector_id) ;
                    $TransSummary.ADD('source',$record.source) ;
                    $TransSummary.ADD('event_id',$record.event_id) ;
                    $TransSummary.ADD('internal_message_id',$record.internal_message_id) ;
                    #$TransSummary.ADD('message_id',$record.message_id) ;
                    $TransSummary.ADD('network_message_id',$record.network_message_id) ;

                    #$TransSummary.ADD('recipient_address',$record.recipient_address) ;
                    $TransSummary.RecipientAddress = $record.recipient_address ; 
                    #$TransSummary.ADD('recipient_status',$record.recipient_status) ;
                    $TransSummary.Status = $record.recipient_status ;  
                    
                    #$TransSummary.ADD('total_bytes',$record.total_bytes) ;
                    $TransSummary.ADD('recipient_count',$record.recipient_count) ;
                    $TransSummary.ADD('related_recipient_address',$record.related_recipient_address) ;
                    $TransSummary.ADD('reference',$record.reference) ;
                    #$TransSummary.ADD('message_subject',$record.message_subject) ;
                    #$TransSummary.ADD('sender_address',$record.sender_address) ;
                    #$TransSummary.SenderAddress = $record.sender_address
                    $TransSummary.ADD('return_path',$record.return_path) ;
                    $TransSummary.ADD('message_info',$record.message_info) ;
                    #$TransSummary.ADD('directionality',$record.directionality) ;
                    $TransSummary.ADD('tenant_id',$record.tenant_id) ;
                    $TransSummary.ADD('original_client_ip',$record.original_client_ip) ; # covered in base hash
                    $TransSummary.ADD('original_server_ip',$record.original_server_ip) ;
                    #$TransSummary.ADD('ToIP', $record.original_server_ip) ;
                    $TransSummary.ToIP = $record.server_ip ; 
                    $TransSummary.ADD('custom_data',$record.custom_data) ;

                } ;

                if($record.recipient_status.contains(";")){
                    $rcpRecs = $record.recipient_status.split(';') ; # if semi-delim'd we have multi recipients & status, split them for processing below
                } else {
                     $rcpRecs = $record.recipient_status ; 
                } ;  ; 
                    
                if($ToXML){
                    if( -not $isMTDetail){
                        $RecipientStatuses=@() ; 
                        # the only one's that need expansion, are the one's delimited and with ##, all 
                        # others have a RecipientAddress & Status pulled from $record.recipient_address & 
                        # full $record.recipient_status value; 

                        #looks like non ## recipient_statu's have an entry corresponding to the number of $record.recipient_address's: [recipientAddr]:UserMailbox.Forwardable.Resolver.CreateRecipientItems.40
                        #split both and use/assign them in like order
                        if($record.recipient_status.contains(';')){
                            $rcpStatusSets = $record.recipient_status.split(';') ; 
                        } else { 
                            $rcpStatusSets = $record.recipient_status
                        } ; 
                        foreach($rcpStatusSet in $rcpStatusSets){
                            $statusRpt = [ordered]@{
                                RecipientAddress = $null ; 
                                Status = $null ; 
                            } ; 
                            if($rcpStatusSet.contains('##')){
                                write-verbose "(RecipientAddress event)" ;
                                $statusRpt.RecipientAddress =  ($rcpStatusSet -split '##')[0] ; 
                                $statusRpt.Status = ($rcpStatusSet -split '##')[1] -split ', ' ; 
                            } else {
                                $smsg = "MTSummary CSV that contains non-##-delimited recipient_status!"
                                write-warning $smsg ; 
                                throw $smsg ; 
                                break ; 
                                <# shouldn't have the below, all status should have ## delim ; 
                                write-verbose "(RecipientEvent)" ;
                                # fake the primary into the same format
                                #$statusRpt.RecipientAddress =  $record.recipient_address ; 
                                #$statusRpt.Status = $record.recipient_status ; 
                                $statusRpt.RecipientAddress = $rcpRecipientSplit[$rcpRecNo] ; 
                                $statusRpt.Status = $rcpStatusSet ; 
                                #>
                            } ; 
                            $RecipientStatuses += New-Object PSObject -Property $statusRpt ; 
                        } ; 
                        $TransSummary.RecipientStatuses = $RecipientStatuses ; 
                    } else { 
                        # MTDetail report, has native recipient_address  & recipient_status
                        #$rcpRecipientSplit = $record.recipient_address.split(';') ; 
                        #$rcpStatusSets = $record.recipient_status.split(';') ; 
                        if($record.recipient_address.contains(';')){
                            $rcpRecipientSplit = $record.recipient_address.split(';') ; 
                        } else { 
                            $rcpRecipientSplit = $record.recipient_address ;
                        } ; 
                        if($record.recipient_status.contains(';')){
                            $rcpStatusSets = $record.recipient_status.split(';') ; 
                        } else { 
                            $rcpStatusSets = $record.recipient_status ;
                        } ; 
                        # if there's both -gt 1 recipient & -gt 1 status, do the loop, 
                        # otherwise, append the set (only reason to expand is per-recipoient status failure reporting/parsing)
                        if( ($rcpRecipientSplit|measure).count -gt 1 -AND ($rcpStatusSets|measure).count -gt 1){
                            $rcpRecNo = 0 ; 
                            foreach($rcp in $rcpRecipientSplit){
                                $statusRpt = [ordered]@{
                                    RecipientAddress = $rcp ; 
                                    Status = $rcpStatusSets[$rcpRecNo] ; 
                                } ; 
                                $rcpRecNo ++ ; 
                            } ; 
                        } else { 
                            $TransSummary.RecipientAddress = $record.recipient_address ; 
                            $TransSummary.Status = $record.recipient_status ; 
                            $aggreg += New-Object PSObject -Property $TransSummary ; 
                        } ; 
                    } ; 
                    $aggreg += New-Object PSObject -Property $TransSummary ; 

                } elseif($ToCSV){
                    
                    if( -not $isMTDetail){
                        #looks like non ## recipient_statu's have an entry corresponding to the number of $record.recipient_address's

                        if($record.recipient_status.contains(';')){
                            $rcpStatusSets = $record.recipient_status.split(';') ; 
                        } else { 
                            $rcpStatusSets = $record.recipient_status ;
                        } ; 
                        foreach($rcpStatusSet in $rcpStatusSets){
                            if($rcpStatusSet.contains('##')){
                                write-verbose "(RecipientAddress event)" ;
                                $TransSummary.RecipientAddress =  ($rcpStatusSet -split '##')[0] ; 
                                #$statusRpt.Status = ($rcpStatusSet -split '##')[1] -split ', ' ; 
                                foreach ($status in ($rcpStatusSet -split '##')[1] -split ', '){
                                    $TransSummary.Status = $status ;
                                    # add an entire new duped line for the status record
                                    $aggreg += New-Object PSObject -Property $TransSummary ; 
                                } ; 
                            } else {
                                $smsg = "MTSummary CSV that contains non-##-delimited recipient_status!"
                                write-warning $smsg ; 
                                throw $smsg ; 
                                break ; 
                            } ; 
                        }

                    } else { 
                        # MTDetail report, has native recipient_address  & recipient_status
                        #$TransSummary.RecipientAddress = $rcpRecipientSplit[$rcpRecNo] ; 
                        #$TransSummary.Status = $rcpRec ; 
                        # ---
                        if($record.recipient_address.contains(';')){
                            $rcpRecipientSplit = $record.recipient_address.split(';') ; 
                        } else { 
                            $rcpRecipientSplit = $record.recipient_address ;
                        } ; 
                        if($record.recipient_status.contains(';')){
                            $rcpStatusSets = $record.recipient_status.split(';') ; 
                        } else { 
                            $rcpStatusSets = $record.recipient_status ;
                        } ; 
                        # if there's both -gt 1 recipient & -gt 1 status, do the loop, 
                        # otherwise, append the set (only reason to expand is per-recipoient status failure reporting/parsing)
                        if( ($rcpRecipientSplit|measure).count -gt 1 -AND ($rcpStatusSets|measure).count -gt 1){
                            $rcpRecNo = 0 ; 
                            foreach($rcp in $rcpRecipientSplit){
                                #$statusRpt = [ordered]@{
                                    #RecipientAddress = $rcp ; 
                                    $TransSummary.RecipientAddress = $rcp ; 
                                    $TransSummary.Status = $rcpStatusSets[$rcpRecNo] ; 
                                #} ; 
                                # add a whole dupe status set for each variant 
                                $aggreg += New-Object PSObject -Property $TransSummary ; 
                                $rcpRecNo ++ ; 
                            } ; 
                        } else { 
                            $TransSummary.RecipientAddress = $record.recipient_address ; 
                            $TransSummary.Status = $record.recipient_status ; 
                            $aggreg += New-Object PSObject -Property $TransSummary ; 
                        } ; 
                        # ---
                        #$aggreg += New-Object PSObject -Property $TransSummary ; 
                    } ; 
                } else { throw "neither ToCSV or ToXML specified!" } ; 
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #-=-record a STATUSWARN=-=-=-=-=-=-=
                $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                #-=-=-=-=-=-=-=-=
                $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
            } ; 

            write-verbose "$((get-date).ToString('HH:mm:ss')):$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
        } ; 
        if($DoDots){write-host -foregroundcolor Red "]" } ; 
        if($ToCSV){
            $pltXCsv.path = join-path -Path ($ifile.DirectoryName) -ChildPath "$($ifile.BaseName)-EXPANDED$($ifile.Extension)" ; 
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):export-csv w`n$(($pltXCsv |out-string).trim())" ; 
            $aggreg | export-csv @pltXCsv ;
            $pltXCsv.path | write-output ;
        } elseif ($ToXML){
            $opath = join-path -Path ($ifile.DirectoryName) -ChildPath "$($ifile.BaseName)-EXPANDED.XML" ; 
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):export-cliXML to`n$(($opath|out-string).trim())" ; 
            $aggreg | export-clixml -Path $opath  ;
            $opath | write-output ;
        } else { 

        } ; 

        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr.replace('=v','=^').replace('v=','^='))" ;
    } ;  # loop-E $files
}

#*------^ convert-HistoricalSearchCSV.ps1 ^------


#*------v copy-XPermissionGroupToCloudOnly.ps1 v------
function copy-XPermissionGroupToCloudOnly {
    <#
    .SYNOPSIS
    copy-XPermissionGroupToCloudOnly.ps1 - Copy an onprem replicated Mail-Enabled Security Group, used for Mailbox Access grants, to a cloud-only EXO DistributionGroup, to grant EXO perms to foreign-hybrid multi-HCW federated objects in the tenant
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-07-13
    FileName    : copy-XPermissionGroupToCloudOnly.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 2:40 PM 12/10/2021 more cleanup 
    * 3:51 PM 8/17/2021 added $MembersCloudOnly | select -unique - kept leaking in duplicates in the inputs.
    * 1:40 PM 8/11/2021 ADDED & debugged -Mailbox param (spec target of grants), and code to add-mailboxperm/add-(ad|recipient)permission to OP or EXO target mailbox, and more detailed follow up dump report. Ran against exo-mailbox wio issues. Need to dbug against a still onprem mbx next.
    * 2:19 PM 8/3/2021 step-debugged, looks functional ; init 
    .DESCRIPTION
    copy-XPermissionGroupToCloudOnly.ps1 - Copy an onprem replicated Mail-Enabled Security Group, used for Mailbox Access grants, to a cloud-only EXO DistributionGroup, to grant EXO perms to foreign-hybrid multi-HCW federated objects in the tenant
    This function comes into use when your o365 Tenant/EXO org has hybrid-federated objects. That is, one set of EXO mailboxes federated (and HCW'd) from one on-prem ActiveDirectory/Exchange org, 
    and another set of EXO mailboxes federated (and HCW'd) from *a second separate* on-prem ActiveDirectory/Exchange org. 
    If your Mailbox permission grants are generally performed via OnPrem mail-enabled security groups (which are replicated to cloud), those groups cannot properly accomodate
    Security principals in the second AD org. 
    So this function duplicates a local mail-enabled security group, as a new EXO distributiongroup, with a similar name, and the appended suffixe '_C1' 
    (n.b. in my org, all grant groups end in '-G' by policy, you'll need to tweak the name generation code below if yours lack a '-G' to target for the renames )
    The resulting EXO DG is intended to hold those SecPrincipals that can't be represented in the on-prem Org. 
    In effect you'll have one onprem DG granting permissions for locally federated SecPrins, 
    And this newly duplicated EXO DG granting permissions for externally federated SecPrins.
    .PARAMETER ticket
    ticket number[-ticket nnnnn]
    .PARAMETER SourceGroupName
    Name of on-prem replicated Exchange DistributionGroup to be copied to a cloud-only variant[-SourceGroupName somegroup]
    .PARAMETER Mailbox
    Identifier for the mailbox/mailuser object that the new group should be granted access to (generally matches target of on-prem SourceGroupName permissions grants)[-Mailbox email@domain.com]
    .PARAMETER Owner
    Identifier for the mailbox/mailuser object that will be the Owner of the new group[-Owner email@domain.com]
    .PARAMETER MembersCloudOnly
    Array of cloud-only unreplicated mailbox/mailuser designators to be added as members of the newly copied group[-MembersCloudOnly email@domain.com,email2@domain.com]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER Whatif
    Parameter to run a Test no-change pass [-Whatif switch]
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .EXAMPLE
    PS> $whatif = $true ;
        [array]$tgroups = @("627192;LYN-SEC-Email-COMPANYMobilityTeam-G;COMPANYMobilityTeam@COMPANY.com;dccoldiron@charlesmachine.works;member1@domain.com,dccoldiron@charlesmachine.works") ;
        [array]$tgroups += "123457;SIT-SEC-Email-GrantMailbox2-G;GrantMailbox2@domain.com;owner2@domain.com;member1@domain.com,member2@domain.com" ;
        foreach($tgrp in $tgroups){
            $pltCXPermGrp=[ordered]@{
                ticket = $tgrp.split(';')[0] ;
                SourceGroupName = $tgrp.split(';')[1] ;
                Mailbox = $tgrp.split(';')[2] ;
                Owner = $tgrp.split(';')[3] ;
                MembersCloudOnly = $tgrp.split(';')[4].split(',') ;
                verbose=$true ;
                whatif=$($whatif) ;
            } ;
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):copy-XPermissionGroupToCloudOnly w`n$(($pltCXPermGrp|out-string).trim())" ;
            copy-XPermissionGroupToCloudOnly @pltCXPermGrp ;
        } ; 
    Example demoing processing of an array of descriptors, as a semicolon-delimited summary of inputs (useful for stacking bulk-creations)
    Schema for the $tgroups input is "[SourceGroupName];[Mailbox];[Owner];[MembersCloudOnly array]"
    .LINK
    https://github.com/tostka/verb-exo
    .LINK
    #>
    ###Requires -Version 5
    ##Requires -Modules ActiveDirectory, MSOnline, AzureAD, ExchangeOnlineManagement, verb-AAD, verb-ADMS, verb-Ex2010, verb-Text
    # 2:49 PM 3/8/2022 pull verb-ex2010 ref - I think it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    #Requires -Modules ActiveDirectory, MSOnline, AzureAD, ExchangeOnlineManagement, verb-AAD, verb-ADMS, verb-Text
    #Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("(lyn|bcc|spb|adl)ms6(4|5)(0|1).(china|global)\.ad\.COMPANY\.com")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    ##[Alias('somealias')]
    PARAM(
        [Parameter(Mandatory=$true,HelpMessage="ticket number[-ticket nnnnn]")]
        $ticket, 
        [Parameter(Mandatory=$true,HelpMessage="Name of on-prem replicated Exchange DistributionGroup to be copied to a cloud-only variant[-SourceGroupName somegroup]")]
        $SourceGroupName, 
        [Parameter(Mandatory=$true,HelpMessage="Identifier for the mailbox/mailuser object that the new group should be granted access to (generally matches target of on-prem SourceGroupName permissions grants)[-Mailbox email@domain.com]")]
        $Mailbox, 
        [Parameter(Mandatory=$true,HelpMessage="Identifier for the mailbox/mailuser object that will be the Owner of the new group[-Owner email@domain.com]")]
        $Owner, 
        [Parameter(Mandatory=$true,HelpMessage="Array of cloud-only unreplicated mailbox/mailuser designators to be added as members of the newly copied group[-MembersCloudOnly email@domain.com,email2@domain.com]")]
        [array]$MembersCloudOnly, 
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
        [switch] $whatIf
    ) ;
    BEGIN{
        $Verbose = ($VerbosePreference -eq 'Continue') ; 
        $propsdg = 'SamAccountName','ManagedBy','AcceptMessagesOnlyFrom','AcceptMessagesOnlyFromDLMembers','AddressListMembership',
            'Alias','DisplayName','EmailAddresses','ExternalDirectoryObjectId','HiddenFromAddressListsEnabled','EmailAddressPolicyEnabled',
            'PrimarySmtpAddress','RecipientType','RecipientTypeDetails','WindowsEmailAddress','Name','DistinguishedName','WhenChanged','WhenCreated'; 
        $rgxMbxPermLocal = '^(S-\d-\d-\d{2}-\d{10}-\d{9}-\d{10}-\d{5}|NT\sAUTHORITY\\SELF)' ;
        $propsmbxperm = 'User','AccessRights','IsInherited','Deny';
        $propsrcpperm = 'trustee','AccessRights','IsInherited','Deny';
        $propsadperm = 'User','AccessRights','ExtendedRights','IsInherited','Deny';

        connect-AD -Verbose:$false | out-null ; 
        rx10 -Verbose:$false ; rxo  -Verbose:$false ; #cmsol  -Verbose:$false ;
        
    } 
    PROCESS{
        # check ExternalDirectoryObjectId to ensure unfederated
        $sBnr="===v $($SourceGroupName) - $($Owner) v===" ;
        $smsg = $sBnr ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $smsg = "==Checking for existing:$($SourceGroupName)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        <# New-exoDistributionGroup -ModeratedBy -RequireSenderAuthenticationEnabled -ModerationEnabled -DisplayName -Confirm -MemberDepartRestriction -IgnoreNamingPolicy -RoomList -HiddenGroupMembershipEnabled -BypassNestedModerationEnabled -CopyOwnerToMember -BccBlocked -Members -MemberJoinRestriction -Type -Alias -ManagedBy -WhatIf -PrimarySmtpAddress -SendModerationNotifications -Notes -OrganizationalUnit -Name -AsJob 
        Set-exoDistributionGroup -HiddenFromAddressListsEnabled
        New-exoDistributionGroup -DisplayName -Name -Members -Type -Alias -PrimarySmtpAddress -ManagedBy -WhatIf -Notes -whatif ; 
        -ManagedBy "Name|Display name|Alias|Distinguished name (DN)|Canonical DN|<domain name>\<account name>|Email address|GUID|LegacyExchangeDN|SamAccountName|User ID or user principal name (UPN)"
        Set-exoDistributionGroup -EmailAddresses -RejectMessagesFromDLMembers -AcceptMessagesOnlyFromSendersOrMembers -AcceptMessagesOnlyFromDLMembers -SimpleDisplayName -MailTip -GrantSendOnBehalfTo -AcceptMessagesOnlyFrom -RejectMessagesFromSendersOrMembers -Alias -DisplayName -ManagedBy -PrimarySmtpAddress -Name -whatif ;
        #>
        if($dg = get-distributiongroup -id $SourceGroupName){
            $tdgName = $dg.Name.replace('-G','-G_C1') ; 
            $nameClean=Remove-StringDiacritic -string $tdgName ;
            $nameClean= Remove-StringLatinCharacters -string $nameClean ;
            $samaccountname=$( ([System.Text.RegularExpressions.Regex]::Replace($nameClean,"[^1-9a-zA-Z_]","").tostring().substring(0,[math]::min([System.Text.RegularExpressions.Regex]::Replace($nameClean,"[^1-9a-zA-Z_]","").tostring().length,20))).toLower() )  ;
            $samaccountname = "$($samaccountname)-$((new-guid).guid.split('-')[0])-C1" ;
            $smsg = "Resolving potential members:`n$(($MembersCloudOnly| select -unique | sort | out-string).trim())" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $rmbrs = $MembersCloudOnly | select -unique | sort |foreach-object {get-exorecipient -id $_} | select -expand primarysmtpaddress ; 
            $pltNxDG=[ordered]@{
                Notes="$((get-group -id ($dg.alias)).notes),$($ticket) for $($Owner)(Cloud-only replica of on-prem group)" ;
                DisplayName=$tdgName ;
                Name=$tdgName ;
                ManagedBy= $Owner ;
                Members = $rmbrs ; 
                Alias=$samaccountname  ;
                RequireSenderAuthenticationEnabled=$true ; 
                Type = 'Security' ; 
                whatif=$($whatif) ;
                ErrorAction='STOP';
            } ;

            $pltSxDG=[ordered]@{
                identity = $null; 
                HiddenFromAddressListsEnabled=$true;
                whatif=$($whatif) ;
                ErrorAction='STOP';
            } ;
            $smsg = "==Checking for existing:$($tdgName)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            if($xdg = get-exodistributiongroup -id $pltNxDG.DisplayName -ea 0){
                $smsg = "(confirmed existing Dname:'$($xdg.DisplayName)'" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }     else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $smsg = "$((get-date).ToString('HH:mm:ss')):xDG:NotFound:$($tgrpName)`nCreating missing SecGrp" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            
                $smsg = "new-exodistributiongroup  w`n$(($pltNxDG|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                TRY {
                    $xdg = new-exodistributiongroup  @pltNxDG ;
                    # $xdg captures equiv to get-distibutiongroup 
                    $smsg = "Result:`n$(($xdg|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } CATCH {
                    $smsg = "Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Continue ;
                } ;
            } ;
            if(!$whatif){
                $pltSxDG.identity = $xdg.primarysmtpaddress ; 
                $smsg = "set-exodistributiongroup w`n$(($pltSxDG|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                TRY {
                    set-exodistributiongroup @pltSxDG ;
                    $pxdg = get-exodistributiongroup -id $pltNxDG.DisplayName ;
                    $pxDGm = get-exodistributiongroupmember -id $pltNxDG.DisplayName ;
                } CATCH {
                    $smsg = "Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Continue ;
                } ;

                if($tmbxr = get-recipient -id $Mailbox -ea 0 ){
                    $smsg = "(-Mailbox:$($tmbxr.PrimarySmtpAddress) specified, adding $($xdg.name) to it's permissions...)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    TRY {
                        # aliased ExOP|EXO|EXOv2 cmdlets (permits simpler single code block for any of the three variants of targets & syntaxes)
                        # each is '[aliasname];[exOPcmd];[exOcmd] (xOv2cmd is converted from [exocmd])
                        [array]$cmdletMaps= 'ps1GetMbx;get-mailbox;get-exomailbox','ps1SetMbx;Set-Mailbox;Set-exoMailbox','ps1GetMUsr;Get-MailUser;Get-exoMailUser',
                                            'ps1SetMUsr;Set-MailUser;Set-exoMailUser','ps1AddMbxPrm;Add-MailboxPermission;Add-exoMailboxPermission;',
                                            'ps1GetMbxPrm;Get-MailboxPermission;Get-exoMailboxPermission;','ps1RmvMbxPrm;Remove-MailboxPermission;Remove-exoMailboxPermission;',
                                            'ps1AddRcpPrm;Add-ADPermission;Add-exoRecipientPermission;','ps1GetRcpPrm;Get-ADPermission;Get-exoRecipientPermission;',
                                            'ps1RmvRcpPrm;Remove-ADPermission;Remove-exoRecipientPermission;'
                        $OpRcp=$tmbxr ;
                        $pltRXO = [ordered]@{
                            credential =  $credO365TORSID ;
                            Verbose = $($VerbosePreference -eq 'Continue');
                        } ; 
                        reconnect-exo @pltRXO ;
                        foreach($cmdletMap in $cmdletMaps){
                            switch ($OpRcp.recipienttype){
                                "MailUser" {
                                    $iIndex = 2 ;
                                    if($script:useEXOv2){
                                        reconnect-eXO2 @pltRXO ; 
                                        if(!($cmdlet= Get-Command $cmdletMap.split(';')[$iIndex ].replace('-exo','-xo') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                                        $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                                        write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                                    } else {
                                        reconnect-exo @pltRXO ;
                                        if(!($cmdlet= Get-Command $cmdletMap.split(';')[$iIndex ])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                                        $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                                        write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                                    } ;
                                }
                                "UserMailbox" { 
                                    $iIndex = 1 ;
                                    reconnect-ex2010 ;
                                    if(!($cmdlet= Get-Command $cmdletMap.split(';')[$iIndex ])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                                    $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                                    write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                                }
                                default { throw "Unrecognized recipienttype!:$($OpRcp.recipienttype)" }
                            } ; 
                        } ; 
                        
                        # exo mbx, need to flip to exo rcp, if we're going to get a functional DN for recipientperms cmds: pull the actual mbx instead of rcp (which provided RecipientType to steer balance)
                        $pltGmbx=[ordered]@{
                            Identity=$tmbxr.PrimarySmtpAddress ; 
                            ErrorAction='STOP' ;};

                        $smsg = "$((get-alias ps1GetMbx).definition) w`n$(($pltGmbx|out-string).trim())" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $tmbxr = ps1GetMbx @pltGmbx ; 
                        
                        $pltAMP=[ordered]@{
                            Identity=$tmbxr.PrimarySmtpAddress ; 
                            User=$pxdg.primarysmtpaddress ; 
                            AccessRights="FullAccess";
                            confirm = $false ; # suppress prompts
                            ErrorAction='STOP' ;
                            whatif=$($whatif);};

                        $pltARP=@{
                            identity=$tmbxr.DistinguishedName ; 
                            trustee=$pxdg.primarysmtpaddress ;
                            AccessRights="SendAs" ;
                            confirm = $false ; # suppress prompts
                            ErrorAction='STOP' ;
                            whatif=$($whatif);}; 
                        # SendAs perms target user onprem, trustee in exo:
                        $smsg = "$((get-alias ps1GetMbxPrm).definition) -Identity $($pltAMP.Identity) | `n?{`$_.user -eq '$($pxdg.name)' -AND `$_.AccessRights -eq '$($pltARP.AccessRights)'}" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        if($mbxperm = ps1GetMbxPrm -Identity $pltAMP.Identity | ?{$_.user -eq $pxdg.name -AND $_.AccessRights -eq $pltAMP.AccessRights}){
                            $smsg = "($($pdxg.name) already granted $($pltAMP.AccessRights) perms on $($pltAMP.identity))" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } else {
                            $smsg = "$((get-alias ps1AddMbxPrm).definition) w`n$(($pltAMP|out-string).trim())" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $xmp = ps1AddMbxPrm @pltAMP ;
                        } ; 
                        $mbxperm = ps1GetMbxPrm -Identity $pltAMP.Identity -user $pltAMP.user ; 
                        $smsg = "$((get-alias ps1GetMbxPrm).definition):`n$(($mbxperm|ft -wrap $propsmbxperm |out-string).trim())" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        switch ($OpRcp.recipienttype){
                                "MailUser" {
                                    $pltARP.identity = $tmbxr.distinguishedname ; 
                                    $smsg = "$((get-alias ps1GetRcpPrm).definition) -Identity $($pltARP.Identity) | `n?{`$_.trustee -eq '$($pxdg.name)' -AND `$_.AccessRights -eq '$($pltARP.AccessRights)'}" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    if($rcpperm = ps1GetRcpPrm -Identity $pltARP.Identity | ?{$_.trustee -eq $pxdg.name -AND $_.AccessRights -eq $pltARP.AccessRights}){
                                        $smsg = "(Trustee:$($pxdg.name) already granted AccessRights:$($pltARP.AccessRights) perms on `n$($pltARP.identity))" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    } else {
                                        $smsg = "$((get-alias ps1AddRcpPrm).definition) w`n$(($pltARP|out-string).trim())" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        $xmp = ps1AddRcpPrm @pltARP ;
                                    } ; 
                                    $rcpperm= ps1GetRcpPrm -Identity $pltARP.Identity -Trustee $pltARP.trustee -errorAction STOP ; 
                                    $smsg = "$((get-alias ps1GetRcpPrm).definition):`n$(($rcpperm|ft -wrap $propsrcpperm |out-string).trim())" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                } ;
                                "UserMailbox" { 
                                    $pltARP.remove('AccessRights') ; 
                                    $pltARP.add('ExtendedRights','Send As') ; 
                                    $pltARP.identity = $tmbxr.distinguishedname ; 
                                    $smsg = "$((get-alias ps1GetRcpPrm).definition) -Identity $($pltARP.Identity) | ?{`$_.user -eq '$($pxdg.name)' -AND `$_.ExtendedRights -eq '$($pltARP.AccessRights)'}" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    if($rcpperm = ps1GetRcpPrm -Identity $pltARP.Identity | ?{$_.user -eq $pxdg.name -AND $_.ExtendedRights -eq $pltARP.AccessRights}){
                                        $smsg = "($($pdxg.name) already granted $($pltARP.AccessRights) perms on $($pltARP.identity))" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    } else {
                                        $smsg = "$((get-alias ps1AddRcpPrm).definition) w`n$(($pltARP|out-string).trim())" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        $xmp = ps1AddRcpPrm @pltARP ;
                                    } ; 
                                    $rcpperm= $rcpperm = ps1GetRcpPrm -Identity $pltARP.Identity | ?{$_.user -eq $pxdg.name -AND $_.ExtendedRights -eq $pltARP.AccessRights} ; 
                                    $smsg = "$((get-alias ps1GetRcpPrm).definition) w`n$(($rcpperm|ft -wrap $propsadperm |out-string).trim())" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    # set common props for final report
                                    $propsrcpperm = $propsadperm ; 
                                } ;
                        } ;  # switch-E

                    } CATCH {
                        $smsg = "Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Continue ;
                    } ;


                } else { 
                    $smsg = "(No -Mailbox specified, slipping $($xdg.name) permissions grant...)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;
                

                $hMsg = @"

*------v REVIEW RESULTS v------

POST:exodistributiongroup
-----------
$(($pxdg|fl $propsdg|out-string).trim())
-----------

Members:
-----------
$(($pxDGm.PrimarySmtpAddress|out-string).trim())
-----------
"@ ; 

            if($Mailbox){
                $hMsg += "Associated Mailbox Permissions:`n$(($mbxperm|ft -wrap $propsmbxperm |out-string).trim())`n`n" ;     

                $hMsg += "Associated Recipient Permissions:`n$(($rcpperm|ft -wrap $propsrcpperm  |out-string).trim())`n`n" ; 
            } ;
            $hMsg += "*------^ REVIEW RESULTS ^------`n" ; 

            $smsg = $hMsg ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            } else {
                $smsg = "(-whatif detected, skipping:set-exodistributiongroup @pltNxDG" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
        } else { 
            $smsg = "Unable to get-distributiongroup -id $($SourceGroupName) ; aborting!" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ;
        $smsg = $sBnr.replace('=v','=^').replace('v=','^=') ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        
    }
    END{}
 }

#*------^ copy-XPermissionGroupToCloudOnly.ps1 ^------


#*------v cxocmw.ps1 v------
function cxoCMW {
    <#
    .SYNOPSIS
    cxoCMW - wrapper for Connect-EXO to connect to specified Tenant
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-07-29
    FileName    : cxoCMW.ps1
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    REVISIONS   :
    * 11:32 AM 4/18/2023 alias into cxomw, retiring
    .DESCRIPTION
    cxoCMW - wrapper for Connect-EXO to connect to specified Tenant
    .EXAMPLE
    cxoCMW
    #>
    [CmdletBinding()]
    [Alias('cxo2cmw' )]
    PARAM()
    Connect-EXO -cred $credO365CMWCSID -Verbose:$($VerbosePreference -eq 'Continue') ; 
}

#*------^ cxocmw.ps1 ^------


#*------v cxotol.ps1 v------
function cxoTOL {
    <#
    .SYNOPSIS
    cxoTOL - wrapper for Connect-EXO to connect to specified Tenant
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-07-29
    FileName    : cxoTOL.ps1
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    REVISIONS   :
    * 11:32 AM 4/18/2023 alias into cxotol, retiring
    .DESCRIPTION
    cxoTOL - wrapper for Connect-EXO to connect to specified Tenant
    .EXAMPLE
    cxoTOL
    #>
    [CmdletBinding()]
    [Alias('cxo2cmw' )]
    PARAM()
    Connect-EXO -cred $credO365TOLSID -Verbose:$($VerbosePreference -eq 'Continue') ; 
}

#*------^ cxotol.ps1 ^------


#*------v cxotor.ps1 v------
function cxoTOR {
    <#
    .SYNOPSIS
    cxoTOR - wrapper for Connect-EXO to connect to specified Tenant
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-07-29
    FileName    : cxoTOR.ps1
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    REVISIONS   :
    * 11:32 AM 4/18/2023 alias into cxoTOR, retiring
    .DESCRIPTION
    cxoTOR - wrapper for Connect-EXO to connect to specified Tenant
    .EXAMPLE
    cxoTOR
    #>
    [CmdletBinding()]
    [Alias('cxo2cmw' )]
    PARAM()
    Connect-EXO -cred $credO365TORSID -Verbose:$($VerbosePreference -eq 'Continue') ; 
}

#*------^ cxotor.ps1 ^------


#*------v cxoVEN.ps1 v------
function cxoVEN {
    <#
    .SYNOPSIS
    cxoVEN - wrapper for Connect-EXO to connect to specified Tenant
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-07-29
    FileName    : cxoVEN.ps1
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    REVISIONS   :
    * 11:32 AM 4/18/2023 alias into cxoVEN, retiring
    .DESCRIPTION
    cxoVEN - wrapper for Connect-EXO to connect to specified Tenant
    .EXAMPLE
    cxoVEN
    #>
    [CmdletBinding()]
    [Alias('cxo2cmw' )]
    PARAM()
    Connect-EXO -cred $credO365VENSID -Verbose:$($VerbosePreference -eq 'Continue') ; 
}

#*------^ cxoVEN.ps1 ^------


#*------v Disconnect-EXO.ps1 v------
Function Disconnect-EXO {
    <#
    .SYNOPSIS
    Disconnect-EXO - Remove all the existing exchange online connections (incl EMOv1/2 PSSessions & EOM3+ nonWinRM - closes anything ConfigurationName: Microsoft.Exchange -AND Name: ExchangeOnlineInternalSession*)
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-03-03
    FileName    : 
    License     : 
    Copyright   : 
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    AddedCredit : ExactMike Perficient
    AddedWebsite:	https://social.technet.microsoft.com/Forums/msonline/en-US/f3292898-9b8c-482a-86f0-3caccc0bd3e5/exchange-powershell-monitoring-remote-sessions?forum=onlineservicesexchange
    AddedTwitter:	
    REVISIONS   :
    * 12:46 PM 3/5/2024 full step debug pass, with Disconnect-PssBroken -verbose:$false ; rem'd and EOM v3.4.0 in place: ran clean this time
    * 3:15 PM 3/1/2024 rem'd obsolete Disconnect-PssBroken line (old PSS-supporting call from EOM)
    * 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
    * 3:26 PM 5/23/2023 fixed typo -eq/=
    * 10:59 AM 4/18/2023 step debugs ; consolidating Disconnect-EXO2 into Disconnect-EXO, aliasing dxo2,Disconnect-EXO2; removing those originals
    * 2:02 PM 4/17/2023 rev: $MinNoWinRMVersion from 2.0.6 => 3.0.0.
    * 12:42 PM 4/17/2023 restored *dxo* 7/26/21 vers; had overwritten on 3/29/22 wiith a copy of dxo2! Needs a verb-exo rebuild to complete.
    * 11:02 AM 4/4/2023 reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not; 
    add $exov3Good and diff EMOv2 from EMOv3 sessions.
    * 3:14 pm 3/29/2023: REN'D $modname => $EOMModName
    * 3:59 PM 8/2/2022 got through dbugging EOM v205 SID interactive pass, working ; added -MinNoWinRMVersion ; fully works from mybox w v206p6, cEOM connection, with functional prefix.
    * 4:07 PM 7/26/2022 found that MS code doesn't chk for multi vers's installed, when building .dll paths: wrote in code to take highest version.
    * 3:30 PM 7/25/2022 tests against CBA & SID interactive creds on EOM v205, need to debug now against EOM v206p6, to accomodate PSSession-less connect & test code.
    * 10:34 AM 4/4/2022 updated CBH; added -MinimumVersion, defaulted, to support on-the-fly exemption
    * 3:54 PM 4/1/2022 add missing $silent param (had support, but no param)
    * 3:03 PM 3/29/2022 rewrote to reflect current specs in v2.0.5 of ExchangeOnlineManagement:Disconnect-ExchangeOnlineManagement cmds
    # here down is dxo orig revs
    * 11:54 AM 3/31/2021 added verbose suppress on remove-module/session commands
    * 1:14 PM 3/1/2021 added color reset
    * 3:24 PM 7/24/2020 updated to support tenant-alignment & sub'd out showdebug for verbose
    * 11:50 AM 5/27/2020 added alias:dxo win func
    * 2:34 PM 4/20/2020 added local $rgxExoPsHostName
    * 8:45 AM 3/3/2020 public cleanup
    * 9:52 AM 11/20/2019 reviewed for credential matl, no way to see the credential on a given pssession, so there's no way to target and disconnect discretely. It's a shotgun close.
    # 10:27 AM 6/20/2019 switched to common $rgxExoPsHostName
    # 1:12 PM 11/7/2018 added Disconnect-PssBroken
    # 11:23 AM 7/10/2018: made exo-only (was overlapping with CCMS)
    # 8:47 AM 6/2/2017 cleaned up deadwood, simplified pshelp
    * 8:49 AM 3/15/2017 Disconnect-EXO: add Remove-PSTitleBar 'EXO' to clean up on disconnect
    * 2/10/14 posted version
    .DESCRIPTION
    Disconnect-EXO - Remove all the existing exchange online connections (incl EMOv1/2 PSSessions & EOM3+ nonWinRM - closes anything ConfigurationName: Microsoft.Exchange -AND Name: ExchangeOnlineInternalSession*)
    Updated to match v2.0.5 of ExchangeOnlineMangement: Unlike the  v1.0.1 'disconnect', 
    this also implements new Clear-ActiveToken support, to reset the token as well as the session. 
    Doesn't support targeting session id, just wacks all sessions matching the configurationname & name of an EXOv2 pssession.
    .PARAMETER MinimumVersion
    MinimumVersion required for ExchangeOnlineManagement module (defaults to '2.0.5')[-MinimumVersion '2.0.6']
    .PARAMETER MinNoWinRMVersion
    MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']
    .PARAMETER silent
    Switch to suppress all non-error echos
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    Disconnect-EXO;
    Disconnect all EXOv2 ConfigurationName: Microsoft.Exchange -AND Name: ExchangeOnlineInternalSession* pssession
    .EXAMPLE
    Disconnect-EXO -silent;
    Demos use of the silent parameter to suppress output of details
    .LINK
    Github      : https://github.com/tostka/verb-exo
    #>
    [CmdletBinding()]
    [Alias('dxo','dxo2','Disconnect-EXO2')]
    Param(
        [Parameter(HelpMessage = "MinimumVersion required for ExchangeOnlineManagement module (defaults to '2.0.5')[-MinimumVersion '2.0.6']")]
        [version] $MinimumVersion = '2.0.5',
        [Parameter(HelpMessage = "MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']")]
        [version] $MinNoWinRMVersion = '3.0.0',
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
        [switch] $silent

    ) 
    $verbose = ($VerbosePreference -eq "Continue") ; 

    $EOMmodname = 'ExchangeOnlineManagement' ;
    $ExoPowershellGalleryModule = "Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll" ; # in EOM v205 hosts test|clear-ActiveToken( both nonexist in v206+)
    #*------v PSS & GMO VARIS v------
    # get-pssession session varis
    $EXOv1ConfigurationName = $EXOv2ConfigurationName = $EXoPConfigurationName = "Microsoft.Exchange" ;

    if(-not (gv EXOv1ConfigurationName -ea 0)){$EXOv1ConfigurationName = "Microsoft.Exchange" };
    if(-not (gv EXOv2ConfigurationName -ea 0)){$EXOv2ConfigurationName = "Microsoft.Exchange" };
    if(-not (gv EXoPConfigurationName -ea 0)){$EXoPConfigurationName = "Microsoft.Exchange" };

    if(-not (gv EXOv1ComputerName -ea 0)){$EXOv1ComputerName = 'ps.outlook.com' };
    if(-not (gv EXOv1runspaceConnectionInfoAppName -ea 0)){$EXOv1runspaceConnectionInfoAppName = '/PowerShell-LiveID'  };
    if(-not (gv EXOv1runspaceConnectionInfoPort -ea 0)){$EXOv1runspaceConnectionInfoPort = '443' };

    if(-not (gv EXOv2ComputerName -ea 0)){$EXOv2ComputerName = 'outlook.office365.com' ;}
    if(-not (gv EXOv2Name -ea 0)){$EXOv2Name = "ExchangeOnlineInternalSession*" ; }
    if(-not (gv rgxEXoPrunspaceConnectionInfoAppName -ea 0)){$rgxEXoPrunspaceConnectionInfoAppName = '^/(exadmin|powershell)$'}; 
    if(-not (gv EXoPrunspaceConnectionInfoPort -ea 0)){$EXoPrunspaceConnectionInfoPort = '80' } ; 
    # gmo varis
    if(-not (gv rgxEXOv1gmoDescription -ea 0)){$rgxEXOv1gmoDescription = "^Implicit\sremoting\sfor\shttps://ps\.outlook\.com/PowerShell" }; 
    if(-not (gv EXOv1gmoprivatedataImplicitRemoting -ea 0)){$EXOv1gmoprivatedataImplicitRemoting = $true };
    if(-not (gv rgxEXOv2gmoDescription -ea 0)){$rgxEXOv2gmoDescription = "^Implicit\sremoting\sfor\shttps://outlook\.office365\.com/PowerShell" }; 
    if(-not (gv EXOv2gmoprivatedataImplicitRemoting -ea 0)){$EXOv2gmoprivatedataImplicitRemoting = $true } ;
    if(-not (gv rgxExoPsessionstatemoduleDescription -ea 0)){$rgxExoPsessionstatemoduleDescription = '/(exadmin|powershell)$' };
     if(-not (gv EXOv1GmoFilter -ea 0)){$EXOv1GmoFilter = 'tmp_*' } ; 
    if(-not (gv EXOv2GmoNoWinRMFilter -ea 0)){$EXOv2GmoNoWinRMFilter = 'tmpEXO_*' };
    #*------^ END PSS & GMO VARIS ^------

    $pssProps = 'Id','Name','ComputerType','ComputerName','ConfigurationName','State','Availability',
        @{name="TokenExpiryTime";expression={get-date $_.TokenExpiryTime.date -format 'yyyyMMdd-HHmmtt'}};
    

    # it's pulling the verb-EXO vers of disconnect-exchangeonline, force load the v206:
    # admin/SID module auto-install code (myBoxes UID split-perm CU, all else t AllUsers)
    #region EOMREV ; #*------v EOMREV Check v------
    $EOMmodname = 'ExchangeOnlineManagement' ;
    $pltIMod = @{Name = $EOMmodname ; ErrorAction = 'Stop' ; verbose=$false} ;
    # do a gmo first, faster than gmo -list
    if([version]$EOMMv = (Get-Module @pltIMod| sort version | select -last 1 ).version){}
    elseif([version]$EOMMv = (Get-Module -ListAvailable @pltIMod| sort version | select -last 1 ).version){} 
    else { 
        $smsg = "$($EOMmodname) PowerShell v$($MinNoWinRMVersion) module is required, do you want to install it?" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
        else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $bRet=Read-Host "Enter YYY to continue. Anything else will exit"  ; 
        if ($bRet.ToUpper() -eq "YYY") {
            $smsg = "Installing $($EOMmodname) module..." ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Install-Module $EOMmodname -Repository PSGallery -AllowClobber -Force ; 
        } else {
            $smsg = "Please install $($EOMmodname) PowerShell v$($MinNoWinRMVersion)  module." ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            #exit 1
            break ; 
        }  ; 
    } ; 
    write-verbose "(Checking for WinRM support in this EOM rev...)" 
    if([version]$EOMMv -ge [version]$MinNoWinRMVersion){
        $MinNoWinRMVersion = $EOMMv.tostring() ;
        $IsNoWinRM = $true ; 
    }elseif([version]$EOMMv -lt [version]$MinimumVersion){
        $smsg = "Installed $($EOMmodname) is v$($MinNoWinRMVersion): This module is obsolete!" ; 
        $smsg += "`nAnd unsupported by this function!" ; 
        $smsg += "`nPlease install $($EOMmodname) PowerShell v$($MinNoWinRMVersion)  module!" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        Break ; 
    } else {
        $IsNoWinRM = $false ; 
    } ; 
    [boolean]$UseConnEXO = [boolean]([version]$EOMMv -ge [version]$MinNoWinRMVersion) ; 
    #endregion EOMREV ; #*------^ END EOMREV Check  ^------
    if($useConnExo){
        # 2:28 PM 8/1/2022 issue: it sometimes defers to the verb-EXO obsolete disconnect-exchangeonline (which doesn't properly resolve .dll paths, and doesn't exist/conflict in EOMv205), force load it out of the module
        if(-not (get-command -mod 'ExchangeOnlineManagement' -name Disconnect-ExchangeOnline -ea 0 )){
            $smsg = "(found dxo2, *not* sourced from EOM: ipmo -forcing EOM)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            import-module -Name 'ExchangeOnlineManagement' -force -RequiredVersion $MinNoWinRMVersion ; 
        } ; 
        # just alias disconnect-ExchangeOnline, it retires token etc as well as closing PSS, but biggest reason is it's got a confirm, hard-coded, needs a function to override
        # flip back to the old d-eom call.
        Disconnect-ExchangeOnline -confirm:$false ; 
        # just use the updated RemoveExistingEXOPSSession
        #PRIOR: RemoveExistingEXOPSSession -Verbose:$false ;
        # v2.0.5 3:01 PM 3/29/2022 no longer exists
    } else { 
        $smsg = "(EXOv2 EOM v205 nonWinRM code in use...)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #$EOMmodname = 'ExchangeOnlineManagement' ;
        #if(-not $EXOv2Name){$EXOv2Name = "ExchangeOnlineInternalSession*" ; } ; 
        #if(-not $EXOv2ConfigurationName){$EXOv2ConfigurationName = "Microsoft.Exchange" };
        $EOMgmtModulePath = split-path (get-module $EOMmodname -list | sort Version | select -last 1).Path ;
        if($IsCoreCLR){
            $EOMgmtModulePath = resolve-path -Path $EOMgmtModulePath\netcore ;
            $smsg = "(.netcore path in use:" ; 
        } else { 
            $EOMgmtModulePath = resolve-path -Path $EOMgmtModulePath\netFramework ; 
            $smsg = "(.netnetFramework path in use:" ;                 
        } ; 
        #$ExoPowershellGalleryModule = "Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll" ;
        $ExoPowershellGalleryModulePath = join-path -path $EOMgmtModulePath -childpath $ExoPowershellGalleryModule ;
        if (-not(get-module $ExoPowershellGalleryModule.replace('.dll','') )) {
            Import-Module $ExoPowershellGalleryModulePath -Verbose:$false -ErrorAction 'STOP';
        } ;    
        if(-not (get-command -module $ExoPowershellGalleryModule.replace('.dll','') | ? Name -match '(clear|test)-ActiveToken')){
            throw "Unable to GCM clear-ActiveToken cmdlet!`n(as provided by:$($ExoPowershellGalleryModulePath))" ; 
        } ; 
    } ; 
    # poll session types
    $existingPSSession = Get-PSSession | 
        Where-Object {$_.ConfigurationName -like "Microsoft.Exchange" -and $_.Name -like "ExchangeOnlineInternalSession*"} ;
    if ($existingPSSession.count -gt 0) {
        for ($index = 0; $index -lt $existingPSSession.count; $index++){
            $session = $existingPSSession[$index]
            $smsg = "Remove-PSSession w`n$(($session | format-table -a  $pssprops|out-string).trim())" ; 
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            Remove-PSSession -session $session
            $smsg = "Removed the PSSession $($session.Name) connected to $($session.ComputerName)"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # Remove any active access token from the cache
            $pltCAT=[ordered]@{
                TokenProvider=$session.TokenProvider ; 
            } ;
            $smsg = "Clear-ActiveToken w`n$(($pltCAT|out-string).trim())" ; 
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            Clear-ActiveToken @pltCAT ;
            # Remove any previous modules loaded because of the current PSSession
            if ($session.PreviousModuleName -ne $null){
                if ((Get-Module $session.PreviousModuleName).Count -ne 0){
                    Remove-Module -Name $session.PreviousModuleName -ErrorAction SilentlyContinue
                }
                $session.PreviousModuleName = $null
            } ; 
            # Remove any leaked module in case of removal of broken session object
            if ($session.CurrentModuleName -ne $null){
                if ((Get-Module $session.CurrentModuleName).Count -ne 0){
                    Remove-Module -Name $session.CurrentModuleName -ErrorAction SilentlyContinue ; 
                } ;  
            }  ; 
        } ;  # loop-E
    } ; # if-E $existingPSSession.count -gt 0
    
    # here's the 'bug', old legacy pss-based force removal cmd, I'd spliced from v205 into verb-mods
    #Disconnect-PssBroken -verbose:$false ;
    Remove-PSTitlebar 'EXO2' #-verbose:$($VerbosePreference -eq "Continue");
    #[console]::ResetColor()  # reset console colorscheme
}

#*------^ Disconnect-EXO.ps1 ^------


#*------v get-ADUsersWithSoftDeletedxoMailboxes.ps1 v------
function get-ADUsersWithSoftDeletedxoMailboxes {
    <#
    .SYNOPSIS
    get-ADUsersWithSoftDeletedxoMailboxes.ps1 - Get *existing* ADUsers with SoftDeleted xoMailboxes
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2022-01-14
    FileName    : get-ADUsersWithSoftDeletedxoMailboxes
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-xo
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 2:51 PM 1/14/2022 init
    .DESCRIPTION
    get-ADUsersWithSoftDeletedxoMailboxes.ps1 - Get *existing* ADUsers with SoftDeleted xoMailboxes
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    None. Returns no objects or output (.NET types)
    System.Boolean
    [| get-member the output to see what .NET obj TypeName is returned, to use here]
    .EXAMPLE
    PS> .\get-ADUsersWithSoftDeletedxoMailboxes.ps1 -verbose
    Run with verbose
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    # 2:49 PM 3/8/2022 pull verb-ex2010 ref - I think it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    #Requires -Modules ActiveDirectory, ExchangeOnlineManagement, verb-ADMS, verb-Auth, verb-IO, verb-logging, verb-Network, verb-Text
    #Requires -RunasAdministrator
    #Requires -Version 3
    #requires -PSEdition Desktop
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\sregex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    ###[Alias('Alias','Alias2')]
    PARAM(
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2
    ) ;
    
    BEGIN { 
        #region CONSTANTS-AND-ENVIRO #*======v CONSTANTS-AND-ENVIRO v======
        # function self-name (equiv to script's: $MyInvocation.MyCommand.Path) ;
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        # Get parameters this function was invoked with
        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
        $Verbose = ($VerbosePreference -eq 'Continue') ; 
        if ($PSScriptRoot -eq "") {
            if ($psISE) { $ScriptName = $psISE.CurrentFile.FullPath } 
            elseif ($context = $psEditor.GetEditorContext()) {$ScriptName = $context.CurrentFile.Path } 
            elseif ($host.version.major -lt 3) {
                $ScriptName = $MyInvocation.MyCommand.Path ;
                $PSScriptRoot = Split-Path $ScriptName -Parent ;
                $PSCommandPath = $ScriptName ;
            } else {
                if ($MyInvocation.MyCommand.Path) {
                    $ScriptName = $MyInvocation.MyCommand.Path ;
                    $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                } else {throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" } ;
            };
            $ScriptDir = Split-Path -Parent $ScriptName ;
            $ScriptBaseName = split-path -leaf $ScriptName ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($ScriptName) ;
        } else {
            $ScriptDir = $PSScriptRoot ;
            if ($PSCommandPath) {$ScriptName = $PSCommandPath } 
            else {
                $ScriptName = $myInvocation.ScriptName
                $PSCommandPath = $ScriptName ;
            } ;
            $ScriptBaseName = (Split-Path -Leaf ((& { $myInvocation }).ScriptName))  ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
        } ;
        if ($showDebug) { write-debug -verbose:$true "`$ScriptDir:$($ScriptDir)`n`$ScriptBaseName:$($ScriptBaseName)`n`$ScriptNameNoExt:$($ScriptNameNoExt)`n`$PSScriptRoot:$($PSScriptRoot)`n`$PSCommandPath:$($PSCommandPath)" ; } ;
        $ComputerName = $env:COMPUTERNAME ;
        $NoProf = [bool]([Environment]::GetCommandLineArgs() -like '-noprofile'); # if($NoProf){# do this};
        # silently stop any running transcripts
        $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ; 
        #endregion CONSTANTS-AND-ENVIRO #*======^ END CONSTANTS-AND-ENVIRO ^======
        
        #region START-LOG #*======v START-LOG OPTIONS v======
        #region START-LOG-HOLISTIC #*------v START-LOG-HOLISTIC v------
        # Single log for script/function example that accomodates detect/redirect from AllUsers scope'd installed code, and hunts a series of drive letters to find an alternate logging dir (defers to profile variables)
        #${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        if(!(get-variable LogPathDrives -ea 0)){$LogPathDrives = 'd','c' };
        foreach($budrv in $LogPathDrives){if(test-path -path "$($budrv):\scripts" -ea 0 ){break} } ;
        if(!(get-variable rgxPSAllUsersScope -ea 0)){
            $rgxPSAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps(((d|m))*)1|dll)$" ;
        } ;
        if(!(get-variable rgxPSCurrUserScope -ea 0)){
            $rgxPSCurrUserScope="^$([regex]::escape([Environment]::GetFolderPath('MyDocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps((d|m)*)1|dll)$" ;
        } ;
        $pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($whatif) ;} ;
        $pltSL.Tag = $ModuleName ; 
        if($script:PSCommandPath){
            if(($script:PSCommandPath -match $rgxPSAllUsersScope) -OR ($script:PSCommandPath -match $rgxPSCurrUserScope)){
                $bDivertLog = $true ; 
                switch -regex ($script:PSCommandPath){
                    $rgxPSAllUsersScope{$smsg = "AllUsers"} 
                    $rgxPSCurrUserScope{$smsg = "CurrentUser"}
                } ;
                $smsg += " context script/module, divert logging into [$budrv]:\scripts" 
                write-verbose $smsg  ;
                if($bDivertLog){
                    if((split-path $script:PSCommandPath -leaf) -ne $cmdletname){
                        # function in a module/script installed to allusers|cu - defer name to Cmdlet/Function name
                        $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
                    } else {
                        # installed allusers|CU script, use the hosting script name
                        $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $script:PSCommandPath -leaf)) ;
                    }
                } ;
            } else {
                $pltSL.Path = $script:PSCommandPath ;
            } ;
        } else {
            if(($MyInvocation.MyCommand.Definition -match $rgxPSAllUsersScope) -OR ($MyInvocation.MyCommand.Definition -match $rgxPSCurrUserScope) ){
                 $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $script:PSCommandPath -leaf)) ;
            } elseif(test-path $MyInvocation.MyCommand.Definition) {
                $pltSL.Path = $MyInvocation.MyCommand.Definition ;
            } elseif($cmdletname){
                $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
            } else {
                $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$CMDLETNAME, FROM WHICH TO BUILD A START-LOG.PATH!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                BREAK ;
            } ; 
        } ;
        write-verbose "start-Log w`n$(($pltSL|out-string).trim())" ; 
        $logspec = start-Log @pltSL ;
        $error.clear() ;
        TRY {
            if($logspec){
                $logging=$logspec.logging ;
                $logfile=$logspec.logfile ;
                $transcript=$logspec.transcript ;
                $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                start-Transcript -path $transcript ;
            } else {throw "Unable to configure logging!" } ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ;
        #endregion START-LOG-HOLISTIC #*------^ END START-LOG-HOLISTIC ^------
        #region START-LOG-SIMPLE #*------v START-LOG-SIMPLE v------
        #Configure default logging from parent script name
        # Configure default logging from parent script name
        $pltSL=@{ NoTimeStamp=$true ; Tag="($TenOrg)-LASTPASS" ; showdebug=$($showdebug) ; whatif=$($whatif) ; Verbose=$($VerbosePreference -eq 'Continue') ; } ;
        if($PSCommandPath){   $logspec = start-Log -Path $PSCommandPath @pltSL ;
        } else { $logspec = start-Log -Path ($MyInvocation.MyCommand.Definition) @pltSL ; } ;
        if($logspec){
            $logging=$logspec.logging ;
            $logfile=$logspec.logfile ;
            $transcript=$logspec.transcript ;
            if(Test-TranscriptionSupported){
                $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                start-transcript -Path $transcript ;
            } ;
        } else {throw "Unable to configure logging!" } ;
        #endregion START-LOG-SIMPLE #*------^ END START-LOG SIMPLE ^------
        #endregion START-LOG #*======^ START-LOG OPTIONS ^======
        
        #region EXCH-CMD-ALIASING-OPTS ; #*======v EXCH-CMD-ALIASING-OPTS v======
        #region EXO-v-EXOv2-ALIASING #*------v Function EXO v EXOv2 ALIASING on $useEXOv2 v------
        # simple loop to stock the set, no set->get conversion, roughed in $Exov2 exo->xo replace. Do specs in exo, and flip to suit under $exov2
        #configure EXO EMS aliases to cover useEXOv2 requirements
        # have to preconnect, as it gcm's the targets
        if ($script:useEXOv2) { reconnect-eXO2 }
        else { reconnect-EXO } ;
        # aliased ExOP|EXO|EXOv2 cmdlets (permits simpler single code block for any of the three variants of targets & syntaxes)
        # each is '[aliasname];[exOcmd] (xOv2cmd & exop are converted from [exocmd])
        [array]$cmdletMaps = 'ps1GetxRcp;get-exorecipient;','ps1GetxMbx;get-exomailbox;','ps1SetxMbx;Set-exoMailbox;','ps1GetxUser;get-exoUser;',
            'ps1GetxMUsr;Get-exoMailUser','ps1SetxMUsr;Set-exoMailUser','ps1SetxCalProc;set-exoCalendarprocessing;',
            'ps1GetxCalProc;get-exoCalendarprocessing;','ps1GetxMbxFldrPerm;get-exoMailboxfolderpermission;',
            'ps1GetxMbxFldrPerm;get-exoMailboxfolderpermission','ps1AddxMbxPrm;Add-exoMailboxPermission','ps1GetxMbxPrm;Get-exoMailboxPermission',
            'ps1RmvxMbxPrm;Remove-exoMailboxPermission','ps1AddRcpPrm;Add-exoRecipientPermission','ps1GetRcpPrm;Get-exoRecipientPermission',
            'ps1RmvRcpPrm;Remove-exoRecipientPermission','ps1GetxAccDom;Get-exoAcceptedDomain;','ps1GetxRetPol;Get-exoRetentionPolicy',
            'ps1GetxDistGrp;get-exoDistributionGroup;','ps1GetxDistGrpMbr;get-exoDistributionGroupmember;','ps1GetxMsgTrc;get-exoMessageTrace;',
            'ps1GetxMsgTrcDtl;get-exoMessageTraceDetail;','ps1GetxMbxFldrStats;get-exoMailboxfolderStatistics','ps1GetxMContact;Get-exomailcontact;',
            'ps1SetxMContact;Set-exomailcontact;','ps1NewxMContact;New-exomailcontact','ps1TestxMapi;Test-exoMAPIConnectivity',
            'ps1GetxOrgCfg;Get-exoOrganizationConfig','ps1GetxMbxRegionCfg;Get-exoMailboxRegionalConfiguration',
            'ps1TestxOAuthConn;Test-exoOAuthConnectivity','ps1NewxDistGrp;new-exoDistributionGroup','ps1SetxDistGrp;set-exoDistributionGroup',
            'ps1AddxDistGrpMbr;Add-exoDistributionGroupMember','ps1RmvxDistGrpMbr;remove-exoDistributionGroupMember',
            'ps1GetxDDG;Get-exoDynamicDistributionGroup','ps1NewxDDG;New-exoDynamicDistributionGroup','ps1SetxDDG;Set-exoDynamicDistributionGroup' ;
            'ps1GetxCasMbx;Get-exoCASMailbox','ps1GetxMbxStat;Get-exoMailboxStatistics','ps1GetxMobilDevStats;Get-exoMobileDeviceStatistics'
        [array]$XoOnlyMaps = 'ps1GetxMsgTrcDtl','ps1TestxOAuthConn' ; # cmdlet alias names from above that are skipped for aliasing in EXOP
        # cmdlets from above that have diff names EXO v EXoP: these each have  schema: [alias];[xoCmdlet];[opCmdlet]; op Aliases use the opCmdlet as target
        [array]$XoRenameMaps = 'ps1GetxMsgTrc;get-exoMessageTrace;get-MessageTrackingLog','ps1AddRcpPrm;Add-exoRecipientPermission;Add-AdPermission',
                'ps1GetRcpPrm;Get-exoRecipientPermission;Get-AdPermission','ps1RmvRcpPrm;Remove-exoRecipientPermission;Remove-ADPermission' ;
        [array]$Xo2VariantMaps =   'ps1GetxCasMbx;Get-exoCASMailbox', 'ps1GetxMbx;get-exomailbox;', 'ps1GetxMbxFldrPerm;get-exoMailboxfolderpermission;',
            'ps1GetxMbxFldrStats;get-exoMailboxfolderStatistics', 'ps1GetxMbxPrm;Get-exoMailboxPermission', 'ps1GetxMbxStat;Get-exoMailboxStatistics',
            'ps1GetxMobilDevStats;Get-exoMobileDeviceStatistics', 'ps1GetxRcp;get-exorecipient;', 'ps1AddRcpPrm;Add-exoRecipientPermission' ; 
        # cmdlets above have XO2 enhanced variant-named versions to target (they never are prefixed verb-xo[noun], always/only verb-exo[noun])
        # code to summarize & indexed-hash the renamed cmdlets for variant processing
        $XoRenameMapNames = @() ; 
        $oxoRenameMaps = @{} ;
        $XoRenameMaps | foreach {     $XoRenameMapNames += $_.split(';')[0] ;     $name = $_.split(';')[0] ;     $oxoRenameMaps[$name] = $_.split(';')  ;  } ;
        $Xo2VariantMapNames = @() ;
        $oXo2VariantMaps = @{} ;
        $Xo2VariantMaps | foreach {  $Xo2VariantMapNames += $_.split(';')[0] ;  $name = $_.split(';')[0] ;  $oXo2VariantMaps[$name] = $_.split(';') ; } ; 
        #$cmdletMapsFltrd = $cmdletmaps|?{$_.split(';')[1] -like '*DistributionGroup*'} ;  # filtering subset
        #$cmdletMapsFltrd += $cmdletmaps|?{$_.split(';')[1] -like '*recipient'}
        $cmdletMapsFltrd = $cmdletmaps ; # or use full set
        foreach($cmdletMap in $cmdletMapsFltrd){
            if($script:useEXOv2){
                if($Xo2VariantMapNames -contains $cmdletMap.split(';')[0]){
                    write-verbose "$($cmdletMap.split(';')[1]) has an XO2-VARIANT cmdlet, renaming for XOV2 enhanced variant" ;
                    # sub -exoNOUN -> -NOUN using ExOP variant cmdlet
                    if(!($cmdlet= Get-Command $oXo2VariantMaps[($cmdletMap.split(';')[0])][2] )){ throw "unable to gcm Alias definition!:$($oxoRenameMaps[($cmdletMap.split(';')[0])][2])" ; break }
                    $nAName = ($cmdletMap.split(';')[0]);
                    if(-not(get-alias -name $naname -ea 0 |?{$_.Definition -eq $cmdlet.name})){
                        $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                        write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                    } ;
                } else { 
                    # common cmdlets between all 3 systems
                    if(!($cmdlet= Get-Command $cmdletMap.split(';')[1].replace('-exo','-xo') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                    $nAName = ($cmdletMap.split(';')[0]) ;
                    if(-not(get-alias -name $naname -ea 0 |?{$_.Definition -eq $cmdlet.name})){
                        $nalias = set-alias -name $nAName -value ($cmdlet.name) -passthru ;
                        write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                    } ;
                } ; 
            } else {
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nAName = ($cmdletMap.split(';')[0]);
                if(-not(get-alias -name $naname -ea 0 |?{$_.Definition -eq $cmdlet.name})){
                    $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                    write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                } ;
            } ;
        } ;# ...
        # cleanup
        get-alias -scope Script |?{$_.name -match '^ps1.*'} | %{Remove-Alias -alias $_.name} ; 
        #endregion EXO-v-EXOv2-ALIASING #*------^ END Function EXO V EXOv2 ALIASING ^------
        
        #endregion EXCH-CMD-ALIASING-OPTS #*======^ END EXCH-CMD-ALIASING-OPTS ^======
        
        #region useEXOP ; #*------v useEXOP v------
        $useEXOP = $false ; 
        if($useEXOP){
            #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
            # do the OP creds too
            $OPCred=$null ;
            # default to the onprem svc acct
            $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC' ;verbose=$($verbose)} ;
            if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                #-=-record a STATUSERROR=-=-=-=-=-=-=
                $statusdelta = ";ERROR"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                if(gv passstatus -scope Script){$script:PassStatus += $statusdelta } ;
                if(gv -Name PassStatus_$($tenorg) -scope Script){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                #-=-=-=-=-=-=-=-=
                $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                BREAK ;
            } ;
            $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;  
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            <# CALLS ARE IN FORM: (cred$($tenorg))
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                verbose = $($verbose) ; }
            ReConnect-Ex2010XO @pltRX10 ; # cross-prem conns
            Reconnect-Ex2010 @pltRX10 ; # local org conns
            #$pltRx10 creds & .username can also be used for local ADMS connections
            #>
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                verbose = $($verbose) ; } ;     
            # TEST
            #if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; BREAK ;}  ;
            # defer cx10/rx10, until just before get-recipients qry
            #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
            # connect to ExOP X10
            <#
            if($pltRX10){
                ReConnect-Ex2010 @pltRX10 ;
            } else { Reconnect-Ex2010 ; } ; 
            #>
        } ;  # if-E $useEXOP
        #endregion useEXOP ; #*------^ END useEXOP ^------
        #region useOPAD ; #*------v useOPAD v------
        if($useEXOP){
            # resolve $domaincontroller dynamic, cross-org
            # setup ADMS PSDrives per tenant 
            if(!$global:ADPsDriveNames){
                $smsg = "(connecting X-Org AD PSDrives)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $global:ADPsDriveNames = mount-ADForestDrives -verbose:$($verbose) ;
            } ; 
            if(($global:ADPsDriveNames|measure).count){
                $useEXOforGroups = $false ; 
                $smsg = "Confirming ADMS PSDrives:`n$(($global:ADPsDriveNames.Name|%{get-psdrive -Name $_ -PSProvider ActiveDirectory} | ft -auto Name,Root,Provider|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                # returned object
                #         $ADPsDriveNames
                #         UserName                Status Name        
                #         --------                ------ ----        
                #         DOM\Samacctname   True  [forestname wo punc] 
                #         DOM\Samacctname   True  [forestname wo punc]
                #         DOM\Samacctname   True  [forestname wo punc]
                
            } else { 
                #-=-record a STATUSERROR=-=-=-=-=-=-=
                $statusdelta = ";ERROR"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                if(gv passstatus -scope Script){$script:PassStatus += $statusdelta } ;
                if(gv -Name PassStatus_$($tenorg) -scope Script){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                #-=-=-=-=-=-=-=-=
                $smsg = "Unable to detect POPULATED `$global:ADPsDriveNames!`n(should have multiple values, resolved to $()"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                BREAK ;
            } ; 
        }  else { 
            <# have to defer to get-azuread, or use EXO's native cmds to poll grp members
            # TODO 1/15/2021
            $useEXOforGroups = $true ; 
            $smsg = "$($TenOrg):HAS NO ON-PREM ACTIVEDIRECTORY, DEFERRING ALL GROUP ACCESS & MGMT TO NATIVE EXO CMDS!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #>
        } ; 
        #endregion useOPAD ; #*------^ END useOPAD ^------

        <#
        if($pltRX10){
            ReConnect-Ex2010 @pltRX10 ;
        } else { Reconnect-Ex2010 ; } ;     
        #>
        if ($PSCmdlet.MyInvocation.ExpectingInput) {
            $smsg = "Data received from pipeline input: '$($InputObject)'" ; 
        } else {
            #write-verbose "Data received from parameter input: '$($InputObject)'" ; 
        } ; 
        
        #### NEW CODE/CONSTANTS HERE ####
        
    } ; # BEGIN-E
    PROCESS {
        $Error.Clear() ; 
        # call func with $PSBoundParameters and an extra (includes Verbose)
        #call-somefunc @PSBoundParameters -anotherParam
        
        # - Pipeline support will iterate the entire PROCESS{} BLOCK, with the bound - $array - 
        #   param, iterated as $array=[pipe element n] through the entire inbound stack. 
        # $_ within PROCESS{}  is also the pipeline element (though it's safer to declare and foreach a bound $array param).
        
        # - foreach() below alternatively handles _named parameter_ calls: -array $objectArray
        # which, when a pipeline input is in use, means the foreach only iterates *once* per 
        #   Process{} iteration (as process only brings in a single element of the pipe per pass) 
        
        #foreach($item in $array) {
            # dosomething w $item
            
            # put your real processing in here, and assume everything that needs to happen per loop pass is within this section.
            # that way every pipeline or named variable param item passed will be processed through. 
            
            $smsg = "getting *existing* ADUsers with SoftDeletedxoMailboxes" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            
            $smsg = "(get all SoftDeleted xoMbxs)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            $error.clear() ;
            TRY {
                $pltGxMbx=[ordered]@{ Resultsize='Unlimited' ;SoftDeletedMailbox=$true ;ErrorAction = 'STOP';} ; 
                $smsg = "$((get-alias ps1GetxMbx).definition) w`n$(($pltGxMbx|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $allsdmbx = ps1GetxMbx @pltGxMbx ;
                $smsg = "(get all LegalHeld mailboxes (InactiveMailboxOnly))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $pltGxMbx=[ordered]@{ Resultsize='Unlimited' ;InactiveMailboxOnly=$true ;ErrorAction = 'STOP';} ; 
                $smsg = "$((get-alias ps1GetxMbx).definition) w`n$(($pltGxMbx|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $allimbx = ps1GetxMbx @pltGxMbx ;
                $smsg = "(compare the populations)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $pltComp=[ordered]@{ReferenceObject=$allsdmbx ;DifferenceObject=$allimbx ;PassThru=$true;Property='userprincipalname' ;} ; 
                $smsg = "compare-object w`n$(($pltComp|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $cmpare = compare-object @pltComp ;
                $smsg = "(isolate all SoftDeleted mbxs that are *not* Inactive/legal-held)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $nonHeldSDs = $allsdmbx | ? isinactivemailbox -eq $false | sort whensoftdeleted ;  
                $smsg = "Filter for non-LegalHeld SoftDeleted mailboxes, with non-Deleted ADUsers...`n" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $availSoftDeleteADUsers = $nonHeldSDs | %{$upn = $_.userprincipalname ; get-adobject -filter 'userprincipalname -eq  $upn' -IncludeDeletedObjects -properties IsDeleted,LastKnownParent,userprincipalname -ea continue} |?{$_.isdeleted -eq $false } ; 
                if($availSoftDeleteADUsers){ 
                    #$availSoftDeleteADUsers | ft -auto name,IsDeleted,lastknownparent,userp*
                    $smsg = "`n$(($availSoftDeleteADUsers | ft -auto name,IsDeleted,lastknownparent,userp*|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $smsg = "(returning matches to pipeline)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $availSoftDeleteADUsers | write-output ; 
                } else {
                    $smsg = "`$availSoftDeleteADUsers: none found" 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ; 
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)"  ;
                Break ; 
            } ; 
        #} ;  # loop-E process loop

    } ;  # PROC-E
    END {
        # clean-up dyn-created vars & those created by a dot sourced script.
        #((Compare-Object -ReferenceObject (Get-Variable).Name -DifferenceObject $DefVaris).InputObject).foreach{Remove-Variable -Name $_} ; 
    } ;  # END-E
}

#*------^ get-ADUsersWithSoftDeletedxoMailboxes.ps1 ^------


#*------v get-ExoMailboxLicenses.ps1 v------
function get-ExoMailboxLicenses {
<#
    .SYNOPSIS
    get-ExoMailboxLicenses - Provides a prefab array indexed hash of Exchange-Online mailbox-supporting licenses (at least one of which is required to accomodate an EXO Usermailbox - Note: This is a static non-query-based list of license. The function must be manually updated to accomodate MS licensure changes over time).
    .PARAMETER Mailboxes
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2022-02-25
    FileName    : get-ExoMailboxLicenses.ps1
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-ex2010
    Tags        : Powershell
    REVISIONS
    * 12:45 PM 6/21/2022 added cbh expl that rolls up a rgx to use for independant manual tests against 
    * 2:21 PM 3/1/2022 updated CBH
    * 4:27 PM 2/25/2022 init vers
    .DESCRIPTION
    get-ExoMailboxLicenses - Provides a prefab array indexed hash of Exchange-Online mailbox-supporting licenses (at least one of which is required to accomodate an EXO Usermailbox - Note: This is a static non-query-based list of license. The function must be manually updated to accomodate MS licensure changes over time).
    .PARAMETER TenOrg
    TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']
    .EXAMPLE
    PS> $hQuotas = get-ExoMailboxLicenses -verbose ; 
    PS> $hQuotas['database2']
    Name           ProhibitSendReceiveQuotaGB ProhibitSendQuotaGB IssueWarningQuotaGB
    ----           -------------------------- ------------------- -------------------
    database2      12.000                     10.000              9.000
    Retrieve local org on-prem MailboxDatabase quotas and assign to a variable, with verbose outputs. Then output the retrieved quotas from the indexed hash returned, for the mailboxdatabase named 'database2'.
    .EXAMPLE
    PS>  $pltGXML=[ordered]@{
    PS>      #TenOrg= $TenOrg;
    PS>      verbose=$($VerbosePreference -eq "Continue") ;
    PS>      #credential= $pltRXO.credential ;
    PS>      #(Get-Variable -name cred$($tenorg) ).value ;
    PS>  } ;
    PS>  $smsg = "$($tenorg):get-ExoMailboxLicenses w`n$(($pltGXML|out-string).trim())" ;
    PS>  if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
    PS>  else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    PS>  $objRet = $null ;
    PS>  $objRet = get-ExoMailboxLicenses @pltGXML ;
    PS>  if( ($objRet|Measure-Object).count -AND $objRet.GetType().FullName -match $rgxHashTableTypeName ){
    PS>      $smsg = "get-ExoMailboxLicenses:$($tenorg):returned populated ExMbxLicenses" ;
    PS>      if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
    PS>      else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    PS>      $ExMbxLicenses = $objRet ;
    PS>  } else {
    PS>      $smsg = "get-ExoMailboxLicenses:$($tenorg):FAILED TO RETURN populated [hashtable] ExMbxLicenses" ;
    PS>      if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } 
    PS>      else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    PS>      THROW $SMSG ; 
    PS>      break ; 
    PS>  } ;
    PS>  $smsg = "$(($ExMbxLicenses.Values|measure).count) EXO UserMailbox-supporting License summaries returned)" ;
    PS>  if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
    PS>  else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;    
    PS>  $smsg = "$(($ExMbxLicenses.Values|measure).count) EXO UserMailbox-supporting License summaries returned)" ;
    PS>  if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
    PS>  else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    PS> $aadu = get-azureaduser -obj someuser@domain.com ; 
    PS> $IsExoLicensed = $false ;
    PS> foreach($pLic in $aadu.AssignedLicenses){
    PS>     $smsg = "--(LicSku:$($plic): checking EXO UserMailboxSupport)" ; 
    PS>     if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    PS>     else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;                                     
    PS>     if($ExMbxLicenses[$plic]){
    PS>         $hSummary.IsExoLicensed = $true ;
    PS>         $smsg = "$($mbx.userprincipalname) HAS EXO UserMailbox-supporting License:$($ExMbxLicenses[$sku].SKU)|$($ExMbxLicenses[$sku].Label)" ; 
    PS>         if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    PS>         else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    PS> } ; 
    PS> if(-not $hSummary.IsExoLicensed){
    PS>     $smsg = "$($mbx.userprincipalname) WAS FOUND TO HAVE *NO* EXO UserMailbox-supporting License!" ; 
    PS>     if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
    PS>     else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    PS> } ;
    Expanded example with testing of returned object, and demoes use of the returned hash against a mailbox spec, steering via .UseDatabaseQuotaDefaults
    EXAMPLE
    PS> $ExMbxLicenses = get-ExoMailboxLicenses ;
    PS> [regex]$rgxExLics = ('(' + (($ExMbxLicenses.GetEnumerator().name |%{[regex]::escape($_)}) -join '|') + ')') ; 
    Demo pulling the underlying licenses list and building a regex for static use
    .LINK
    https://github.com/tostka/verb-ex2010
    #>
    #Requires -Modules verb-IO, verb-logging, verb-Text
    [OutputType('System.Collections.Hashtable')]
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
        [ValidateNotNullOrEmpty()]
        [string]$TenOrg = 'TOR',
        [Parameter(HelpMessage="Credential to use for this connection [-credential [credential obj variable]")]
        [System.Management.Automation.PSCredential]$Credential = $global:credTORSID
    ) ;
    
    ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
    $verbose = ($VerbosePreference -eq "Continue") ;
    
    # check if using Pipeline input or explicit params:
    if ($PSCmdlet.MyInvocation.ExpectingInput) {
        write-verbose "Data received from pipeline input: '$($InputObject)'" ;
    } else {
        # doesn't actually return an obj in the echo
        #write-verbose "Data received from parameter input: '$($InputObject)'" ;
    } ;
    

    # input table of Exchange Online assignable licenses that include a UserMailbox:
    $ExMbxLicensesTbl = @"
|SKU|Label|Notes|
|ENTERPRISEPACK|Office 365 Enterprise E3|OfficE; EXO (OL,OWA,OM,100G mbx)|
|EXCHANGESTANDARD|Exchange Online Plan 1|No Office; no Services; 50G mbx, No ArchiveMbx|
|SPE_F1|Microsoft 365 F3| OfficeWeb, OfficeMobile; EXO (OWA,OM 2G Mbx)|(formerly Microsoft 365 F1, renamed Mar2020)
|STANDARDPACK|OFFICE 365 E1| OfficeWeb, OfficeMobile; EXO (OWA,OM 50G Mbx)
|EXCHANGEENTERPRISE_FACULTY|Exch Online Plan 2 for Faculty|No Office; no Services; 100G mbx, +ArchiveMbx, +vmail, +DLP|
|EXCHANGE_L_STANDARD|Exchange Online (Plan 1)|No Office; no Services; 50G mbx, No ArchiveMbx|
|EXCHANGE_S_ENTERPRISE|Exchange Online Plan 2 S|No Office; no Services; 100G mbx, +ArchiveMbx, +vmail, +DLP|
|EXCHANGEENTERPRISE|Exchange Online Plan 2|No Office; no Services; 50G mbx, +ArchiveMbx, +vmail, +DLP|
|STANDARDWOFFPACK_STUDENT|O365 Education E1 for Students|OfficeWeb, OfficeMobile; EXO (OWA,OM 50G Mbx)|
|STANDARDWOFFPACK_IW_FACULTY|O365 Education for Faculty||
|STANDARDWOFFPACK_IW_STUDENT|O365 Education for Students||
|STANDARDPACK_STUDENT|Office 365 (Plan A1) for Students||
|ENTERPRISEPACKLRG|Office 365 (Plan E3)||
|STANDARDWOFFPACK_FACULTY|Office 365 Education E1 for Faculty|OfficeWeb, OfficeMobile; EXO (OWA,OM 50G Mbx)|
|ENTERPRISEWITHSCAL_FACULTY|Office 365 Education E4 for Faculty||
|ENTERPRISEWITHSCAL_STUDENT|Office 365 Education E4 for Students||
|STANDARDPACK|Office 365 Enterprise E1|OfficeWeb, OfficeMobile; EXO (OWA,OM 50G Mbx)|
|STANDARDWOFFPACK|Office 365 Enterprise E2|OfficeWeb, OfficeMobile; EXO (OWA,OM 50G Mbx), No ArchiveMbx|
|ENTERPRISEPACKWITHOUTPROPLUS|Office 365 Enterprise E3 without ProPlus Add-on||
|ENTERPRISEWITHSCAL|Office 365 Enterprise E4||
|ENTERPRISEPREMIUM|Office 365 Enterprise E5|OfficE; EXO (OL,OWA,OM,100G mbx),AAD P1 & P2, Az Info Protection Plan 2; UC; ATP|
|DESKLESSPACK_YAMMER|Office 365 Enterprise K1 with Yammer||
|DESKLESSPACK|Office 365 Enterprise K1 without Yammer||
|DESKLESSWOFFPACK|Office 365 Enterprise K2||
|MIDSIZEPACK|Office 365 Midsize Business||
|STANDARDWOFFPACKPACK_FACULTY|Office 365 Plan A2 for Faculty||
|STANDARDWOFFPACKPACK_STUDENT|Office 365 Plan A2 for Students||
|ENTERPRISEPACK_FACULTY|Office 365 Plan A3 for Faculty||
|ENTERPRISEPACK_STUDENT|Office 365 Plan A3 for Students||
|OFFICESUBSCRIPTION_FACULTY|Office 365 ProPlus for Faculty||
|LITEPACK_P2|Office 365 Small Business Premium||
|SPE_E3|MICROSOFT 365 E3|OfficeWeb, OfficeMobile; EXO (OL,OWA,OM 2G Mbx)||
|SPE_E5|MICROSOFT 365 E5||
"@ ;
    $ExMbxLicenses = $ExMbxLicensesTbl | convertfrom-markdowntable ;

    # building a CustObj (actually an indexed hash) with the default quota specs from all db's. The 'index' for each db, is the db's Name (which is also stored as Database on the $mbx)
    $smsg = "(converting $(($ExMbxLicenses|measure).count) UserMailbox-supporting o365 Licenses to indexed hash)" ;     
    if($verbose){
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    } ; 
    if($host.version.major -gt 2){$hExMbxLicenses = [ordered]@{} } 
    else { $hExMbxLicenses = @{} } ;
    
    $ttl = ($ExMbxLicenses|measure).count ; $Procd = 0 ; 
    foreach ($Sku in $ExMbxLicenses){
        $Procd ++ ; 
        $sBnrS="`n#*------v PROCESSING : ($($Procd)/$($ttl)) $($Sku.SKU) v------" ; 
        $smsg = $sBnrS ; 
        if($verbose){
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
        
        $name =$($Sku | select -expand SKU) ; 
        $hExMbxLicenses[$name] = $Sku ; 

        $smsg = "$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
        if($verbose){
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
    } ;  # loop-E

    if($hExMbxLicenses){
        $smsg = "(Returning summary objects to pipeline)" ; 
        if($verbose){
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
        $hExMbxLicenses | Write-Output ; 
    } else {
        $smsg = "NO RETURNABLE `$hExMbxLicenses OBJECT!" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        THROW $smsg ;
    } ; 
}

#*------^ get-ExoMailboxLicenses.ps1 ^------


#*------v get-EXOMsgTraceDetailed.ps1 v------
function get-EXOMsgTraceDetailed {
    <#
    .SYNOPSIS
    get-EXOMsgTraceDetailed.ps1 - Run a MessageTrace with output summarizing, export to csv, and optional followup with MessageTraceDetail, summarize (expand TransportRules opt), and export to csv
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-11-05
    FileName    : get-EXOMsgTraceDetailed.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-mod
    Tags        : Powershell,Exchange,ExchangeOnline,Tracking,Delivery
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 4:38 PM 1/24/2022 retooled start/enddateto convert 'local tz' inputs, to t 
        GMT/UTC; and track/convert content back to local time ; added testing of 
        msgtrace splat params, only when populated ;  updated CBH & Examples (covering 
        variant formats of booking response msgs); converted hash summary output to 
        psobject ; ren -doMTD -> -Detailed ; validate $days is a positive integer;
        swapped strings with new central constants: $sFulltimeStamp, $sFiletimestamp
    * 4:04 PM 11/19/2021 flipped wh,wv,ww to wlt - added -days ; updated logic testing for dates/days against MS 10d limit (stored as new constant) ; checks out functional; needs 7pswlt rplcments of write-*
    * 12:40 PM 11/15/2021 - expanded subject -match/-like to post test and use the opposing option where the detected failed to yield filtered msgs. 
    * 3:46 pm 11/12/2021 - added -Subject test-IsRegexPattern() and autoflip tween -match & -like post filtering. 
    * 2:37 PM 11/5/2021 init
    .DESCRIPTION
    get-EXOMsgTraceDetailed.ps1 - Run a MessageTrace with output summarizing, export to csv, and optional followup with MessageTraceDetail, summarize (expand TransportRules opt), and export to csv
    
    This function wraps the EXO get-MessageTrace & get-MessageTraceDetail, to run structured message traces with export to CSV, optional follow-on Get-MessageTraceDetail, post-filtering on specified Subject, and outputs a summary hashtable object with the following:

    Returns summary object to pipeline, with following properties:
    [obj].MTMessages: MessageTracking messages matched
    [obj].MTMessagesCSVFile full path to exported MTMessages as csv file
    [obj].MTDetails: MessageTrackingDetail refactored summary of MTD as transactions
    [obj].MTDCSVFile: full path to exported MTDs as csv file 
    [obj].MTDReport: expanded Detail summary output
    [obj].MTDRptCSVFile: full path to exported MTDReport as csv file 
    > Note: As of 4/2021, MS wrecked utility of get-MessageTrace, dropping range from 30 days to 10 days, with silent failure to return -gt 10d (not even a range error). 
    > So there's not a lot of utility to supporting -Enddate (date) -Days 11, to pull historical 11day windows: If it's more than 10d old, you've got to use HistSearch regardless. 

    .PARAMETER ticket
    Ticket [-ticket 999999]
    .PARAMETER SenderAddress
    SenderAddress[-SenderAddress addr@domain.com]
    .PARAMETER RecipientAddress
    RecipientAddress [-RecipientAddress addr@domain.com]
    .PARAMETER StartDate
    Start of range to be searched[-StartDate '11/5/2021 2:16 PM
    .PARAMETER EndDate
    End of range to be searched (defaults to current time if unspecified)[-EndDate '11/5/2021 5:16 PM']
    .PARAMETER subject
    Subject of target message [-Subject 'Some subject']
    .PARAMETER MessageId
    MessageId of target message [-MessageId '[messageid string]']
    .PARAMETER MessageTraceId
    MessageTraceId of target message [-MessageTraceId '[MessageTraceId string]']
    .PARAMETER MessageTraceDetailLimit
    Integer number of maximum messages to be follow-up MessageTraceDetail'd [-MessageTraceDetailLimit 20]
    .PARAMETER doMTDReportRuleHits
    switch to do Summarize & Expansion of any MTD TransportRule events (defaults true) [-doMTDReportRuleHits]
    .PARAMETER Detailed
    switch to perform MessageTrackingDetail pass, after intial MessageTrace (up to limti specified in -MessageTraceDetailLimit (defaults true) [-Detailed]
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    None. Returns no objects or output (.NET types)
    .EXAMPLE
    PS> $results = get-EXOMsgTraceDetailed.ps1 -ticket 651268 -SenderAddress='SENDER@DOMAIN.COM' -RecipientAddress='RECIPIENT@DOMAIN.COM' -StartDate='11/1/2021  4:35:39 PM' -Subject 'Accepted: Exmark/RLC Bring Up' -verbose ;
    # dump messages table and group Status
    $results.MTMessages | ft -a ReceivedLocal,Sender*,Recipient*,subject,*status,*ip ;
    $results.MTMessages | group status | ft -auto count,name ;
    # dump MessageTraceDetail table
    $results.MTDetails | sort Date | ft -a date,event,action,detail,sender*,recipient* ;
    # dump MessageTraceDetail Summary Report as table
    $results.MTDReport| sort date | ft -a DateLocal,Event,Action,Detail ;
    # echo csv output files
    $results.MTMessagesCSVFile ;
    $results.MTDRptCSVFile ;
    Run a typical MessageTrace on sender & recipient, specified start/end dates, and subject, with default 100-message MessageTraceDetail report, with verbose output.
    And then demo of working with the data returned
    .EXAMPLE
    PS> $results = get-EXOMsgTraceDetailed.ps1 -ticket 651268 -SenderAddress='ATTENDEE@DOMAIN.COM' -RecipientAddress='ORGANIZER@DOMAIN.COM' -StartDate='11/1/2021  4:35:39 PM' -Subject 'Accepted: [MEETINGSUBJ]' -verbose ;
    Run a Meeting ACCEPTED MessageTrace - 
        no booking conflict, 
        From: Attendee To: Originator
        Subject: 'Accepted: [MEETINGSUBJ]'
    - with default 100-message MessageTraceDetail report, with verbose output.
    .EXAMPLE
    PS> $results = get-EXOMsgTraceDetailed.ps1 -ticket 651268 -SenderAddress='ROOM@DOMAIN.COM' -RecipientAddress='ORGANIZER@DOMAIN.COM' -StartDate='11/1/2021  4:35:39 PM' -Subject 'Declined: [MEETINGSUBJ]' -verbose ;
    Run a Meeting DECLINED MessageTrace - 
         Booking conflict, 
         From: Room, To: Originator (and copy to any SendOnBehalf delegate that actually created the meeting)
         Subject is: 'Declined: [MEETINGSUBJ]'
    - with default 100-message MessageTraceDetail report, with verbose output.
    .EXAMPLE
    PS> $results = get-EXOMsgTraceDetailed.ps1 -ticket 651268 -SenderAddress='ROOM@DOMAIN.COM' -RecipientAddress='ORGANIZER@DOMAIN.COM' -StartDate='11/1/2021  4:35:39 PM' -Subject 'Tentative: [MEETINGSUBJ]' -verbose ;
    Run a Meeting TENTATIVE response (Moderated resource), MessageTrace, - 
        reflects a AllRequestinPolicy:`$true resource ;
        w ResourceDelegates; 
        no booking conflict;
        but pending ResDelegate approval
        From: Room, To: Originator (and copy to any SendOnBehalf delegate that actually created the meeting)
        Subject is: 'Tentative: [MEETINGSUBJ]'
     -  with default 100-message MessageTraceDetail report, with verbose output. 
    .EXAMPLE
    PS> $results = get-EXOMsgTraceDetailed.ps1 -ticket 651268 -SenderAddress='ORGANIZER@DOMAIN.COM' -RecipientAddress='RESDELEGATE@DOMAIN.COM' -StartDate='11/1/2021  4:35:39 PM' -Subject 'FW: [MEETINGSUBJ]' -verbose ;
    Run a Meeting 'FW: [MEETINGSUBJ]' MODERATION REQUEST MessageTrace - 
        TO: ResourceDelegates (redirected Forward) FROM: ORGANIZER
        reflects a Resource with: AllRequestinPolicy:`$true; 
        ResourceDelegates configured; 
        no booking conflict, but pending ResDelegate approval 
    - MessageTrace (which will come from Meeting Originator email address), to the ResDelegate addresses, with default 100-message MessageTraceDetail report, with verbose output.
    .LINK
    https://docs.microsoft.com/en-us/powershell/module/exchange/get-messagetrace
    .LINK
    https://docs.microsoft.com/en-us/powershell/module/exchange/get-messagetracedetail
    .LINK
    https://github.com/tostka/verb-exo
    #>
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\sregex\sexpr")][ValidateSet("US","GB","AU")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)]#positiveInt:[ValidateRange(0,[int]::MaxValue)]#negativeInt:[ValidateRange([int]::MinValue,0)][ValidateCount(1,3)]
    [CmdletBinding(DefaultParameterSetName='Days')]
    PARAM(
        [Parameter(Mandatory=$True,HelpMessage="Ticket [-ticket 999999]")]
        [ValidateNotNullOrEmpty()]    
        [string]$ticket,
        [Parameter(HelpMessage="SenderAddress[-SenderAddress addr@domain.com]")]
        [string]$SenderAddress,
        [Parameter(HelpMessage="RecipientAddress [-RecipientAddress addr@domain.com]")]
        [string]$RecipientAddress,
        [Parameter(ParameterSetName='Dates',HelpMessage="Start of range to be searched[-StartDate '11/5/2021 2:16 PM']")]
        [string]$StartDate,
        [Parameter(ParameterSetName='Dates',HelpMessage="End of range to be searched (defaults to current time if unspecified)[-EndDate '11/5/2021 5:16 PM']")]
        [string]$EndDate=(get-date),
        [Parameter(ParameterSetName='Days',HelpMessage="Days to be searched, back from current time(Alt to use of StartDate & EndDate)[-Days 7]")]
        [ValidateRange(0,[int]::MaxValue)]
        [int]$Days,
        [Parameter(HelpMessage="Subject of target message [-Subject 'Some subject']")]
        [string]$subject,
        [Parameter(HelpMessage="MessageId of target message [-MessageId '[messageid string]']")]
        [string]$MessageId,
        [Parameter(HelpMessage="MessageTraceId of target message [-MessageTraceId '[MessageTraceId string]']")] 
        [string]$MessageTraceId,
        [Parameter(HelpMessage="Integer number of maximum messages to be follow-up MessageTraceDetail'd [-MessageTraceDetailLimit 20]")]
        [int]$MessageTraceDetailLimit = 100,
        [Parameter(HelpMessage="switch to do Summarize & Expansion of any MTD TransportRule events (defaults true) [-DetailedReportRuleHits]")]
        [switch]$DetailedReportRuleHits= $true,
        [Parameter(HelpMessage="switch to perform MessageTrackingDetail pass, after intial MessageTrace (up to limti specified in -MessageTraceDetailLimit (defaults true) [-Detailed]")]
        [switch]$Detailed=$true
    ) ;
    <# #-=-=-=MUTUALLY EXCLUSIVE PARAMS OPTIONS:-=-=-=-=-=
# designate a default paramset, up in cmdletbinding line
[CmdletBinding(DefaultParameterSetName='SETNAME')]
  # * set blank, if none of the sets are to be forced (eg optional mut-excl params)
  # * force exclusion by setting ParameterSetName to a diff value per exclusive param

# example:single $Computername param with *multiple* ParameterSetName's, and varying Mandatory status per set
    [Parameter(ParameterSetName='LocalOnly', Mandatory=$false)]
    $LocalAction,
    [Parameter(ParameterSetName='Credential', Mandatory=$true)]
    [Parameter(ParameterSetName='NonCredential', Mandatory=$false)]
    $ComputerName,
    # $Credential as tied exclusive parameter
    [Parameter(ParameterSetName='Credential', Mandatory=$false)]
    $Credential ;    
    # effect: 
    -computername is mandetory when credential is in use
    -when $localAction param (w localOnly set) is in use, neither $Computername or $Credential is permitted
    write-verbose -verbose:$verbose "ParameterSetName:$($PSCmdlet.ParameterSetName)"
    Can also steer processing around which ParameterSetName is in force:
    if ($PSCmdlet.ParameterSetName -eq 'LocalOnly') {
        return "some localonly stuff" ; 
    } ;     
#-=-=-=-=-=-=-=-=
#>
    BEGIN{
        # get-EXOMsgTraceDetailed.ps1 -ticket 651268 -SenderAddress='SENDER@exmark.com' -RecipientAddress='RECIPIENT@domain.com' -StartDate='11/1/2021  4:35:39 PM' -Subject 'Accepted: [MTGSUBJECT]';
        <#$ticket = '651268' ;
        $subject = 'Accepted: Exmark/RLC Bring Up' ;
        $MessageId=$null ; 
        $MessageTraceId=$null ; 
        $Detailed=$true ;
        $MessageTraceDetailLimit = 100 ; 
        $DetailedReportRuleHits= $true ;
        #>

        $propsMT = @{N='ReceivedLocal';E={$_.Received.ToLocalTime()}},'SenderAddress','RecipientAddress','Subject','Status','ToIP','FromIP','Size','MessageId','MessageTraceId','Index' ;
        # setup a refactor of Receivedlocal on Received, but return *all* properties
        $propsMTAll = 'RunspaceId','Organization','MessageId','Received', @{N='ReceivedLocal';E={$_.Received.ToLocalTime()}},'SenderAddress','RecipientAddress','Subject','Status','ToIP','FromIP','Size','MessageTraceId','StartDate','EndDate','Index'
        #$propsMTD = 'Date','Event','Action','Detail','Data' ;
        # add a locatltime variant
        $propsMTD = @{N='DateLocal';E={$_.Date.ToLocalTime()}},'Date','Event','Action','Detail','Data' ;

        $propsMsgDump = @{N='ReceivedLocal';E={$_.Received.ToLocalTime()}},'Status','SenderAddress','RecipientAddress','Subject' ;
        $DaysLimit = 10 # reflect the current MS get-messagetrace window limit
        $sFulltimeStamp = 'MM/dd/yyyy-HH:mm:ss.fff' ;
        $sFiletimestamp = 'yyyyMMdd-HHmmtt' ;

        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        # Get parameters this function was invoked with
        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
        $Verbose = ($VerbosePreference -eq 'Continue') ; 
        if ($PSScriptRoot -eq "") {
            if ($psISE) { $ScriptName = $psISE.CurrentFile.FullPath } 
            elseif ($context = $psEditor.GetEditorContext()) {$ScriptName = $context.CurrentFile.Path } 
            elseif ($host.version.major -lt 3) {
                $ScriptName = $MyInvocation.MyCommand.Path ;
                $PSScriptRoot = Split-Path $ScriptName -Parent ;
                $PSCommandPath = $ScriptName ;
            } else {
                if ($MyInvocation.MyCommand.Path) {
                    $ScriptName = $MyInvocation.MyCommand.Path ;
                    $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                } else {throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" } ;
            };
            $ScriptDir = Split-Path -Parent $ScriptName ;
            $ScriptBaseName = split-path -leaf $ScriptName ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($ScriptName) ;
        } else {
            $ScriptDir = $PSScriptRoot ;
            if ($PSCommandPath) {$ScriptName = $PSCommandPath } 
            else {
                $ScriptName = $myInvocation.ScriptName
                $PSCommandPath = $ScriptName ;
            } ;
            $ScriptBaseName = (Split-Path -Leaf ((& { $myInvocation }).ScriptName))  ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
        } ;
        if ($showDebug) { 
            $smsg = "`$ScriptDir:$($ScriptDir)`n`$ScriptBaseName:$($ScriptBaseName)`n`$ScriptNameNoExt:$($ScriptNameNoExt)`n`$PSScriptRoot:$($PSScriptRoot)`n`$PSCommandPath:$($PSCommandPath)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;
        $ComputerName = $env:COMPUTERNAME ;
        $NoProf = [bool]([Environment]::GetCommandLineArgs() -like '-noprofile'); # if($NoProf){# do this};
        # silently stop any running transcripts
        $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ; 

        # #*------v STANDARD START-LOG BP v------
       if(!(get-variable LogPathDrives -ea 0)){$LogPathDrives = 'd','c' };
        foreach($budrv in $LogPathDrives){if(test-path -path "$($budrv):\scripts" -ea 0 ){break} } ;
        if(!(get-variable rgxPSAllUsersScope -ea 0)){
            $rgxPSAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\
        .*\.(ps(((d|m))*)1|dll)$" ;
        } ;
        if(!(get-variable rgxPSCurrUserScope -ea 0)){
            $rgxPSCurrUserScope="^$([regex]::escape([Environment]::GetFolderPath('MyDocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.
        *\.(ps((d|m)*)1|dll)$" ;
        } ;
        $pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ;
        whatif=$($whatif) ;} ;
        $pltSL.Tag = $Ticket ;
        if($script:PSCommandPath){
            if(($script:PSCommandPath -match $rgxPSAllUsersScope) -OR ($script:PSCommandPath -match $rgxPSCurrUserScope)){
                $bDivertLog = $true ;
                switch -regex ($script:PSCommandPath){
                    $rgxPSAllUsersScope{$smsg = "AllUsers"}
                    $rgxPSCurrUserScope{$smsg = "CurrentUser"}
                } ;
                $smsg += " context script/module, divert logging into [$budrv]:\scripts"
                write-verbose $smsg  ;
                if($bDivertLog){
                    if((split-path $script:PSCommandPath -leaf) -ne $cmdletname){
                        # function in a module/script installed to allusers|cu - defer name to Cmdlet/Function name
                        $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
                    } else {
                        # installed allusers|CU script, use the hosting script name
                        $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $script:PSCommandPath -leaf)) ;
                    }
                } ;
            } else {
                $pltSL.Path = $script:PSCommandPath ;
            } ;
        } else {
            if(($MyInvocation.MyCommand.Definition -match $rgxPSAllUsersScope) -OR ($MyInvocation.MyCommand.Definition -match
        $rgxPSCurrUserScope) ){
                 $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $script:PSCommandPath -leaf)) ;
            } elseif(test-path $MyInvocation.MyCommand.Definition) {
                $pltSL.Path = $MyInvocation.MyCommand.Definition ;
            } elseif($cmdletname){
                $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
            } else {
                $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$CMDLETNAME, FROM WHICH TO BUILD A START-LOG.PATH!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                BREAK ;
            } ;
        } ;
        write-verbose "start-Log w`n$(($pltSL|out-string).trim())" ;
        $logspec = start-Log @pltSL ;
        $error.clear() ;
        TRY {
            if($logspec){
                $logging=$logspec.logging ;
                $logfile=$logspec.logfile ;
                $transcript=$logspec.transcript ;
                $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                # capture the start or it dumps into pipe
                $startResults = start-Transcript -path $transcript ;
            } else {throw "Unable to configure logging!" } ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details:
        $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ;
        #*------^ END STANDARD START-LOG BP ^------

        if ($PSCmdlet.ParameterSetName -eq 'Dates') {
            if($EndDate -and -not $StartDate){
                $StartDate = (get-date $EndDate).addDays(-1 * $DaysLimit) ; 
            } ; 
            
        } else {
            if (-not $Days) {
                $StartDate = (get-date $EndDate).addDays(-1 * $DaysLimit) ; 
                $smsg = "No Days, StartDate or EndDate specified. Defaulting to $($DaysLimit)day Search window:$((get-date).adddays(-1 * $DaysLimit))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $EndDate = (get-date) ;
                $StartDate = (get-date $EndDate).addDays(-1 * $Days) ; 
                $smsg = "-Days:$($Days) specified: "
                #$smsg += "calculated StartDate:$((get-date $StartDate -format $sFulltimeStamp ))" ; 
                #$smsg += ", calculated EndDate:$((get-date $EndDate -format $sFulltimeStamp ))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #(get-date -format $sFiletimestamp);
            } ; 
        } ;

        $smsg = "(converting `$StartDate & `$EndDate to UTC, using input as `$StartLocal & `$EndLocal)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

        # convert dates to GMT .ToUniversalTime(
        $StartDate = ([datetime]$StartDate).ToUniversalTime() ; 
        $EndDate = ([datetime]$EndDate).ToUniversalTime() ; 
        $StartLocal = ([datetime]$StartDate).ToLocalTime() ; 
        $EndLocal = ([datetime]$EndDate).ToLocalTime() ; 
        
        # sanity test the start/end dates, just in case (won't throw an error in gxmt)
        if($StartDate -gt $EndDate){
            $smsg = "`-StartDate:$($StartDate) is GREATER THAN -EndDate:($EndDate)!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            throw $smsg ; 
            break ; 
        } ; 

        $smsg = "`$StartDate:$(get-date -Date $StartLocal -format $sFulltimeStamp )" ;
        $smsg += "`n`$EndDate:$(get-date -Date $EndLocal -format $sFulltimeStamp )" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

        if((New-TimeSpan -Start $StartDate -End (get-date)).days -gt $DaysLimit){
            $smsg = "Search span (between -StartDate & -EndDate, or- Days in use) *exceeds* MS supported days history limit!`nReduce the window below a historical 10d, or use get-HistoricalSearch instead!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            Break ; 
        } ; 

    }  # BEG-E
    PROCESS {

        # default StartDate to -10 can't do more
        $pltMsgT=[ordered]@{
          #SenderAddress=$SenderAddress;
          #RecipientAddress=$RecipientAddress;
          #StartDate=(get-date $StartDate);
          #StartDate= $StartDate;
          #EndDate=(get-date $EndDate);
          #EndDate=$EndDate;
          Page= 1 ; # default it to 1 vs $null as we'll be purging empties further down
          ErrorAction = 'STOP' ;
          verbose = $($VerbosePreference -eq "Continue") ;
        } ;
        # throwing errors using unpopulated, so add them conditionally 

        $ofile ="$($ticket)-MsgTrc" ;
        if($SenderAddress){
            $pltMsgT.add('SenderAddress',$SenderAddress) ;
            $ofile+=",From-$($pltMsgT.SenderAddress.replace("*","ANY"))" 
        } ;
        if($RecipientAddress){
            $pltMsgT.add('RecipientAddress',$RecipientAddress) ;
            $ofile+=",To-$($pltMsgT.RecipientAddress.replace("*","ANY"))" ;
        } ;
        if($MessageId){
            $pltMsgT.add('MessageId',$MessageId) ; 
            $ofile+=",MsgId-$($pltMsgT.MessageId.replace('<','').replace('>',''))" ;
        } ;
        if($MessageTraceId){
            $pltMsgT.add('MessageTraceId',$MessageTraceId) ; 
            $ofile+=",MsgId-$($pltMsgT.MessageTraceId.replace('<','').replace('>',''))"  ;
        } ;
        if($subject){
            $ofile+=",Subj-$($subject.substring(0,[System.Math]::Min(15,$subject.Length)))..." 
        } ;
        if($StartDate){
            $pltMsgT.add('StartDate',$StartDate) ; 
            $ofile+= "-$(get-date $pltMsgT.StartDate -format $sFiletimestamp)-"  ;
        } ;
        if($EndDate){
            $pltMsgT.add('EndDate',$EndDate) ; 
            $ofile+= "$(get-date $pltMsgT.EndDate -format $sFiletimestamp)" ;
        } ;
        $ofile=[RegEx]::Replace($ofile, "[{0}]" -f ([RegEx]::Escape(-join [System.IO.Path]::GetInvalidFileNameChars())), '') ;
        # use the tested redirected $logfile path
        #$ofile = join-path -path (split-path $logfile) -ChildPath $ofile ; 
        $hReports = [ordered]@{} ; 
        rxo ;
        $error.clear() ;
        TRY {
            # prepurge empty hash value keys:
            #$pltMsgT=$pltMsgT.GetEnumerator()|? value ;
            # remove null keyed objects
            #$pltMsgT | Foreach {$p = $_ ;@($p.GetEnumerator()) | ?{ ($_.Value | Out-String).length -eq 0 } | Foreach-Object {$p.Remove($_.Key)} ;} ;
            # skip it, we're only adding populated items now
            #write-verbose "hashtype:$($pltmsgt.GetType().FullName)" ; 
            # and issue was first untested negative integer -Days; and 2nd GMT window for start/enddate, so the 'local' input needs to be converted to/from gmt to get the targeted content.

            $smsg = "Get-exoMessageTrace  w`n$(($pltMsgT|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            $Page = 1  ;
            $Msgs=$null ;
            do {
                $smsg = "Collecting - Page $($Page)..."  ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $pltMsgT.Page=$Page ;
                $PageMsgs = Get-exoMessageTrace @pltMsgT |  ?{$_.SenderAddress -notlike '*micro*' -or $_.SenderAddress -notlike '*root*' }  ;
                $Page++  ;
                $Msgs += @($PageMsgs)  ;
            } until ($PageMsgs -eq $null) ;
            $Msgs=$Msgs| Sort Received ;
            $smsg = "Raw sender/recipient Msgs:$(($Msgs|measure).Count)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            if($subject){
                $smsg = "Post-Filtering on Subject:$($subject)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                # detect whether to filter on -match (regex) or -like (asterisk, or default non-regex)
                if(test-IsRegexPattern -string $subject -verbose:$($VerbosePreference -eq "Continue")){
                    $smsg = "(detected -subject as regex - using -match comparisonn)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $MsgsFltrd = $Msgs | ?{$_.Subject -match $subject} ;
                    if(-not $MsgsFltrd){
                        $smsg = "Subject: regex -match comparison *FAILED* to return matches`nretrying Subject filter as -Like..." ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $MsgsFltrd = $Msgs | ?{$_.Subject -like $subject} ;
                    } ; 
                } else { 
                    $smsg = "(detected -subject as NON-regex - using -like comparison)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $MsgsFltrd = $Msgs | ?{$_.Subject -like $subject} ;
                    if(-not $MsgsFltrd){
                        $smsg = "Subject: -like comparison *FAILED* to return matches`nretrying Subject filter as -match..." ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $MsgsFltrd = $Msgs | ?{$_.Subject -match $subject} 
                    } ; 
                } ; 
                $smsg = "Post Subj filter matches:$(($MsgsFltrd|measure).Count)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $msgs = $MsgsFltrd ; 
            } ;
            $ofile+= "-r$(get-date -format $sFiletimestamp).csv" ;
            $ofile = (split-path $ofile -leaf) # can't fix a full path, just the leaf name, then re-path
            $ofile=[RegEx]::Replace($ofile, "[{0}]" -f ([RegEx]::Escape(-join [System.IO.Path]::GetInvalidFileNameChars())), '') ;
            #$ofile=".\logs\$($ofile)" ;
            #$ofile=(join-path -path (split-path $logfile) -childpath "logs\$($ofile)") ;
            $ofile=(join-path -path (split-path $logfile) -childpath $ofile) ;
            if($Msgs){
                # reselect with local time variant
                $Msgs = $Msgs | select $propsMTAll ; 
                $smsg = "($(($Msgs|measure).count)msgs | export-csv $($ofile))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $Msgs | select $propsMT | export-csv -notype -path $ofile  ;
                $smsg = "(adding `$hReports.MTMessages)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $hReports.add('MTMessages',$msgs) ; 

                # add the csvfilename
                $smsg = "(adding `$hReports.MTMessagesCSVFile:$($ofile))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $hReports.add('MTMessagesCSVFile',$ofile) ; 

                $smsg = "Status Distrib:" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $smsg = "`n#*------v MOST RECENT MATCH v------" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $smsg = "$(($msgs[-1]| fl $propsMsgDump |out-string).trim())";
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $smsg = "`n#*------^ MOST RECENT MATCH ^------" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $smsg = "`n#*------v Status DISTRIB v------" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $smsg = "$(($Msgs | select -expand Status | group | sort count,count -desc | select count,name|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $smsg = "`n#*------^ Status DISTRIB ^------" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                if(test-path -path $ofile){
                    $smsg = "(log file confirmed)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    Resolve-Path -Path $ofile | select -expand Path | out-clipboard ;
                    $smsg = "$($Msgs.count) matches output to:`n'$($ofile)'`n(copied to CB)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                } else { "MISSING MsgTrc LOG FILE!" } ;
                if($Detailed){
                    if($msgs.count -gt $MessageTraceDetailLimit){
                        $smsg = "$($msgs.count) EXCEEDS `$MessageTraceDetailLimit:$($MessageTraceDetailLimit)!.`nget-MTD'ing only most recent $($MessageTraceDetailLimit) msgs...!"
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        $mtdmsgs = $msgs | select -last $MessageTraceDetailLimit ; 
                    } else { $mtdmsgs = $msgs }  ; 
                    $smsg = "`n[$(($msgs|measure).count)msgs]|=>Get-exoMessageTraceDetail:" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                    $mtds = $mtdmsgs | Get-exoMessageTraceDetail ;

                    $mtdRpt = @() ; 
                    if($DetailedReportRuleHits){
                        $TRules = get-exotransportrule  ; 
                        $smsg = "Checking for `$mtds|`?{$_.Event -eq 'Transport rule'}:" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    } ; 
                    foreach($mtd in $mtds){
                        $mtdsummary = [ordered]@{
                            Date = $mtd.Date ; 
                            DateLocal = ([datetime]$mtd.Date).ToLocalTime() ; 
                            Event = $mtd.Event ;
                            Action = $mtd.Action ;
                            Detail = $mtd.Detail ;
                            TRuleName = $null ; 
                            TRuleDetails = $null ; 
                        } ; 
                        if($DetailedReportRuleHits){
                            if ($mtd| ?{$_.Event -eq 'Transport rule'}){
                                # $smsg = "`n$(($mtd | fl Date,Event,Action,Detail |out-string).trim())" ; 
                                if($mtd.detail -match "Transport\srule:\s'',\sID:\s\('(\w{8}-\w{4}-\w{4}-\w{4}-\w{12})'\)"){
                                    #$smsg = "$(($trules|?{$_.guid -eq $matches[1]}  | format-list Name,State,Priority|out-string).trim())" ; 
                                    $ruledetail = $trules|?{$_.guid -eq $matches[1]}  | select Name,Guid,State,Priority ; 
                                    $mtdsummary.TRuleName = $ruledetail.Name ; 
                                    $mtdsummary.TRuleDetails = $ruledetail ; 
                                } ; 
                                $smsg = "`n$(($mtdsummary| fl Date,Event,Action,Detail,TRuleName |out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            } ; 
                        } else {
                            $smsg = "`n$(($mtdsummary| fl Date,Event,Action,Detail|out-string).trim())" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        }  ;
   
                        $mtdRpt += [pscustomobject]$mtdsummary ; 
                    } ; 
                
                    if($mtds){
                        $ofileMTD = $ofile.replace('-MsgTrc','-MTD') ;
                        $smsg = "($(($mtds|measure).count)mtds | export-csv $($ofileMTD))" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        $mtds | select $propsMTD | export-csv -notype -path $ofileMTD  ;

                        if(test-path -path $ofileMTD){
                            $smsg = "(log file confirmed)" ;
                            $smsg += "`n$($mtds.count) MTD matches output to:`n'$($ofileMTD)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                        } else { write-warning "MISSING MTD LOG FILE!" } ;
                        $hReports.add('MTDetails',$mtds) ; 

                        <# add the csvfilename
                        $smsg = "(adding `$hReports.MTDCSVFile:$($ofileMTD))" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        $hReports.add('MTDCSVFile',$MTDCSVFile) ; 
                        #>
                        #$hReports.add('MTDReport',$ofileMTD) ; 
                        # mtdreport
                        $hReports.add('MTDReport', $mtdRpt) ; 
                        $ofileMTDRpt = $ofile.replace('-MsgTrc','-MTDRpt') ;
                        $mtdRpt | export-csv -notype -path $ofileMTDRpt  ;
                        if(test-path -path $ofileMTD){
                            $smsg = "(log file confirmed)" ;
                            $smsg += "`n$($mtdRpt.count) MTDReport matches output to:`n'$($ofileMTDRpt)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            # add the csvfilename
                            $smsg = "(adding `$hReports.MTDRptCSVFile:$($ofileMTDRpt))" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            $hReports.add('MTDRptCSVFile',$ofileMTDRpt) ; 

                        } else { 
                            $smsg = "MISSING MTD LOG FILE!" 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        } ;
                   } ;
                } ;
            } else {
                $smsg = "NO MATCHES FOUND from::`n$(($pltMsgT|out-string).trim()|out-default)`n(with any relevant ConnectorId postfilter)" 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            } ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ; 

        
    } ;  # PROC-E
    END {
        # convert the hashtable to object for output to pipeline
        $Rpt += New-Object PSObject -Property $hReports ;
        $smsg = "(Returning summary object to pipeline)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        $Rpt | Write-Output ; 
    } ; 
}

#*------^ get-EXOMsgTraceDetailed.ps1 ^------


#*------v get-MailboxFolderStats.ps1 v------
function get-MailboxFolderStats {
    <#
    .SYNOPSIS
    get-MailboxFolderStats.ps1 - Perform smart get-mailboxfolderstatistics command, as appropriate to target location -Mailbox, on either Exchange on-premesis or Exchange Online.
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-03-12
    FileName    : get-MailboxFolderStats
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Mailbox,Statistics,Reporting
    REVISIONS
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    # 12:17 PM 5/14/2021 updated passstatus code to curr, and added -ea to the gv's (suppress errors when not present)
    * 11:54 AM 4/2/2021 updated wlt & recstat support, updated catch blocks
    * 3:28 PM 3/16/2021 added multi-tenant support
    * 1:12 PM 3/15/2021 init work was done 3/12, removed recursive-err generating #Require on the hosting verb-EXO module
    .DESCRIPTION
    get-MailboxFolderStats.ps1 - Perform smart get-mailboxfolderstatistics command, as appropriate to target location -Mailbox, on either Exchange on-premesis or Exchange Online.
    Dependancy on my verb-ex2010 Exchange onprem (and is within verb-exo EXO mod, which adds dependant EXO connection support).
    .PARAMETER TenOrg
    TenantTag values, indicating Tenant to Create DDG WITHIN[-TenOrg 'TOL']    
    .PARAMETER  Mailbox
    Mailbox identifier [samaccountname,name,emailaddr,alias]
    .PARAMETER Ticket
    Ticket # [-Ticket nnnnn]
    .PARAMETER IncludeAge
    Switch to include Oldest/Newest message per folder information[-IncludeAge]
    .PARAMETER IncludeSize
    Switch to include aggregate size of each folder [-IncludeSize]
    .PARAMETER NonEmptyOnly
    Switch to display infor for only non-zero content folders (defaults `$true)[-NonEmptyOnly]
    .INPUTS
    Accepts piped input.
    .OUTPUTS
    Outputs csv & console summary of mailbox folders content
    .EXAMPLE
    get-MailboxFolderStats -Mailbox quotes@domain.com -Ticket 99999 -includeage -verbose ;
    Perform a mailbox stats summary report query, on the specified mailbox, and include specified ticket# in output csv (which is output below .\logs\ dir of current directory at runtime).
    .EXAMPLE
    $report = get-MailboxFolderStats -Mailbox quotes@domain.com -Ticket 99999 -includeage -asobject ;
    Return an object for the summary report, rather than console dump (in addition to csv export)
    .EXAMPLE
    get-MailboxFolderStats -Mailbox quotes@domain.com -Ticket 347298 -includeage -includesize ;
    Perform a mailbox stats, and include size per folder (in KB) in output report
    .LINK
    https://github.com/tostka/verb-exo
    .LINK
    https://github.com/tostka/verb-ex2010
    #>
    #Requires -Version 3
    ##Requires -Modules verb-ex2010
    # 2:49 PM 3/8/2022 pull verb-ex2010 ref - I think it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag values, indicating Tenant to Create DDG WITHIN[-TenOrg 'TOL']")]
        [ValidateNotNullOrEmpty()]
        [string]$TenOrg = ('TOR'),
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Mailbox identifier [samaccountname,name,emailaddr,alias]")]
        [ValidateNotNullOrEmpty()][string]$Mailbox,    
        [Parameter(Mandatory=$false,HelpMessage="Ticket # [-Ticket nnnnn]")]
        #[ValidateLength(5)] # non-mandatory
        [int]$Ticket,
        [Parameter(HelpMessage="Switch to include Oldest/Newest message per folder information[-IncludeAge]")]
        [switch] $IncludeAge,
        [Parameter(HelpMessage="Switch to include aggregate size of each folder [-IncludeSize]")]
        [switch] $IncludeSize,
        [Parameter(HelpMessage="Switch to display info for only non-zero content folders (defaults `$true)[-NonEmptyOnly]")]
        [switch] $NonEmptyOnly=$true,
        [Parameter(HelpMessage="Switch to return raw object rather than formated console report(defaults `$true)[-NonEmptyOnly]")]
        [switch] $asObject
    ) ;
    BEGIN {
        $Verbose=($VerbosePreference -eq 'Continue') ;  
        # Get parameters this function was invoked with
        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;  
        $pltGMFS=@{identity= $Mailbox ;} ; 
        $propsFldr = @{Name='Folder';Expression={$_.Identity.tostring()}},@{Name="Items";Expression={$_.ItemsInFolder}} ;
        $rgxSysFldrs = '.*\\(Versions|SubstrateHolds|DiscoveryHolds|Yammer.*|Social\sActivity\sNotifications|Suggested\sContacts|Recipient\sCache|PersonMetadata|Audits|Calendar\sLogging|Purges)$' ; 
        if($IncludeAge){ 
            $pltGMFS.add('IncludeOldestAndNewestItems',$true) ; 
            $propsFldr += @{Name="OldestItem";Expression={get-date $_.OldestItemReceivedDate}},@{Name="NewestItem";Expression={$_.NewestItemReceivedDate}} ; 
        } ;
        if($IncludeSize){ 
            $pltGMFS.add('IncludeAnalysis',$true) ; 
            # w dehydrated, raw parsing is: $mbxstats.TotalItemSize.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB ;
            $propsFldr += @{Name="SizeMB";Expression={[math]::round($_.FolderSize.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}} ; 
        } ;

        $Retries = 4 ;
        $RetrySleep = 5 ;
        if(!$ThrottleMs){$ThrottleMs = 50 ;}
        $CredRole = 'CSVC' ; # role of svc to be dyn pulled from metaXXX if no -Credential spec'd, 
        if(!$rgxDriveBanChars){$rgxDriveBanChars = '[;~/\\\.:]' ; } ; # ;~/\.:, 

        $UseOP=$false ; 
        if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
            $UseOP = $true ; 
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ; 
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } else { 
            $UseOP = $false ; 
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ; 
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; 

        # o365/EXO creds
        $o365Cred=$null ;
        <# Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile* 
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
        Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
        .EXAMPLE
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
        Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
        .EXAMPLE
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
        Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
        #>
        #if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -verbose:$($verbose))){
        # force it to use the csvc mapping from $xxxmeta.o365_CSvcUpn, failthrough to SID spec 
        if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -UserRole 'CSVC','SID' -verbose:$($verbose))){
            # make it script scope, so we don't have to predetect & purge before using new-variable
            New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
            $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } else {
            #-=-record a STATUS=-=-=-=-=-=-=
            $statusdelta = ";ERROR";
            if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
            #-=-=-=-=-=-=-=-=
            $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
            exit ;
        } ;
        <# CALLS ARE IN FORM: (cred$($tenorg))
        $pltRXO = @{Credential = $Credential ; verbose = $($verbose) ; }
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            verbose = $($verbose) ; } ; 
        if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
        else { reconnect-EXO @pltRXO } ;
        # or with Tenant-specific cred($Tenorg) lookup
        #>

        if($UseOP){
            # do the OP creds too
            $OPCred=$null ;
            # default to the onprem svc acct
            $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC' ;verbose=$($verbose)} ;
            if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                #-=-record a STATUS=-=-=-=-=-=-=
                $statusdelta = ";ERROR";
                if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                #-=-=-=-=-=-=-=-=
                $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                exit ;
            } ;

            # === Exchange LEMS/REMS detect & connect code

            $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;  
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ; 

    } ;  # BEGIN-E
    PROCESS {
        $ofile=".\$($ticket)-$($Mailbox)-folder-sizes-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
        $error.clear() ;
        TRY {
            if(!(gcm get-recipient -ea 0)){rx10} ;
            $OpRcp=get-recipient $Mailbox ;
            switch ($OpRcp.recipienttype){
                "MailUser" {
                    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($tmbx) IS AN EXO MBOX" ;
                    
                    if($VerbosePreference = "Continue"){
                        $VerbosePrefPrior = $VerbosePreference ;
                        $VerbosePreference = "SilentlyContinue" ;
                        $verbose = ($VerbosePreference -eq "Continue") ;
                    } ; 
                    disconnect-exo ; # pre-disconnect    
                    $pltRXO = @{
                        Credential = (Get-Variable -name cred$($tenorg) ).value ;
                        verbose = $($verbose) ; }
                    if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
                    else { reconnect-EXO @pltRXO } ;
                    if($VerbosePrefPrior -eq "Continue"){
                        $VerbosePreference = $VerbosePrefPrior ;
                        $verbose = ($VerbosePreference -eq "Continue") ;
                    } ;

                    set-alias ps1GetMbxFldrStat Get-exoMailboxFolderStatistics ; 
                } ;
                "UserMailbox" {
                    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($tmbx) IS AN EX2010 MBOX" ;
                    
                    if($VerbosePreference = "Continue"){
                        $VerbosePrefPrior = $VerbosePreference ;
                        $VerbosePreference = "SilentlyContinue" ;
                        $verbose = ($VerbosePreference -eq "Continue") ;
                    } ; 
                    # connect OP
                    $pltRX10 = @{
                        Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                        verbose = $($verbose) ; } ;     
                    if($pltRX10){
                        Connect-Ex2010 @pltRX10 ;
                    } else { connect-Ex2010 ; } ;
                    # reenable VerbosePreference:Continue, if set, during mod loads 
                    if($VerbosePrefPrior -eq "Continue"){
                        $VerbosePreference = $VerbosePrefPrior ;
                        $verbose = ($VerbosePreference -eq "Continue") ;
                    } ;

                    set-alias ps1GetMbxFldrStat Get-MailboxFolderStatistics ; 
                } ;
                default {
                    throw "UNRECOGNIZED ONPREM RECIPIENTTYPE:$($OpRcp.recipienttype)" ; exit ; 
                } ; 
            } ;
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$((get-alias ps1GetMbxFldrStat).definition) w`n$(($pltGMFS|out-string).trim())" ; 
            $fldrs = ps1GetMbxFldrStat @pltGMFS ;
            if($NonEmptyOnly){
                write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):(REPORTING NON-ZERO FOLDERS ONLY)" ; $fldrs = $fldrs | ?{$_.ItemsInFolder -gt 0}
            } ; 
            $fldrs | ?{$_.identity -notmatch $rgxSysFldrs } | select $propsFldr | export-csv  -path $ofile -notype ;
            if(!$asObject){
                import-csv $ofile | ft -auto | out-default ; 
            } else { 
                write-verbose "-asObject specified, returning object to pipeline (rather than console dump)" ; 
                import-csv $ofile | write-output ; 
            } ; 
            write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):`n===>`$ofile:$($ofile)`n" ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ; 
    } ;  # PROC-E
    END {
        remove-alias ps1GetMbxFldrStat ;
    } ; 
    
}

#*------^ get-MailboxFolderStats.ps1 ^------


#*------v get-MsgTrace.ps1 v------
function get-MsgTrace {
    <#
    .SYNOPSIS
    get-MsgTrace.ps1 - Perform smart get-exoMessageTrace/MessageTrackingLog command, as appropriate to target location -Mailbox, on either Exchange on-premesis or Exchange Online.
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-03-12
    FileName    : get-MsgTrace.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Mailbox,Statistics,Reporting
    REVISIONS
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 2:40 PM 12/10/2021 more cleanup 
     * 12:17 PM 5/14/2021 updated passstatus code to curr, and added -ea to the gv's (suppress errors when not present)
    * 2:23 PM 3/16/2021 added multi-tenant support ; debugged both exOP & exo, added -ReportFail & -ReportRowsLimit params. At this point Exclusive params are only partially configured
    * 1:12 PM 3/15/2021 init work was done 3/12, removed recursive-err generating #Require on the hosting verb-EXO module
    .DESCRIPTION
    get-MsgTrace - Perform smart get-exoMessageTrace/MessageTrackingLog command, as appropriate to target location -Mailbox, on either Exchange on-premesis or Exchange Online.
    Dependancy on my verb-ex2010 Exchange onprem (and is within verb-exo EXO mod, which adds dependant EXO connection support).
    .PARAMETER TenOrg
    TenantTag values, indicating Tenant to Create DDG WITHIN[-TenOrg 'TOL']    
    .PARAMETER Recipients
    Recipient email addresses identifiers (comma-delimited)[-Recipients xxx@domain.com]
    .PARAMETER Sender
    Sender email address identifiers (EXO supports comma-delimited) [-Sender xxx@domain.com]
    .PARAMETER Subject
    "Message Subject string to be matched (post-filtered from broad query)[-Subject 'subject phrase']
    .PARAMETER Logon
    User Logon tag to be applied to output file[-Logon samaccountname]
    .PARAMETER Status
    Transport Status (EventID on-Prem)(RECEIVE|DELIVER|FAIL|SEND|RESOLVE|EXPAND|TRANSFER|DEFER) [-EventID SEND
    .PARAMETER Connectorid
    Connector identifier[-Connectorid SendConnX]
    .PARAMETER Source
    Source keyword to be used for filtering (STOREDRIVER|SMTP|DNS|ROUTING)[-Source SMTP]
    .PARAMETER MessageId
    "Target MessageId for search[-MessageId xxxxxxx]
    .PARAMETER MessageTraceId
    Target MessageId for search[-MessageTraceId xxxxxxx]
    .PARAMETER StartDate
    Start of time span to be searched[-StartDate 1/1/2021]
    .PARAMETER EndDate
    End of time span to be searched[-EndDate 1/7/2021]
    .PARAMETER Ticket
    Ticket # [-Ticket nnnnn]
    .PARAMETER useEXOP
    Switch to specify ONPREM Exch get-MessageTrackingLog trace (defaults `$false == EXO Message Search)[-useEXOP]
    .PARAMETER ReportRowsLimit
    Max number of rows to output to console when a -ReportXXX param is specified (defaults 100)[-ReportRowsLimit]
    .PARAMETER asObject
    Switch to return raw object rather than formated console report(defaults `$true)[-NonEmptyOnly]
    .INPUTS
    Accepts piped input.
    .OUTPUTS
    Outputs csv & console summary of mailbox folders content
    .EXAMPLE
    get-MsgTrace -Sender SENDER@DOMAIN.com -Ticket 99999 -days 7 -verbose ;
    Perform a default EXO trace last 7 days of traffic on specified sender, use specified Ticket number in csv file name, with verbose output
    .EXAMPLE
    $msgs = get-MsgTrace -Sender quotes@bossplow.com -Ticket 347298 -days 7 -asobject -verbose ;
    Above EXO MessageTrace returning an object for further postfiltering.
    .EXAMPLE
    get-msgtrace -sender ACCOUNT@COMPANY.com -useEXOP -ticket 99999 -d 1 -verbose ; 
    Run an ONPREM get-MessageTrackingLog search
    .EXAMPLE 
    $msgs = get-msgtrace -sender ACCOUNT@COMPANY.com -useEXOP -ticket 99999 -start (get-date).addhours(-1) -verbose -ReportFail; 
    Run an ONPREM get-MessageTrackingLog search, with specific -Start time (End will be asserted), with detailed dump of (first 100) EventID 'Fail' items
    .LINK
    https://github.com/tostka/verb-exo
    .LINK
    https://github.com/tostka/verb-ex2010
    #>
    #Requires -Version 3
    ##Requires -Modules verb-ex2010
    # 2:49 PM 3/8/2022 pull verb-ex2010 ref - I think it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("(lyn|bcc|spb|adl)ms6(4|5)(0|1).(china|global)\.ad\.COMPANY\.com")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    [CmdletBinding(DefaultParameterSetName='SendRec')]
    <# $isplt=@{  ticket="347298" ;  uid="wilinaj";  days=7 ;  Sender="quotes@bossplow.com" ;  Recipients="" ;  MessageSubject="" ;  EventID='' ;  Connectorid="" ;  Source="" ;} ; 
    #>
    Param(
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag values, indicating Tenant to Create DDG WITHIN[-TenOrg 'TOL']")]
        [ValidateNotNullOrEmpty()]
        [string]$TenOrg = ('TOR'),
        [Parameter(ParameterSetName='SendRec',HelpMessage="Recipient email addresses identifiers (comma-delimited)[-Recipients xxx@domain.com]")]
        [string]$Recipients,    
        [Parameter(ParameterSetName='SendRec',HelpMessage="Sender email address identifier (EXO supports comma-delimited)")]
        [string]$Sender, 
        [Parameter(HelpMessage="Message Subject string to be matched (post-filtered from broad query)[-Subject 'subject phrase']")]
        [string]$Subject,
        [Parameter(HelpMessage="User Logon tag to be applied to output file[-Logon samaccountname]")]
        [string]$Logon,
        [Parameter(HelpMessage="Transport Status (EventID on-Prem)(RECEIVE|DELIVER|FAIL|SEND|RESOLVE|EXPAND|TRANSFER|DEFER) [-EventID SEND")]
        [ValidateSet("RECEIVE","DELIVER","FAIL","SEND","RESOLVE","EXPAND","TRANSFER","DEFER")]
        [string]$Status,
        [Parameter(HelpMessage="Connector identifier[-Connectorid SendConnX]")]
        [string]$Connectorid,
        [Parameter(HelpMessage="Source keyword to be used for filtering (STOREDRIVER|SMTP|DNS|ROUTING)[-Source SMTP]")]
        [ValidateSet("STOREDRIVER","SMTP","DNS","ROUTING")]
        [string]$Source,
        [Parameter(ParameterSetName='MsgID',HelpMessage="Target MessageId for search[-MessageId xxxxxxx]")]
        [string]$MessageId, 
        [Parameter(ParameterSetName='MsgTrcID',HelpMessage="Target MessageId for search[-MessageTraceId xxxxxxx]")]
        [string]$MessageTraceId,
        [Parameter(HelpMessage="Start of time span to be searched[-StartDate 1/1/2021]")]
        [string]$StartDate,
        [Parameter(HelpMessage="End of time span to be searched[-EndDate 1/7/2021]")]
        [string]$EndDate,
        [Parameter(HelpMessage="Days back to search[-Days 7]")]
        [int]$Days,
        [Parameter(Mandatory=$false,HelpMessage="Ticket # [-Ticket nnnnn]")]
        #[ValidateLength(5)] # non-mandatory
        [int]$Ticket,
        [Parameter(HelpMessage="Switch to specify ONPREM Exch get-MessageTrackingLog trace (defaults `$false == EXO Message Search)[-useEXOP]")]
        [switch] $useEXOP=$false,
        [Parameter(HelpMessage="Switch to return raw object rather than formated console report(defaults `$true)[-NonEmptyOnly]")]
        [switch] $asObject,
        [Parameter(HelpMessage="Switch to return detailed analysis of FAIL items[-ReportFail]")]
        [switch] $ReportFail,
        [Parameter(HelpMessage="Max number of rows to output to console when a -ReportXXX param is specified (defaults 100)[-ReportRowsLimit]")]
        [int]$ReportRowsLimit = 100  
    ) ;
    BEGIN {
        $Verbose=($VerbosePreference -eq 'Continue') ;  
        # Get parameters this function was invoked with
        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
        $propsFldr = @{Name='Folder';Expression={$_.Identity.tostring()}},@{Name="Items";Expression={$_.ItemsInFolder}} ;
        $propsMsgEx10 = 'Timestamp',@{N='TimestampLocal';E={$_.Timestamp.ToLocalTime()}},'Source','EventId','RelatedRecipientAddress','Sender',@{N='Recipients';E={$_.Recipients}},"RecipientCount",@{N='RecipientStatus';E={$_.RecipientStatus}},"MessageSubject","TotalBytes",@{N='Reference';E={$_.Reference}},'MessageLatency','MessageLatencyType','InternalMessageId','MessageId','ReturnPath','ClientIp','ClientHostname','ServerIp','ServerHostname','ConnectorId','SourceContext','MessageInfo',@{N='EventData';E={$_.EventData}} ;
        $propsMsgEXO = @{N='ReceivedLocal';E={$_.Received.ToLocalTime()}},'SenderAddress','RecipientAddress','Subject','Status','ToIP','FromIP','Size','MessageId','MessageTraceId','Index' ;
        
        # pull settings per Tenant fr Meta
        $Meta = gv -name "$($TenOrg)Meta" ; 
        <# pull value fr meta
        if($Meta -is [system.array]){ throw "Unable to resolve unique `$xxxMeta! from `$TenOrg:$($TenOrg)" ; break} ; 
        if(!$Meta.value.DefaultObjectOwner){throw "Unable to resolve $($Meta.Name).value.DefaultObjectOwner from `$TenOrg:$($TenOrg)" ; break} 
        else { $ManagedBy=$Meta.value.DefaultObjectOwner} ;  ;
        #>

        $Retries = 4 ;
        $RetrySleep = 5 ;
        if(!$ThrottleMs){$ThrottleMs = 50 ;}
        $CredRole = 'CSVC' ; # role of svc to be dyn pulled from metaXXX if no -Credential spec'd, 
        if(!$rgxDriveBanChars){$rgxDriveBanChars = '[;~/\\\.:]' ; } ; # ;~/\.:, 
        
        if($useEXOP){
            $UseOP=$false ; 
            if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
                $UseOP = $true ; 
                $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ; 
                if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else { 
                $UseOP = $false ; 
                $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ; 
                if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } ; 
        } else { 
            # o365/EXO creds
            $o365Cred=$null ;
            <# Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile* 
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
            Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
            Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
            Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            #>
            #if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -verbose:$($verbose))){
            # force it to use the csvc mapping from $xxxmeta.o365_CSvcUpn, failthrough to SID spec 
            if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -UserRole 'CSVC','SID' -verbose:$($verbose))){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
                $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                #-=-record a STATUS=-=-=-=-=-=-=
                $statusdelta = ";ERROR";
                if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                #-=-=-=-=-=-=-=-=
                $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                exit ;
            } ;
            <# CALLS ARE IN FORM: (cred$($tenorg))
            $pltRXO = @{Credential = $Credential ; verbose = $($verbose) ; }
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                verbose = $($verbose) ; } ; 
            if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
            else { reconnect-EXO @pltRXO } ;
            # or with Tenant-specific cred($Tenorg) lookup
            #>
        } ; 

        if($UseOP){
            # do the OP creds too
            $OPCred=$null ;
            # default to the onprem svc acct
            $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC' ;verbose=$($verbose)} ;
            if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                #-=-record a STATUS=-=-=-=-=-=-=
                $statusdelta = ";ERROR";
                if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                #-=-=-=-=-=-=-=-=
                $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                exit ;
            } ;

            # === Exchange LEMS/REMS detect & connect code

            $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;  
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ; 
        
    } ;  # BEGIN-E
    PROCESS {
        #$ofile=".\$($ticket)-$($Mailbox)-folder-sizes-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
        $error.clear() ;
    
        switch ($useEXOP){
            $false {

                write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):PERFORMING AN EXO MSGTRACE" ;
                if($VerbosePreference = "Continue"){
                    $VerbosePrefPrior = $VerbosePreference ;
                    $VerbosePreference = "SilentlyContinue" ;
                    $verbose = ($VerbosePreference -eq "Continue") ;
                } ; 
                disconnect-exo ; # pre-disconnect    
                $pltRXO = @{
                    Credential = (Get-Variable -name cred$($tenorg) ).value ;
                    verbose = $($verbose) ; }
                if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
                else { reconnect-EXO @pltRXO } ;
                if($VerbosePrefPrior -eq "Continue"){
                    $VerbosePreference = $VerbosePrefPrior ;
                    $verbose = ($VerbosePreference -eq "Continue") ;
                } ;

                # recycle $pltRXO for the AAD connection
                connect-AAD @pltRXO ;

                set-alias ps1GetMsgTrace Get-exoMessageTrace  ; 
                $props = $propsMsgEXO ; 
                $msgtrk=[ordered]@{
                    PageSize=1000 ;
                    Page=$null ;
                    StartDate=$null ;
                    EndDate=$null ;
                } ;
                if($Days -AND -not($StartDate -AND $EndDate)){
                    $msgtrk.StartDate=(get-date ([datetime]::Now)).adddays(-1*$days);
                    $msgtrk.EndDate=(get-date) ;
                } ;
                if($StartDate -and !($days)){
                    $msgtrk.StartDate=$(get-date $StartDate)
                } ;
                if($EndDate -and !($days)){
                    $msgtrk.EndDate=$(get-date $EndDate)
                } elseif($StartDate -and !($EndDate)){
                    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):
    (StartDate w *NO* Enddate, asserting currenttime)" ;
                    $msgtrk.EndDate=(get-date) ;
                } ;
                
                $error.clear() ;
                TRY {
                    #Connect-AAD ;
                    $tendoms=Get-AzureADDomain ;
                } CATCH {
                    $ErrTrapt=$Error[0] ;
                    Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
                    $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrpd.Exception.GetType().FullName)]{" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Exit #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                } ; 
            
                $Ten = ($tendoms |?{$_.name -like '*.mail.onmicrosoft.com'}).name.split('.')[0] ;
                $ofile ="$($ticket)-$($Ten)-$($Logon)-EXOMsgTrk" ;
                if($Sender){
                    if($Sender -match '\*'){
                        "(wild-card Sender detected)" ;
                        $msgtrk.add("SenderAddress",$Sender) ;
                    } else {
                        $msgtrk.add("SenderAddress",$Sender) ;
                    } ;
                    $ofile+=",From-$($Sender.replace("*","ANY"))" ;
                } ;
                if($Recipients){
                    if($Recipients -match '\*'){        "(wild-card Recipient detected)" ;
                        $msgtrk.add("RecipientAddress",$Recipients) ;
                    } else {
                            $msgtrk.add("RecipientAddress",$Recipients) ;
                    } ;
                    $ofile+=",To-$($Recipients.replace("*","ANY"))" ;
                } ;
                if($MessageId){
                    $msgtrk.add("MessageId",$MessageId) ;
                    $ofile+=",MsgId-$($MessageId.replace('<','').replace('>',''))" ;
                } ;
                if($MessageTraceId){
                    $msgtrk.add("MessageTraceId",$MessageTraceId) ;
                    $ofile+=",MsgId-$($MessageTraceId.replace('<','').replace('>',''))" ;
                } ;
                if($Subject){    $ofile+=",Subj-$($Subject.substring(0,[System.Math]::Min(10,$Subject.Length)))..." ;
                } ;
                if($Status){
                    $msgtrk.add("Status",$Status)  ;
                    $ofile+=",Status-$($Status)" ;
                } ;
                if($days){$ofile+= "-$($days)d-" } ;
                if($StartDate){$ofile+= "-$(get-date $StartDate -format 'yyyyMMdd-HHmmtt')-" } ;
                if($EndDate){$ofile+= "$(get-date $EndDate -format 'yyyyMMdd-HHmmtt')" } ;
                
                write-verbose -verbose:$true  "$((get-date).ToString('HH:mm:ss')):Running MsgTrk:$($Ten)" ;
    $(($msgtrk|out-string).trim()|out-default) ;
  
                TRY {
                    $Page = 1  ;
                    $Msgs=$null ;
                    do {
                        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):Collecting - Page $($Page)..."  ;
                        $msgtrk.Page=$Page ;
                        $PageMsgs = ps1GetMsgTrace @msgtrk |  ?{$_.SenderAddress -notlike '*micro*' -or $_.SenderAddress -notlike '*root*' }  ;
                        $Page++  ;
                        $Msgs += @($PageMsgs)  ;
                    } until ($PageMsgs -eq $null) ;
                } CATCH {
                    Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
                    Exit ;
                } ; 
                $Msgs=$Msgs| Sort Received ;
                write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):==Msgs Returned:$(($Msgs|measure).count)" ;
                write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):Raw matches:$(($Msgs|measure).Count)" ;
                if($Subject){
                    write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):Post-Filtering on Subject:$($Subject)" ;
                    $Msgs = $Msgs | ?{$_.Subject -like $Subject} ;
                    $ofile+="-Subj-$($Subject.replace("*"," ").replace("\"," "))" ;
                    write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):Post Subj filter matches:$(($Msgs|measure).Count)" ;
                } ;
                $ofile+= "-run$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
                $ofile=[RegEx]::Replace($ofile, "[{0}]" -f ([RegEx]::Escape(-join [System.IO.Path]::GetInvalidFileNameChars())), '') ;
                $ofile=".\logs\$($ofile)" ;
                if($Msgs){
                    $Msgs | select $props | export-csv -notype -path $ofile  ;
                    write-host -foregroundcolor yellow "Status Distrib:" ;
                    write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):`n#*------v MOST RECENT MATCH v------" ;
                    write-host -foregroundcolor white "$(($msgs[-1]| format-list ReceivedLocal,StatusSenderAddress,RecipientAddress,Subject|out-string).trim())";
                    write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):`n#*------^ MOST RECENT MATCH ^------" ;
                    write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):`n#*------v Status DISTRIB v------" ;
                    "$(($Msgs | select -expand Status | group | sort count,count -desc | select count,name |out-string).trim())";
                    write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):`n#*------^ Status DISTRIB ^------" ;
                    if(test-path -path $ofile){
                            write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):(log file confirmed)" ;
                            Resolve-Path -Path $ofile | select -expand Path | out-clipboard ;
                            write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($Msgs.count) matches output to:`n'$($ofile)'`n(copied to CB)" ;
                    } else { "MISSING LOG FILE!" } ;

                    if($ReportFail){
                        $sBnr3="`n#*------v Status:FAIL Traffic (up to 1st $($ReportRowsLimit)) v------" ; 
                        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3)" ;
                        write-host -foregroundcolor cyan "$(($MSGS|?{$_.Status -eq 'FAIL'} | select -first $($ReportRowsLimit) | fl recipients,recipientstatus,ServerHostname|out-string).trim())" ; 
                        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3.replace('~v','~^').replace('v~','^~'))`n" ;
                    } ; 
                    
                    if($asObject){
                        $Msgs | write-output ; 
                    } ; 
                } else {
                    write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):NO MATCHES FOUND from::`n$(($msgtrk|out-string).trim()|out-default)`n(with any relevant ConnectorId postfilter)" ;
                } ;
            } ; # end EXO switchblock

            $true {
                write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):PERFORMING AN ONPREM MSGTRACK" ;
                if($VerbosePreference = "Continue"){
                    $VerbosePrefPrior = $VerbosePreference ;
                    $VerbosePreference = "SilentlyContinue" ;
                    $verbose = ($VerbosePreference -eq "Continue") ;
                } ; 
                # connect OP
                $pltRX10 = @{
                    Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                    verbose = $($verbose) ; } ;     
                if($pltRX10){
                    Connect-Ex2010 @pltRX10 ;
                } else { connect-Ex2010 ; } ;

                # reenable VerbosePreference:Continue, if set, during mod loads 
                if($VerbosePrefPrior -eq "Continue"){
                    $VerbosePreference = $VerbosePrefPrior ;
                    $verbose = ($VerbosePreference -eq "Continue") ;
                } ;

                set-alias ps1GetMsgTrace get-messagetrackinglog  ; 
                $props = $propsMsgEx10 ; 
                $msgtrk=@{
                    Start=(get-date ([datetime]::Now)).adddays(-1*$days) ;
                    End=(get-date) ;
                    resultsize="UNLIMITED" ;
                } ;
                # Page=$null ;
                $msgtrk=[ordered]@{
                    resultsize="UNLIMITED" ;
                    Start=$null ;
                    End=$null ;
                } ;
                if($Days -AND -not($StartDate -AND $EndDate)){
                    $msgtrk.Start=(get-date ([datetime]::Now)).adddays(-1*$days);
                    $msgtrk.End=(get-date) ;
                } ;
                if($StartDate -and !($days)){
                    $msgtrk.Start=$(get-date $StartDate)
                } ;
                if($EndDate -and !($days)){
                    $msgtrk.End=$(get-date $EndDate)
                } elseif($StartDate -and !($EndDate)){
                    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):
    (StartDate w *NO* End, asserting currenttime)" ;
                    $msgtrk.End=(get-date) ;
                } ;
                TRY {
                    $Site=[System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().Name ;
                    # "$($ticket)-$($uid)-$($Site.substring(0,3))-MsgTrk" ;
                    $ofile ="$($ticket)-$($Site.substring(0,3))-OPMsgTrk" ;
                    if($Sender){$msgtrk.add("Sender",$Sender) ;
                        $ofile+=",From-$($Sender)" ;
                        } ;
                    if($Recipients){$msgtrk.add("Recipients",$Recipients) ;
                        $ofile+=",To-$($Recipients)" ;
                    } ;
                    if($Subject){$msgtrk.add("MessageSubject",$Subject)  ;
                        $ofile+=",Subj-$($Subject.substring(0,[System.Math]::Min(10,$Subject.Length)))..." ;
                    } ;
                    if($EventID){$msgtrk.add("EventID",$Status)  ;
                        $ofile+=",Evt-$($Status)" ;
                    } ;
                    
                    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$((get-alias ps1GetMsgTrace).ResolvedCommandName) w`n$(($msgtrk|out-string).trim())" ; 
                    $Srvrs=(Get-ExchangeServer | where { $_.isHubTransportServer -eq $true -and $_.Site -match ".*\/$($Site)$"} | select -expand Name) ;
                    #$Msgs=($Srvrs| get-messagetrackinglog @msgtrk) | sort Timestamp ;
                    $Msgs =@() ; # 
                    # loop the servers, to provide a status output
                    foreach($Srvr in $Srvrs){
                        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):Tracking $($Srvr) server..." ; 
                        $sMsgs = ($Srvr| get-messagetrackinglog @msgtrk) ;
                        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):(($Srvr):$(($sMsgs|measure).count) matched msgs)" ; 
                        $Msgs+=$sMsgs ; 
                        $sMsgs = $null ; 
                    } ; 
                    #$Msgs = $Msgs |  sort Timestamp ;
                    $Msgs=$Msgs| Sort Timestamp ;
                    write-verbose -verbose:$true  "$((get-date).ToString('HH:mm:ss')):Raw matches:$(($Msgs|measure).Count)" ;
                    if($Connectorid){
                        write-verbose -verbose:$true  "$((get-date).ToString('HH:mm:ss')):Filtering on Conn:$($Connectorid)" ;
                        $Msgs = $Msgs | ?{$_.connectorid -like $Connectorid} ;
                        $ofile+="-conn-$($Connectorid.replace("*"," ").replace("\"," "))" ;
                        write-verbose -verbose:$true  "$((get-date).ToString('HH:mm:ss')):Post Conn filter matches:$(($Msgs|measure).Count)" ;
                    } ;
                    if($Source){
                        write-verbose -verbose:$true  "$((get-date).ToString('HH:mm:ss')):Filtering on Source:$($Source)" ;
                        $Msgs = $Msgs | ?{$_.Source -like $Source} ;
                        write-verbose -verbose:$true  "$((get-date).ToString('HH:mm:ss')):Post Src filter matches:$(($Msgs|measure).Count)" ;
                        $ofile+="-src-$($Source)" ;
                    } ;
                    if($Days){$ofile+= "-$($days)d-run$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;} 
                    else {
                        $ofile+= "-$(get-date $msgtrk.Start -format 'yyyyMMdd-HHmmtt')-$(get-date $msgtrk.End -format 'yyyyMMdd-HHmmtt')-run$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
                    } ;  
                    $ofile=[RegEx]::Replace($ofile, "[{0}]" -f ([RegEx]::Escape(-join [System.IO.Path]::GetInvalidFileNameChars())), '') ;
                    $ofile=".\logs\$($ofile)" ;
                    
                    if($Msgs){
                        $Msgs | SELECT $props| EXPORT-CSV -notype -path $ofile ;
                        write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):`n#*------v MOST RECENT MATCH v------" ;
                        write-host -foregroundcolor cyan "$(((($msgs[-1]| format-list Timestamp,EventId,Sender,Recipients,MessageSubject|out-string).trim())|out-string).trim())" ; 
                        write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):`n#*------^ MOST RECENT MATCH ^------" ;
                        write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):`n#*------v EVENTID DISTRIB v------" ;
                        write-host -foregroundcolor cyan "$(($Msgs | select -expand EventId | group | sort count,count -desc | select count,name |out-string).trim())" ; 
                        write-host -fore gray "(SEND=SMTP SEND,TRANSFER=Routing,RESOLVE=Recipient conversion)" ;
                        write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):`n#*------^ EVENTID DISTRIB ^------" ;
                        if(test-path -path $ofile){
                            write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):(log file confirmed)" ;
                            Resolve-Path -Path $ofile | select -expand Path | out-clipboard ;
                            write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($Msgs.count) matches output to:`n'$($ofile)'`n(copied to CB)" ;
                        } else { "MISSING LOG FILE!" } ;
                        
                        if($ReportFail){
                            $sBnr3="`n#*~~~~~~v -ReportFail specified: Status:FAIL Traffic (up to 1st $($ReportRowsLimit)): v~~~~~~" ; 
                            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3)" ;
                            write-host -foregroundcolor cyan "$(((($MSGS|?{$_.eventid -eq 'fail'} | select -first $($ReportRowsLimit) | fl recipients,recipientstatus,ServerHostname|out-string).trim())|out-string).trim())" ; 
                            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3.replace('~v','~^').replace('v~','^~'))`n" ;
                        } ; 

                        if($asObject){
                            $Msgs | SELECT $props | write-output ; 
                        } ; 
                    } else {    write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):NO MATCHES FOUND from::`n$(($msgtrk|out-string).trim()|out-default)`n(with any relevant ConnectorId postfilter)" ;
                    } ;
                } CATCH {
                    Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
                    Exit ;
                } ; 
            } ;
            default {
                throw "UNRECOGNIZED useEXOP value)" ; exit ; 
            } ; 
        } ; # SWITCH-E
        
    } ;  # PROC-E
    END {
        remove-alias ps1GetMsgTrace ;
    } ; 
}

#*------^ get-MsgTrace.ps1 ^------


#*------v Get-OrgNameFromUPN.ps1 v------
function Get-OrgNameFromUPN{
    <#
    .SYNOPSIS
    Get-OrgNameFromUPN.ps1 - Extract organization name from UserPrincipalName ; localized verb-EXO vers of non-'$global:' helper funct from ExchangeOnlineManagement. The globals export fine, these don't and appear to need to be loaded manually
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 20201109-0833AM
    FileName    : Get-OrgNameFromUPN.ps1
    License     : [none specified]
    Copyright   : [none specified]
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell
    AddedCredit : Microsoft (edited version of published commands in the module)
    AddedWebsite:	https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
    REVISIONS
    * 8:34 AM 11/9/2020 init
    .DESCRIPTION
    Get-OrgNameFromUPN.ps1 - Extract organization name from UserPrincipalName ; localized verb-EXO vers of non-'$global:' helper funct from ExchangeOnlineManagement. The globals export fine, these don't and appear to need to be loaded manually

    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    Get-OrgNameFromUPN
    Stock call
    .LINK
    https://github.com/tostka/verb-EXO
    .LINK
    https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
    #>
    [CmdletBinding()]
    param([string] $UPN)
    $fields = $UPN -split '@'
    return $fields[-1]
}

#*------^ Get-OrgNameFromUPN.ps1 ^------


#*------v get-xoHistSearch.ps1 v------
function get-xoHistSearch {
    <#
    .SYNOPSIS
    get-xoHistSearch.ps1 - wrapper/automation for EXO's get-HistoricalSearch cmdlet, Assembles ReportTitle & models an export-csv filename, around recipient, sender, reportType etc params specified for get-historicalsearch, also dawdle loops monitoring & alerting the progress of the associated PSJob created by the search submission.
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-07-13
    FileName    : get-xoHistSearch.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 1:44 PM 1/6/2022 updated example2 to have start/end rather than days; added region tags for bracketed blocks of code
    * 2:40 PM 12/10/2021 more cleanup 
    * 12:49 PM 9/28/2021 init; added MsgID support; added MsgID example
    .DESCRIPTION
    get-xoHistSearch.ps1 - wrapper/automation for EXO's get-HistoricalSearch cmdlet, Assembles ReportTitle & models an export-csv filename, around recipient, sender, reportType etc params specified for get-historicalsearch, also dawdle loops monitoring & alerting the progress of the associated PSJob created by the search submission.
    .PARAMETER Requester
    Requester identifier[-Requester user@domain.com]
    .PARAMETER Ticket
    Ticket # [-Ticket nnnnn]
    .PARAMETER Days
    Days of History to retrieve (from current time, defaults to 30) # [-Days nnnnn]
    .PARAMETER StartDate
    Optional StartDate (use of -Days will autocalc from current datetime)[-StartDate mm/dd/yyyy]
    .PARAMETER EndDate
    Optional EndDate (use of -Days will autocalc from current datetime) [-EndDate mm/dd/yyyy]
    .PARAMETER Recipients
    RecipientAddresses [-Recipients 'recip1@domain.com','recip2@domain.com']
    .PARAMETER Sender
    SenderAddress [-Sender 'sender@domain.com']
    .PARAMETER MessageID
    MessageID to be traced [-MessageID '<XXXXX@XXXXX.namprd04.prod.outlook.com>']
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    Returns report to pipeline
    .EXAMPLE
    PS> $pltHS = [ordered]@{ 
            Ticket = TICKET;
            Requester = 'REQUESTOR' ;
            Days = 30 ;
            Recipient = $null ;
            Sender = 'SENDER@DOMAIN.COM' ;
            NotifyAddress = 'NOTIFY@DOMAIN.COM' ;
            verbose = $true ;
            showdebug = $true ;
         } ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):get-xoHistSearch w`n$(($pltHS|out-string).trim())" ;
    get-xoHistSearch @pltHS ;
    Demo splatted-params search against Days and Sender
    .EXAMPLE
    PS> $pltHS = [ordered]@{ 
        Ticket = 'TICKET';
        Requester = 'REQUESTOR' ;;
        StartDate = (get-date 'TIMESTAMP').AddMinutes(-5) ;
        EndDate = (get-date 'TIMESTAMP').AddMinutes(60) ; ; 
        Recipient = $null ;
        Sender = 'SENDER' ;
        NotifyAddress = 'todd.kadrie@toro.com' ;
        MessageId = '<CH2PR04MB6886105FBBEB2C3FB2DD9D0DF4759@CH2PR04MB6886.namprd04.prod.outlook.com>' ;
        verbose = $true ;
        showdebug = $true ;
    } ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):get-xoHistSearch w`n$(($pltHS|out-string).trim())" ;
    get-xoHistSearch @pltHS ;
    Demo splatted-params -MessageID HistoricalSearch with Start & EndDates bracketing timestamp (from problem message)
    .LINK
    https://docs.microsoft.com/en-us/powershell/module/exchange/get-historicalsearch
    .LINK
    https://github.com/tostka/verb-exo
    #>
    ###Requires -Version 5
    #Requires -Modules ExchangeOnlineManagement,verb-Auth, verb-IO, verb-logging, verb-Text
    ###Requires -Modules ActiveDirectory, AzureAD, MSOnline, ExchangeOnlineManagement, verb-ADMS, verb-Auth, verb-Ex2010, verb-EXO, verb-IO, verb-logging, verb-Text
    #Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("(lyn|bcc|spb|adl)ms6(4|5)(0|1).(china|global)\.ad\.COMPANY\.com")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding(DefaultParameterSetName='Days')]
    #[CmdletBinding()]
    #[Alias('gxhs')]
    PARAM(
        [Parameter(Mandatory=$False,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
        $TenOrg = 'TOR',
        [Parameter(Mandatory=$False,HelpMessage="Requester identifier[-Requester user@domain.com]")]
        $Requester,
        [Parameter(Mandatory=$False,HelpMessage="Ticket # [-Ticket nnnnn]")]
        $Ticket,
        [Parameter(ParameterSetName='Days',Mandatory=$False,HelpMessage="Days of History to retrieve (from current time, defaults to 30) # [-Days nnnnn]")]
        [int]$Days=30,
        [Parameter(ParameterSetName='Date',Mandatory=$False,HelpMessage="Optional StartDate (use of -Days will autocalc from current datetime)[-StartDate mm/dd/yyyy]")]
        [DateTime]$StartDate,
        [Parameter(ParameterSetName='Date',Mandatory=$False,HelpMessage="Optional EndDate (use of -Days will autocalc from current datetime) [-EndDate mm/dd/yyyy]")]
        [DateTime]$EndDate,
        [Parameter(Mandatory=$False,HelpMessage="RecipientAddresses [-Recipients 'recip1@domain.com','recip2@domain.com']")]
        [string]$Recipients,
        [Parameter(Mandatory=$False,HelpMessage="SenderAddress [-Sender 'sender@domain.com']")]
        [string]$Sender,
        [Parameter(Mandatory=$False,HelpMessage="MessageID to be traced [-MessageID '<XXXXX@XXXXX.namprd04.prod.outlook.com>']")]
        [string]$MessageID,
        [Parameter(Mandatory=$False,HelpMessage="Result status Notification Address [-NotifyAddress 'recipx@domain.com']")]
        [string]$NotifyAddress,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2,
        [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
        [switch] $showDebug
    ) ;
    BEGIN{
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        #$rgxEmailAddr = "^([0-9a-zA-Z]+[-f._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ;
        #$rgxDName = "^([a-zA-Z]{2,}\s[a-zA-Z]{1,}'?-?[a-zA-Z]{2,}\s?([a-zA-Z]{1,})?)" ;
        #$rgxSamAcctNameTOR = "^\w{2,20}$" ; # up to 20k, the limit prior to win2k
        #$rgxSamAcctName = "^[^\/\\\[\]:;|=,+?<>@?]+$" # no char limit ;

        $propsJob = "Status",@{name="Stat"; expression={$_.ReportStatusDescription}},@{name="From"; expression={$_.SenderAddress}},@{name="To"; expression={$_.RecipientAddress}},@{name="Prog"; expression={$_.JobProgress}},@{name="ETA"; expression={(get-date ($_.EstimatedCompletionTime.ToLocalTime()) -f 'MM/dd HH:mmtt')}} ;
        $propsJobResults = 'JobId','FileRows','ErrorCode','ErrorDescription','Status','ReportStatusDescription','SenderAddress','RecipientAddress','MessageID','CompletionDate','JobProgress','EstimatedCompletionTime','FileUrl' ;

        <#
        $progInterval= 500 ; # write-progress wait interval in ms
        $DoRetries = 4 ;
        $RetrySleep = 5 ;
        [int]$retryLimit=1; # just one retry to patch lineuri duped users and retry 1x
        [int]$retryDelay=20;    # secs wait time after failure
        #>

        #$ComputerName = $env:COMPUTERNAME ;
        #$sQot = [char]34 ; $sQotS = [char]39 ;

        if ($psISE){
            $ScriptDir = Split-Path -Path $psISE.CurrentFile.FullPath ;
            $ScriptBaseName = split-path -leaf $psise.currentfile.fullpath ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($psise.currentfile.fullpath) ;
                    $PSScriptRoot = $ScriptDir ;
            if($PSScriptRoot -ne $ScriptDir){ write-warning "UNABLE TO UPDATE BLANK `$PSScriptRoot TO CURRENT `$ScriptDir!"} ;
            $PSCommandPath = $psise.currentfile.fullpath ;
            if($PSCommandPath -ne $psise.currentfile.fullpath){ write-warning "UNABLE TO UPDATE BLANK `$PSCommandPath TO CURRENT `$psise.currentfile.fullpath!"} ;
        } else {
            if($host.version.major -lt 3){
                $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                $PSCommandPath = $myInvocation.ScriptName ;
                $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
            } elseif($PSScriptRoot) {
                $ScriptDir = $PSScriptRoot ;
                if($PSCommandPath){
                    $ScriptBaseName = split-path -leaf $PSCommandPath ;
                    $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($PSCommandPath) ;
                } else {
                    $PSCommandPath = $myInvocation.ScriptName ;
                    $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                    $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
                } ;
            } else {
                if($MyInvocation.MyCommand.Path) {
                    $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                    $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                    $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
                } else {
                    throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" ;
                } ;
            } ;
        } ;
        if($showDebug){
            write-host -foregroundcolor green "`SHOWDEBUG: `$ScriptDir:$($ScriptDir)`n`$ScriptBaseName:$($ScriptBaseName)`n`$ScriptNameNoExt:$($ScriptNameNoExt)`n`$PSScriptRoot:$($PSScriptRoot)`n`$PSCommandPath:$($PSCommandPath)" ;
        } ;
        #region EMAIL_HANDLING_BOILERPLATE ; #====== v EMAIL HANDLING BOILERPLATE (USE IN SUB MAIN) v==================================
        $bodyAsHtml=$true ;
        $smtpPriority="Normal";
        # SMTP port (default is 25)
        $smtpPort = 25 ;
        $smtpToFailThru="dG9kZC5rYWRyaWVAdG9yby5jb20="| convertfrom-Base64String
        # pull the notifc smtpto from the xxxMeta.NotificationDlUs value
        if(!$showdebug){
            if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs){
                $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs ;
            }elseif((Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1){
                $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1 ;
            } else {$smtpTo=$smtpToFailThru} ;
        } else {
            # debug pass, don't send to main dl, use NotificationAddr1    if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs){
            if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1){
                #set-variable -Name $meta.name -Value ((get-variable -name $meta.name).value  += @{'o365_AcceptedDomains' = (Get-exoAcceptedDomain).domainname} )
                $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1 ;
            } else {$smtpTo=$smtpToFailThru } ;
        } ;
        $smtpFrom = (($scriptBaseName.replace(".","-")) + "@$( (Get-Variable  -name "$($TenOrg)Meta").value.o365_OPDomain )") ;
        $smtpSubj= "Proc Rpt:"
        if($whatif) {$smtpSubj+="WHATIF:" }
        else {$smtpSubj+="PROD:" } ;
        $smtpSubj+= "$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"   ;
        if(!($bodyAsHtml)){
            # if not inline attachment in body, need to load report as attachment
            $smtpAttachment=$rptfile ;
        } else {
            #9:49 AM 3/26/2015 just blank the attachment if we're not mailing it
            $smtpAttachment=$null;
        };
        # setup body as a hash
        $smtpBody = @() ;
        # (`n = CrLf in body)
        #endregion EMAIL_HANDLING_BOILERPLATE ; #====== ^ EMAIL HANDLING BOILERPLATE (USE IN SUB MAIN) ^ ==================================

        #*======v FUNCTIONS v======

        #-------v Function _cleanup v-------
        function _cleanup {
            <#
            .SYNOPSIS
            _cleanup.ps1 - clear all objects, prep close transcript, email report and exit
            .NOTES
            Version     : 1.0.0
            Author      : Todd Kadrie
            Website     :	http://www.toddomation.com
            Twitter     :	@tostka / http://twitter.com/tostka
            CreatedDate : 2020-
            FileName    :
            License     : MIT License
            Copyright   : (c) 2020 Todd Kadrie
            Github      : https://github.com/tostka/verb-XXX
            Tags        : Powershell
            AddedCredit : REFERENCE
            AddedWebsite:	URL
            AddedTwitter:	URL
            REVISIONS
            # 10:32 AM 9/14/2021: _cleanup(): # only mail on PassStatus
            # 8:47 AM 11/24/2020 cloned over intact from maintain-exousrmbxretentionpolicies
            # 3:15 PM 10/13/2020 added CBH, added params: summarizeStatus,
                NoTranscriptStop, TranscriptItemsLimit, each exempts certain blocks of process
                - trying to genericize for reuse on other scripts ; added html body support
                (using <pre../pre> to preserve text layout, even in outlook display
            # 12:40 PM 10/23/2018 added write-log trainling bnr
            # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
            # 8:45 AM 10/13/2015 reset $DebugPreference to default SilentlyContinue, if on
            # # 8:46 AM 3/11/2015 at some time from then to 1:06 PM 3/26/2015 added ISE Transcript
            # 8:39 AM 12/10/2014 shifted to stop-transcriptLog function
            # 7:43 AM 1/24/2014 always stop the running transcript before exiting
            .DESCRIPTION
            _cleanup.ps1 - clear all objects, prep close transcript, email report and exit
            .PARAMETER  LogPath
            Alt transcript/logfile path for mailing (rather than `$transcript/`$logfile)[-LogPath c:\path-to\log.txt]
            .PARAMETER TranscriptItemsLimit
            Number of transactions to determine Transcript inclusion[-TranscriptItemsLimit]
            .PARAMETER summarizeStatus
            Switch to output a summary of the `$script:PassStatus delimted string[-summarizeStatus]
            .PARAMETER NoTranscriptStop
            Switch to skip transcript stop & exit [-NoTranscriptStop]
            .PARAMETER ShowDebug
            Parameter to display Debugging messages [-ShowDebug switch]
            .PARAMETER Whatif
            Parameter to run a Test no-change pass [-Whatif switch]
            .EXAMPLE
            _cleanup
            Default Call
            .EXAMPLE
            $pltCleanup=@{LogPath=$tmpcopy summarizeStatus=$true ;  NoTranscriptStop=$true ; showDebug=$($showDebug) ;  whatif=$($whatif) ; } ;
            _cleanup @pltCleanup ;
            Splatted parameter'd call
            #>
            [CmdletBinding()]
            PARAM(
                [Parameter(HelpMessage="Alt transcript/logfile path for mailing (rather than `$transcript/`$logfile)[-LogPath c:\path-to\log.txt]")]
                [ValidateScript({Test-Path $_})]
                $LogPath,
                [Parameter(HelpMessage="Number of transactions to determine Transcript inclusion[-TranscriptItemsLimit]")]
                [int] $TranscriptItemsLimit = 10,
                [Parameter(HelpMessage="Switch to output a summary of the `$script:PassStatus delimted string[-summarizeStatus]")]
                [switch] $summarizeStatus,
                [Parameter(HelpMessage="Switch to skip transcript stop & exit [-NoTranscriptStop]")]
                [switch] $NoTranscriptStop,
                [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
                [switch] $showDebug,
                [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
                [switch] $whatIf
            ) ;
            # clear all objects, prep close transcript, email report and exit
            # REVISIONS
            $smsg = "_cleanup" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            if(!$NoTranscriptStop){
                # handle transcript closure in the main script (Tenant loop)
                stop-transcript
                if(($host.Name -eq "Windows PowerShell ISE Host") -AND ($host.version.Major -lt 5)){
                    # 8:46 AM 3/11/2015 shift the logfilename gen out here, so that we can arch it
                    #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -uformat "%Y%m%d-%H%M" ) + "-ISEtrans.log")) ;
                    # 2:16 PM 4/27/2015 shift to static timestamp $timeStampNow
                    #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + $timeStampNow + "-ISEtrans.log")) ;
                    # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
                    $Logname=(join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -format 'yyyyMMdd-HHmmtt') + "-ISEtrans.log")) ;
                    $smsg = "`$Logname: $($Logname)";
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Start-iseTranscript -logname $Logname -Verbose:($VerbosePreference -eq 'Continue') ;
                    #Archive-Log $Logname -Verbose:($VerbosePreference -eq 'Continue');
                    # 1:23 PM 4/23/2015 standardize processing file so that we can send a link to open the transcript for review
                    $transcript = $Logname
                } else {
                    $smsg = "Stop Transcript" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Stop-TranscriptLog -Verbose:($VerbosePreference -eq 'Continue') ;
                    #if($showdebug){ $smsg = "Archive Transcript" };
                    #Archive-Log $transcript -Verbose:($VerbosePreference -eq 'Continue') ;
                } # if-E
            } else {
                $smsg = "(_cleanup(): deferring transcript stop to main script)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; # !$NoTranscriptStop
            # add trailing notifc
            $smsg = "Mailing Report" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # variant options:
            #$smtpSubj= "Proc Rpt:$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"   ;
            #Load as an attachment into the body text:
            #$body = (Get-Content "path-to-file\file.html" ) | converto-html ;
            #$SmtpBody += ("Pass Completed "+ [System.DateTime]::Now + "`nResults Attached: " +$transcript) ;
            # 4:07 PM 10/11/2018 giant transcript, no send
            #$SmtpBody += "Pass Completed $([System.DateTime]::Now)`nResults Attached:($transcript)" ;
            #$SmtpBody += "Pass Completed $([System.DateTime]::Now)`nTranscript:($transcript)" ;
            # group out the PassStatus_$($tenorg) strings into a report for eml body
            if($script:PassStatus){
                if($summarizeStatus){
                    if($script:TargetTenants){
                        # loop the TargetTenants/TenOrgs and summarize each processed
                        foreach($TenOrg in $TargetTenants){
                            $SmtpBody += "`n===Processing Summary: $($TenOrg):" ;
                            # can't split an empty string
                            if((get-Variable -Name PassStatus_$($tenorg)).value){
                                if((get-Variable -Name PassStatus_$($tenorg)).value.split(';') |Where-Object{$_ -ne ''}){
                                    $SmtpBody += (summarize-PassStatus -PassStatus (get-Variable -Name PassStatus_$($tenorg)).value -verbose:$($VerbosePreference -eq 'Continue') );
                                } ;
                            } else {
                                $SmtpBody += "(no processing of mailboxes in $($TenOrg), this pass)" ;
                            } ;
                            $SmtpBody += "`n" ;

                        } ;
                    } ;

                    if($PassStatus){
                        if($PassStatus.split(';') |Where-Object{$_ -ne ''}){
                            $SmtpBody += (summarize-PassStatus -PassStatus $PassStatus -verbose:$($VerbosePreference -eq 'Continue') );
                        } ;
                    } else {
                        $SmtpBody += "(no `$PassStatus updates, this pass)" ;
                    } ;

                } else {
                    # dump PassStatus right into the email
                    $SmtpBody += "`n`$script:PassStatus: $($script:PassStatus):" ;
                } ;
                if($SmtpAttachment){
                    $smtpBody +="(Logs Attached)"
                };
                $SmtpBody += "`n$('-'*50)" ;
                # include transcript in body, where fewer than limit of processed items logged in PassStatus
                # no, there're 3 transcripts, stored in $Alltranscripts, but skip it#
        #        if( ($script:PassStatus.split(';') |?{$_ -ne ''}|measure).count -lt $TranscriptItemsLimit){
        #            # add full transcript if less than 10 entries processed
        #            $SmtpBody += "`nTranscript:$(gc $transcript)`n" ;
        #        } else {
                    if(!$ArchPath ){ $ArchPath = get-ArchivePath } ;
                    if($Alltranscripts){
                        $Alltranscripts |ForEach-Object{
                            #$archedTrans = join-path -path $ArchPath -childpath (split-path $transcript -leaf) ;
                            $archedTrans = join-path -path $ArchPath -childpath (split-path $_ -leaf) ;
                            $smtpBody += "`nTranscript accessible at:`n$($archedTrans)`n" ;
                        } ;
                    } ;
                #};
            }
            $SmtpBody += "Pass Completed $([System.DateTime]::Now)" ;
            $SmtpBody += "`n" + $MailBody
            # body rendered in OL loses all wordrwraps
            # force strip out the html
            #$smtpBody = [regex]::Replace($smtpBody, "\<[^\>]*\>", '') ;
            $styleCSS = "<style>BODY{font-family: Arial; font-size: 10pt;}" ;
            $styleCSS += "TABLE{border: 1px solid black; border-collapse: collapse;}" ;
            $styleCSS += "TH{border: 1px solid black; background: #dddddd; padding: 5px; }" ;
            $styleCSS += "TD{border: 1px solid black; padding: 5px; }" ;
            $styleCSS += "</style>" ;
            <#
            $html = @"
<html>
<head><title>$title</title></head>
<body>
<pre>$smtpBody</pre>
</body>
</html>
"@ ;
#>
            # one with style support (goees in the <head../head> block)
            $html = @"
<html>
<head>
$($styleCSS)
<title>$title</title></head>
<body>
<pre>
$($smtpBody)
</pre>
</body>
</html>
"@ ;
            # convertto-html doesn't do raw txt, just objects
            #$smtpBody = $smtpBody | ConvertTo-Html -Head $styleCSS ;
            # use the bp html <pre../pre> version
            $smtpBody = $html ;
            # name $attachment for the actual $SmtpAttachment expected by Send-EmailNotif
            #$SmtpAttachment=$transcript ;
            # test for ERROR|CHANGE - actually non-blank, only gets appended to with one or the other
            # to test for one, (but not a regex)
            # # always force
            #if($script:passstatus.split(';') -contains 'ERROR'){
            # only mail on PassStatus
            if([string]::IsNullOrEmpty($script:PassStatus)){
                $smsg = "No Email Report: `$script:PassStatus isNullOrEmpty" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {

                $Email = @{
                    smtpFrom = $SMTPFrom ;
                    SMTPTo = $SMTPTo ;
                    SMTPSubj = $SMTPSubj ;
                    #SMTPServer = $SMTPServer ;
                    SmtpBody = $SmtpBody ;
                    SmtpAttachment = $SmtpAttachment ;
                    BodyAsHtml = $false ; # let the htmltag rgx in Send-EmailNotif flip on as needed
                    verbose = $($VerbosePreference -eq "Continue") ;
                } ;
                $smsg = "Send-EmailNotif w`n$(($Email|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Send-EmailNotif @Email ;
            } ;
            #add an exit comment
            $smsg = "END $BARSD4 $scriptBaseName $BARSD4"
            $smsg += "`n$BARSD40"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # finally restore the DebugPref if set
            if ($ShowDebug -OR ($DebugPreference = "Continue")) {
                $smsg = "Resetting `$DebugPreference from 'Continue' back to default 'SilentlyContinue'" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $showdebug=$false
                # 8:41 AM 10/13/2015 also need to enable write-debug output (and turn this off at end of script, it's a global, normally SilentlyContinue)
                $DebugPreference = "SilentlyContinue" ;
            } # if-E
            $smsg= "#*======^ END PASS:$($ScriptBaseName) ^======" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            if(!$NoTranscriptStop){
                EXIT # trailing tempfile cleanup in the sub main
            } ;
        } #*------^ END Function _cleanup ^------

        #*======^ END FUNCTIONS ^======

        #*======v SUB MAIN  v====== (not really, but it's a landmark for post-functions exec)

        #rx10 -Verbose:$false ;
        #rxo  -Verbose:$false ; cmsol  -Verbose:$false ;

        $sBnr="`n#*======v $(${CmdletName}) : v======" ;
        $smsg = $sBnr ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        # email trigger vari, and email body aggretating log
        $PassStatus = $MailBody = $null ;

        # add try catch as well - this may be making it zero-tolerance and catching all minor errors, disable it
        #Set-StrictMode -Version 2.0 ;

        #region SERVICE_CONNECTIONS #*------v SERVICE CONNECTIONS v------
        #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        # steer all onprem code on $XXXMeta.ExOPAccessFromToro & Ex10Server values
        $UseOP=$false ;
        <#
        if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
            $UseOP = $true ;
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ;
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        } else {
            $UseOP = $false ;
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ;
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        } ;
        #>
        $UseOP=$false ;

        $useEXO = $true ; # non-dyn setting, drives variant EXO reconnect & query code
        if($useEXO){
            #region GENERIC_EXO_CREDS_&_SVC_CONN #*------v GENERIC EXO CREDS & SVC CONN BP v------
            # o365/EXO creds
            <### Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile*
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
            Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
            Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
            Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            ###>
            $o365Cred=$null ;
            if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -UserRole 'CSVC','SID' -verbose:$($verbose))){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                if(get-Variable -Name cred$($tenorg) -scope Script){
                    Remove-Variable -Name cred$($tenorg) -scope Script
                } ;
                New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
                $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                Break ;
            } ;
            <### CALLS ARE IN FORM: (cred$($tenorg))
            $pltRXO = @{Credential = $Credential ; verbose = $($verbose) ; }
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; Silent = $true ;} ;
            if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
            else { reconnect-EXO @pltRXO } ;
            # or with Tenant-specific cred($Tenorg) lookup
            #$pltRXO creds & .username can also be used for AzureAD connections
            Connect-AAD @pltRXO ;
            ###>
            # configure splat for connections: (see above useage)
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; Silent = $true ;} ;
            #endregion GENERIC_EXO_CREDS_&_SVC_CONN #*------^ END GENERIC EXO CREDS & SVC CONN BP ^------
        } # if-E $useEXO

        if($UseOP){
            #region GENERIC_EXOP_CREDS_&_SRVR_CONN #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
            # do the OP creds too
            $OPCred=$null ;
            # default to the onprem svc acct
            $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC','SID'; verbose=$($verbose)} ;
            if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                if(get-Variable -Variable -Name "cred$($tenorg)OP" -scope Script){
                    Remove-Variable -Name "cred$($tenorg)OP" -scope Script ;
                } ;
                New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                Break ;
            } ;
            $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            <# CALLS ARE IN FORM: (cred$($tenorg))
             $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; Silent = $true ; } ;
            Reconnect-Ex2010 @pltRX10 ; # local org conns
            #$pltRx10 creds & .username can also be used for local ADMS connections
            #>
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; Silent = $true ; } ;

            # defer cx10/rx10, until just before get-recipients qry
            #endregion GENERIC_EXOP_CREDS_&_SRVR_CONN #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
            # connect to ExOP X10
            if($pltRX10){
                #ReConnect-Ex2010XO @pltRX10 ;
                ReConnect-Ex2010 @pltRX10 ;
            } else { Reconnect-Ex2010 ; } ;
        } ;  # if-E $useOP

        
        if($UseOP){
            #region GENERIC_ADMS_CONN_&_XO #*------v GENERIC ADMS CONN & XO  v------
            <# already confirmed in modloads
            # load ADMS
            $reqMods += "load-ADMS".split(";") ;
            if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
            #>
            write-host -foregroundcolor gray  "(loading ADMS...)" ;
            #write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):MSG" ;

            load-ADMS -Verbose:$FALSE ;

            # resolve $domaincontroller dynamic, cross-org
            # setup ADMS PSDrives per tenant
            if(!$global:ADPsDriveNames){
                $smsg = "(connecting X-Org AD PSDrives)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $global:ADPsDriveNames = mount-ADForestDrives -verbose:$($verbose) ;
            } ;
            if(($global:ADPsDriveNames|Measure-Object).count){
                $useEXOforGroups = $false ;
                $smsg = "Confirming ADMS PSDrives:`n$(($global:ADPsDriveNames.Name|%{get-psdrive -Name $_ -PSProvider ActiveDirectory} | ft -auto Name,Root,Provider|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                # returned object
                #         $ADPsDriveNames
                #         UserName                Status Name
                #         --------                ------ ----
                #         DOM\Samacctname   True  [forestname wo punc]
                #         DOM\Samacctname   True  [forestname wo punc]
                #         DOM\Samacctname   True  [forestname wo punc]

            } else {
                #-=-record a STATUS=-=-=-=-=-=-=
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                #-=-=-=-=-=-=-=-=
                $smsg = "Unable to detect POPULATED `$global:ADPsDriveNames!`n(should have multiple values, resolved to $()"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                Break ;
            } ;
        } ;
        #if (!$domaincontroller) { $domaincontroller = get-gcfast } ;
        #if(!$domaincontroller){ if(test-path function:get-gcfast){$domaincontroller=get-gcfast} else { throw "no get-gcfast()!" } ;} else {"(existing `$domaincontroller:$($domaincontroller))"} ;
        # use new get-GCFastXO cross-org dc finde
        # default to Op_ExADRoot forest from $TenOrg Meta
        #$domaincontroller = get-GCFastXO -TenOrg $TenOrg -subdomain ((Get-Variable -name "$($TenOrg)Meta").value['OP_ExADRoot']) -verbose:$($verbose) |Where-Object{$_.length};
        #endregion GENERIC_ADMS_CONN_&_XO #*------^ END GENERIC ADMS CONN & XO ^------

        <# 
        #region MSOL_CONNECTION ; #*------v  MSOL CONNECTION v------ 
        $reqMods += "connect-msol".split(";") ;
        if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
        write-host -foregroundcolor gray  "(loading AAD...)" ;
        #connect-msol ;
        connect-msol @pltRXO ;
        #endregion MSOL_CONNECTION ; #*------^  MSOL CONNECTION ^------ 
        #>

        <#
        #region AZUREAD_CONNECTION ; #*------v AZUREAD CONNECTION v------ 
        $reqMods += "Connect-AAD".split(";") ;
        if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
        write-host -foregroundcolor gray  "(loading AAD...)" ;
        #connect-msol ;
        Connect-AAD @pltRXO ;
        #region AZUREAD_CONNECTION ; #*------^ AZUREAD CONNECTION ^------ 
        #>


        <# defined above
        # EXO connection
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            verbose = $($verbose) ; } ;
        #>
        if($VerbosePreference = "Continue"){
            $VerbosePrefPrior = $VerbosePreference ;
            $VerbosePreference = "SilentlyContinue" ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        disconnect-exo ;
        if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
        else { reconnect-EXO @pltRXO } ;
        # reenable VerbosePreference:Continue, if set, during mod loads
        if($VerbosePrefPrior -eq "Continue"){
            $VerbosePreference = $VerbosePrefPrior ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        #endregion SERVICE_CONNECTIONS #*------^ END SERVICE CONNECTIONS ^------


        $error.clear() ;
        TRY {
            # 11:56 AM 4/24/2015 moved below func defs, in sub main
            $archPath = get-ArchivePath ;

            # 12:44 PM 4/24/2015 fine squash any array coming out (till we get it sorted)
            if($archPath -is [system.array]){
                if($bDebug) {Write-Verbose "Flattening `$archpath array" -verbose:$verbose}
                $archPath = $archPath[0] ;
            }  # if-E;

        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(Get-Variable passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(Get-Variable -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ;
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$($smsg)" } ;

            #set-AdServerSettings -ViewEntireForest $false ;

            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ;

        #region CONFIGURE_DEFAULT_LOGGING_FROM_PARENT_SCRIPT_NAME #*======V CONFIGURE DEFAULT LOGGING FROM PARENT SCRIPT NAME v======
        if(!(get-variable LogPathDrives -ea 0)){$LogPathDrives = 'd','c' };
        foreach($budrv in $LogPathDrives){if(test-path -path "$($budrv):\scripts" -ea 0 ){break} } ;
        if(!(get-variable rgxPSAllUsersScope -ea 0)){
            $rgxPSAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps(((d|m))*)1|dll)$" ;
        } ;
        if(!(get-variable rgxPSCurrUserScope -ea 0)){
            $rgxPSCurrUserScope="^$([regex]::escape([Environment]::GetFolderPath('MyDocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps((d|m)*)1|dll)$" ;
        } ;
        $pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($whatif) ;} ;
        $pltSL.Tag = $ticket -join ',' ;
        if($script:PSCommandPath){
            if(($script:PSCommandPath -match $rgxPSAllUsersScope) -OR ($script:PSCommandPath -match $rgxPSCurrUserScope)){
                $bDivertLog = $true ;
                switch -regex ($script:PSCommandPath){
                    $rgxPSAllUsersScope{$smsg = "AllUsers"}
                    $rgxPSCurrUserScope{$smsg = "CurrentUser"}
                } ;
                $smsg += " context script/module, divert logging into [$budrv]:\scripts"
                write-verbose $smsg  ;
                if($bDivertLog){
                    if((split-path $script:PSCommandPath -leaf) -ne $cmdletname){
                        # function in a module/script installed to allusers|cu - defer name to Cmdlet/Function name
                        $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
                    } else {
                        # installed allusers|CU script, use the hosting script name
                        $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $script:PSCommandPath -leaf)) ;
                    }
                } ;
            } else {
                $pltSL.Path = $script:PSCommandPath ;
            } ;
        } else {
            if(($MyInvocation.MyCommand.Definition -match $rgxPSAllUsersScope) -OR ($MyInvocation.MyCommand.Definition -match $rgxPSCurrUserScope) ){
                 $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $script:PSCommandPath -leaf)) ;
            } elseif(test-path $MyInvocation.MyCommand.Definition) {
                $pltSL.Path = $MyInvocation.MyCommand.Definition ;
            } elseif($cmdletname){
                $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
            } else {
                $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$CMDLETNAME, FROM WHICH TO BUILD A START-LOG.PATH!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                BREAK ;
            } ;
        } ;
        write-verbose "start-Log w`n$(($pltSL|out-string).trim())" ;
        $logspec = start-Log @pltSL ;
        $error.clear() ;
        TRY {
            if($logspec){
                $logging=$logspec.logging ;
                $logfile=$logspec.logfile ;
                $transcript=$logspec.transcript ;
                $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                start-Transcript -path $transcript ;
            } else {throw "Unable to configure logging!" } ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ;
        #endregion CONFIGURE_DEFAULT_LOGGING_FROM_PARENT_SCRIPT_NAME #*======^ CONFIGURE DEFAULT LOGGING FROM PARENT SCRIPT NAME ^======



    } # BEGIN-E
    PROCESS{

        $pltHS=@{
            ReportTitle=$null ;
            StartDate=(get-date ([datetime]::Today)).adddays($days * -1) ;
            EndDate=(get-date) ;
            ReportType="MessageTrace" ;
            NotifyAddress=$NotifyAddress ;
        } ;
        if($StartDate){
          $smsg = "(setting `$pltHS.StartDate to `$StartDate)" ;
          if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
          else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
          $pltHS.StartDate = $StartDate
        } ;
        if($EndDate){
            $smsg = "(setting `$pltHS.EndDate to `$EndDate)" ;
          if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
          else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $pltHS.EndDate = $EndDate
        } ;
        if($MessageID){
            $pltHs.add('MessageID',$MessageID) ;
        } ;
        if($ticket){$pltHS.ReportTitle = "$($ticket)-" };
        if($Requester){$pltHS.ReportTitle += "$($Requester) " } ;
        $pltHS.ReportTitle = "$($pltHS.ReportType) " ;
        if($Recipients){
            $pltHS.add("RecipientAddress","$($Recipients)" ) ;
            $pltHS.ReportTitle = "TO-$($recip) " ;
        } ;
        if($Sender){
          $pltHS.add("SenderAddress","$($Sender)" ) ;
          $pltHS.ReportTitle += "FROM-$($Sender) " ;
        } ;
        if($days){
            $pltHS.ReportTitle += "$($days)D-History"    } else {        $pltHS.ReportTitle += "$(get-date $pltHS.StartDate -format 'yyyyMMdd-HHmmtt')" ;
            $pltHS.ReportTitle += "-$(get-date $pltHS.EndDate -format 'yyyyMMdd-HHmmtt')" ;
        } ;

        $smsg = "===Start-ExoHistoricalSearch w `$pltHS:$($pltHS|out-string)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        TRY {
            $HSo=Start-ExoHistoricalSearch @pltHS ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(Get-Variable passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(Get-Variable -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ;
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ;

        $smsg = "===Confirming new HS Job:$($Hso.JobID)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        $error.clear() ;
        TRY {
            $oHSJob = Get-ExoHistoricalSearch -JobID $hSO.jobID ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(Get-Variable passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(Get-Variable -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ;
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ;

        $1F=$false ;
        Do {
            if($1F){Start-Sleep -s 60} ;
            write-host "." -NoNewLine ;
            $1F=$true ;
            $oHSJob = Get-ExoHistoricalSearch -JobID $hSO.jobID ;

            $smsg = "`n$(($oHSJob | ft -auto $propsJob|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        } Until ($oHSJob.status -eq 'Done') ;

        $ofile ="$($ticket)-$($Requester)-EXOHistSrch" ;
        #$ofile+=",$($pltHS.ReportTitle)" ;
        $ofile+=",$(create-AcronymFromCaps $pltHS.ReportType)" ;
        if($pltHS.SenderAddress){$ofile+=",From-$($pltHS.SenderAddress.replace("*","ANY"))" } ;
        if($pltHS.RecipientAddress){$ofile+=",To-$($pltHS.RecipientAddress.replace("*","ANY"))" } ;
        if($pltHS.MessageID){$ofile+=",MsgID-$($pltHS.replace('<','').replace('>','').substring(0,8))" } ;
        $ofile+=",$(get-date $pltHS.StartDate -format 'yyyyMMdd-HHmm')-$(get-date $pltHS.EndDate -format 'yyyyMMdd-HHmm')" ;
        #$ofile+= ",run-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
        $ofile+= ".csv" ;
        $ofile=[RegEx]::Replace($ofile, "[{0}]" -f ([RegEx]::Escape(-join [System.IO.Path]::GetInvalidFileNameChars())), '') ;

        if($env:computername -match $rgxMyWorkstationsW){
            $ofile="c:\usr\work\incid\$($ofile)"
        } else {
            $drvhunt = 'd','c' ;
            foreach($dh in $drvhunt){
                $dhpath = "$($dh):\scripts\logs" ;
                if(test-path $dhpath ){ break } else {$dhpath = $null} ;
            } ;
            if($dhpath){$ofile="$($dhpath)\$($ofile)"}
        } ;

        write-host "`a" ;
        write-host "`a" ;
        write-host "`a" ;
        if($oHSJob.CompletionDate){
            $ts = New-TimeSpan -Start $oHSJob.SubmitDate -End $oHSJob.CompletionDate
        } else {
            $ts = New-TimeSpan -Start $oHSJob.SubmitDate -End (get-date) ;
        } ;
        $msg = "DONE!`n(Report gen took: {0:g} (h:m:s:ms)`n" -f $ts ;
        $msg += "`n$(($oHSJob |fl $propsJobResults |out-string).trim())`n`nUse CSV filename:`n$($ofile)`n" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        $smsg = "(also avail at https://admin.exchange.microsoft.com/#/messagetrace under 'Downloadable reports')" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        $msg = "Post-download, to convert the download .csv to [name]-expanded.csv (MessageTrace csv equivelent) `nconvert-HistoricalSearchCSV.ps1 -ToCSV -Files $($ofile)"  ;
        $smsg += "`nNOTE:MS ENCODING BREAK: Force the encoding when direct import-csv'ing the raw HistSearch .csv! `nimport-csv -encoding unicode -path '$($ofile)'" ;
        #write-host $msg ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;


    }
    END{
        _Cleanup

    } ;
}

#*------^ get-xoHistSearch.ps1 ^------


#*------v get-XOMailboxFolderList.ps1 v------
function get-XOMailboxFolderList {
    <#
	.SYNOPSIS
	get-XOMailboxFolderList - Enumerates all user-accessible folders for the specified Exchange Online mailbox
	.NOTES
	Version     : 1.0.0
	Author      : Vasil Michev
	Website     : https://www.michev.info/blog/post/2500/how-to-reset-mailbox-folder-permissions
	Twitter     :	
	CreatedDate : 2022-06-15
	FileName    : get-XOMailboxFolderList.ps1
	License     : Not Asserted
	Copyright   : Not Asserted
	Github      : https://github.com/michevnew/PowerShell/blob/master/reset-XOMailboxAllFolderPerms.ps1
	Tags        : Powershell,ExchangeOnline,Mailbox,Delegate
	AddedCredit : Todd Kadrie
	AddedWebsite: http://www.toddomation.com
	AddedTwitter: @tostka / http://twitter.com/tostka
	REVISIONS
	* 12:48 PM 9/22/2023 revised (to shift into my verb-exo module for generic use): add/expand CBH; renam ReturnFolderList -> get-XOMailboxFolderList (alias orig name)
	* 6/15/22 vm posted version
	.DESCRIPTION
	get-XOMailboxFolderList - Enumerates all user-accessible folders for the specified Exchange Online mailbox
	PARAMETER SMTPAddress
	Smtp Address of mailbx to be processed
	.INPUTS
    SMTP address of the mailbox.
    .OUTPUTS
    Array with information about the mailbox folders.
	.EXAMPLE
	PS> $folders = get-XOMailboxFolderList -SMTPAddress email@domain.com ; 
	This command will return a list of all user-accessible folders for the specified email address
	.LINK
	https://github.com/tostka/verb-EXO
	#>
    [CmdletBinding()]
    [Alias('ReturnFolderList')]
    PARAM(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true, HelpMessage="Smtp Address of mailbx to be processed")]
            $SMTPAddress
    ) ; 
    #$MBfolders = Invoke-Command -Session $session -ScriptBlock { Get-MailboxFolderStatistics $using:SMTPAddress | Select-Object Name,FolderType,Identity } -HideComputerName -ErrorAction Stop ; 
    # EOM3+ direct, no pssession support
    #$MBfolders = Get-xoMailboxFolderStatistics $SMTPAddress | Select-Object Name,FolderType,Identity -ErrorAction Stop ; 
    #*======v BP Wrapper for running EXO dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp) v======
    # define the splat of all params:
    $pltGMFS = [ordered]@{Identity = $SMTPAddress ; erroraction = 'STOP'; verbose = $($VerbosePreference -eq "Continue") ;} ;
    $cmdlet = 'Get-MailboxFolderStatistics' ; $verb,$noun = $cmdlet.split('-') ;  #Spec cmdletname (VERB-NOUN), & split v/n
    TRY{$xoS = Get-ConnectionInformation -ErrorAction STOP }CATCH{reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP }
    TRY{
        if((-not $xos) -OR ($xoS | ?{$_.tokenstatus -notmatch 'Active|Expired' -AND $_.State -ne 'Connected'} )){reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP } ; 
        if($xos){
            $xcmd = "$verb-$($xoS.ModulePrefix)$noun `@pltGMFS" ; # build cmdline w splat, then echo:
            $smsg = "$($([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value)) w`n$(($pltGMFS|out-string).trim())" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            $MBfolders = invoke-expression $xcmd  | Select-Object Name,FolderType,Identity -ErrorAction Stop ; 
            if($MBfolders){write-verbose "(confirmed valid $([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value) output)" ; }
        } else { 
            $smsg = "Missing `$xos EXO connection!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            throw $smsg ; BREAK ; 
        } 
    } CATCH {
        $ErrTrapd=$Error[0] ;
        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    } ; 
    <# version 12:43 PM 9/21/2023 moved cixo up to 1st, won't have prefix if not populated, also needs to fail/retry to ensure conn;  
    11:48 AM 9/20/2023 minor tweaks ; 3:01 PM 9/19/2023 initial 
    ## this runs: 1) connection status check, w rxo on demand; 2) splat wrapper with integrated prefix support; 3) try/catch on exec; 
    useful alias: cixo => get-connectioninformation;
    #>
    #*======^ END BP wrapper for running dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp)  ^======
    $MBfolders = $MBfolders | ? {($_.FolderType -eq "User created" -or $_.FolderType -in $includedfolders) -and ($_.Name -notin $excludedfolders)} ; 
    if (-not $MBfolders) { return } 
    else { return ($MBfolders | select Name,FolderType,Identity) } ; 
}

#*------^ get-XOMailboxFolderList.ps1 ^------


#*------v Get-xoMailboxFolderPermissionsRecursive.ps1 v------
function Get-xoMailboxFolderPermissionsRecursive {
        <#
        .SYNOPSIS
        Gets the current permissions for all user-accessible folders for a given mailbox.
        .NOTES
        Version     : 0.0.
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 2023-
        FileName    : Get-xoMailboxFolderPermissionsRecursive.ps1
        License     : MIT License
        Copyright   : (c) 2023 Todd Kadrie
        Github      : https://github.com/tostka/verb-XXX
        Tags        : Powershell
        AddedCredit : REFERENCE
        AddedWebsite: URL
        AddedTwitter: URL
        REVISIONS
        * 1:45 PM 9/22/2023 ren Get-MailboxFolderPermissionsRecursive -> Get-xoMailboxFolderPermissionsRecursive (alias orig)
        * 10:47 AM 9/19/2023 rejigger to simply echo what it finds
        .DESCRIPTION
        The Get-xoMailboxFolderPermissionsRecursive cmdlet echoes permissions for all user-accessible folders for the given mailbox(es), specified via the -Mailbox parameter. The list of folders is generated via the get-XOMailboxFolderList function. Configure the $includedfolders and $excludedfolders variables to granularly control the folder list.
        .PARAMETER Mailbox
        Use the -Mailbox parameter to designate the mailbox. Any valid Exchange mailbox identifier can be specified. Multiple mailboxes can be specified in a comma-separated list or array, see examples below.
		.PARAMETER Quiet
		Switch to suppress outputs
        .EXAMPLE
        PS> $mbperms =  Get-xoMailboxFolderPermissionsRecursive -Ticket 999999 -Mailbox user@domain.com.com -OutVariable global:varFolderPermissionsFound ; 
        This command returns all permissions on all user-accessible folders in the user@domain.com mailbox, and tags the output .csv file with the specified ticket number.
        .EXAMPLE
        PS> $return = Get-xoMailboxFolderPermissionsRecursive -Mailbox @('emailaddress@domain.com','emailaddres2s@domain.com') -ResetDefaultLevel -verbose -whatif:$true
        Typical two-user pass as array, using specifying to include reset of all Default levels, with Whatif & verbose, assign output to $return
        .EXAMPLE
        PS> $return = Get-xoMailboxFolderPermissionsRecursive -Mailbox brad.stensrud@toro.com -ticket 760151 ; 
        PS> write-host "`n==Returned permission entries:" ; 
        PS> $return | ft -a ; 
        PS> write-host "==usertype distribution:" ; 
        PS> $return | group usertype |  ft -a count,name ; 
        PS> write-host "==output the subset of UNKNOWN usertype grants:" ; 
        PS> $return |?{$_.usertype -eq 'UNKNOWN'} | ft -a ; 
        PS> write-host "==username distribution:" ; 
        PS> $return |group user |  ft -a count,name ; 
        PS> write-host "==review UserType:Internal & username <> to mailbox owner:" ; 
        PS> write-verbose "derive 'owner' name:Should be the usertype:Internal w AccessRights:OWNER and highest frequency" ; 
        PS> $owner = $return | ?{$_.accessrights -like '*owner*' -AND $_.UserType -eq 'Internal'} | select -expand user | group | sort -desc | select -first 1 name | select -expand name ;
        PS> $return |?{$_.UserType -eq 'Internal' -AND $_.user -ne $owner} | ft -a ; 
        PS> write-host "==Non-Owner Grants:" ; 
        PS> $return |?{$_.user -ne $owner} | ft -a ; 
        PS> write-host "(count:$(($return |?{$_.user -ne $owner} |  measure | select -expand count|out-string).trim()))`n" ; 
        Typical single-user pass with ticket specified, assign output to $return, with range of post analysis examination of returned perm entries
        .EXAMPLE
        PS> write-verbose "Gather folder permissions from target mailbox" ; 
        PS> $mbfp = Get-xoMailboxFolderPermissionsRecursive -Ticket 999999 -Mailbox todd.kadrie@toro.com ; 
        PS> write-host "Echo returned folderperms to console, tabular" ; 
        PS> $mbfp | ft -a ; 
        PS> write-host "echo postfiltered broken-SID perms" ; 
        PS> $mbfp | ?{$_.user -match 'NT:S-1-5-21-'} | ft -a ; 
        PS> write-verbose "Run a removal of each of the broken-SID permissions" ; 
        PS> $mbfp | ?{$_.user -match 'NT:S-1-5-21-'} | %{ remove-xomailboxfolderpermission -id $_.foldername -user $_.user -whatif } ;
        Demo collecting all grants in target mailbox; reviewing return; post-filtering for broken SID entries; and then removing those entries with remove-xoMailboxFolderPermission, whatif pass is specified
        .INPUTS
        A mailbox identifier.
        .OUTPUTS
        Array of Mailbox address, Folder name and User.
        #>
        #Requires -Modules ActiveDirectory, ExchangeOnlineManagement, verb-Auth
        [cmdletbinding()]
        [Alias('Get-MailboxFolderPermissionsRecursive')]
        Param(
            [Parameter(Mandatory=$False,HelpMessage="Ticket Number [-Ticket '999999']")]
                [string]$Ticket,
            [Parameter(Mandatory=$true,ValueFromPipeline=$false,HelpMessage="Use the -Mailbox parameter to designate the mailbox. Any valid Exchange mailbox identifier can be specified. Multiple mailboxes can be specified in a comma-separated list or array, see examples below.")]
                [ValidateNotNullOrEmpty()]
                [Alias("Identity")]
                [String[]]$Mailbox,
            [Parameter(HelpMessage="Switch to suppress outputs")]
                [switch]$Quiet        
        ) ; 
        BEGIN{
            $includedfolders = @("Root","Inbox","Calendar", "Contacts", "DeletedItems", "Drafts", "JunkEmail", "Journal", 
                "Notes", "Outbox", "SentItems", "Tasks", "CommunicatorHistory", "Clutter", "Archive") ; 
            $Defaultfolders = @("Root","Inbox","Calendar", "Contacts", "DeletedItems", "SentItems", "Tasks") #Trimmed down list of default folders
            #Exclude additional Non-default folders created by Outlook or other mail programs. Folder NAMES, not types! So make sure to include translations too!
            #Exclude SearchDiscoveryHoldsFolder and SearchDiscoveryHoldsUnindexedItemFolder as they're not marked as default folders #Exclude "Calendar Logging" on older Exchange versions
            $excludedfolders = @("News Feed","Quick Step Settings","Social Activity Notifications","Suggested Contacts", 
                "SearchDiscoveryHoldsUnindexedItemFolder", "SearchDiscoveryHoldsFolder","Calendar Logging") ; 

            $prpADU = 'DistinguishedName','enabled','samaccountname','sid','UserPrincipalName' ; 
            $DefaultRoleUserNames = @("Default","Anonymous","Owner@local","Member@local") ; 
            if(!$ThrottleMs){$ThrottleMs = 500} ; 
            if( -not (get-variable -name PSScriptRoot -ea 0) -OR ($PSScriptRoot -eq '') -OR ($PSScriptRoot -eq $null)){
            if ($psISE) { $ScriptName = $psISE.CurrentFile.FullPath } 
            elseif($psEditor){
                if ($context = $psEditor.GetEditorContext()) {$ScriptName = $context.CurrentFile.Path } 
            } elseif ($host.version.major -lt 3) {
                $ScriptName = $MyInvocation.MyCommand.Path ;
                $PSScriptRoot = Split-Path $ScriptName -Parent ;
                $PSCommandPath = $ScriptName ;
            } else {
                if ($MyInvocation.MyCommand.Path) {
                    $ScriptName = $MyInvocation.MyCommand.Path ;
                    $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                } else {throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" } ;
            };
            if($ScriptName){
                $ScriptDir = Split-Path -Parent $ScriptName ;
                $ScriptBaseName = split-path -leaf $ScriptName ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($ScriptName) ;
            } ; 
        } else {
            if($PSScriptRoot){$ScriptDir = $PSScriptRoot ;}
            else{
                write-warning "Unpopulated `$PSScriptRoot!" ; 
                $ScriptDir=(Split-Path -parent $MyInvocation.MyCommand.Definition) + "\" ;
            }
            if ($PSCommandPath) {$ScriptName = $PSCommandPath } 
            else {
                $ScriptName = $myInvocation.ScriptName
                $PSCommandPath = $ScriptName ;
            } ;
            $ScriptBaseName = (Split-Path -Leaf ((& { $myInvocation }).ScriptName))  ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
        } ;
        if(-not $ScriptDir){
            write-host "Failed `$ScriptDir resolution on PSv$($host.version.major): Falling back to $MyInvocation parsing..." ; 
            $ScriptDir=(Split-Path -parent $MyInvocation.MyCommand.Definition) + "\" ;
            $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ; 
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;     
        } else {
            if(-not $PSCommandPath ){
                $PSCommandPath  = $ScriptName ; 
                if($PSCommandPath){ write-host "(Derived missing `$PSCommandPath from `$ScriptName)" ; } ;
            } ; 
            if(-not $PSScriptRoot  ){
                $PSScriptRoot   = $ScriptDir ; 
                if($PSScriptRoot){ write-host "(Derived missing `$PSScriptRoot from `$ScriptDir)" ; } ;
            } ; 
        } ; 
        if(-not ($ScriptDir -AND $ScriptBaseName -AND $ScriptNameNoExt)){ 
            throw "Invalid Invocation. Blank `$ScriptDir/`$ScriptBaseName/`ScriptNameNoExt" ; 
            BREAK ; 
        } ; 

        $smsg = "`$ScriptDir:$($ScriptDir)" ;
        $smsg += "`n`$ScriptBaseName:$($ScriptBaseName)" ;
        $smsg += "`n`$ScriptNameNoExt:$($ScriptNameNoExt)" ;
        $smsg += "`n`$PSScriptRoot:$($PSScriptRoot)" ;
        $smsg += "`n`$PSCommandPath:$($PSCommandPath)" ;  ;
        write-verbose $smsg ; 
        #endregion ENVIRO_DISCOVER ; #*------^ END ENVIRO_DISCOVER ^------

            Write-Verbose "Parsing the Mailbox parameter..."
            $SMTPAddresses = @{}
            foreach ($mb in $Mailbox) {
                Start-Sleep -Milliseconds 80 #Add some delay to avoid throttling...
                #*======v BP Wrapper for running EXO dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp) v======
                # define the splat of all params:
                $pltGMbx = [ordered]@{identity =  $mb ; erroraction = 'STOP'; verbose = $($VerbosePreference -eq "Continue") ;} ;
                $cmdlet = 'get-Mailbox' ; $verb,$noun = $cmdlet.split('-') ;  #Spec cmdletname (VERB-NOUN), & split v/n
                TRY{$xoS = Get-ConnectionInformation -ErrorAction STOP }CATCH{reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP }
                TRY{
                    if((-not $xos) -OR ($xoS | ?{$_.tokenstatus -notmatch 'Active|Expired' -AND $_.State -ne 'Connected'} )){reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP } ; 
                    if($xos){
                        $xcmd = "$verb-$($xoS.ModulePrefix)$noun `@pltGMbx" ; # build cmdline w splat, then echo:
                        $smsg = "$($([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value)) w`n$(($pltGMbx|out-string).trim())" ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        $SMTPAddress  = invoke-expression $xcmd  | 
                            Select-Object -ExpandProperty PrimarySmtpAddress -ErrorAction SilentlyContinue;
                        if($SMTPAddress){write-verbose "(confirmed valid $([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value) output)" ; }
                    } else { 
                        $smsg = "Missing `$xos EXO connection!" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        throw $smsg ; BREAK ; 
                    } 
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                    write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                } ; 
                <# version 12:43 PM 9/21/2023 moved cixo up to 1st, won't have prefix if not populated, also needs to fail/retry to ensure conn;  
                11:48 AM 9/20/2023 minor tweaks ; 3:01 PM 9/19/2023 initial 
                ## this runs: 1) connection status check, w rxo on demand; 2) splat wrapper with integrated prefix support; 3) try/catch on exec; 
                useful alias: cixo => get-connectioninformation;
                #>
                #*======^ END BP wrapper for running dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp)  ^======
                if (-not $SMTPAddress) { if (-not $Quiet) { 
                    $smsg = "Mailbox with identifier $mb not found, skipping..." }; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    continue 
                } elseif (($SMTPAddress.count -gt 1) -or ($SMTPAddresses[$mb]) -or ($SMTPAddresses.ContainsValue($SMTPAddress))) { 
                    $smsg = "Multiple mailboxes matching the identifier $mb found, skipping..."; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    continue 
                }else { $SMTPAddresses[$mb] = $SMTPAddress } ; 
            }
            if (-not $SMTPAddresses -or ($SMTPAddresses.Count -eq 0)) { 
                Throw "No matching mailboxes found, check the parameter values." 
            } ; 
            $smsg = "The following list of mailboxes will be used:$($SMTPAddresses.values  -join ", ")" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $smsg = "List of default folder TYPES that will be used:$($includedfolders  -join ", ")" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $smsg = "List of folder NAMES that will be excluded:$($excludedfolders  -join ", ")" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        } ; # BEG-E
        PROCESS {
            $out = @() ; 
            foreach ($smtp in $SMTPAddresses.Values) {
                $sBnrS = $smsg ="`n#*------v PROCESSING Mailbox: $($smtp)... v------" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                Start-Sleep -Milliseconds $ThrottleMs  ; #Add some delay to avoid throttling...
                Write-Verbose "Obtaining folder list for mailbox ""$smtp""..." ; 
                $folders = get-XOMailboxFolderList $smtp ; 
                Write-Verbose "A total of $($folders.count) folders found for $($smtp)." ; 
                if (-not $folders) { 
                    $smsg ="No matching folders found for $($smtp), skipping..." ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    continue 
                } ; 
                #Cycle over each folder we are interested in
                foreach ($folder in $folders) {
                    $smsg = "`n==PROCESSING:$($folder.name)`n" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    #"Fix" for folders with "/" characters, treat the Root folder separately
                    if ($folder.FolderType -eq "Root") { $foldername = $smtp }
                    else { $foldername = $folder.Identity.ToString().Replace([char]63743,"/").Replace($smtp,$smtp + ":") } ; 
                    
                    $fPermissions = get-XOMailboxFolderPermissionsSummary $foldername
                    if (-not $ResetDefaultLevel) { $fPermissions = $fPermissions | ? {$_.UserName -notin @("Default","Anonymous","Owner@local","Member@local")}}  ; #filter out default permissions
                    if (-not $fPermissions) { Write-Verbose "No permission entries found for $($foldername), skipping..." ; continue } ; 
                    #echo the folder permissions for each delegate
                    foreach ($u in $fPermissions) {
                        write-host "`n" ; 
                        if ($u.UserType -eq "Default") {
                            #UserType enumeration https://docs.microsoft.com/en-us/previous-versions/office/developer/exchange-server-2010/ff319704(v%3Dexchg.140)
                            #if ($ResetDefaultLevel) {
                                <# https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes?view=powershell-7.3#the-using-scope-modifier
                                    scope $using: - Used to access variables defined in another scope while running scripts via cmdlets like Start-Job and Invoke-Command.

                                #>
                                TRY {
                                    #write-host -foregroundcolor yellow "Resetting permissions on ""$foldername"" for principal ""Default""." ;
                                    if ($folder.FolderType -eq "Calendar") {
                                        $smsg = "'Default:Calendar entry':" ;
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        #if (($u.AccessRights -join ",") -ne "AvailabilityOnly") {
                                        # TTC customizes the view as LimitedDetails: $CalPermsDefault
                                        if (($u.AccessRights -join ",") -ne $CalPermsDefault) {
                                            #Invoke-Command -Session $session -ScriptBlock { Set-MailboxFolderPermission -Identity $Using:foldername -User Default -AccessRights AvailabilityOnly -WhatIf:$using:WhatIfPreference -Confirm:$false } -ErrorAction Stop -HideComputerName ;
                                            # can't use -session $session with EOM3+, try direct calls; should work
                                            #Set-xoMailboxFolderPermission -Identity $foldername -User Default -AccessRights $CalPermsDefault -WhatIf:$WhatIfPreference -Confirm:$false -ErrorAction Stop ;
                                        } else { continue } ; 
                                        #$outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $folder.name;"User" = $u.UserName;"AccessRights" = "AvailabilityOnly"}) ; 
                                        $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $u.identity;"User" = $u.UserName ; 
                                            UserType = $u.UserType ; 
                                            AccessRights = $u.AccessRights ; 
                                            SharingPermissionFlags = $u.SharingPermissionFlags ; 
                                        }) ;
                                        $out += $outtemp; 
                                        if (-not $Quiet ) { 
                                            #$outtemp | ft -a 
                                            $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        }  ;
                                    } else {
                                        if (($u.AccessRights -join ",") -ne "None") {
                                            $smsg = "'Default:non-NONE entry':" ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                            #Invoke-Command -Session $session -ScriptBlock { Set-MailboxFolderPermission -Identity $Using:foldername -User Default -AccessRights None -WhatIf:$using:WhatIfPreference -Confirm:$false } -ErrorAction Stop -HideComputerName 
                                            # eom3+ no pss
                                            #Set-xoMailboxFolderPermission -Identity $Using:foldername -User Default -AccessRights None -WhatIf:$using:WhatIfPreference -Confirm:$false -ErrorAction Stop ;
                                            # dump these
                                            $smsg = "'non-NONE entry':" ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                        } else { continue } ; 
                                        $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $u.identity;"User" = $u.UserName ; 
                                            UserType = $u.UserType ; 
                                            AccessRights = $u.AccessRights ; 
                                            SharingPermissionFlags = $u.SharingPermissionFlags ; 
                                        }) ;
                                        # echo, don't dump, the END is emitting a full obj stack
                                        $out += $outtemp; 
                                        if (-not $Quiet ) { 
                                            #$outtemp | ft -a 
                                            $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        }  ;
                                    } ; 
                                    #$out += $outtemp; if (-not $Quiet -and -not $WhatIfPreference) { $outtemp }  ; #Write output to the console unless the -Quiet parameter is used
                                } CATCH {$_ | fl * -Force; continue}  ; #catch-all for any unhandled errors
                            #} else { continue } ; 
                        } elseif ($u.UserType -eq "Anonymous") { 
                            # continue #Maybe set them all to none when $resetdefault is used?
                            $smsg = "'Anonymous entry':" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $u.identity;"User" = $u.UserName ; 
                                UserType = $u.UserType ; 
                                AccessRights = $u.AccessRights ; 
                                SharingPermissionFlags = $u.SharingPermissionFlags ; 
                            }) ;
                            $out += $outtemp; 
                            if (-not $Quiet ) { 
                                #$outtemp | ft -a 
                                $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            }  ;
                        } elseif ($u.UserType -eq "Unknown") { 
                            #write-host -foregroundcolor yellow "Skipping orphaned permissions entry: $($u.UserName)"; continue 
                            # actually on reviews, we *want* to see and dump the orphan/corrupt entries:
                            $smsg = "'UNKNOWN entry':" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            # may as well attempt a gadu resolve on the SID
                            if($u.UserName -match '^NT:S-'){
                                $smsg = "(entry UserName appears to be a BROKEN SID (SECURITY IDENTIFYER == DELETED USER OBJECT)" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                write-verbose "(attempting: get-aduser -id $($u.UserName.replace('NT:','')) )" ; 
                                TRY{
                                   if($ADU =  get-aduser -id ($u.UserName.replace('NT:','')) -ErrorAction STOP){
                                        $smsg = "Resolved`n $($u.UserName.replace('NT:',''))`n to an existing ADUser object:`n$(($adu | fl $prpADU |out-string).trim())" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                   }else {
                                        write-warning "Unable to resolve $($u.UserName.replace('NT:','')) to an existing ADUser object (likely deleted TERM)"
                                   } ; 
                           
                                }CATCH{ write-warning "Unable to resolve $($u.UserName.replace('NT:','')) to an existing ADUser object (likely deleted TERM)" }
                            }
                            $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $u.identity;"User" = $u.UserName ; 
                                UserType = $u.UserType ; 
                                AccessRights = $u.AccessRights ; 
                                SharingPermissionFlags = $u.SharingPermissionFlags ; 
                            }) ;
                            #$out += $outtemp; if (-not $Quiet ) { $outtemp | ft -a }  ;
                            # echo, don't dump, the END is emitting a full obj stack
                            $out += $outtemp; 
                            if (-not $Quiet ) { 
                                #$outtemp | ft -a 
                                $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            }  ;
                        } elseif ($u.UserType -eq "Internal") { 
                            #write-host -foregroundcolor yellow "Skipping orphaned permissions entry: $($u.UserName)"; continue 
                            # actually on reviews, we *want* to see and dump the entries:
                            $smsg = "'Internal entry':" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $u.identity;"User" = $u.UserName ; 
                                UserType = $u.UserType ; 
                                AccessRights = $u.AccessRights ; 
                                SharingPermissionFlags = $u.SharingPermissionFlags ; 
                            }) ;
                            $out += $outtemp; 
                            if (-not $Quiet ) { 
                                #$outtemp | ft -a 
                                $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            }  ;
                        } else {
                            if ($u.UserType -eq "External") { $u.User = $u.UserName }
                            TRY {
                                #if (-not $u.User) { continue } ; 
                                #Invoke-Command -Session $session -ScriptBlock { Remove-MailboxFolderPermission -Identity $Using:foldername -User $Using:u.User -WhatIf:$using:WhatIfPreference -Confirm:$false } -ErrorAction Stop -HideComputerName ;
                                # eom3+ no pss
                                #Remove-xoMailboxFolderPermission -Identity $foldername -User $u.User -WhatIf:$WhatIfPreference -Confirm:$false -ErrorAction Stop ;
                                $smsg = "'non-NONE entry':" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $u.identity;"User" = $u.UserName ; 
                                    UserType = $u.UserType ; 
                                    AccessRights = $u.AccessRights ; 
                                    SharingPermissionFlags = $u.SharingPermissionFlags ; 
                                }) ;
                                $out += $outtemp; 
                                if (-not $Quiet ) { 
                                    #$outtemp | ft -a 
                                    $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                }  ;
                            } CATCH [System.Management.Automation.RemoteException] {
                                if (-not $Quiet) {
                                    if ($_.CategoryInfo.Reason -eq "UserNotFoundInPermissionEntryException") { Write-Host "WARNING: No existing permissions entry found on ""$foldername"" for principal ""$($u.UserName)""" -ForegroundColor Yellow }
                                    elseif ($_.CategoryInfo.Reason -eq "CannotChangePermissionsOnFolderException") { Write-Host "ERROR: Folder permissions for ""$foldername"" CANNOT be changed!" -ForegroundColor Red }
                                    elseif ($_.CategoryInfo.Reason -eq "CannotRemoveSpecialUserException") { Write-Host "ERROR: Folder permissions for ""$($u.UserName)"" CANNOT be changed!" -ForegroundColor Red }
                                    elseif ($_.CategoryInfo.Reason -eq "ManagementObjectNotFoundException") { Write-Host "ERROR: Folder ""$foldername"" not found, this should not happen..." -ForegroundColor Red }
                                    elseif ($_.CategoryInfo.Reason -eq "InvalidInternalUserIdException") { Write-Host "ERROR: ""$($u.UserName)"" is not a valid security principal for folder-level permissions..." -ForegroundColor Red }
                                    else {$_ | fl * -Force; continue}  ; #catch-all for any unhandled errors
                                } ;  # if-E !quiet
                            } catch {$_ | fl * -Force; continue} ;#catch-all for any unhandled errors
                        } # if-E
                    }  ; # ACE loop-E
                } ;  # FOLDERS loop-E
                $smsg = $sBnrS.replace('-v','-^').replace('v-','^-') ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            }  # MBX loop-E
        } ;  # PROC-E
        END{
            if ($out) {
                #$out | Export-Csv -Path "$((Get-Date).ToString('yyyy-MM-dd_HH-mm-ss'))_MailboxFolderPermissionsRemoved.csv" -NoTypeInformation -Encoding UTF8 -UseCulture ;
                #$opath = "$((Get-Date).ToString('yyyy-MM-dd_HH-mm-ss'))_MailboxFolderPermissionsRemoved.csv" ; 
                #write-host "Exporting results to the CSV file...`n$($opath)" ;
                #$out | Export-Csv -Path $opath -NoTypeInformation -Encoding UTF8 -UseCulture ;
                [string]$opath = $null ; 
                if($ticket){$opath += "$($TICKET)-" }
                # $opath += "$($item)_MailboxFolderPermissionsRemoved-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ; 
                if(($SMTPAddresses.Values |  measure | select -expand count ) -gt 3){
                    $opath += "$($SMTPAddresses.Values[0]),xxx_MailboxFolderPermissionsRemoved-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ; 
                } else { 
                    $opath += "$($SMTPAddresses.Values -join ',')_MailboxFolderPermissionsRemoved-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ; 
                } ; 
                $oPath = join-path -path (join-path -path $ScriptDir -childpath "logs") -ChildPath $opath ; 
                write-host "Exporting results to the CSV file...`n$($opath)" ;
                $out | Export-Csv -Path $opath -NoTypeInformation -Encoding UTF8 -UseCulture ;
                #Write output to the console unless the -Quiet parameter is used
                #if (-not $Quiet -and -not $WhatIfPreference) { return $out | Out-Default }  ; 
                if (-not $Quiet -and -not $WhatIfPreference) { return $out  }  ; # above is returning as an array of text with no fields; output the object and aggregate it
            } else { write-host -foregroundcolor yellow "Output is empty, skipping the export to CSV file..." } ;
            Write-Verbose "Finish..." ;
        } ; 
    }

#*------^ Get-xoMailboxFolderPermissionsRecursive.ps1 ^------


#*------v get-XOMailboxFolderPermissionsSummary.ps1 v------
function get-XOMailboxFolderPermissionsSummary {
    <#
	.SYNOPSIS
	get-XOMailboxFolderPermissionsSummary - Enumerates all permissions for the given  Exchange Online mailbox folder
	.NOTES
	Version     : 1.0.0
	Author      : Vasil Michev
	Website     : https://www.michev.info/blog/post/2500/how-to-reset-mailbox-folder-permissions
	Twitter     :	
	CreatedDate : 2022-06-15
	FileName    : get-XOMailboxFolderPermissionsSummary.ps1
	License     : Not Asserted
	Copyright   : Not Asserted
	Github      : https://github.com/michevnew/PowerShell/blob/master/reset-XOMailboxAllFolderPerms.ps1
	Tags        : Powershell,ExchangeOnline,Mailbox,Delegate
	AddedCredit : Todd Kadrie
	AddedWebsite: http://www.toddomation.com
	AddedTwitter: @tostka / http://twitter.com/tostka
	REVISIONS
	* 12:48 PM 9/22/2023 revised (to shift into my verb-exo module for generic use): add/expand CBH; renam GetFolderPermissions -> get-XOMailboxFolderPermissionsSummary (alias orig name)
	* 6/15/22 vm posted version
	.DESCRIPTION
	Enumerates all permissions for the given  Exchange Online mailbox folder
	.PARAMETER foldername
	Identifier of the target folder, expressed in 'email@domain.com:\folderpath' format
	..INPUTS
    Identifier for the folder.
    .OUTPUTS
    Array with information about the mailbox folder permissions.
	.EXAMPLE
	PS> $perms = get-XOMailboxFolderPermissionsSummary user@domain.com:\Calendar ; 
	This command will return a list of all user-accessible folders for the specified email address
	.LINK
	https://github.com/tostka/verb-EXO
	#>
	[CmdletBinding()]
	[Alias('GetFolderPermissions')]
    PARAM(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true, HelpMessage="Identifier of the target folder, expressed in 'email@domain.com:\folderpath' format")]
        $foldername
    ) ; 
    <#if (-not $session -or ($session.State -ne "Opened")) { Write-Error "No active Exchange Remote PowerShell session detected, please connect first. To connect to ExO: https://technet.microsoft.com/en-us/library/jj984289(v=exchg.160).aspx" -ErrorAction Stop }
    $FolderPerm = Invoke-Command -Session $session -ScriptBlock { Get-MailboxFolderPermission $using:foldername | Select-Object Identity,User,AccessRights,SharingPermissionFlags } -HideComputerName -ErrorAction Stop |
            select Identity,@{n="User";e={$_.User.RecipientPrincipal.Guid.Guid}},@{n="UserType";e={$_.User.UserType.ToString()}},@{n="UserName";e={$_.User.DisplayName}},AccessRights,SharingPermissionFlags ; 
    #>
    $prpFldrPerm = 'Identity','User','AccessRights','SharingPermissionFlags' ; 
    $prpFldrPermLeaf = 'Identity',
        @{n="User";e={$_.User.RecipientPrincipal.Guid.Guid}},
        @{n="UserType";e={$_.User.UserType.ToString()}},
        @{n="UserName";e={$_.User.DisplayName}},
        'AccessRights','SharingPermissionFlags' ; 
    # looked at adding:.user.RecipientPrincipal.value to above: but User is actually proxying RecipientPrincipal nested guid - wo it, it indicates there's no resolved recipient

    # eom3+ no pssession supp
    #$FolderPerm = Get-xoMailboxFolderPermission $foldername | Select-Object Identity,User,AccessRights,SharingPermissionFlags -ErrorAction Stop |
    #     select Identity,@{n="User";e={$_.User.RecipientPrincipal.Guid.Guid}},@{n="UserType";e={$_.User.UserType.ToString()}},@{n="UserName";e={$_.User.DisplayName}},AccessRights,SharingPermissionFlags ; 
    #*======v BP Wrapper for running EXO dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp) v======
    # define the splat of all params:
    $pltGMFP = [ordered]@{identity = $foldername ;erroraction = 'STOP'; verbose = $($VerbosePreference -eq "Continue") ;} ;
    $cmdlet = 'Get-MailboxFolderPermission' ; $verb,$noun = $cmdlet.split('-') ;  #Spec cmdletname (VERB-NOUN), & split v/n
    TRY{$xoS = Get-ConnectionInformation -ErrorAction STOP }CATCH{reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP }
    TRY{
        if((-not $xos) -OR ($xoS | ?{$_.tokenstatus -notmatch 'Active|Expired' -AND $_.State -ne 'Connected'} )){reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP } ; 
        if($xos){
            $xcmd = "$verb-$($xoS.ModulePrefix)$noun `@pltGMFP" ; # build cmdline w splat, then echo:
            $smsg =  "$($([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value)) w`n$(($pltGMFP|out-string).trim())" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            $FolderPerm = invoke-expression $xcmd  | Select-Object $prpFldrPerm -ErrorAction Stop | 
                Select-Object $prpFldrPermLeaf ; 
            if($FolderPerm){write-verbose "(confirmed valid $([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value) output)" ; }
        } else { 
            $smsg = "Missing `$xos EXO connection!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            throw $smsg ; BREAK ; 
        } 
    } CATCH {
        $ErrTrapd=$Error[0] ;
        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    } ; 
    <# version 12:43 PM 9/21/2023 moved cixo up to 1st, won't have prefix if not populated, also needs to fail/retry to ensure conn;  
    11:48 AM 9/20/2023 minor tweaks ; 3:01 PM 9/19/2023 initial 
    ## this runs: 1) connection status check, w rxo on demand; 2) splat wrapper with integrated prefix support; 3) try/catch on exec; 
    useful alias: cixo => get-connectioninformation;
    #>
    #*======^ END BP wrapper for running dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp)  ^======
    if (-not $FolderPerm) { return }
    else { return $FolderPerm }
}

#*------^ get-XOMailboxFolderPermissionsSummary.ps1 ^------


#*------v import-XoW.ps1 v------
function import-XoW_func {
    <#
    .SYNOPSIS
    import-XoW - import freestanding local invoke-XOWrapper_func.ps1 (back fill lack of xow support in verb-exo mod)
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-07-13
    FileName    : import-XoW_func.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 10:07 AM 3/28/2023 typo, didn't have $ModuleName in trailing w-h
    * 10:20 AM 3/27/2023 completing work, added CBH demo
    * 10:32 AM 3/24/2023 flip wee lxoW into full function call
    .DESCRIPTION
    import-XoW - import freestanding local invoke-XOWrapper_func.ps1 (back fill lack of xow support in verb-exo mod)
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None.
    .EXAMPLE
    PS> if(-not(get-command invoke-XoWrapper -ea 0)){
    PS>     write-verbose "need the _func.ps1 to target, gcm doesn't do substrings, wo a wildcard" ; 
    PS>     if(-not($lmod = get-command import-XoW_func.ps1)){
    PS>         write-verbose "found local $($lmod.source), deferring to..." ; 
    PS>         ipmo -fo -verb $lmod ; 
    PS>     } else {
    PS>         #*------v import-XoW v------
    PS>             ## pasted copy of this function
    PS>         #*------^ import-XoW ^------
    PS>     } ; ;
    PS>     lxoW -verbose ;
    PS> } ; 
    Call as Local override demo for host scripts
    .LINK
    https://github.com/tostka/verb-exo
    #>
    [CmdletBinding()]
    [Alias('lxoW')]
    PARAM(
        [Parameter(Mandatory=$false,HelpMessage="Tenant Tag (3-letter abbrebiation)[-TenOrg 'XYZ']")]
        #[ValidateNotNullOrEmpty()]
        [string]$ModuleName = 'invoke-XOWrapper_func.ps1'
    ) ;
    write-verbose "ipmo invoke-XOWrapper/xOW function" ;
    if($iflpath = get-command $ModuleName | select -expand source){ 
        if(test-path $iflpath){
            $tMod = $iflpath ; 
        }elseif(test-path (join-path -path 'C:\usr\work\o365\scripts\' -childpath $ModuleName)){
            $tMod = (join-path -path 'C:\usr\work\o365\scripts\' -childpath $ModuleName) ;  
        } else {throw 'Unable to locate xoW_func.ps1!' ;
            break ;
        } ;
        if($tmod){
            write-verbose 'Check for preloaded target function' ; 
            if(-not(get-command (split-path $tmod -leaf).replace('_func.ps1',''))){ 
                write-verbose "`$tMod:$($tMod)" ;
                Import-Module -force -verbose $tMod ;
            } else { write-host "($tmod already loaded)" } ;
        } else { write-warning "unable to resolve `$tmod!" } ;
    } else { 
        throw "Unable to locate/gcm $($ModuleName)" ; 
    } ;  
 }

#*------^ import-XoW.ps1 ^------


#*------v Invoke-EXOOnlineConnection.ps1 v------
function Invoke-ExoOnlineConnection{
    <#
    .SYNOPSIS
    Invoke-ExoOnlineConnection.ps1 - EXO non-ending MFA session, that renews it self ; once you connect to EXO with this it will stay open
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2020-11-10
    FileName    : Invoke-ExoOnlineConnection.ps1
    License     : [none specified]
    Copyright   : [none specified]
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : Mahmoud Badran
    AddedWebsite: https://techcommunity.microsoft.com/t5/exchange/60-minutes-timeout-on-mfa-session/m-p/559224
    REVISIONS
    .DESCRIPTION
    Invoke-ExoOnlineConnection.ps1 - EXO non-ending MFA session, that renews it self ; once you connect to EXO with this it will stay open
    normally came as a .ps1 with a local function. Haven't tested, looks like it should work, trick is to preregister the timer/check interval outside of the function, prior to call.
    .PARAMETER  Checktimer
    Switch to trigger a timercheck. [-Checktimer]
    PARAMETERRepairPSSession
    Switch to trigger a session repair. [-RepairPSSession]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output
    .EXAMPLE
    ## Create an Timer instance to trackand recheck status
    $timer = New-Object Timers.Timer
    ## Now setup the Timer instance to fire events
    $timer.Interval = 600000
    $timer.AutoReset = $true  # enable the event again after its been fired
    $timer.Enabled = $true
    ## register your event
    ## $args[0] Timer object
    ## $args[1] Elapsed event properties
    Register-ObjectEvent -InputObject $timer -EventName Elapsed -SourceIdentifier Repair  -Action {Invoke-ExoOnlineConnection -Checktimer}
    .EXAMPLE
    .LINK
    https://github.com/tostka/verb-EXO
    .LINK
    https://techcommunity.microsoft.com/t5/exchange/60-minutes-timeout-on-mfa-session/m-p/559224
    #>
    [cmdletbinding()]
    Param(
        [Parameter(Mandatory=$false,HelpMessage = "Switch to trigger a timercheck. [-Checktimer]")]
        [switch]$Checktimer,
        [Parameter(mandatory=$false, valuefrompipeline=$false,HelpMessage = "Switch to trigger a session repair. [-RepairPSSession]")]
        [switch]$RepairPSSession,
        [Parameter(HelpMessage = "Credential to use for this connection [-credential [credential obj variable]")]
        [System.Management.Automation.PSCredential]$Credential = $global:credo365TORSID
    )
    BEGIN{
        if(!$Global:ErrorActionPreference){$Global:ErrorActionPreference = "Stop"} ; 
        if(!$Global:VerbosePreference){$Global:VerbosePreference = "Continue"} ; 
        #if(!$office365UserPrincipalName){$office365UserPrincipalName = "ADMIN@o365.com" } ; 
        if(!$PSExoPowershellModuleRoot){$PSExoPowershellModuleRoot = (Get-ChildItem -Path $($env:LOCALAPPDATA+"\Apps\2.0\") -Filter CreateExoPSSession.ps1 -Recurse -ErrorAction SilentlyContinue -Force | Select -Last 1).DirectoryName } ; 
        if(!$ExoPowershellModule){$ExoPowershellModule = "Microsoft.Exchange.Management.ExoPowershellModule.dll"} ; 
        if(!$ExoPowershellModulePath){$ExoPowershellModulePath = [System.IO.Path]::Combine($PSExoPowershellModuleRoot, $ExoPowershellModule)} ; 
        if(!(get-module $ExoPowershellModule.replace('.dll','') )){Import-Module $ExoPowershellModulePath -verbose:$false } ; 
    }
    PROCESS{
        #determine if  PsSession is loaded in memory
        $ExosessionInfo = Get-PsSession
        #calculate session time style: $global:_EXO_ExchangeEnvironmentName = $ExchangeEnvironmentName;
        # MS uses these global name
        if ($global:_EXO_ExosessionStartTime){
             $global:_EXO_ExosessionTotalTime = ((Get-Date) - $global:_EXO_ExosessionStartTime)
        }
        #need to loop through each session a user might have opened previously
        foreach ($ExosessionItem in $ExosessionInfo){
            #check session timer to know if we need to break the connection in advance of a timeout. Break and make new after 40 minutes.
            if ($ExosessionItem.ComputerName.Contains("outlook.office365.com") -and $ExosessionItem.State -eq "Opened" -and $global:_EXO_ExosessionTotalTime.TotalSeconds -ge "2400"){
                Write-Verbose -Message "The PowerShell session has been running for $($global:_EXO_ExosessionTotalTime.TotalMinutes) minutes. We need to shut it down and create a new session due to the access token expiration at 60 minutes."
                $ExosessionItem | Remove-PSSession
                Start-Sleep -Seconds 3
                $strSessionFound = $false
                $global:_EXO_ExosessionTotalTime = $null #reset the timer
            } else { Write-Verbose -Message "The PowerShell session has been running for $($global:_EXO_ExosessionTotalTime.TotalMinutes) minutes.)"}
            #Force repair PSSession
            if ($ExosessionItem.ComputerName.Contains("outlook.office365.com") -and $RepairPSSession){
                Write-Verbose -Message "Attempting to repair broken PowerShell session to Exchange Online using cached credential."
                $ExosessionItem | Remove-PSSession
                Start-Sleep -Seconds 3
                $strSessionFound = $false
                $global:_EXO_ExosessionTotalTime = $null
            }elseif ($ExosessionItem.ComputerName.Contains("outlook.office365.com") -and $ExosessionItem.State -eq "Opened"){
                $strSessionFound = $true
            }
        }
        if (!$strSessionFound){
            Write-Verbose -Message "Creating new Exchange Online PowerShell session..."
            try{
                $pltNEXOS = @{
                    ExchangeEnvironmentName         = $ExchangeEnvironmentName ;
                    ConnectionUri                   = "https://outlook.office365.com/powershell-liveid/" ;
                    #AzureADAuthorizationEndpointUri = $AzureADAuthorizationEndpointUri ;
                    UserPrincipalName               = $Credential.username ;
                    PSSessionOption                 = $PSSessionOption ;
                    #Credential                      = $Credential ;
                    BypassMailboxAnchoring          = $($BypassMailboxAnchoring) ;
                    #ShowProgress                    = $($showProgress) # isn't a param of new-exopssessoin, is used with set-exo
                    #DelegatedOrg                    = $DelegatedOrganization ;
                    ErrorAction                      = 'SilentlyContinue' ; 
                    ErrorVariable                    = $newOnlineSessionError ; 
                }
                #$ExoSession  = New-ExoPSSession -UserPrincipalName $Credential.username -ConnectionUri "https://outlook.office365.com/powershell-liveid/" -ErrorAction SilentlyContinue -ErrorVariable $newOnlineSessionError
                write-verbose "New-ExoPSSession w`n$(($pltNEXOS|out-string).trim())" ; 
                $ExoSession  = New-ExoPSSession @pltNEXOS ; 
            }catch{
                Write-Verbose -Message "Throw error..."
                throw;
            } finally {
                if ($newOnlineSessionError) {
                 Write-Verbose -Message "Final error..."
                    throw $newOnlineSessionError
                }
            }
            Write-Verbose -Message "Importing remote PowerShell session..."
            $global:_EXO_ExosessionStartTime = (Get-Date)
            #Import-PSSession $ExoSession -AllowClobber | Out-Null
            Import-PSSession $ExoSession -AllowClobber -DisableNameChecking
        } ;
    } ;
    END{} ;
}

#*------^ Invoke-EXOOnlineConnection.ps1 ^------


#*------v invoke-XOWrapper.ps1 v------
function invoke-XOWrapper  {
    <#
    .SYNOPSIS
     invoke-XOWrapper.ps1 - (alias XoW) Wraps a given ExchangeOnlineManagment module (EOM) cmdlet, with a pre-authentication test and token refresh, to work around (Hybrid Exch bug: 'GetSteppablePipeline' in v2.0.5 of the module, when any basic-authenticated Exchange Onprem session is concurrently open in the session (EOM can't differentiate the EXO session from the ExOP session).
    .NOTES
    Version     : 0.0.1
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    FileName    : invoke-XOWrapper_func.ps1
    CreatedDate : 2022-09-16
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell,ExchangeOnlineManagement,Bug,Workaround
    REVISIONS
    * 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
    * 2:02 PM 4/17/2023 rev: $MinNoWinRMVersion from 2.0.6 => 3.0.0.
    * 2:33 PM 4/13/2023 pull [E]req for verb-exo (merging)
    * 3:19 PM 3/29/2023 REN: $tMod => $EOMModName; $MinNoWinRMVersion IS A PARAM, leaving it unrenamed (other generic code to $EOMMinNoWinRMVersion)
    * 10:16 AM 3/24/2023 ported over the xow_func.ps1 logic (lastest jb vers) into this better-named func, with xow alias.
    * 1:07 PM 12/6/2022 add test for silent support, before adding it to the splat
    * 3:54 PM 11/29/2022:  force the $MinNoWinRMVersion value to the currnet highest loaded:; 
    * 3:24 PM 11/28/2022 move to verb-EXO: ren xoW.ps1 -> invoke-XOWrapper with alias spec'd
    * 2:31 PM 11/23/2022 add: MinNoWinRMVersion param, used to test UseConnEXO, to avoid testing test-exoToken pres (not going to be there -gt v206); updated CBH
         Add: $Credential & -CredentialOP to permit calls from existing scripts with preferred creds
    * 4:33 PM 10/5/2022 CBH exmpl add
    * 10:12 AM 9/16/2022init
    .DESCRIPTION
    invoke-XOWrapper.ps1 - (alias XoW) Wraps a given ExchangeOnlineManagment module (EOM) cmdlet, with a pre-authentication test and token refresh, to work around (Hybrid Exch bug: 'GetSteppablePipeline' in v2.0.5 of the module, when any basic-authenticated Exchange Onprem session is concurrently open in the session (EOM can't differentiate the EXO session from the ExOP session).
    - For ExchangeOnlineManagement v205 or less: Leverages my verb-EXO module:test-EXOToken() wrap of the EOM v205 (and before) internal Test-ActiveToken() function (which has been torn out of EOM v206pre6 forward, as it doesn't use the basic auth that creates the long-unaddressed conflict).
    - ExchangeOnlineManagement v206+ it isn't necessary so it simply wraps & returns the underlying targeted cmdlet (to provide backward compatibility on either v205 or v206+).
    - In general you'll want to use an explicit -Credential, with xow, or it will default to a pre-set cred. (won't match outer session).
    - Note: # bug on reconnect in xow, blowing a $true into the pipe, post-filter it out on return ; 
    $msgstmp = $msgstmp |?{$_.gettype().fullname -ne 'System.boolean'} ;
    - Requires/relies on connection-maintenance functions (aliased below) from my verb-EXO and verb-AAD modules.
    - For use without those modules, replace the...
      dx10 ;  dxo ;  dxo2 ;  daad ;  rxo2 ;  rx10 ;  caad ;
    ... commands with...
      get-psssession | remove-pssession ; 
      Connect-ExchangeOnline -UserPrincipalName ADMINLOGON@DOMAIN ; 
      $ExOPServer="SERVEREXOP" ; $pltNPSS=@{ConnectionURI="http://$ExOPServer/powershell";ConfigurationName='Microsoft.Exchange' ; name='ExchangeOP'} ; 
      $ExPSS = New-PSSession @pltNPSS  ;
      $ExIPSS = Import-PSSession $ExPSS -allowclobber ; 
      Connect-AzureAD -Credential ADMINLOGON@DOMAIN ; 
    ... to use strictly generic EOM, AAD & PS cmdlets for the handling.
    
    - Note: Even with the above changes my verb-EXO module is still a *hard dependancy*, as the EOM:test-ActiveToken() that validates token status *isn't an exported public function* within EOM, 
    and loading it requires manually constructed pathing - .net vs .netcore variants - and an ipmo to get it into memory (hence my test-EXOToken wrapper). 
    .PARAMETER  Command
    ExchangeOnlineManagement module cmdlet to be wrapped and run. Make the target commands *a scriptblock* - Wrap the target in curly-braces - to get multiline defs in without the need for fancy nested quoting, or invoke-expression etc. (alias 'cmd')
    .PARAMETER  Credential
    Credential object
    .PARAMETER MinNoWinRMVersion
    MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']
    .EXAMPLE
    PS> write-verbose ipmo the invoke-XOWrapper module file into memory ; 
    PS> ipmo -fo -verb d:\scripts\invoke-XOWrapper_func.ps1 ; 
    PS> write-verbose run a curly-wrapped scriptblock through the invoke-XOWrapper() function. 
    PS> invoke-XOWrapper {get-xorecipient *somename* | select -expand prim*} ; 
    Load the function from file, then run simple wrap of get-recipient (uses positional parameter spec, to avoid need for -cmd).
    .EXAMPLE
    PS> invoke-XOWrapper -cmd {get-xorecipient *namestring* | ?{$_.PrimarySmtpAddress -like '*@domain.com'}  | select -expand prim*} -verbose ; 
        VERBOSE: (confirm EMO load)
        VERBOSE: (check EMO version)
        VERBOSE: (test for test-exoToken())
        Azure Active Directory - Disconnected
        10:15:57:Connecting to EXOv2:(somID@domain.com)
        True
        20220916 10:16:07:Adding EMS (connecting to serverExOP.sub.domain.com)...

        ComputerName                Availability  State ConfigurationName
        ------------                ------------  ----- -----------------
        serverExOP.sub.domain.com    Available Opened Microsoft.Exchange
        ...
        10:16:13:Authenticating to AAD:toro.com, w somID@domain.com...
        10:16:13:Connect-AzureAD w
        Name                           Value
        ----                           -----
        ErrorAction                    Stop
        TenantID                       549366xxxxba08b
        AccountId                      somID@domain.com
        10:16:14:
        Account                Environment TenantId                             TenantDomain           AccountType
        -------                ----------- --------                             ------------           -----------
        somID@domain.com       AzureCloud  549366xxxxba08b                      TENANT.onmicrosoft.com User
        10:16:14:Connected to Tenant:
        TenantId                             UserId                 LoginType
        --------                             ------                 ---------
        549366xxxxba08b somID@domain.com     LiveId
        10:16:14:(Authenticated to AAD:TOR as somID@domain.com    
        somerecipient@domain.com
    Includes typical reauth output when Token has expired, with verbose output
    .EXAMPLE
    PS> xow -cmd {get-xorecipient *namestring* | ?{$_.PrimarySmtpAddress -like '*@domain.com'}  | select -expand prim*} -verbose ; 
        VERBOSE: (confirm EMO load)
        VERBOSE: (check EMO version)
        VERBOSE: (test for test-exoToken())
        Azure Active Directory - Disconnected
        10:15:57:Connecting to EXOv2:(somID@domain.com)
        True
        20220916 10:16:07:Adding EMS (connecting to serverExOP.sub.domain.com)...

        ComputerName                Availability  State ConfigurationName
        ------------                ------------  ----- -----------------
        serverExOP.sub.domain.com    Available Opened Microsoft.Exchange
        ...
        10:16:13:Authenticating to AAD:toro.com, w somID@domain.com...
        10:16:13:Connect-AzureAD w
        Name                           Value
        ----                           -----
        ErrorAction                    Stop
        TenantID                       549366xxxxba08b
        AccountId                      somID@domain.com
        10:16:14:
        Account                Environment TenantId                             TenantDomain           AccountType
        -------                ----------- --------                             ------------           -----------
        somID@domain.com       AzureCloud  549366xxxxba08b                      TENANT.onmicrosoft.com User
        10:16:14:Connected to Tenant:
        TenantId                             UserId                 LoginType
        --------                             ------                 ---------
        549366xxxxba08b somID@domain.com     LiveId
        10:16:14:(Authenticated to AAD:TOR as somID@domain.com    
        somerecipient@domain.com
    XOW alias call demo. Includes typical reauth output when Token has expired, with verbose output
    .EXAMPLE
    PS>  $xrcp = invoke-XOWrapper {get-xorecipient somealias }
    Demo capturing return (which is dropped into pipeline within invoke-XOWrapper) into a variable ; 
    .EXAMPLE
    PS>  $xrcp = invoke-XOWrapper {get-xorecipient somealias } -credential $pltRXO.Credential -credentialOP $pltRX10.Credential ; 
    Demo passing in specified credentials ; 
    #>
    #Requires -Modules ExchangeOnlineManagement, AzureAD, verb-AAD
    [CmdletBinding()] 
    [Alias('xoW')]
    PARAM(
        [Parameter(Position=0)][Alias('cmd')]
        $command,
        [Parameter(HelpMessage = "EXO Credential to use for this connection [-credential `$credo365]")]
        [System.Management.Automation.PSCredential]$Credential = $global:credo365TORSID,
        [Parameter(HelpMessage = 'ExOP Credential object (for staged hybrid XOP reconnects)[-credentialOP `$credOP]')]
        [System.Management.Automation.PSCredential]$CredentialOP = $credTORSID,
        [Parameter(HelpMessage = "MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']")]
        [version] $MinNoWinRMVersion = '3.0.0'
    ) ; 
    write-verbose "(confirm EMO load)" ; 
    $EOMModName = 'exchangeonlinemanagement' ; 
    if(-not (get-module $EOMModName| sort version | select -last 1 )){ipmo -force $EOMModName} ; 
    $xMod = get-module $EOMModName | sort version | select -last 1 ; 
    write-verbose "(check EMO version)" ; 

    function _Redo-Connection {
        write-verbose "_Redo-Connection..." ; 
        #dx10 ;  dxo ;  dxo2 ;  daad ;  rxo2 ;  rx10 ;  caad ;
        write-verbose "Disconnect-Ex2010" ; $bret = $null ; 
        $bRet = Disconnect-Ex2010 ;  
        if($bRet){
            write-warning "`TRAPPED UNCAPTURED OUTPUT!$bRET:w`n$(($bRet|out-string).trim())" ; 
        } ; 
        write-verbose "Disconnect-EXO" ; $bret = $null ; 
        $bRet = Disconnect-EXO ;  
        if($bRet){
            write-warning "`TRAPPED UNCAPTURED OUTPUT!$bRET:w`n$(($bRet|out-string).trim())" ; 
        } ; 
        write-verbose "Disconnect-EXO2" ; $bret = $null ; 
        $bRet = Disconnect-EXO2 ;  
        if($bRet){
            write-warning "`TRAPPED UNCAPTURED OUTPUT!$bRET:w`n$(($bRet|out-string).trim())" ; 
        } ; 
        write-verbose "Disconnect-AAD" ; $bret = $null ; 
        $bRet = Disconnect-AAD ;  
        if($bRet){
            write-warning "`TRAPPED UNCAPTURED OUTPUT!$bRET:w`n$(($bRet|out-string).trim())" ; 
        } ; 
        if($pltRXO){
            write-verbose "Reconnect-EXO2 @pltRXO" ; $bret = $null ; 
            $bRet =Reconnect-EXO2 @pltRXO ; 
            if($bRet){
                write-warning "`TRAPPED UNCAPTURED OUTPUT!$bRET:w`n$(($bRet|out-string).trim())" ; 
            } ; 
        } else {Reconnect-EXO2 } 
        if($pltRX10){
            write-verbose "ReConnect-Ex2010 @pltRX10" ; $bret = $null ;
            $bRet =ReConnect-Ex2010 @pltRX10  ;  
            if($bRet){
                write-warning "`TRAPPED UNCAPTURED OUTPUT!$bRET:w`n$(($bRet|out-string).trim())" ; 
            } ; 
        } else {Reconnect-Ex2010 } 
        if($pltRXO){
            write-verbose "Connect-AAD @pltRXO" ; $bret = $null ;
            $bRet =Connect-AAD @pltRXO ;
            if($bRet){
                write-warning "`TRAPPED UNCAPTURED OUTPUT!$bRET:w`n$(($bRet|out-string).trim())" ; 
            } ; 
        } else {Connect-AAD} ;         
    } ; 

    #[boolean]$UseConnEXO = [boolean]([version](get-module $EOMModName).version -ge $MinNoWinRMVersion) ; 
    [boolean]$UseConnEXO = [boolean]([version]$xMod.version -ge $MinNoWinRMVersion) ; 
    if([version](get-module $EOMModName| sort version | select -last 1 ).version -ge $MinNoWinRMVersion){
        $smsg = "Found gmo EOM.version -gt `$MinNoWinRMVersion: forcing `$MinNoWinRMVersion to EOM.version" ; 
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        $MinNoWinRMVersion = (get-module $EOMModName| sort version | select -last 1 ).version.tostring() ; 
    }else{
        $smsg = "gmo EOM.version -eq/lt `$MinNoWinRMVersion: using existing `$MinNoWinRMVersion ($MinNoWinRMVersion)" ;  ; 
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
    } ; 

    if($UseConnEXO){
        $smsg = "$($xMod.Name) v$($xMod.Version.ToString()) is GREATER than $($MinNoWinRMVersion):this function is not needed for natively Modern Auth EXO connectivit!" ; 
        $smsg += "`n(proxying command through...)" ; 
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        #Levels:Error|Warn|Info|H1|H2|H3|Debug|Verbose|Prompt        
        #Break ; 
        # should just proxy thru wo testing
        invoke-command $command ;   
    } else {
        if($Credential){
            $pltRXO = @{
                    Credential = $Credential ;
                    #verbose = $($verbose) ;
                    Verbose = $FALSE ; 
            } ;
            if((gcm Reconnect-EXO2).Parameters.keys -contains 'silent'){
                $pltRxo.add('Silent',$false) ;
            } ; 
        } ;
        if($CredentialOP){
            $pltRX10 = @{
                    Credential = $CredentialOP ;
                    #verbose = $($verbose) ;
                    Verbose = $FALSE ; 
            } ;
            if((gcm Reconnect-Ex2010).Parameters.keys -contains 'silent'){
                $pltRX10.add('Silent',$false) ;
            } ;
        } ;
        write-verbose "(test for test-exoToken())" ; 
        try{get-command test-exoToken | out-null }catch{
            

        } ; 
        if(-not(test-exotoken -Credential $pltRXO.Credential)){
            _Redo-Connection ;
        } ;
        $smsg = "invoke-command $($command) ;" ; 
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        <# trying to catch fails in the cmd below, to detect the steppable pipeline error & steer into a reconnect, than retry
            [powershell - Handle errors in ScriptBlock in Invoke-Command Cmdlet - Stack Overflow - stackoverflow.com/](https://stackoverflow.com/questions/12600921/handle-errors-in-scriptblock-in-invoke-command-cmdlet)

            The Invoke-Command argument list is a one way deal. You can either output the error variable in the script e.g. on the last line of the scriptblock put:

            $errortext

            or better yet, just don't capture the error via the -ErrorVariable at all. The scriptblock output, including errors, will flow back to the caller even over a remote connection.

            C:\> Invoke-Command -cn localhost { Get-Process xyzzy } -ErrorVariable errmsg 2>$null
            C:\> $errmsg
            Cannot find a process with the name "xyzzy". Verify the process name and call the cmdlet again.
                + CategoryInfo          : ObjectNotFound: (xyzzy:String) [Get-Process], ProcessCommandException
                + FullyQualifiedErrorId : NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand
                + PSComputerName        : localhost

            In general, I think it is much better to keep errors on the error stream, separated from the normal output.
            edited Oct 2, 2012 at 0:07
            answered Sep 26, 2012 at 13:44
            Keith Hill
            189k4040 gold badges339339 silver badges363
        #>
        TRY{
            #invoke-command $command -ErrorAction STOP ;        
            invoke-command $command -ErrorAction STOP -ErrorVariable errmsg 2>$null
            write-verbose "`$errmsg:`n$(($errmsg|out-string).trim())" ; 
        } CATCH [CmdletInvocationException]{
            $ErrTrapd=$Error[0] ;
            write-warning "`$errmsg:`n$(($errmsg|out-string).trim())" ; 
            $SMSG = "GetSteppablePipeline EOM Hybrid bug detected, disconnect all and reconnect" ; 
            #$smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            <#
            $smsg = $ErrTrapd.Exception.Message ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            BREAK ;
            $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            $smsg = $ErrTrapd.Exception.Message ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            BREAK ;
            #>
            try{get-command test-exoToken | out-null }catch{
                _Redo-Connection  
            } ; 
            if(-not(test-exotoken -credential $pltRXO.credential)){
                _Redo-Connection  
            } ;
             invoke-command $command -ErrorAction STOP ;    

        } CATCH {
            $ErrTrapd=$Error[0] ;
            write-warning "`$errmsg:`n$(($errmsg|out-string).trim())" ; 
            $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            $smsg = $ErrTrapd.Exception.Message ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            BREAK ;            
        } ;
    } ; 
}

#*------^ invoke-XOWrapper.ps1 ^------


#*------v move-MailboxToXo.ps1 v------
function move-MailboxToXo{
    <#
    .SYNOPSIS
    move-MailboxToXo.ps1 - EX Hybrid Onprem-> EXO mailbox move
    .NOTES
    Version: 1.1.13
    Author: Todd Kadrie
    Website:	http://www.toddomation.com
    Twitter:	@tostka, http://twitter.com/tostka
    REVISIONS   :
    * 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
    # 11:44 AM 6/23/2023 sync over again fr 👇🏼 ; completely untested, just pasted in updated params, funcs, and submain block, above trailing write-output .
    # 12:41 PM 3/14/2022 sync'd to latest mods of move-EXOmailboxNow, largely rem'ing the xo AD material, long-broken by undocumented fw chgs.
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 2:40 PM 12/10/2021 more cleanup 
    * 11:24 AM 9/16/2021 encoded eml
    # 10:46 AM 6/2/2021 sub'd verb-logging for v-trans
    * 1:54 PM 5/19/2021 expanded get-hybridcred to use both esvc & sid userroles
    * 11:40 AM 5/14/2021 added -ea 0 to the gv tests (suppresses not-found error when called without logging config)
    # 11:11 AM 5/7/2021 replaced verbose & bdebugs ; fixed missing logging function & added trailing echo of path.
    * 3:55 PM 5/6/2021 update logging, with move to module, it's logging into the ALlusers profile dir
    * 11:05 AM 5/5/2021 refactor into a function, add to verb-exo; ren move-ExoMailboxNow -> move-MailboxToXo
    * 9:54 AM 5/5/2021 removed comment dates; rem'd spurious -domainc param on get-exorecipient
    * 3:15 PM 5/4/2021 v1.1.10 added trailing |?{$_.length} bug workaround for get-gcfastxo.ps1
    * 1:36 PM 3/31/2021 updated rgx to incl jumpboxes; repairs to new cross-org material (subseq to maint-RetPol changes/breaks) ; For some reason nowe requires ; rewrote all connect-reconn's to use central def'd splats AcceptLargeDataLoss in the movereq (wasn't there prev, but worked) ; had shifted out of domaincontroller use (due to new use of get-addomainctontroller returning array's instead of single entries, worked around the issue, put dc's back into queries, to cut down on retry/dawdle. ; updated the re-publish script under description, now echo's requiredvers
    * 9:41 AM 3/30/2021 publishing
    * 9:23 AM 11/17/2020 lots of minor revs, made sure all
    (re)connect-(ex2010|exo)'s had creds, and supported Exov2 switch, replaced
    approp write-verbose -> pswlt blocks ; updated catches to full cred & pswlt
    support ; dbg'd whatif succeessfully. Successfully moved TestNewGenericTodd
    * 9:07 AM 10/26/2020 added EXOv2 support (param, and if/then calls) ;
    * 3:17 PM 10/23/2020 exported xo dc code to new verb-adms:get-gcfastXO() ; now
    fully XO-supporting, determins MigEndPt by cycling $xxxMeta.MepArry
    (semi-colon-delimited string of MEP name;fqdn;regex - regex matches regional
    server DB names and steers the mbx MEP to match).
    * 4:13 PM 10/21/2020 midway through multi-tenant update, left off with:still needs ADMS mount-ADForestDrives() and set-location code @ 395 (had to recode mount-admforestdrives and debug cred production code & infra-string inputs before it would work; will need to dupe to suspend variant on final completion
    * 11:48 AM 4/27/2020 updated for jumpbox/published/installed script, genericized
    * 1:46 PM 2/4/2020 #920 Remove-exoMoveRequest: doesn't like $true on force
    * 12:35 PM 11/26/2019 debugged through issues created by genericizing the domain lookups - still dependant on hard MEP choice mappings on db names - added a default mep chooser that just takes index-0 on the list. Better'n nothing but if CMW has multi-meps, it could pick the wrong one.
    * 12:23 PM 11/22/2019 partial port for x-tenant use, need to get the OPCred spec pulled out of globals too...
    * 7:30 AM 8/14/2019 `$BatchName:revise & add SID
    * 9:38 AM 5/8/2019 added -NoTEST param, to skip MEP tests (no point running 2x, after initial whatif pass)
    * 9:39 AM 1/21/2019 final form used to migrate forwarded mbxs to EXO - RetentPolicy code disabled until we have DL's stocked with population of each target policy, for exempting if they turn up Default DRM Retention Policy again.
    * 8:27 PM 1/18/2019 added -BatchName param, to append later items to an existing Batch, without auto-gening the batchname
    * 7:24 PM 1/18/2019 a LOT of updates, used for forarded mbx moves, 97 - would have used MigrationBatch, but needed to use monitor-exoxxx.ps1 to catch moverequest completion and migrate fowd on the fly
    * 3:59 PM 1/18/2019 spliced in the functions & modloads from convert-OPUserGenerics2Shared.ps1 and the write-log() from check-exolicense.ps1.
    * 10:58 AM 11/27/2018 updated the trailing batch status echo
    * 2:07 PM 11/16/2018 fix typo and incomplete Test-exoMigrationServerAvailability  code, now failure causes it to retsta all MEPs, also removed duped credential prompts
    * 2:19 PM 10/9/2018 correct help text for TargetMailboxes - it's an array, not a comma-delim list
    * 2:49 PM 9/19/2018 added -CompleteEveningOf support and self-determining 6pm/5:30($ADSiteCodeAU) Cutover targets by region/MEP
    * 2:50 PM 9/5/2018 added existingmove pre-removal validated
    * 1:57 PM 9/5/2018 added echo'd replicated-monitoring cmd to the mix, updated move test to check that EXOrecipient has the $TORMeta['o365_TenantDomainMail'] address, or abort move
    * 1:12 PM 8/29/2018 added @$TORMeta['o365_TenantDom'] email addr test and auto-fix, echo of monitoring command to console
    * 1:36 PM 8/27/2018 Added UPN identify (was throwing error: The operation couldn't be performed because 'servicedesk' matches multiple entries.). Also looking up explicit $tmbx obj to pull values from, pretest, supporess prompt for predefined $OPcred ;
    * ident code both move-EXOmailboxNow.ps1 move-EXOmailboxSuspend.ps1 & , only diff is Suspend uses: SuspendWhenReadyToComplete=$TRUE in following;
    $MvSplat=@{
        Identity=$tmbx.userprincipalname ;
        remote=$true;
        RemoteHostName="MEPFQDN.DOMAIN.com" ;
        TargetDeliveryDomain="$TORMeta['o365_TenantDomainMail']" ;
        RemoteCredential=$OPcred ;
        BadItemLimit=1000 ;
        Suspend=$false ;
        SuspendWhenReadyToComplete=$false ;
        BatchName=$Batchname ;
        whatif=$($whatif) ;
    } ;
    .DESCRIPTION
    move-MailboxToXo.ps1 - Non-Suspend Onprem-> EXO mailbox move
    .PARAMETER TargetMailboxes
    Mailbox identifiers(array)[-Targetmailboxes]
    .PARAMETER BatchFile
    CSV file of mailbox descriptors, including at least PrimarySMTPAddress field [-BatchFile c:\path-to\file.csv]
    .PARAMETER BatchName
    Hard-code MoveRequest BatchName
    .PARAMETER Suspend
    Suspend move on creation Flag [-Suspend]
    .PARAMETER NoTEST
    NoTest Flag [-NoTEST]
    .PARAMETER Credential
    Credential to use for this connection [-credential [credential obj variable]")][System.Management.Automation.PSCredential]
    .PARAMETER UserRole
    Role of account (SID|CSID|UID|B2BI|CSVC|ESvc|LSvc)[-UserRole SID]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER silent
    Switch to specify suppression of all but warn/error echos.(unimplemented, here for cross-compat)
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .PARAMETER whatif
    Whatif Flag (DEFAULTED TRUE!) [-whatIf]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    move-MailboxToXo.ps1 -TargetMailboxes ACCOUNT@COMPANY.com -showDebug  -whatIf ;
    Perform immediate move of specified mailbox, with debug output & whtif pass
    .EXAMPLE
    move-MailboxToXo.ps1 -TargetMailboxes ACCOUNT@COMPANY.com -showDebug -notest -whatIf ;
    Perform immediate move of specified mailbox, suppress MEP tests (-NoTest), showdebug output & whatif pass
    .LINK
    https://bitbucket.org/tostka/powershell/
    #>
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
            [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(Position=0,Mandatory=$False,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Mailbox identifiers(array)[-Targetmailboxes]")]
            [ValidateNotNullOrEmpty()]$TargetMailboxes,
        [Parameter(Mandatory=$false,HelpMessage="CSV file of mailbox descriptors, including at least PrimarySMTPAddress field [-BatchFile c:\path-to\file.csv]")]
            [ValidateScript({Test-Path $_})][string]$BatchFile,
        [Parameter(Position=0,HelpMessage="Hard-code MoveRequest BatchName")]
            [string]$BatchName,
        [Parameter(HelpMessage="Suspend move on creation Flag [-Suspend]")]
            [switch] $Suspend,
        [Parameter(HelpMessage="NoTest Flag [-NoTEST]")]
            [switch] $NoTEST,
        [Parameter(HelpMessage="Credential to use for cloud actions [-credential [credential obj variable]")]
            [System.Management.Automation.PSCredential]$Credential,
        # = $global:$credO365TORSID,
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ; 
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ; 
                return $true ; 
            })]
            [string[]]$UserRole = @('SID','CSVC'),
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
            [switch] $useEXOv2=$true,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
                [switch] $silent,
        [Parameter(HelpMessage="Unpromtped run Flag [-showDebug]")]
            [switch] $NoPrompt,
        [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
            [switch] $showDebug,
        [Parameter(HelpMessage="Whatif Flag (DEFAULTED TRUE!) [-whatIf]")]
            [switch] $whatIf=$true
    ) # PARAM BLOCK END

    $verbose = ($VerbosePreference -eq "Continue") ;


    #region INIT; # ------
    #*======v SCRIPT/DOMAIN/MACHINE/INITIALIZATION-DECLARE-BOILERPLATE v======
    # SCRIPT-CONFIG MATERIAL TO SET THE UNDERLYING $DBGPREF:
    if ($Whatif){Write-Verbose -Verbose:$true "`$Whatif is TRUE (`$whatif:$($whatif))" ; };
    # If using WMI calls, push any cred into WMI:
    #if ($Credential -ne $Null) {$WmiParameters.Credential = $Credential }  ;

    # scriptname with extension
    $ScriptDir=(Split-Path -parent $MyInvocation.MyCommand.Definition) + "\" ;
    $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
    $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
    $ComputerName = $env:COMPUTERNAME ;

    # build smtpfrom & to fr Meta
    $smtpFrom = (($scriptBaseName.replace(".","-")) + "@$((Get-Variable  -name "$($TenOrg)Meta").value.o365_OPDomain)") ;
    #$smtpSubj= ("Daily Rpt: "+ (Split-Path $transcript -Leaf) + " " + [System.DateTime]::Now) ;
    $smtpSubj= "Proc Rpt:"   ;
    if($whatif) {
        $smtpSubj+="WHATIF:" ;
    } else {
        $smtpSubj+="PROD:" ;
    } ;
    $smtpSubj+= "$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"   ;
    #$smtpTo=$TORMeta['NotificationAddr1'] ;
    #$smtpTo=$TORMeta['NotificationDlUs'] ;
    $smtpToFailThru="todd.kadrie@toro.com"
    # one bene of looping: no module dependancy, works before modloads occur
    # pull the notifc smtpto from the xxxMeta.NotificationDlUs value
    # non-looping - $TenOrg is an input param, does't need modules to work yet
    if(!$showdebug){
        if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs){
            $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs ;
        }elseif((Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1){
            $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1 ;
        } else {
            $smtpTo=$smtpToFailThru;
        } ;
    } else {
        # debug pass, don't send to main dl, use NotificationAddr1    if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs){
        if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1){
            #set-variable -Name $meta.name -Value ((get-variable -name $meta.name).value  += @{'o365_AcceptedDomains' = (Get-exoAcceptedDomain).domainname} )
            $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1 ;
        } else {
            $smtpTo=$smtpToFailThru ;
        } ;
    }

    $sQot = [char]34 ; $sQotS = [char]39 ;
    $NoProf=[bool]([Environment]::GetCommandLineArgs() -like '-noprofile'); # if($NoProf){# do this};

    #$ProgInterval= 500 ; # write-progress wait interval in ms
    # add gui vb prompt support
    #[System.Reflection.Assembly]::LoadWithPartialName('Microsoft.VisualBasic') | Out-Null ;
    # should use Windows.Forms where possible, more stable

    switch -regex ($env:COMPUTERNAME) {
        ($rgxMyBox) { $LocalInclDir = "c:\usr\work\exch\scripts" ; }
        ($rgxProdEx2010Servers) { $LocalInclDir = "c:\scripts" ; }
        ($rgxLabEx2010Servers) { $LocalInclDir = "c:\scripts" ; }
        #($rgxProdL13Servers) { $LocalInclDir = "c:\scripts" ; }
        # ($rgxLabL13Servers) { $LocalInclDir = "c:\scripts" ; }
        ($rgxAdminJumpBoxes) {
            $LocalInclDir = (split-path $profile) ;
        }
    } ;

    #configure EXO EMS aliases to cover useEXOv2 requirements
    switch ($script:useEXOv2){
        $true {
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):using ExoV2 cmdlets" ;
            #reconnect-eXO2 @pltRXO ;
            set-alias ps1GetXRcp get-xorecipient ;
            set-alias ps1GetXMbx get-xomailbox ;
            set-alias ps1SetXMbx Set-xoMailbox ;
            set-alias ps1GetxUser get-xoUser ;
            set-alias ps1GetXCalProc get-xoCalendarprocessing ;
            set-alias ps1GetXMbxFldrPerm get-xoMailboxfolderpermission ;
            set-alias ps1GetXAccDom Get-xoAcceptedDomain ;
            set-alias ps1GGetXRetPol Get-xoRetentionPolicy ;
            set-alias ps1GetXDistGrp get-xoDistributionGroup ;
            set-alias ps1GetXDistGrpMbr get-xoDistributionGroupmember ;
            set-alias ps1TestXMigrSrvrAvail Test-xoMigrationServerAvailability ;
            set-alias ps1GetXMovReq get-xomoverequest ;
            set-alias ps1RmvXMovReq  Remove-xoMoveRequest ;
            set-alias ps1NewXMovReq  New-xoMoveRequest ;
            set-alias ps1GetXMovReqStats Get-xoMoveRequestStatistics
        }
        $false {
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):using EXO cmdlets" ;
            #reconnect-exo @pltRXO
            set-alias ps1GetXRcp get-exorecipient ;
            set-alias ps1GetXMbx get-exomailbox ;
            set-alias ps1SetXMbx Set-exoMailbox ;
            set-alias ps1GetxUser get-exoUser ;
            set-alias ps1GetXCalProc get-exoCalendarprocessing  ;
            set-alias ps1GetXMbxFldrPerm get-exoMailboxfolderpermission  ;
            set-alias ps1GetXAccDom Get-exoAcceptedDomain ;
            set-alias ps1GGetXRetPol Get-exoRetentionPolicy
            set-alias ps1GetXDistGrp get-exoDistributionGroup  ;
            set-alias ps1GetXDistGrpMbr get-exoDistributionGroupmember ;
            set-alias ps1TestXMigrSrvrAvail Test-exoMigrationServerAvailability ;
            set-alias ps1GetXMovReq get-exomoverequest ;
            set-alias ps1RmvXMovReq  Remove-exoMoveRequest ;
            set-alias ps1NewXMovReq  New-exoMoveRequest ;
            set-alias ps1GetXMovReqStats Get-exoMoveRequestStatistics
        } ;
    } ;  # SWTCH-E useEXOv2

    $Retries = 4 ;
    $RetrySleep = 5 ;
    $DawdleWait = 30 ; # wait time (secs) between dawdle checks
    $DirSyncInterval = 30 ; # AADConnect dirsync interval
    if(!$ThrottleMs){$ThrottleMs = 50 ;} ;
    $CredRole = 'CSVC' ; # role of svc to be dyn pulled from metaXXX if no -Credential spec'd,

    #$LastDays = -3 ;
    #if($LastDays -gt 0){$LastDays = $LastDays * -1 } ; # flip non-negative to negative integer, updated *-1 in the usage line

    if(!$rgxDriveBanChars){$rgxDriveBanChars = '[;~/\\\.:]' ; } ; # ;~/\.:,

    #*======v FUNCTIONS v======

    #-=-=TEMP SUPPRESS VERBOSE-=-=-=-=-=-=
    # suppress VerbosePreference:Continue, if set, during mod loads (VERY NOISEY)
    if($VerbosePreference = "Continue"){
        $VerbosePrefPrior = $VerbosePreference ;
        $VerbosePreference = "SilentlyContinue" ;
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ;
    #*------v  MOD LOADS  v------
    # strings are: "[tModName];[tModFile];tModCmdlet"
    $tMods = @() ;
    $tMods+="verb-Auth;C:\sc\verb-Auth\verb-Auth\verb-Auth.psm1;get-password" ;
    $tMods+="verb-logging;C:\sc\verb-logging\verb-logging\verb-logging.psm1;write-log";
    $tMods+="verb-IO;C:\sc\verb-IO\verb-IO\verb-IO.psm1;Add-PSTitleBar" ;
    $tMods+="verb-Mods;C:\sc\verb-Mods\verb-Mods\verb-Mods.psm1;check-ReqMods" ;
    $tMods+="verb-Text;C:\sc\verb-Text\verb-Text\verb-Text.psm1;Remove-StringDiacritic" ;
    #$tMods+="verb-Desktop;C:\sc\verb-Desktop\verb-Desktop\verb-Desktop.psm1;Speak-words" ;
    $tMods+="verb-dev;C:\sc\verb-dev\verb-dev\verb-dev.psm1;Get-CommentBlocks" ;
    $tMods+="verb-Network;C:\sc\verb-Network\verb-Network\verb-Network.psm1;Send-EmailNotif" ;
    $tMods+="verb-Automation.ps1;C:\sc\verb-Automation.ps1\verb-Automation.ps1\verb-Automation.ps1.psm1;Retry-Command" ;
    #$tMods+="verb-AAD;C:\sc\verb-AAD\verb-AAD\verb-AAD.psm1;Build-AADSignErrorsHash";
    $tMods+="verb-ADMS;C:\sc\verb-ADMS\verb-ADMS\verb-ADMS.psm1;load-ADMS";
    $tMods+="verb-Ex2010;C:\sc\verb-Ex2010\verb-Ex2010\verb-Ex2010.psm1;Connect-Ex2010";
    $tMods+="verb-EXO;C:\sc\verb-EXO\verb-EXO\verb-EXO.psm1;Connect-Exo";
    #$tMods+="verb-L13;C:\sc\verb-L13\verb-L13\verb-L13.psm1;Connect-L13";
    #$tMods+="verb-Teams;C:\sc\verb-Teams\verb-Teams\verb-Teams.psm1;Connect-Teams";
    #$tMods+="verb-SOL;C:\sc\verb-SOL\verb-SOL\verb-SOL.psm1;Connect-SOL" ;
    #$tMods+="verb-Azure;C:\sc\verb-Azure\verb-Azure\verb-Azure.psm1;get-AADBearToken" ;
    foreach($tMod in $tMods){
      $tModName = $tMod.split(';')[0] ; $tModFile = $tMod.split(';')[1] ; $tModCmdlet = $tMod.split(';')[2] ;
      $smsg = "( processing `$tModName:$($tModName)`t`$tModFile:$($tModFile)`t`$tModCmdlet:$($tModCmdlet) )" ;
      if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
      else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
      if($tModName -eq 'verb-Network' -OR $tModName -eq 'verb-Azure'){
          #write-host "GOTCHA!" ;
      } ;
      $lVers = get-module -name $tModName -ListAvailable -ea 0 | sort version | select -last 1 ;
      if($lVers){   $lVers=($lVers | sort version)[-1];   try {     import-module -name $tModName -RequiredVersion $lVers.Version.tostring() -force -DisableNameChecking -Verbose:$false  } catch {     write-warning "*BROKEN INSTALLED MODULE*:$($tModName)`nBACK-LOADING DCOPY@ $($tModDFile)" ;import-module -name $tModDFile -force -DisableNameChecking -verbose:$false  } ;
      } elseif (test-path $tModFile) {
        write-warning "*NO* INSTALLED MODULE*:$($tModName)`nBACK-LOADING DCOPY@ $($tModDFile)" ;
        try {import-module -name $tModDFile -force -DisableNameChecking -Verbose:$false} # force non-verbose, suppress spam
        catch {   write-error "*FAILED* TO LOAD MODULE*:$($tModName) VIA $(tModFile) !" ;   $tModFile = "$($tModName).ps1" ;   $sLoad = (join-path -path $LocalInclDir -childpath $tModFile) ;   if (Test-Path $sLoad) {       Write-Verbose -verbose ((Get-Date).ToString("HH:mm:ss") + "LOADING:" + $sLoad) ;       . $sLoad ;       if ($showdebug) { Write-Verbose -verbose "Post $sLoad" };   } else {       $sLoad = (join-path -path $backInclDir -childpath $tModFile) ;       if (Test-Path $sLoad) {           Write-Verbose -verbose ((Get-Date).ToString("HH:mm:ss") + "LOADING:" + $sLoad) ;           . $sLoad ;           if ($showdebug) { Write-Verbose -verbose "Post $sLoad" };       } else {           Write-Warning ((Get-Date).ToString("HH:mm:ss") + ":MISSING:" + $sLoad + " EXITING...") ;           exit;       } ;   } ; } ;
      } ;
      if(!(test-path function:$tModCmdlet)){
          write-warning -verbose:$true  "UNABLE TO VALIDATE PRESENCE OF $tModCmdlet`nfailing through to `$backInclDir .ps1 version" ;
          $sLoad = (join-path -path $backInclDir -childpath "$($tModName).ps1") ;
          if (Test-Path $sLoad) {     Write-Verbose -verbose:$true ((Get-Date).ToString("HH:mm:ss") + "LOADING:" + $sLoad) ;     . $sLoad ;     if ($showdebug) { Write-Verbose -verbose "Post $sLoad" };     if(!(test-path function:$tModCmdlet)){         write-warning "$((get-date).ToString('HH:mm:ss')):FAILED TO CONFIRM `$tModCmdlet:$($tModCmdlet) FOR $($tModName)" ;     } else {          write-verbose -verbose:$true  "(confirmed $tModName loaded: $tModCmdlet present)"     }
          } else {     Write-Warning ((Get-Date).ToString("HH:mm:ss") + ":MISSING:" + $sLoad + " EXITING...") ;     exit; } ;
      } else {     write-verbose -verbose:$true  "(confirmed $tModName loaded: $tModCmdlet present)" } ;
      if($tModName -eq 'verb-logging'){

            <#
            if($PSCommandPath){   $logspec = start-Log -Path $PSCommandPath -NoTimeStamp -Tag LASTPASS -showdebug:$($showdebug) -whatif:$($whatif) ;
            } else {    $logspec = start-Log -Path ($MyInvocation.MyCommand.Definition) -showdebug:$($showdebug) -whatif:$($whatif) ; } ;
            if($logspec){
                $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                $logging=$logspec.logging ;
                $logfile=$logspec.logfile ;
                $transcript=$logspec.transcript ;
                #Configure default logging from parent script name
                #start-transcript -Path $transcript ;
            } else {throw "Unable to configure logging!" } ;
            #>

      } ;
    } ;  # loop-E
    #*------^ END MOD LOADS ^------
    #-=-=-=-=RE-ENABLE PRIOR VERBOSE-=-=-=-=
    # reenable VerbosePreference:Continue, if set, during mod loads
    if($VerbosePrefPrior -eq "Continue"){
        $VerbosePreference = $VerbosePrefPrior ;
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ;
    #-=-=-=-=-=-=-=-=

    #*------v Function check-ReqMods  v------
    function check-ReqMods ($reqMods){    $bValidMods=$true ;    $reqMods | foreach-object {        if( !(test-path function:$_ ) ) {          write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing $($_) function." ;          $bValidMods=$false ;        }    } ;    write-output $bValidMods ;} ;
    #*------^ END Function check-ReqMods  ^------

    #*======^ END FUNCTIONS ^======

    #*======v SUB MAIN v======

    # email trigger vari, it will be semi-delimd list of mail-triggering events
    $script:PassStatus = $null ;

    # check for $TenOrg & credential alignment
    # with credential un-defaulted, no need to compare $TenOrg & credential
    $tvari = "PassStatus_$($tenorg)" ; if(get-Variable -Name $tvari -scope Script -ea 0){Remove-Variable -Name $tvari -scope Script}
    New-Variable -Name PassStatus_$($tenorg) -scope Script -Value $null ;

    $reqMods+="Add-PSTitleBar;Remove-PSTitleBar".split(";") ;
    #Disconnect-EMSR (variant name in some ps1's for Disconnect-Ex2010)
    #$reqMods+="Reconnect-CCMS;Connect-CCMS;Disconnect-CCMS".split(";") ;
    #$reqMods+="Reconnect-SOL;Connect-SOL;Disconnect-SOL".split(";") ;
    $reqMods+="Test-TranscriptionSupported;Test-Transcribing;Stop-TranscriptLog;Start-IseTranscript;Start-TranscriptLog;get-ArchivePath;Archive-Log;Start-TranscriptLog".split(";") ;
    # add verb-automation content
    $reqMods+="retry-command".split(";") ;
    # lab, fails wo
    $reqMods+="Load-EMSSnap" ;
    # remove dupes
    $reqMods=$reqMods| select -Unique ;
    <#
    $dPref = 'd','c' ; foreach($budrv in $dpref){ if(test-path -path "$($budrv):\scripts" -ea 0 ){ break ;  } ;  } ;
    [regex]$rgxScriptsAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\Scripts" ;
    if($PSCommandPath){
        if($PSCommandPath -match $rgxScriptsAllUsersScope){
            # AllUsers installed script, divert into [$budrv]:\scripts (don't write logs into allusers context folder)
            $logspec = start-Log -Path (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $PSCommandPath -leaf)) -NoTimeStamp -Tag "($TenOrg)-LASTPASS" -showdebug:$($showdebug) -whatif:$($whatif) ;
        }else {
            $logspec = start-Log -Path $PSCommandPath -NoTimeStamp -Tag "($TenOrg)-LASTPASS" -showdebug:$($showdebug) -whatif:$($whatif) ;
        } ;
    } else {
        if($MyInvocation.MyCommand.Definition -match $rgxScriptsAllUsersScope){
            $logspec = start-Log -Path (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $PSCommandPath -leaf)) -NoTimeStamp -Tag "($TenOrg)-LASTPASS" -showdebug:$($showdebug) -whatif:$($whatif) ;
        } else {
            $logspec = start-Log -Path $MyInvocation.MyCommand.Definition -NoTimeStamp -Tag "($TenOrg)-LASTPASS" -showdebug:$($showdebug) -whatif:$($whatif) ;
        } ;
    } ;
    #>
    # 10:29 AM 5/19/2021 splice in curr start-log bloc
    # detect profile installs (installed mod or script), and redir to stock location
    $dPref = 'd','c' ; foreach($budrv in $dpref){ if(test-path -path "$($budrv):\scripts" -ea 0 ){ break ;  } ;  } ;
    [regex]$rgxScriptsModsAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)" ;
    [regex]$rgxScriptsModsCurrUserScope="^$([regex]::escape([environment]::getfolderpath('Mydocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)" ;
    # -Tag "($TenOrg)-LASTPASS" 
    $lTag = @($TargetMailboxes)[0].tostring().substring(0,[System.Math]::Min(12,@($TargetMailboxes)[0].length))
    $pltSLog = [ordered]@{ NoTimeStamp=$false ; Tag=$lTag  ; showdebug=$($showdebug) ;whatif=$($whatif) ;} ;
    if($PSCommandPath){
        if(($PSCommandPath -match $rgxScriptsModsAllUsersScope) -OR ($PSCommandPath -match $rgxScriptsModsCurrUserScope) ){
            # AllUsers or CU installed script, divert into [$budrv]:\scripts (don't write logs into allusers context folder)
            if($PSCommandPath -match '\.ps(d|m)1$'){
                # module function: use the ${CmdletName} for childpath
                $pltSLog.Path= (join-path -Path "$($budrv):\scripts" -ChildPath "$(${CmdletName}).ps1" )  ;
            } else { 
                $pltSLog.Path=(join-path -Path "$($budrv):\scripts" -ChildPath (split-path $PSCommandPath -leaf)) ;
            } ; 
        }else {
            $pltSLog.Path=$PSCommandPath ;
        } ;
    } else {
        if( ($MyInvocation.MyCommand.Definition -match $rgxScriptsModsAllUsersScope) -OR ($MyInvocation.MyCommand.Definition -match $rgxScriptsModsCurrUserScope) ){
            $pltSLog.Path=(join-path -Path "$($budrv):\scripts" -ChildPath (split-path $PSCommandPath -leaf)) ;
        } else {
            $pltSLog.Path=$MyInvocation.MyCommand.Definition ;
        } ;
    } ;
    $smsg = "start-Log w`n$(($pltSLog|out-string).trim())" ;
    if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
    $logspec = start-Log @pltSLog ;
    <#
    if($logspec){
        $logging=$logspec.logging ;
        $logfile=$logspec.logfile ;
        $transcript=$logspec.transcript ;

        if($whatif){
            $logfile=$logfile.replace("-BATCH","-BATCH-WHATIF") ;
            $transcript=$transcript.replace("-BATCH","-BATCH-WHATIF") ;
        } else {
            $logfile=$logfile.replace("-BATCH","-BATCH-EXEC") ;
            $transcript=$transcript.replace("-BATCH","-BATCH-EXEC") ;
        } ;
        if($Ticket){
            $logfile=$logfile.replace("-BATCH","-$($Ticket)") ;
            $transcript=$transcript.replace("-BATCH","-$($Ticket)") ;
        } else {
            $logfile=$logfile.replace("-BATCH","-nnnnnn") ;
            $transcript=$transcript.replace("-BATCH","-nnnnnn") ;
        } ;

        if(Test-TranscriptionSupported){
            $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
            start-transcript -Path $transcript ;
        } ;
    } else {throw "Unable to configure logging!" } ;
    #>
    # reloc batch calc, to include the substring in the log/transcript
    if(!$BatchName){
        $BatchName = "ExoMoves-$($env:USERNAME)" ;
        # include the 1st TargetMailbox fr the param, use first 12 chars (or less)
        $BatchName += '-' + @($TargetMailboxes)[0].tostring().substring(0,[System.Math]::Min(12,@($TargetMailboxes)[0].length)) ;
        if( (@($TargetMailboxes)|measure).count -gt 1 ){
            # append an ellipses to indicate multiple mbxs moved
            $BatchName += '...' ;
        } ;
        $BatchName += "-$(get-date -format 'yyyyMMdd-HHmmtt')" ;
        $smsg= "Using Dynamic BatchName:$($BatchName)" ;
    } else {
        $smsg= "Using -BatchName:$($BatchName)" ;
    } ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    if($logspec){
        $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
        $logging=$logspec.logging ;
        $logfile=$logspec.logfile ;
        $transcript=$logspec.transcript ;
        #Configure default logging from parent script name
        # logfile                        C:\usr\work\o365\scripts\logs\move-EXOmailboxNow-(TOR)-LASTPASS-LOG-BATCH-WHATIF-log.txt
        # transcript                     C:\usr\work\o365\scripts\logs\move-EXOmailboxNow-(TOR)-LASTPASS-Transcript-BATCH-WHATIF-trans-log.txt
        if($Ticket){
            $logfile=$logfile.replace("-BATCH","-$($Ticket)-BATCH") ;
            $transcript=$transcript.replace("-BATCH","-$($Ticket)-BATCH") ;
        } else {
            $logfile=$logfile.replace("-BATCH","-nnnnnn") ;
            $transcript=$transcript.replace("-BATCH","-nnnnnn") ;
        } ;
        $logfile = $logfile.replace('-LASTPASS','').replace('BATCH',(Remove-InvalidFileNameChars -name $BatchName )) ;
        $transcript = $transcript.replace('-LASTPASS','').replace('BATCH',(Remove-InvalidFileNameChars -name $BatchName )) ;
        if(Test-TranscriptionSupported){start-transcript -Path $transcript }
        else { write-warning "$($host.name) v$($host.version.major) does *not* support Transcription!" } ;
    } else {throw "Unable to configure logging!" } ;

    $smsg= "#*======v START PASS:$($ScriptBaseName) v======" ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    <# disable cross-org handling, post tenant migr, no need
    # seeing Curly & Cheech turn up in EX10 queries, pre-purge *any* AD psdrive
    if($existingADPSDrives = get-psdrive -PSProvider ActiveDirectory -ea 0){
        $smsg = "Purging *existing* AD PSDrives found:$(($existingADPSDrives| ft -auto name,provider,root,globalcatalog|out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $error.clear() ;
        TRY {
            $existingADPSDrives | remove-psdrive -Verbose:$($verbose) # -WhatIf:$($whatif) ;
        } CATCH {
            Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($Error[0].Exception.GetType().FullName)]{" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            BREAK ;
        } ;

    } ;

    # also purge the $global:ADPsDriveNames or $script:ADPsDriveNames
    if(gv -name ADPsDriveNames -scope global -ea 0){
        $error.clear() ;
        TRY {
            Remove-Variable -name ADPsDriveNames -Scope Global ;
        } CATCH {
            Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($Error[0].Exception.GetType().FullName)]{" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            BREAK ;
        } ;
    } ;
    if(gv -name ADPsDriveNames -scope script -ea 0){
        $error.clear() ;
        TRY {
            Remove-Variable -name ADPsDriveNames -Scope script ;
        } CATCH {
            Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($Error[0].Exception.GetType().FullName)]{" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            BREAK ;
        } ;
    } ;
    #>
    # $XXXMeta.ExOPAccessFromToro & Ex10Server
    # steer all onprem code
    $UseOP=$false ;
    if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
        $UseOP = $true ;
        $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ;
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
    } else {
        $UseOP = $false ;
        $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ;
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
    } ;

    # TEST
    if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;

    $useEXO = $true ; # non-dyn setting, drives variant EXO reconnect & query code
    if($useEXO){
        #*------v GENERIC EXO CREDS & SVC CONN BP v------
        # o365/EXO creds
        <### Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile*
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
        Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
        .EXAMPLE
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
        Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
        .EXAMPLE
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
        Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
        ###>
        $o365Cred=$null ;
        <# $TenOrg is a mandetory param in this script, skip dyn resolution
        switch -regex ($env:USERDOMAIN){
            "(TORO|CMW)" {$TenOrg = $env:USERDOMAIN.substring(0,3).toupper() } ;
            "TORO-LAB" {$TenOrg = 'TOL' }
            default {
                throw "UNRECOGNIZED `$env:USERDOMAIN!:$($env:USERDOMAIN)" ;
                exit ;
            } ;
        } ;
        #>
        if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -UserRole 'CSVC','ESVC','SID' -verbose:$($verbose))){
            # make it script scope, so we don't have to predetect & purge before using new-variable - except now it does [headcratch]
            $tvari = "cred$($tenorg)" ; if(get-Variable -Name $tvari -scope Script -ea 0){Remove-Variable -Name $tvari -scope Script}
            New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
            $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } else {
            $statusdelta = ";ERROR";
            $script:PassStatus += $statusdelta ;
            set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
            $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
            exit ;
        } ;
        <### CALLS ARE IN FORM: (cred$($tenorg))
        $pltRXO = @{Credential = $Credential ; verbose = $($verbose) ; }
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            verbose = $($verbose) ; } ;
        if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
        else { reconnect-EXO @pltRXO } ;
        # or with Tenant-specific cred($Tenorg) lookup
        #$pltRXO creds & .username can also be used for AzureAD connections
        Connect-AAD @pltRXO ;
        ###>
        # configure splat for connections: (see above useage)
        # downstream commands
        $pltRXO = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
        } ;
        if((gcm Reconnect-EXO).Parameters.keys -contains 'silent'){
            $pltRxo.add('Silent',$silent) ;
        } ;
        # default connectivity cmds - force silent false
        $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$true) ;
        if((gcm Reconnect-EXO).Parameters.keys -notcontains 'silent'){ $pltRxo.remove('Silent') } ; 
        #*------^ END GENERIC EXO CREDS & SVC CONN BP ^------
    } # if-E $useEXO

    if($UseOP){
        #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
        # do the OP creds too
        $OPCred=$null ;
        # default to the onprem svc acct
        $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC','SID'; verbose=$($verbose)} ;
        if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
            # make it script scope, so we don't have to predetect & purge before using new-variable
            $tvari = "cred$($tenorg)OP" ; if(get-Variable -Name $tvari -scope Script -ea 0){Remove-Variable -Name $tvari -scope Script} ; 
            New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
            $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } else {
            $statusdelta = ";ERROR";
            $script:PassStatus += $statusdelta ;
            set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
            $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole $($userrole -join '|') value!"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
            exit ;
        } ;
        $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        <# CALLS ARE IN FORM: (cred$($tenorg))
        $pltRX10 = @{
            Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
            verbose = $($verbose) ; }
        Reconnect-Ex2010 @pltRX10 ; # local org conns
        #$pltRx10 creds & .username can also be used for local ADMS connections
        #>
        $pltRX10 = @{
            Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
            verbose = $($verbose) ; } ;
        # TEST
        if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
        # defer cx10/rx10, until just before get-recipients qry
        #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
        # connect to ExOP X10
        <#
        if($pltRX10){
            ReConnect-Ex2010 @pltRX10 ;
        } else { Reconnect-Ex2010 ; } ;
        #>
    } ;  # if-E $useEXOP


    $smsg= "Using EXOP cred:$($pltRXO.Credential.username)" ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    $smsg= "Using OPCred cred:$($pltRX10.Credential.username)" ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    <# 4:42 PM 6/21/2022 with exo2 hybrid bug, have to move rx10 AFTER rxo
    if($VerbosePreference = "Continue"){
        $VerbosePrefPrior = $VerbosePreference ;
        $VerbosePreference = "SilentlyContinue" ;
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ;
    if($pltRX10){ReConnect-Ex2010 @pltRX10 }
    else { Reconnect-Ex2010 ; } ;
    if($VerbosePrefPrior -eq "Continue"){
        $VerbosePreference = $VerbosePrefPrior ;
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ;
    # which also includes loadadms (old ad/ex bug), must be done after rx10


    # load ADMS
    $reqMods+="load-ADMS".split(";") ;
    if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
    $smsg = "(loading ADMS...)" ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    load-ADMS ;

    # multi-org AD
    #still needs ADMS mount-ADForestDrives() and set-location code @ 395 (had to recode mount-admforestdrives and debug cred production code & infra-string inputs before it would work; will need to dupe to suspend variant on final completion
    #

    if(!$global:ADPsDriveNames){
        $smsg = "(connecting X-Org AD PSDrives)" ;
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        $global:ADPsDriveNames = mount-ADForestDrives -verbose:$($verbose) ;
    } ;
    #>
    # EXO connection


    #$reqMods+="connect-exo;Reconnect-exo;Disconnect-exo".split(";") ;
    if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
    $smsg = "(loading EXO...)" ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    #reconnect-exo -credential $pltRXO.Credential ;
    if ($script:useEXOv2) { reconnect-eXO2 @pltRXOC }
    else { reconnect-EXO @pltRXOC } ;


    # 4:45 PM 6/21/2022 exov2 hybrid bug, move rx10/adms below rxo
    if($VerbosePreference = "Continue"){
        $VerbosePrefPrior = $VerbosePreference ;
        $VerbosePreference = "SilentlyContinue" ;
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ;
    if($pltRX10){ReConnect-Ex2010 @pltRX10 }
    else { Reconnect-Ex2010 ; } ;
    if($VerbosePrefPrior -eq "Continue"){
        $VerbosePreference = $VerbosePrefPrior ;
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ;
    # which also includes loadadms (old ad/ex bug), must be done after rx10


    # load ADMS
    $reqMods+="load-ADMS".split(";") ;
    if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
    $smsg = "(loading ADMS...)" ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    load-ADMS ;

    # multi-org AD
    #still needs ADMS mount-ADForestDrives() and set-location code @ 395 (had to recode mount-admforestdrives and debug cred production code & infra-string inputs before it would work; will need to dupe to suspend variant on final completion
    #

    <#if(!$global:ADPsDriveNames){
        $smsg = "(connecting X-Org AD PSDrives)" ;
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        $global:ADPsDriveNames = mount-ADForestDrives -verbose:$($verbose) ;
    } ;
    #>


    <# RLMS connection
    $reqMods+="Get-LyncServerInSite;load-LMS;Disconnect-LMSR".split(";") ;
    if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
    write-verbose -verbose:$true  "(loading LMS...)" ;
    Reconnect-L13 ;
    #>

    # forestdom is used to build the expected Tenant onmicrosoft address filter
    #$script:forestdom=((get-adforest | select -expand upnsuffixes) |?{$_ -eq (Get-Variable  -name "$($TenOrg)Meta").value.o365_OPDomain}) ;
    #-=-get-gcfastXO use to pull a root domain (or enable-exforestview for OPEX)=-=-=-=-=-
    if($UseOP){
        <# 4:46 PM 6/21/2022 wo functional crossorg, this is all wasted code
        # suppress VerbosePreference:Continue, if set, during mod loads (VERY NOISEY)
        if($VerbosePreference -eq "Continue"){
            $VerbosePrefPrior = $VerbosePreference ;
            $VerbosePreference = "SilentlyContinue" ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        # we need $domaincontroller pop'd whether useCached or not
        # connect to ExOP X10 4:02 PM 3/23/2021 this SHOULDN'T BE A RECONNECT! should be a cold connect, *with* a pre-disconnect! I just watched it skid from TOR to CMW wo dropping connect!
        if($pltRX10){
            #Disconnect-Ex2010 -verbose:$($verbose) ;
            #get-pssession | remove-pssession ;
            # if it's not a multi-tenant process, don't pre-disconnect
            $smsg = "reconnect-Ex2010 w`n$(($pltRX10|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            ReConnect-Ex2010 @pltRX10 ;
        } else { connect-Ex2010 ; } ;
        if($VerbosePrefPrior -eq "Continue"){
            $VerbosePreference = $VerbosePrefPrior ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        # pre-clear dc, before querying
        $domaincontroller = $null ;
        # 3:24 PM 3/ 9/2022 post tenant migr, we aren't doing local anymore, use get-gcfast instead
        #$domaincontroller = get-gcfastxo -TenOrg $TenOrg -Subdomain $subdom -verbose:$($verbose) |?{$_.length};
        $domaincontroller = get-gcfast -verbose:$($verbose) |?{$_.length};
        #>
        <#
        # we don't know which subdoms may be in play
        pushd ; # cache pwd
        if( $tPsd = "$((Get-Variable  -name "$($TenOrg)Meta").value.ADForestName -replace $rgxDriveBanChars):" ){
            if(test-path $tPsd){
                $error.clear() ;
                TRY {
                    set-location -Path $tPsd -ea STOP ;
                    $objForest = get-adforest ;
                    $doms = @($objForest.Domains) ; # ad mod get-adforest vers
                    # do simple detect 2 doms (parent & child), use child (non-parent dom):
                    if(($doms|?{$_ -ne $objforest.name}|measure).count -eq 1){
                        $subdom = $doms|?{$_ -ne $objforest.name} ;
                        $domaincontroller = get-gcfastxo -TenOrg $TenOrg -Subdomain $subdom -verbose:$($verbose) |?{$_.length};
                        $smsg = "get-gcfastxo:returned $($domaincontroller)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } else {
                        # as this is just EX, and not AD search, open the forestview up - all Ex OP qrys will search entire forest
                        enable-forestview
                        $domaincontroller = $null ;
                    } ;
                    $script:forestdom=(($objForest | select -expand upnsuffixes) |?{$_ -eq (Get-Variable  -name "$($TenOrg)Meta").value.o365_OPDomain}) ;
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg= "Failed to exec cmd because: $($ErrTrapd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    popd ; # restore dir
                    Exit #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                } ;
            } else {
                $smsg = "UNABLE TO FIND *MOUNTED* AD PSDRIVE $($Tpsd) FROM `$$($TENorg)Meta!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Exit #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
            } ;
        } else {
            $smsg = "UNABLE TO RESOLVE PROPER AD PSDRIVE FROM `$$($TENorg)Meta!" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Exit #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ;
        popd ; # cd to prior dir
        #>
        # 4:47 PM 6/21/2022 still uses a dc in the getb-mailboxe low
        $domaincontroller = get-gcfast -verbose:$($verbose) |?{$_.length};

    } ; # $useOP
    #-=-=-=-=-=-=-

    # move the domaincontroller lookup code down into the per-user, user's subdomain is required to run get-aduser or Exch cmdlets to find the object.

    #-=-NON-SUSPEND, COMPLETE 1ST PASS:SuspendWhenReadyToComplete=$false, launch Suspend=$false=-=-=-=-=-=-=

    # fall back manual prompt creds
    <#
    if($TORMeta['o365_SIDUpn'] -AND $TORMeta['logon_SID']){
        $EXOMoveID=$TORMeta['o365_SIDUpn'] # EXO UPN-based admin sid
        $OPMoveID=$TORMeta['logon_SID'] ; # # ONPrem EX legacy fmt admin sid
    } ;
    #>
    # tenant & hyb creds already gotten above: EXO:$pltRXO.Credential & Ex10/AD:$pltRX10.Credential

    if(!$ThrottleMs){$ThrottleMs = 500 } ;#amt to throttle per pass, to *try* to stay out of throttling

    write-host "`a`n" ;
    write-host -foregroundcolor green "DID YOU PRECONVERT SECURITY GRPS & DUMP ACLS!?" ;
    write-host "`a`n" ;
    if($NoPrompt){
        $smsg = "(-NoPrompt: skipping interactive)" ;
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        $bRet = 'YYY'
    }else{
        $bRet=Read-Host "Enter YYY to continue. Anything else will exit"
    } ;
    if ($bRet.ToUpper() -eq "YYY") {
         Write-host "Moving on"
    } else {
         Write-Host "Invalid response. Exiting"
         # exit <asserted exit error #>
         exit 1
    } # if-block end

    <# timezone standards:
    $cstzone = [System.TimeZoneInfo]::FindSystemTimeZoneById("Central Standard Time") ;
    $AUCSTzone = [System.TimeZoneInfo]::FindSystemTimeZoneById("Cen. Australia Standard Time") ;
    $GMTzone = [System.TimeZoneInfo]::FindSystemTimeZoneById("GMT Standard Time") ;
    #>

    <#
    if($global:credo365TORSID){$exocred = $global:credo365TORSID}
    else {$exocred = Get-Credential -credential $EXOMoveID } ;

    if($global:credTORSID){$pltRX10.Credential = $global:credTORSID}
    else {$pltRX10.Credential = Get-Credential -credential $OPMoveID} ;
    #>
    <# rem it, don't want to trigger the exov2 bug, assume it's always functional, post above connect
    if($pltRX10){
        ReConnect-Ex2010 @pltRX10 ;
    } else { Reconnect-Ex2010 ; } ;
    #>

    if($BatchFile){
        $smsg= "Using -BatchName:$($BatchName)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $TargetMailboxes=import-csv -path $BatchFile | select -expand PrimarySMTPAddress;
    } elseif ($Targetmailboxes){
        # defer to parameter version
    }else {
        $smsg= "MISSING `$BATCHFILE, ABORTING!" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        Cleanup
    } ;  ;

    # moved batchname calc up to logging area (to include in log)

    #if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
    #else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    $ttl=($TargetMailboxes|measure).count ;
    $Procd=0 ;

    foreach($tMbxId in $TargetMailboxes){
        $Procd++ ;
        $sBnr="#*======v `$tmbx:($($Procd)/$($ttl)):$($tMbxId) v======" ;
        $smsg="$($sBnr)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        if ($script:useEXOv2) { reconnect-eXO2 @pltRXOC }
        else { reconnect-EXO @pltRXOC } ;

        # use new get-GCFastXO cross-org dc finder
        #$domaincontroller = get-GCFastXO -TenOrg $TenOrg -ADObject $tMbxId -verbose:$($verbose) ;
        <# post tenantmigr, no point
        #-=-=use new get-GCFastXO cross-org dc finder against a TenOrg and -ADObject-=-=-=-=-=-=
        $domaincontroller = $null ; # pre-clear, ensure no xo carryover
        if($tMbxId){
            # the get-addomaincontroller is returning an array; use the first item (second is blank)
            $domaincontroller = get-GCFastXO -TenOrg $TenOrg -ADObject $tMbxId -verbose:$($verbose) |?{$_.length} ;
        } else {throw "unpopulated `$TargetMailboxes parameter, unable to resolve a matching OR OP_ExADRoot property" ; } ;
        #-=-=-=-=-=-=-=-=
        #>

        # issue is that 2 objects are coming back: first is null, 2nd is the dc spec
        $Exit = 0 ;
        Do {
            Try {
                if(!(get-AdServerSettings).ViewEntireForest){ enable-ForestView } ;
                $ombx=get-mailbox -id $tMbxId -domaincontroller $domaincontroller ;
                # dc issues, drop it, and use dawdles
                #$ombx=get-mailbox -id $tMbxId  ;

                $Exit = $Retries ;
            } Catch {
                $smsg = "Failed to exec cmd because: $($Error[0])" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Start-Sleep -Seconds $RetrySleep ;
                    if($pltRX10){
                        ReConnect-Ex2010 @pltRX10 ;
                    } else { Reconnect-Ex2010 ; } ;
                $Exit ++ ;
                $smsg = "Try #: $Exit" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" }
                If ($Exit -eq $Retries) {
                    $smsg = "Unable to exec cmd!"
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;
            }  ;
        } Until ($Exit -eq $Retries) ;

        $rgxTenDomAddr = 'smtp:.*@\w*.mail.onmicrosoft.com' ;
        $rgxTenDomEAP = '^smtp:.*(\@\w*\.mail\.onmicrosoft.com)$'
        #$TenantDomainMail=$TORMeta['o365_TenantDomainMail'] ;
        $TenantDomainMail=(Get-Variable  -name "$($TenOrg)Meta").value.o365_TenantDomainMail ;

        # dynamically pull the onmicrosoft address from lowest priority policy
        $error.clear() ;
        TRY {
            ((get-emailaddresspolicy | sort priority -desc)[0] | select -expand EnabledEmailAddressTemplates|?{$_ -match $rgxTenDomEAP }) | out-null ;
            $OnMicrosoftAddrDomain=$matches[1] ;
        } CATCH {
            $smsg = "Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Exit #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
            # -Variable -Name PassStatus_$($tenorg) -scope Script -Value $null ;
        } ;

        if($ombx){

            if($tenantCoAddr=$ombx | select -expand emailaddresses | ?{$_ -match $rgxTenDomAddr}){
                $smsg= "mbx HAS matching address:$($tenantCoAddr)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                # moved the $OnMicrosoftAddrDomain lookup outside of the if/then
                if($OnMicrosoftAddrDomain){
                    $smsg= "mbx MISSING @TENANTDOM.mail.onmicrosoft.com:$($addr.PrimarySMTPAddress)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN} #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    # precheck for addrs
                    $smsg= "SMTP Addrs:`n$(($ombx | Select -Expand EmailAddresses | ? {$_ -like "smtp:*"}|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $ombx | Select -Expand EmailAddresses | ? {$_ -like "smtp:*"} ;
                    $smsg= "EAP Settings:`n$(($ombx|fl EmailAddressPolicyEnabled,CustomAttribute5|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $newOnMSAddr="$($ombx.alias)$($OnMicrosoftAddrDomain)" ;
                    $spltSetmailbox=@{
                        identity=$ombx.samaccountname ;
                        #domaincontroller= $domaincontroller ;
                        EmailAddresses= @{add="$($newOnMSAddr)"} ;
                        whatif=$($whatif) ;
                    } ;

                    $smsg= "Set-Mailbox w`n$(($spltSetmailbox|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    $smsg= "emailaddresses (expanded):`n$(($spltsetmailbox.emailaddresses |out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    $Exit = 0 ;
                    Do {
                        Try {
                            Set-Mailbox @spltSetmailbox ;
                            $Exit = $Retries ;
                        } Catch {
                            $smsg = "Failed to exec cmd because: $($Error[0])" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Start-Sleep -Seconds $RetrySleep ;
                            if($pltRX10){
                                ReConnect-Ex2010 @pltRX10 ;
                            } else { Reconnect-Ex2010 ; } ;
                            $Exit ++ ;
                            $smsg = "Try #: $Exit" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" }
                            If ($Exit -eq $Retries) {
                                $smsg = "Unable to exec cmd!"
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } ;
                        }  ;
                    } Until ($Exit -eq $Retries) ;

                    $1F=$false ;Do {
                        if($1F){Sleep -s 5} ;  write-host "." -NoNewLine ; $1F=$true ;
                        Try {
                            $ombx=get-Mailbox $ombx.samaccountname
                        } CATCH {
                            Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
                            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($Error[0].Exception.GetType().FullName)]{" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                        } ;
                    } Until ($ombx.emailaddresses -like '*.onmicrosoft.com') ;

                    $smsg= "`nUpdated Addrs:`n$(( $ombx.EmailAddresses |?{$_ -match 'smtp:.*'}|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):MONITORING COMMAND FOR ABOVE:" ;
                    "Do {write-host '.' -NoNewLine;Start-Sleep -m (1000 * 60)} Until (Get-exoRecipient $($ombx.userprincipalname) -ea 0| select -expand emailaddresses|?{$_ -like '*@$($TenantDomainMail)'}) ; write-host '``a' "

                } else{
                    $smsg= ":mbx MISSING @$($TenantDomainMail):$($addr.PrimarySMTPAddress)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                    else{ write-host -foregroundcolor RED "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;

                if($tenantCoAddr=$ombx | select -expand emailaddresses | ?{$_ -match [regex]'smtp:.*@$($TenantDomainMail)'}){
                    $smsg= "mbx HAS matching address:$($tenantCoAddr)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } else {
                    $smsg= "mbx MISSING @$($TenantDomainMail):$($addr.PrimarySMTPAddress)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                    else{ write-host -foregroundcolor RED "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;

            } ;

            $Exit = 0 ;
            Do {
                Try {
                    #$exorcp=Get-exoRecipient $($ombx.userprincipalname) -ea 0| select -expand emailaddresses|?{$_ -match $rgxTenDomAddr} ;
                    # go back to using static dc
                    $exorcp=Get-exoRecipient $($ombx.userprincipalname) ;
                    $Exit = $Retries ;
                } Catch {
                    $smsg = "Failed to exec cmd because: $($Error[0])" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Start-Sleep -Seconds $RetrySleep ;
                    if($pltRX10){
                        ReConnect-Ex2010 @pltRX10 ;
                    } else { Reconnect-Ex2010 ; } ;
                    $Exit ++ ;
                    $smsg = "Try #: $Exit" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" }
                    If ($Exit -eq $Retries) {
                        $smsg = "Unable to exec cmd!"
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                }  ;
            } Until ($Exit -eq $Retries) ;

            if($exorcp){
                # use the cached obj
                #$RemoteHostName = ($MigEnd|?{$_.remoteserver -like 'my*'})[0].remoteserver ;
                $MvSplat=[ordered]@{
                    Identity=$ombx.userprincipalname ;
                    remote=$true;
                    #RemoteHostName=$RemoteHostName ;
                    RemoteHostName=$null ;
                    TargetDeliveryDomain= $OnMicrosoftAddrDomain.replace('@','') # @$($TenantDomainMail)
                    RemoteCredential=$pltRX10.Credential ;
                    BadItemLimit=1000 ;
                    AcceptLargeDataLoss=$true ;
                    Suspend=$false ;
                    SuspendWhenReadyToComplete=$false ;
                    BatchName=$Batchname ;
                    whatif=$($whatif) ;
                } ;

                #
                $tMEPID=$null ;
                if((Get-Variable  -name "$($TenOrg)Meta").value.MEPArray){
                        #set-variable -Name $meta.name -Value ((get-variable -name $meta.name).value  += @{'o365_AcceptedDomains' = (Get-exoAcceptedDomain).domainname} )
                        #$smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1 ;
                        # loop the MepArray members, till you find the one the mbx.db matches on, then use it's MEPID
                        foreach($MA in (Get-Variable  -name "$($TenOrg)Meta").value.meparray){
                            #$ombx.Database
                            if($ombx.Database -match $MA.split(';')[2]){
                                $tMEPID = $MA.split(';')[1] ;
                                break ;
                            } ;
                        } ;
                } else {
                    $smsg = "UNABLE TO RESOLVE `$($TenOrg)Meta.MEPArray" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                    else{ write-host -foregroundcolor RED "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    throw $smsg ;
                } ;
                if($tMEPID){$MvSplat.RemoteHostName= $tMepID}
                else {
                    $smsg = "`$tMEPID undefined!" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                    else{ write-host -foregroundcolor RED "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    throw $smsg ;
                } ;

                if(!$NoTEST){
                    $tMEPID |foreach-object {
                        $error.clear() ;
                        TRY {
                            $smsg= "Testing OnPrem Admin account $($pltRX10.Credential.username) against $($_)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            if ($script:useEXOv2) { reconnect-eXO2 @pltRXOC }
                            else { reconnect-EXO @pltRXOC } ;
                            $oTest= ps1TestXMigrSrvrAvail -ExchangeRemoteMove -RemoteServer $_ -Credentials $pltRX10.Credential ;
                        } CATCH {
                            $smsg= "Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                            else{ write-host -foregroundcolor RED "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $bMEPFail=$true ;
                            #Exit #Opts: STOP(debug)|EXIT(close)|Continue(move on in loop cycle)
                            Continue
                        } # try/catch-E ;
                        $smsg= $oTest ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                } else {
                    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):-NoTEST param detected: Skipping MEP tests" ;
                } ;

                <# version that keys suspend off of explicit script name
                switch -regex ($ScriptBaseName){
                    "^move-EXOmailboxSuspend\.ps1$" {
                        $smsg= "Configuring:SuspendWhenReadyToComplete=`$TRUE" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } ; #Error|Warn
                        $MvSplat.SuspendWhenReadyToComplete=$true ;
                    }
                    "^move-EXOmailboxNow\.ps1$" {
                        $smsg= "Configuring:SuspendWhenReadyToComplete=`$FALSE" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } ; #Error|Warn
                        $MvSplatSuspendWhenReadyToComplete=$false ;
                    }
                    default {throw "Unrecognized FILENAME:$($ScriptNameNoExt)"}
                } ;
                #>
                # switch to explicit -Suspend param (for move into verb-exo module): $Suspend
                if($Suspend){
                    $smsg= "-Suspend specified: Configuring:SuspendWhenReadyToComplete=`$TRUE" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $MvSplat.SuspendWhenReadyToComplete=$true ;
                } else {
                    $smsg= "Configuring:SuspendWhenReadyToComplete=`$FALSE" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $MvSplat.SuspendWhenReadyToComplete=$false ;
                } ;

                $Exit = 0 ;
                Do {
                    Try {
                        $existMove=ps1GetXMovReq -Identity $mvsplat.identity -ea 0 ;
                        $Exit = $Retries ;
                    } Catch {
                        $smsg = "Failed to exec cmd because: $($Error[0])" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Start-Sleep -Seconds $RetrySleep ;
                        if($pltRX10){
                            ReConnect-Ex2010 @pltRX10 ;
                        } else { Reconnect-Ex2010 ; } ;
                        $Exit ++ ;
                        $smsg = "Try #: $Exit" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" }
                        If ($Exit -eq $Retries) {
                            $smsg = "Unable to exec cmd!"
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ;
                    }  ;
                } Until ($Exit -eq $Retries) ;

                if($existMove){
                    $smsg= "==Removing ExistMove:$($existMove.alias)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    $Exit = 0 ;
                    Do {
                        Try {
                            # add force confirm, it prompted to purge some priors
                            ps1RmvXMovReq $existMove.alias -force:$true -confirm:$false -whatif:$($whatif) ;
                            $Exit = $Retries ;
                        } Catch {
                            $smsg = "Failed to exec cmd because: $($Error[0])" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Start-Sleep -Seconds $RetrySleep ;
                            if ($script:useEXOv2) { reconnect-eXO2 @pltRXOC }
                            else { reconnect-EXO @pltRXOC } ;
                            $Exit ++ ;
                            $smsg = "Try #: $Exit" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" }
                            If ($Exit -eq $Retries) {
                                $smsg = "Unable to exec cmd!"
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } ;
                      }  ;

                    } Until ($Exit -eq $Retries) ;


                    "(waiting for move to purge)" ;
                    Do {write-host "." -NoNewLine;Start-Sleep -m (1000 * 10)} Until (!(ps1GetXMovReq -Identity $mvsplat.identity -ea 0))
                } ;

                $smsg= "===$($ombx.UserPrincipalName):$((get-alias ps1NewXMovReq).definition) w`n$(($mvSplat|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                $Exit = 0 ;
                Do {
                    Try {
                        ps1NewXMovReq @MvSplat;
                        $Exit = $Retries ;
                    } Catch {
                        $smsg = "Failed to exec cmd because: $($Error[0])" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Start-Sleep -Seconds $RetrySleep ;
                        if ($script:useEXOv2) { reconnect-eXO2 @pltRXOC }
                        else { reconnect-EXO @pltRXOC } ;
                        $Exit ++ ;
                        $smsg = "Try #: $Exit" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" }
                        If ($Exit -eq $Retries) {
                            $smsg = "Unable to exec cmd!"
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ;
                    }  ;
                } Until ($Exit -eq $Retries) ;

            } else {
                $smsg= "===$($ombx.userprinciplname) missing $((Get-Variable  -name "$($TenOrg)Meta").value.o365_TenantDom) address at EXO END.`nSKIPPING EXO MOVE!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                else{ write-host -foregroundcolor RED "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
        } else {
                $smsg= "===$($tMbxId):NOT FOUND, SKIPPING!:" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                else{ write-host -foregroundcolor RED "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        };

        $smsg= "$($sBnr.replace('=v','=^').replace('v=','^='))" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        # add an EXO delay to avoid issues
        Start-Sleep -Milliseconds $ThrottleMs ;
    } ;  # loop-E

    if(!$whatif){
        $smsg= "CLOUD MIGRATION STATUS:`n$((ps1GetXMovReq -BatchName $BatchName | ps1GetXMovReqStats | FL DisplayName,status,percentcomplete,itemstransferred,BadItemsEncountered|out-string).trim())`n" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $smsg= "`nContinue monitoring with:`n$((get-alias ps1GetXMovReq).definition) -BatchName $($BatchName) | $((get-alias ps1GetXMovReqStats).definition) | fl DisplayName,status,percentcomplete,itemstransferred,BadItemsEncountered`n" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    } ;

    if((get-AdServerSettings).ViewEntireForest){ disable-ForestView } ;
    

    # return the passstatus to the pipeline
    $script:PassStatus | write-output

    if((get-AdServerSettings).ViewEntireForest){ disable-ForestView } ;

    if($host.Name -eq "Windows PowerShell ISE Host" -and $host.version.major -lt 5){
        # 11:51 AM 9/22/2020 isev5 supports transcript, anything prior has to fake it
        # 8:46 AM 3/11/2015 shift the logfilename gen out here, so that we can arch it
        #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -uformat "%Y%m%d-%H%M" ) + "-ISEtrans.log")) ;
        # 2:16 PM 4/27/2015 shift to static timestamp $timeStampNow
        #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + $timeStampNow + "-ISEtrans.log")) ;
        # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
        #$Logname=(join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -format 'yyyyMMdd-HHmmtt') + "-ISEtrans.log")) ;
        # maintain-ExoUsrMbxFreeBusyDetails-TOR-ForceAll-Transcript-BATCH-EXEC-20200921-1539PM-trans-log.txt
        $Logname=$transcript.replace('-trans-log.txt','-ISEtrans-log.txt') ;
        write-host "`$Logname: $Logname";
        Start-iseTranscript -logname $Logname  -Verbose:($VerbosePreference -eq 'Continue') ;
        #Archive-Log $Logname ;
        # 1:23 PM 4/23/2015 standardize processing file so that we can send a link to open the transcript for review
        $transcript = $Logname ;
        if($host.version.Major -ge 5){ stop-transcript  -Verbose:($VerbosePreference -eq 'Continue')} # ISE in psV5 actually supports transcription. If you don't stop it, it just keeps rolling
    } else {
        write-verbose "$((get-date).ToString('HH:mm:ss')):Stop Transcript" ;
        Stop-TranscriptLog -Transcript $transcript -verbose:$($VerbosePreference -eq "Continue") ;
    } # if-E
    
    # prod is still showing a running unstopped transcript, kill it again
    $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
    
    # also trailing echo the log:
    $smsg = "`$logging:`$true:written to:`n$($logfile)" ; 
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    $smsg = "$((get-date).ToString('HH:mm:ss')):$($sBnr.replace('=v','=^').replace('v=','^='))" ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    #*------^ END SUB MAIN ^------
}

#*------^ move-MailboxToXo.ps1 ^------


#*------v new-DgTor.ps1 v------
function new-DgTor {
    <#
    .SYNOPSIS
    new-DgTor.ps1 - Create new DistributionGroup and populate. Notates requestor, ticket# and admin, in Notes field of DL
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-08-30
    FileName    : new-DgTor.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,DistributionGroup,DistributionList,Hybrid
    REVISIONS
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 2:40 PM 12/10/2021 more cleanup 
    * 4:54 PM 9/30/2021 updated CloudFirst code, and used to create functional 
    exoDG, also added code to dynamically create onprem unreplicated MailContacts 
    for CloudFirst, to represent an onprem AddrBook object ; flipped members & 
    ManagedBy to [string[]]; added UG->DG conversion example,
    with splat; swapped undependable $scriptbasename w $cmdletname (tends to show
    module as name); updated cloudfirst variant code, switched recipient &
    managedby's to raw smtpaddresses ; finally validated hybrid OnPrem DG creation as well. 
    * 4:28 PM 9/14/2021 ren: new-DL-Tor -> new-DgTor ;; debugged -CloudFirst - working as intended ; fixed pipeline bug coming out of Start-IseTranscript , properly returns newdg object to pipeline;  converted to function, add to verb-exo (once it includes proper hybrid, most approp place); -CloudFirst still undebugged
    *2:56 PM 9/13/2021 rewrote for modern modules & template, -outputObject default. Tested ExOP version, haven't done -CloudFirst debugging yet.
    # 11:05 AM 6/13/2019 updated get-admininitials()
    # 8:24 AM 2/13/2018 support empty groups (for infra EXO rule grps, to be stocked later) - looks like it was there, members are only added where specified (foreach). Adding explicit echo's to reflect the status. 
    # 2:54 PM 2/8/2018 updated to support EXO-hosted mailuser owners (members already worked without modification)
    #12:50 PM 11/27/2017 sec wants them defaulted RequireSenderAuthenticationEnabled to $true ; 
    # 1:41 PM 6/13/2017 spliced in latest 3/16/16 get-gcfast()
    # 10:35 AM 4/4/2017 added new -InetReceive:$true param, to configure RequireSenderAuthenticationEnabled=$false
    # 10:32 AM 4/4/2017 had to splice in latest loadmod set - failed if not already in EMS session
    # 12:23 PM 4/3/2017 add default RequireSenderAuthenticationEnabled  $false (allow inet mailing by default)
    # 9:50 AM 3/3/2017 Get-AdminInitials: with the new standard of Fname/name: S-[name] this needs an update to strip prefix S-
    # 9:48 AM 3/2/2017 merged in updated Add-EMSRemote Set
    # 12:44 PM 10/18/2016 update rgx for ticket to accommodate 5-digit (or 6) CW numbers "^\d{6}$"=>^\d{5,6}$
    #* 9:11 AM 9/30/2016 added pretest if(get-command -name set-AdServerSettings -ea 0)
    # 1:55 PM 6/6/2016 debugged, works. 
    # 1:52 PM 6/6/2016 cleanedup typo trailing spaces on some of the dummy hash buils
    # 12:12 PM 6/6/2016 added Execute-WithRetry(), implementing retries via function. - neither worked, just do 
    # 10:50 AM 6/6/2016 : 
        add retry support below params
        * add region tags
        * updated to enable-mbx LoadMod block
        * Move splats below constants - constants should always be in place 1st
    # 1:12 PM 2/11/2016 fixed new bug in get-GCFast, wasn't detecting blank $site
    # 12:20 PM 2/11/2016 updated to standard EMS/AD Call block & Add-EMSRemote()
    #10:49 AM 2/11/2016: updated get-GCFast to current spec, updated any calls for "-site 'lyndale'" to just default to local machine lookup
    # 7:40 AM Add-EMSRemote: 2/5/2016 another damn cls REM IT! I want to see all the connectivity info, switched wh->wv, added explicit echo's of what it's doing.
    # 11:08 AM 1/15/2016 re-updated Add-EMSRemote, using a -eq v -like with a wildcard string. Have to repush copies all over now.
    # 10:43 AM 1/13/2016 updated Add-EMSRemote set
    # 10:02 AM 1/13/2016: fixed cls bug due to spurious ";cls" included in the try/catch boilerplate: Write-Error "$((get-date).ToString('HH:mm:ss')): Command: $($_.InvocationInfo.MyCommand)" ;cls => Write-Error "$((get-date).ToString('HH:mm:ss')): Command: $($_.InvocationInfo.MyCommand)" ;
    # 9:58 AM 10/21/2015 ren $InputSplat.Site => $InputSplat.SiteCode, to sync up name standard across scripts
    # 9:08 AM 10/14/2015 added debugpref maint code to get write-debug to work
    # 11:55 AM 10/7/2015 sorted now; wasn't using -SiteOverRide in the fancy csv-fed param I was using
    #1:56 PM 10/6/2015 fix $SiteOverride, to actually override the ManagedBy's OU (BEA user was forcing to BEA vs override of LYN)
    # 1:09 PM 10/6/2015 updated code to spec - seems to work
    # 10:57 AM 10/6/2015 blanked the @InputSplat{} values
    # 10:43 AM 10/6/2015 ren paras to standard (tix->Ticket)
    # 2:34 PM 10/2/2015 fix break and port in EMSremote etc
    8:53 AM 9/4/2015 sub'd in cleanedup EMSRemote Set
    8:35 AM 9/4/2015 seems to work, from EMSRemote
    2:36 PM 9/3/2015 added -identity $dg.samaccountname to Get-DistributionGroupMember
    2:17 PM 9/3/2015 added -ea 0 to Get-DistributionGroupMember cmds (were erroring if no members)
    1:36 PM 9/3/2015 did alot of tshooing on add-emsr, to get it functional all seems to run right now
    1:12 PM 8/26/2015 removed partial GUI code and validated functions properly.
    1:15 PM 6/24/2015 added whatif test to New-DistributionGroup @DLSplat -ea Stop ;
    1:04 PM 6/24/2015 tests out functional on params as well. Looks pretty good
    12:46 PM 6/24/2015 functional, need to test params
    9:21 AM 6/24/2015 combo/hybrid old ]PSNewDL! with add-MbxAccessGrant.ps1
    1:55 PM 6/15/2015 initial version
    .DESCRIPTION
    new-DgTor.ps1 - Create new DistributionGroup and populate. Notates requestor, ticket# and admin, in Notes field of DL
    Derives DG settings from ManagedBy specified: 
    - Constructs Name using SiteCode (root child OU at 1st level of MangedBy DN): [SITECODE]-DL-[$DNameBase]
    - Find's standard DG OU within the same Site OU tree
    .PARAMETER TenOrg
    TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER Ticket
    ITSM Request/Incident Number [nnnnnn]
    .PARAMETER DNameBase
    Base Name string, for DL Name construction. [SIT-DL] will be automatically appended[Base Name String]
    .PARAMETER ManagedBy
    Specify the userid to be responsible for access-grant-approvals[name,emailaddr,alias]
    .PARAMETER HiddenFromAddressLists
    Switch to configure -HiddenFromAddressListsEnabled `$true [-HiddenFromAddressLists]
    .PARAMETER CloudFirst
    Switch to specify EXO Cloud-First DG (vs Federated replicated AD/EXOnPrem DG) [-CloudFirst]
    .PARAMETER SiteOverride
    Specify a 3-letter Site Code. Used to force DL name/placement to vary from ManagedBy's current site[3-letter Site code]
    .PARAMETER Members
    Comma-delimited string of potential users to be granted access[name,emailaddr,alias]
    .PARAMETER InetReceive
    Can receive from external senders [-InetReceive:`$true]
    .PARAMETER HiddenFromAddressLists
    Switch to configure -HiddenFromAddressListsEnabled `$true [-HiddenFromAddressLists]
    .PARAMETER OutObject
    Switch to specify to return the new DG as an object (defaults true)[-OutObject]
    .PARAMETER Whatif
    Parameter to run a Test no-change pass, and log results [-Whatif switch]
    .PARAMETER ShowDebug
    Parameter to display Debugging messages (diverts reports to alt address) [-ShowDebug switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    SystemObject
    [| get-member the output to see what .NET obj TypeName is returned, to use here]
    .EXAMPLE
    PS> new-DgTor -SiteOverride ENT -DNameBase "DL Base DisplayName" -ManagedBy MANAGERID -Members 'MEMBER1@DOMAIN.com','MEMBER2@DOMAIN.com' -HiddenFromAddressLists -showDebug -verbose -Ticket 99999 -whatif;
    Create a DL with a siteoverride (spec'ing as ENT-name, rather than alt site)
    .EXAMPLE
    PS> $ndg = new-DgTor -TenOrg TOR -DNameBase "DL BASE DISPLAYNAME" -ManagedBy MANAGERID -Members 'MEMBER1@DOMAIN.com','MEMBER2@DOMAIN.com' -HiddenFromAddressLists -showDebug -verbose -Ticket 99999 -outobject;
    Create a DG with SiteOverride and return resulting new DG as an object, assigned to $ndg
    .EXAMPLE
    $whatif=$true ; 
    reconnect-exo ; 
    TRY{
        $tugn = 'TeamsUGNamwe_GUID' ;
        $tug = Get-exoUnifiedGroup -Identity $tugn ;
        $tugmbrs = Get-exoUnifiedGroupLinks -Id $tug.name -LinkType Members ;
        $pltNDg=[ordered]@{   TenOrg='TOR' ;
            CloudFirst=$true ;
            DNameBase="IS-$($tug.displayname)" ;
            ManagedBy=($tug.managedby | get-exorecipient -ea STOP | select -expand primarysmtpaddress) ;
            Members=($tugmbrs.primarysmtpaddress| get-exorecipient -ea STOP | select -expand primarysmtpaddress) ;
            HiddenFromAddressLists=$false;
            showDebug=$true;
            verbose=$true;
            Ticket='99999' ;
            outobject=$true;
            whatif=$($whatif);
          } ;
         write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):new-DgTor w`n$(($pltNDg|out-string).trim())" ;
         $ndg = new-DgTor @pltNDg;
         $ndg ;
    } CATCH {
    Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
    break ;
    } ;
    # Traditionally the UG would then be set Hidden from Address Books, in deference to the DG
    Set-exoUnifiedGroup -Id $tug.name -HiddenFromAddressListsEnabled $true
    
    Demo conversion of a Teams Unified Group membership (which permits unsubscribes, and silent loss of mail) into a standard DG. 
    .EXAMPLE
    $whatif=$true ;
    reconnect-exo ;
    reconnect-ex2010 ;
    TRY{
        $tugn = 'TeamsUGNamwe_GUID' ;
        $tug = Get-exoUnifiedGroup -Identity $tugn ;
        $tugmbrs = Get-exoUnifiedGroupLinks -Id $tug.name -LinkType Members ;
        $pltNDg=[ordered]@{   TenOrg='TOR' ;
          CloudFirst=$false ;
          SiteOverride = 'ENT' ;
          DNameBase="IS-$($tug.displayname)" ;
          ManagedBy=($tug.managedby | get-exorecipient -ea continue | select -expand primarysmtpaddress | select -unique | get-recipient -ea continue | select -expand primarysmtpaddress | select -unique) ;
          Members=($tugmbrs.primarysmtpaddress| get-recipient -ea continue | select -expand primarysmtpaddress) ;
          HiddenFromAddressLists=$false;
          showDebug=$true;
          verbose=$true;
          Ticket='99999' ;
          outobject=$true;
          whatif=$($whatif);
         } ;
        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):new-DgTor w`n$(($pltNDg|out-string).trim())" ;
        $ndg = new-DgTor @pltNDg;
        $ndg ;
    } CATCH {
        Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
        break ;
    } ;
    # Traditionally the UG would then be set Hidden from Address Books, in deference to the DG
    Set-exoUnifiedGroup -Id $tug.name -HiddenFromAddressListsEnabled $true
    
    Demo conversion of a Teams Unified Group membership (which permits unsubscribes, and silent loss of mail) into a standard on-prem hybrid replicated DG, 
    with the prefix/SiteCode overridden to use 'ENT' over the ManagedBy's home SiteCode. 
    
    Note:An onprem DG can have MailContacts in the membership (and in the ManagedBy as well), with the same primarysmtpaddress as remote-hybrid cloud mailboxes. 
    (e.g. EXO mailboxes that aren't Hybrid/AD'd locally to the DG-hosting OnPrem mail org)
    Upon ADC replication of a MailContact member (or ManagedBy) to AzureAD, any MailContact set in either property, will be auto-replaced during replication, 
    with the matching EXO mailbox object. A neat way of maintaining hybrid onPrem-deliverable DG's, containing non-locally-replicated EXO mailboxes.
    .LINK
    https://github.com/tostka/verb-exo        
    #>
    ###Requires -Modules ActiveDirectory, AzureAD, MSOnline, ExchangeOnlineManagement, verb-ADMS, verb-Auth, verb-Ex2010, verb-EXO, verb-IO, verb-logging, verb-Text, verb-logging
    ##Requires -Modules ActiveDirectory, AzureAD, MSOnline, ExchangeOnlineManagement, verb-ADMS, verb-Auth, verb-Ex2010, verb-IO, verb-logging, verb-Text, verb-logging
    # 2:49 PM 3/8/2022 pull verb-ex2010 ref - I think it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    #Requires -Modules ActiveDirectory, AzureAD, MSOnline, ExchangeOnlineManagement, verb-ADMS, verb-Auth, verb-IO, verb-logging, verb-Text, verb-logging
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("(lyn|bcc|spb|adl)ms6(4|5)(0|1).(china|global)\.ad\.DOMAIN\.com")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    PARAM(
        [Parameter(HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
        [ValidateNotNullOrEmpty()]
        $TenOrg = 'TOR',
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2,
        [Parameter(Mandatory=$true,HelpMessage="Base Name string, for DL Name construction. [SIT-DL] will be automatically appended[Base Name String]")]
        [string]$DNameBase,
        [Parameter(Position=0,HelpMessage="ITSM Request/Incident Number [nnnnnn]")]
        #[ValidatePattern("^\d{5,6}$")]
        [string]$Ticket,
        [Parameter(Mandatory=$true,HelpMessage="Specify the userid to be responsible for access-grant-approvals[name,emailaddr,alias]")]
        [string[]]$ManagedBy,
        [Parameter(HelpMessage="Specify a 3-letter Site Code. Used to force DL name/placement to vary from ManageBy's current site[3-letter Site code]")]
        [string]$SiteOverride,
        [Parameter(HelpMessage="Comma-delimited string of potential users to be granted access[name,emailaddr,alias]")]
        [string[]]$Members,
        [Parameter(HelpMessage="Can receive from external senders [-InetReceive:`$true]")]
        [switch]$InetReceive,
        [Parameter(HelpMessage="Switch to configure -HiddenFromAddressListsEnabled `$true [-HiddenFromAddressLists]")]
        [switch]$HiddenFromAddressLists,
        [Parameter(HelpMessage="Switch to specify EXO Cloud-First DG (vs Federated replicated AD/EXOnPrem DG) [-CloudFirst]")]
        [switch]$CloudFirst,
        [Parameter(HelpMessage="Switch to specify to return the new DG as an object (defaults true)[-OutObject]")]
        [switch]$OutObject=$true,
        [Parameter(HelpMessage='Parameter to display Debugging messages (also diverts reports to alt address) [-ShowDebug switch]')]
        [switch] $showDebug=$false,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
        [switch]$whatIf=$false
    ) ;
    
    ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;         
    $verbose = ($VerbosePreference -eq "Continue") ;

    $progInterval= 500 ; # write-progress wait interval in ms
    # 1:05 PM 4/28/2017 retries
    $DoRetries = 4 ;
    $RetrySleep = 5 ;

    # 10:22 AM 2/24/2016 add an explicit vari $MaxProcessingUserLimit for max-processing users, and bump it > 4000 (causing processing aborts as of 2/17/16)
    $MaxProcessingUserLimit = 10000 ;
    # 2:20 PM 3/25/2015 added optional report inline-in email body
    $bodyAsHtml=$true ;

    # 12:15 PM 2/9/2015 add an SMTP retry limit (per user attempted)
    # 7:20 AM 5/7/2015 leveraging the varis for LineURI non-unique recoveries
    [int]$retryLimit=1; # just one retry to patch lineuri duped users and retry 1x
    [int]$retryDelay=20;    # secs wait time after failure

    # 1:57 PM 2/18/2015
    $abortPassLimit = 4;    # maximum failed users to abort entire pass
    # 9:49 AM 2/17/2015 SMTP Priority level[Normal|High|Low]
    $smtpPriority="Normal";
    # SMTP port (default is 25)
    $smtpPort = 25 ;

   
    
    if ($psISE){
            $ScriptDir = Split-Path -Path $psISE.CurrentFile.FullPath ;
            $ScriptBaseName = split-path -leaf $psise.currentfile.fullpath ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($psise.currentfile.fullpath) ;
                    $PSScriptRoot = $ScriptDir ;
            if($PSScriptRoot -ne $ScriptDir){ write-warning "UNABLE TO UPDATE BLANK `$PSScriptRoot TO CURRENT `$ScriptDir!"} ;
            $PSCommandPath = $psise.currentfile.fullpath ;
            if($PSCommandPath -ne $psise.currentfile.fullpath){ write-warning "UNABLE TO UPDATE BLANK `$PSCommandPath TO CURRENT `$psise.currentfile.fullpath!"} ;
    } else {
        if($host.version.major -lt 3){
            $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
            $PSCommandPath = $myInvocation.ScriptName ;
            $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
        } elseif($PSScriptRoot) {
            $ScriptDir = $PSScriptRoot ;
            if($PSCommandPath){
                $ScriptBaseName = split-path -leaf $PSCommandPath ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($PSCommandPath) ;
            } else {
                $PSCommandPath = $myInvocation.ScriptName ;
                $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
            } ;
        } else {
            if($MyInvocation.MyCommand.Path) {
                $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
            } else {
                throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" ;
            } ;
        } ;
    } ;
    if($showDebug){
        write-host -foregroundcolor green "`SHOWDEBUG: `$ScriptDir:$($ScriptDir)`n`$ScriptBaseName:$($ScriptBaseName)`n`$ScriptNameNoExt:$($ScriptNameNoExt)`n`$PSScriptRoot:$($PSScriptRoot)`n`$PSCommandPath:$($PSCommandPath)" ;
    } ;
    
    
    #*================v FUNCTIONS  v================

    #-------v Function _cleanup v-------
    function _cleanup {
        <#
        .SYNOPSIS
        _cleanup.ps1 - clear all objects, prep close transcript, email report and exit
        .NOTES
        Version     : 1.0.0
        Author      : Todd Kadrie
        Website     :	http://www.toddomation.com
        Twitter     :	@tostka / http://twitter.com/tostka
        CreatedDate : 2020-
        FileName    :
        License     : MIT License
        Copyright   : (c) 2020 Todd Kadrie
        Github      : https://github.com/tostka/verb-XXX
        Tags        : Powershell
        AddedCredit : REFERENCE
        AddedWebsite:	URL
        AddedTwitter:	URL
        REVISIONS
        # 8:47 AM 11/24/2020 cloned over intact from maintain-exousrmbxretentionpolicies
        # 3:15 PM 10/13/2020 added CBH, added params: summarizeStatus,
            NoTranscriptStop, TranscriptItemsLimit, each exempts certain blocks of process
            - trying to genericize for reuse on other scripts ; added html body support
            (using <pre../pre> to preserve text layout, even in outlook display
        # 12:40 PM 10/23/2018 added write-log trainling bnr
        # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
        # 8:45 AM 10/13/2015 reset $DebugPreference to default SilentlyContinue, if on
        # # 8:46 AM 3/11/2015 at some time from then to 1:06 PM 3/26/2015 added ISE Transcript
        # 8:39 AM 12/10/2014 shifted to stop-transcriptLog function
        # 7:43 AM 1/24/2014 always stop the running transcript before exiting
        .DESCRIPTION
        _cleanup.ps1 - clear all objects, prep close transcript, email report and exit
        .PARAMETER  LogPath
        Alt transcript/logfile path for mailing (rather than `$transcript/`$logfile)[-LogPath c:\path-to\log.txt]
        .PARAMETER TranscriptItemsLimit
        Number of transactions to determine Transcript inclusion[-TranscriptItemsLimit]
        .PARAMETER summarizeStatus
        Switch to output a summary of the `$script:PassStatus delimted string[-summarizeStatus]
        .PARAMETER NoTranscriptStop
        Switch to skip transcript stop & exit [-NoTranscriptStop]
        .PARAMETER ShowDebug
        Parameter to display Debugging messages [-ShowDebug switch]
        .PARAMETER Whatif
        Parameter to run a Test no-change pass [-Whatif switch]
        .EXAMPLE
        _cleanup
        Default Call
        .EXAMPLE
        $plt_cleanup=@{LogPath=$tmpcopy summarizeStatus=$true ;  NoTranscriptStop=$true ; showDebug=$($showDebug) ;  whatif=$($whatif) ; } ;
        _cleanup @pltCleanup ;
        Splatted parameter'd call
        #>
        [CmdletBinding()]
        PARAM(
            [Parameter(HelpMessage="Alt transcript/logfile path for mailing (rather than `$transcript/`$logfile)[-LogPath c:\path-to\log.txt]")]
            [ValidateScript({Test-Path $_})]
            $LogPath,
            [Parameter(HelpMessage="Number of transactions to determine Transcript inclusion[-TranscriptItemsLimit]")]
            [int] $TranscriptItemsLimit = 10,
            [Parameter(HelpMessage="Switch to output a summary of the `$script:PassStatus delimted string[-summarizeStatus]")]
            [switch] $summarizeStatus,
            [Parameter(HelpMessage="Switch to skip transcript stop & exit [-NoTranscriptStop]")]
            [switch] $NoTranscriptStop,
            [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
            [switch] $showDebug,
            [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
            [switch] $whatIf
        ) ;

        # clear all objects, prep close transcript, email report and exit
        # REVISIONS

        $smsg = "_cleanup" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        if(!$NoTranscriptStop){
            # handle transcript closure in the main script (Tenant loop)
            stop-transcript
            if(($host.Name -eq "Windows PowerShell ISE Host") -AND ($host.version.Major -lt 5)){
                $Logname=(join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -format 'yyyyMMdd-HHmmtt') + "-ISEtrans.log")) ;
                $smsg = "`$Logname: $($Logname)";
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $xRet = Start-iseTranscript -logname $Logname -Verbose:($VerbosePreference -eq 'Continue') ;
                #Archive-Log $Logname -Verbose:($VerbosePreference -eq 'Continue');
                # 1:23 PM 4/23/2015 standardize processing file so that we can send a link to open the transcript for review
                $transcript = $Logname
            } else {
                $smsg = "Stop Transcript" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $xRet = Stop-TranscriptLog -Verbose:($VerbosePreference -eq 'Continue') ;
                #if($showdebug){ $smsg = "Archive Transcript" };
                #Archive-Log $transcript -Verbose:($VerbosePreference -eq 'Continue') ;
            } # if-E
        } else {
            $smsg = "(_cleanup(): deferring transcript stop to main script)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ; # !$NoTranscriptStop

        # variant options:
        #$smtpSubj= "Proc Rpt:$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"   ;
        #Load as an attachment into the body text:
        #$body = (Get-Content "path-to-file\file.html" ) | converto-html ;
        #$SmtpBody += ("Pass Completed "+ [System.DateTime]::Now + "`nResults Attached: " +$transcript) ;
        # 4:07 PM 10/11/2018 giant transcript, no send
        #$SmtpBody += "Pass Completed $([System.DateTime]::Now)`nResults Attached:($transcript)" ;
        #$SmtpBody += "Pass Completed $([System.DateTime]::Now)`nTranscript:($transcript)" ;

        # group out the PassStatus_$($tenorg) strings into a report for eml body
        if($script:PassStatus){
            if($summarizeStatus){
                if($script:TargetTenants){
                    # loop the TargetTenants/TenOrgs and summarize each processed
                    foreach($TenOrg in $TargetTenants){
                        $SmtpBody += "`n===Processing Summary: $($TenOrg):" ;
                        # can't split an empty string
                        if((get-Variable -Name PassStatus_$($tenorg)).value){
                            if((get-Variable -Name PassStatus_$($tenorg)).value.split(';') |?{$_ -ne ''}){
                                $SmtpBody += (summarize-PassStatus -PassStatus (get-Variable -Name PassStatus_$($tenorg)).value -verbose:$($VerbosePreference -eq 'Continue') );
                            } ;
                        } else {
                            $SmtpBody += "(no processing of mailboxes in $($TenOrg), this pass)" ;
                        } ;
                        $SmtpBody += "`n" ;

                    } ;
                } ;
            } else {
                # dump PassStatus right into the email
                $SmtpBody += "`n`$script:PassStatus: $($script:PassStatus):" ;
            } ;
            if($SmtpAttachment){
                $smtpBody +="(Logs Attached)"
            };
            $SmtpBody += "`n$('-'*50)" ;
            # include transcript in body, where fewer than limit of processed items logged in PassStatus
            # no, there're 3 transcripts, stored in $Alltranscripts, but skip it#
    #        if( ($script:PassStatus.split(';') |?{$_ -ne ''}|measure).count -lt $TranscriptItemsLimit){
    #            # add full transcript if less than 10 entries processed
    #            $SmtpBody += "`nTranscript:$(gc $transcript)`n" ;
    #        } else {
                if(!$ArchPath ){ $ArchPath = get-ArchivePath } ;
                if($Alltranscripts){
                    $Alltranscripts |%{
                        #$archedTrans = join-path -path $ArchPath -childpath (split-path $transcript -leaf) ;
                        $archedTrans = join-path -path $ArchPath -childpath (split-path $_ -leaf) ;
                        $smtpBody += "`nTranscript accessible at:`n$($archedTrans)`n" ;
                    } ;
                } ;
            #};
        }
        $SmtpBody += "Pass Completed $([System.DateTime]::Now)" ;

        # body rendered in OL loses all wordrwraps
        # force strip out the html
        #$smtpBody = [regex]::Replace($smtpBody, "\<[^\>]*\>", '') ;
        # or do min html format

        $styleCSS = "<style>BODY{font-family: Arial; font-size: 10pt;}" ;
        $styleCSS += "TABLE{border: 1px solid black; border-collapse: collapse;}" ;
        $styleCSS += "TH{border: 1px solid black; background: #dddddd; padding: 5px; }" ;
        $styleCSS += "TD{border: 1px solid black; padding: 5px; }" ;
        $styleCSS += "</style>" ;

    <# simple no css
    $html = @"
<html>
<head><title>$title</title></head>
<body>
<pre>$smtpBody</pre>
</body>
</html>
"@ ;
#>
    # one with style support (goees in the <head../head> block)
    $html = @"
<html>
<head>
$($styleCSS)
<title>$title</title></head>
<body>
<pre>
$($smtpBody)
</pre>
</body>
</html>
"@ ;

        # convertto-html doesn't do raw txt, just objects
        #$smtpBody = $smtpBody | ConvertTo-Html -Head $styleCSS ;
        # use the bp html <pre../pre> version
        $smtpBody = $html ;

        # name $attachment for the actual $SmtpAttachment expected by Send-EmailNotif
        #$SmtpAttachment=$transcript ;
        # test for ERROR|CHANGE - actually non-blank, only gets appended to with one or the other
        # to test for one, (but not a regex)
        <# # always force
        #if($script:passstatus.split(';') -contains 'ERROR'){
        # or run on change/error/passstatus flag
        if([string]::IsNullOrEmpty($script:PassStatus)){
            $smsg = "No Email Report: `$script:PassStatus isNullOrEmpty" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } else {
        #>
            $Email = @{
                smtpFrom = $SMTPFrom ;
                SMTPTo = $SMTPTo ;
                SMTPSubj = $SMTPSubj ;
                #SMTPServer = $SMTPServer ;
                SmtpBody = $SmtpBody ;
                SmtpAttachment = $SmtpAttachment ;
                BodyAsHtml = $false ; # let the htmltag rgx in Send-EmailNotif flip on as needed
                verbose = $($VerbosePreference -eq "Continue") ;
            } ;
            <# DISABLED add trailing notifc
            $smsg = "Send-EmailNotif w`n$(($Email|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # 9:02 AM 9/2/2021 don't neeed email on these
            Send-EmailNotif @Email ;
            #>
        #} ;

        if(!$NoTranscriptStop){
            #EXIT # trailing tempfile _cleanup in the sub main
            #Break ; 
        } ;

    } #*------^ END Function _cleanup ^------

    #*================^ END FUNCTIONS  ^================

    #*======v SUB MAIN  v======
    
    $sBnr="`n#*======v $(${CmdletName}) : v======" ; 
    $smsg = $sBnr ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    $Verbose = ($VerbosePreference -eq 'Continue') ; 

    # *** REGION MARKER LOAD
    #region LOAD
    # *** LOADING


    # 1:00 PM 4/28/2017 email trigger vari
    $PassStatus = $null ;

    # 1:01 PM 4/28/2017 add try catch as well - this may be making it zero-tolerance and catching all minor errors, disable it
    #Set-StrictMode -Version 2.0 ;

    #region SERVICE-CONNECTIONS #*======v SERVICE-CONNECTIONS v======
    #region useEXO ; #*------v useEXO v------
    $useEXO = $false ; # non-dyn setting, drives variant EXO reconnect & query code
    if($CloudFirst){ $useEXO = $true } ; 
    if($useEXO){
        #*------v GENERIC EXO CREDS & SVC CONN BP v------
        # o365/EXO creds
        <### Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile* 
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
        Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
        .EXAMPLE
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
        Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
        .EXAMPLE
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
        Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
        ###>
        $o365Cred=$null ;
        if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -UserRole 'CSVC','SID' -verbose:$($verbose))){
            # make it script scope, so we don't have to predetect & purge before using new-variable
            if(get-Variable -Name cred$($tenorg) -scope Script -ea 0 ){ remove-Variable -Name cred$($tenorg) -scope Script } ;
            New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
            $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } else {
            $statusdelta = ";ERROR";
            $script:PassStatus += $statusdelta ;
            set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
            $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
            Break ;
        } ;
        <### CALLS ARE IN FORM: (cred$($tenorg))
        $pltRXO = @{Credential = $Credential ; verbose = $($verbose) ; }
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            #verbose = $($verbose) ; 
            Verbose = $FALSE ; Silent = $true ;} ; 
        if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
        else { reconnect-EXO @pltRXO } ;
        # or with Tenant-specific cred($Tenorg) lookup
        #$pltRXO creds & .username can also be used for AzureAD connections 
        Connect-AAD @pltRXO ; 
        ###>
        # configure splat for connections: (see above useage)
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            #verbose = $($verbose) ; 
            Verbose = $FALSE ; Silent = $true ;} ; 
        #*------^ END GENERIC EXO CREDS & SVC CONN BP ^------
    } # if-E $useEXO
    #endregion useEXO ; #*------^ END useEXO ^------
    
    #region UseExOP #*------v UseExOP v------ 
    # steer all onprem code on $XXXMeta.ExOPAccessFromToro & Ex10Server values
    $UseExOP=$false ; 
    if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
        $UseExOP = $true ; 
        $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ; 
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
    } else { 
        $UseExOP = $false ; 
        $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ; 
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
    } ; 
    if($UseExOP){
        #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
        # do the OP creds too
        $OPCred=$null ;
        # default to the onprem svc acct
        $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC','SID'; verbose=$($verbose)} ;
        if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
            # make it script scope, so we don't have to predetect & purge before using new-variable
            if(get-Variable -Name "cred$($tenorg)OP" -scope Script -ea 0 ){ remove-Variable -Name "cred$($tenorg)OP" -scope Script } ;
            New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
            $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } else {
            $statusdelta = ";ERROR";
            $script:PassStatus += $statusdelta ;
            set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
            $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
            Break ;
        } ;
        $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;  
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        <# CALLS ARE IN FORM: (cred$($tenorg))
            $pltRX10 = @{
            Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
            #verbose = $($verbose) ; 
            Verbose = $FALSE ; Silent = $true ; } ;  
        Reconnect-Ex2010 @pltRX10 ; # local org conns
        #$pltRx10 creds & .username can also be used for local ADMS connections
        #>
        $pltRX10 = @{
            Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
            #verbose = $($verbose) ; 
            Verbose = $FALSE ; Silent = $true ; } ;     
        
        # defer cx10/rx10, until just before get-recipients qry
        #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
        # connect to ExOP X10
        if($pltRX10){
            #ReConnect-Ex2010XO @pltRX10 ;
            ReConnect-Ex2010 @pltRX10 ;
        } else { Reconnect-Ex2010 ; } ; 
    } ;  # if-E $useEXOP

    
    #region UseOPAD #*------v UseOPAD v------
    if($UseExOP){
        write-host -foregroundcolor gray  "(loading ADMS...)" ;
        load-ADMS -Verbose:$FALSE ;
        # resolve $domaincontroller dynamic, cross-org
        # setup ADMS PSDrives per tenant 
        if(!$global:ADPsDriveNames){
            $smsg = "(connecting X-Org AD PSDrives)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $global:ADPsDriveNames = mount-ADForestDrives -verbose:$($verbose) ;
        } ; 
        if(($global:ADPsDriveNames|measure).count){
            $useEXOforGroups = $false ; 
            $smsg = "Confirming ADMS PSDrives:`n$(($global:ADPsDriveNames.Name|%{get-psdrive -Name $_ -PSProvider ActiveDirectory} | ft -auto Name,Root,Provider|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # returned object
            #         $ADPsDriveNames
            #         UserName                Status Name        
            #         --------                ------ ----        
            #         DOM\Samacctname   True  [forestname wo punc] 
            #         DOM\Samacctname   True  [forestname wo punc]
            #         DOM\Samacctname   True  [forestname wo punc]
        
        } else { 
            #-=-record a STATUS=-=-=-=-=-=-=
            $statusdelta = ";ERROR";
            $script:PassStatus += $statusdelta ;
            set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
            #-=-=-=-=-=-=-=-=
            $smsg = "Unable to detect POPULATED `$global:ADPsDriveNames!`n(should have multiple values, resolved to $()"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
            Break ;
        } ; 
    } ; 
    #if (!$domaincontroller) { $domaincontroller = get-gcfast } ;
    #if(!$domaincontroller){ if(test-path function:get-gcfast){$domaincontroller=get-gcfast} else { throw "no get-gcfast()!" } ;} else {"(existing `$domaincontroller:$($domaincontroller))"} ;
    # use new get-GCFastXO cross-org dc finde
    # default to Op_ExADRoot forest from $TenOrg Meta
    if($UseExOP){
        $domaincontroller = get-GCFastXO -TenOrg $TenOrg -subdomain ((gv -name "$($TenOrg)Meta").value['OP_ExADRoot']) -verbose:$($verbose) |?{$_.length};
    } ; 
    #endregion UseOPAD #*------^ END UseOPAD ^------

    <# MSOL CONNECTION
    $reqMods += "connect-msol".split(";") ;
    if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
    write-host -foregroundcolor gray  "(loading AAD...)" ;
    #connect-msol ;
    connect-msol @pltRXO ; 
    #>

    <#
    # AZUREAD CONNECTION
    $reqMods += "Connect-AAD".split(";") ;
    if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
    write-host -foregroundcolor gray  "(loading AAD...)" ;
    #connect-msol ;
    Connect-AAD @pltRXO ; 
    #>

    <# defined above
    # EXO connection
    $pltRXO = @{
        Credential = (Get-Variable -name cred$($tenorg) ).value ;
        verbose = $($verbose) ; } ; 
    #>
    <# 
    if($VerbosePreference = "Continue"){
        $VerbosePrefPrior = $VerbosePreference ;
        $VerbosePreference = "SilentlyContinue" ;
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ; 
    disconnect-exo ;
    if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
    else { reconnect-EXO @pltRXO } ;
    # reenable VerbosePreference:Continue, if set, during mod loads 
    if($VerbosePrefPrior -eq "Continue"){
        $VerbosePreference = $VerbosePrefPrior ;
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ;
    #>
    #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    #endregion SERVICE-CONNECTIONS #*======^ END SERVICE-CONNECTIONS ^======

    $error.clear() ;
    TRY {
        #$LMSLoaded = load-LMS ; write-host -foregroundcolor green "`$LMSLoaded: $LMSLoaded" ;
        # 12:55 PM 4/25/2017 add ems
        #$sName="Microsoft.Exchange.Management.PowerShell*"; if (!(Get-PSSnapin | where {$_.Name -eq $sName})) {Add-PSSnapin $sName -ea Stop};
        # 2:04 PM 4/26/2017 use a full func
        <#$EMSLoaded = Load-EMSSnap ; Write-Debug "`$EMSLoaded: $EMSLoaded" ;
        get-exchangeserver | out-null ;
        #$ADMTLoaded = load-ADMS ; write-host -foregroundcolor green "`$ADMTLoaded: $ADMTLoaded" ;
        #>
        <# 2nd gen disabled
        rx10 -Verbose:$false ; 
        rxo  -Verbose:$false ; 
        #cmsol -Verbose:$false ; 
        connect-ad -Verbose:$false | out-null ;;
        if(!$domaincontroller){$domaincontroller=get-gcfast} ;
        #>

        # 11:56 AM 4/24/2015 moved below func defs, in sub main
        $archPath = get-ArchivePath ;

        # 12:44 PM 4/24/2015 fine squash any array coming out (till we get it sorted)
        if($archPath -is [system.array]){
            if($bDebug) {Write-Verbose "Flattening `$archpath array" -verbose:$verbose}
            $archPath = $archPath[0] ;
        }  # if-E;

    } CATCH {
        $ErrTrapd=$Error[0] ;
        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level warn } #Error|Warn|Debug 
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #-=-record a STATUSWARN=-=-=-=-=-=-=
        $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
        if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
        if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
        #-=-=-=-=-=-=-=-=
        $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$($smsg)" } ;

        set-AdServerSettings -ViewEntireForest $false ;

        Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
    } ; 

    #*======V CONFIGURE DEFAULT LOGGING FROM PARENT SCRIPT NAME v======
    <# old code
    #$pltSL=@{ NoTimeStamp=$true ; Tag="($TenOrg)-LASTPASS" ; showdebug=$($showdebug) ; whatif=$($whatif) ; Verbose=$($VerbosePreference -eq 'Continue') ; } ;
    $pltSL=@{ NoTimeStamp=$FALSE ; Tag="($Ticket)" ; showdebug=$($showdebug) ; whatif=$($whatif) ; Verbose=$($VerbosePreference -eq 'Continue') ; } ;
    if($PSCommandPath){   $logspec = start-Log -Path $PSCommandPath @pltSL ;
    } else { $logspec = start-Log -Path ($MyInvocation.MyCommand.Definition) @pltSL ; } ;
    if($logspec){
        $logging=$logspec.logging ;
        $logfile=$logspec.logfile ;
        $transcript=$logspec.transcript ;
        if(Test-TranscriptionSupported){
            $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
            start-transcript -Path $transcript ;
        } ;
    } else {throw "Unable to configure logging!" } ;
    #>
    if(!(get-variable LogPathDrives -ea 0)){$LogPathDrives = 'd','c' };
    foreach($budrv in $LogPathDrives){if(test-path -path "$($budrv):\scripts" -ea 0 ){break} } ;
    if(!(get-variable rgxPSAllUsersScope -ea 0)){
        $rgxPSAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps(((d|m))*)1|dll)$" ;
    } ;
    if(!(get-variable rgxPSCurrUserScope -ea 0)){
        $rgxPSCurrUserScope="^$([regex]::escape([Environment]::GetFolderPath('MyDocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps((d|m)*)1|dll)$" ;
    } ;
    $pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($whatif) ;} ;
    $pltSL.Tag = ($ticket,$DNameBase -join '-') ;
    if($script:PSCommandPath){
        if(($script:PSCommandPath -match $rgxPSAllUsersScope) -OR ($script:PSCommandPath -match $rgxPSCurrUserScope)){
            $bDivertLog = $true ;
            switch -regex ($script:PSCommandPath){
                $rgxPSAllUsersScope{$smsg = "AllUsers"}
                $rgxPSCurrUserScope{$smsg = "CurrentUser"}
            } ;
            $smsg += " context script/module, divert logging into [$budrv]:\scripts"
            write-verbose $smsg  ;
            if($bDivertLog){
                if((split-path $script:PSCommandPath -leaf) -ne $cmdletname){
                    # function in a module/script installed to allusers|cu - defer name to Cmdlet/Function name
                    $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
                } else {
                    # installed allusers|CU script, use the hosting script name
                    $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $script:PSCommandPath -leaf)) ;
                }
            } ;
        } else {
            $pltSL.Path = $script:PSCommandPath ;
        } ;
    } else {
        if(($MyInvocation.MyCommand.Definition -match $rgxPSAllUsersScope) -OR ($MyInvocation.MyCommand.Definition -match $rgxPSCurrUserScope) ){
             $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $script:PSCommandPath -leaf)) ;
        } elseif(test-path $MyInvocation.MyCommand.Definition) {
            $pltSL.Path = $MyInvocation.MyCommand.Definition ;
        } elseif($cmdletname){
            $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
        } else {
            $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$CMDLETNAME, FROM WHICH TO BUILD A START-LOG.PATH!" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            BREAK ;
        } ;
    } ;
    write-verbose "start-Log w`n$(($pltSL|out-string).trim())" ;
    $logspec = start-Log @pltSL ;
    $error.clear() ;
    TRY {
        if($logspec){
            $logging=$logspec.logging ;
            $logfile=$logspec.logfile ;
            $transcript=$logspec.transcript ;
            $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
            start-Transcript -path $transcript ;
        } else {throw "Unable to configure logging!" } ;
    } CATCH {
        $ErrTrapd=$Error[0] ;
        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    } ;

    #*======^ CONFIGURE DEFAULT LOGGING FROM PARENT SCRIPT NAME ^======

    # -----------

    $smtpToFailThru=convertFrom-Base64String -string "dG9kZC5rYWRyaWVAdG9yby5jb20=" # simple encoded addr
    # pull the notifc smtpto from the xxxMeta.NotificationDlUs value
    if(!$showdebug){
        if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs){
            $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs ;
        }elseif((Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1){
            $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1 ;
        } else {
            $smtpTo=$smtpToFailThru;
        } ;
    } else {
        # debug pass, don't send to main dl, use NotificationAddr1    if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs){
        if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1){
            #set-variable -Name $meta.name -Value ((get-variable -name $meta.name).value  += @{'o365_AcceptedDomains' = (Get-exoAcceptedDomain).domainname} )
            $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1 ;
        } else {
            $smtpTo=$smtpToFailThru ;
        } ;
    }
    <# 
    if($bDivertLog){ # scriptbasename will likely be a module name, use diverted start-log values
        $smtpFrom = ((split-path $pltsl.path -leaf).replace('.','-') + "@$( (Get-Variable  -name "$($TenOrg)Meta").value.o365_OPDomain )")
    } else {
        $smtpFrom = (($scriptBaseName.replace(".","-")) + "@$( (Get-Variable  -name "$($TenOrg)Meta").value.o365_OPDomain )") ;
    } ; 
    #>
    # shift to cmdletname, more dependable
    $smtpFrom = (($CmdletName.replace(".","-")) + "@$( (Get-Variable  -name "$($TenOrg)Meta").value.o365_OPDomain )") ;
    $smtpSubj= "Proc Rpt:"
    if($whatif) {
        $smtpSubj+="WHATIF:" ;
    } else {
        $smtpSubj+="PROD:" ;
    } ;
    <#
    if($bDivertLog){ # scriptbasename will likely be a module name, use diverted start-log values
        $smtpSubj+= "$((split-path $pltsl.path -leaf)):$(get-date -format 'yyyyMMdd-HHmmtt')"   ;
    } else {
        $smtpSubj+= "$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"   ;
    } ; 
    #>
    # shift to cmdletname, more dependable
    $smtpSubj+= "$($CmdletName):$(get-date -format 'yyyyMMdd-HHmmtt')"   ;
    if(!($bodyAsHtml)){
        # if not inline attachment in body, need to load report as attachment
        $smtpAttachment=$rptfile ;
    } else {
        #9:49 AM 3/26/2015 just blank the attachment if we're not mailing it
        $smtpAttachment=$null;
    };
    # setup body as a hash
    $smtpBody = @() ;
    # (`n = CrLf in body)
    #====== ^ EMAIL HANDLING BOILERPLATE (USE IN SUB MAIN) ^==================================


    #*======v DL PSTED IN CODE  v======
    if($host.version.major -ge 3){
        $InputSplat=[ordered]@{ Dummy = $null ;  } ;
        $pltNewDG=[ordered]@{ Dummy = $null ;  } ;
        $pltSetDG=[ordered]@{ Dummy = $null ;  } ;
    } else {
        $InputSplat=@{ Dummy = $null ;  } ;
        $pltNewDG=@{ Dummy = $null ;  } ;
        $pltSetDG=@{ Dummy = $null ;  } ;

    } ;
    $InputSplat.remove("Dummy") ;
    $InputSplat.Add("DNameBase","") ; 
    $InputSplat.Add("Ticket",$($null)) ; 
    $InputSplat.Add("ManagedBy","") ; 
    $InputSplat.Add("SiteOverride","") ; 
    $InputSplat.Add("Members","") ; 
    $InputSplat.Add("InetReceive","") ; 

    $pltNewDG.remove("Dummy") ;
    $pltNewDG.Add("DisplayName",$("")) ; 
    $pltNewDG.Add("Alias",$("")) ; 
    $pltNewDG.Add("OrganizationalUnit",$("")) ; 
    $pltNewDG.Add("SamAccountName",$($null)) ; # 1:22 PM 6/6/2016 defer SamAccountName too
    $pltNewDG.Add("type",$( "Distribution")) ; 
    $pltNewDG.Add("Notes",$( $null)) ; 
    $pltNewDG.Add("ManagedBy",$($InputSplat.ManagedBy)) ; 
    $pltNewDG.Add("whatif",$($whatif)) ; 
    $pltNewDG.Add("ErrorAction","STOP") ; 

    $pltSetDG.remove("Dummy") ;
    $pltSetDG.Add("Identity","") ; 
    $pltSetDG.Add("whatif",$($whatif)) ; 
    $pltSetDG.Add("ErrorAction","STOP") ; 

    #region SPLATDEFS ; # ------ 

    $smsg = ":===PASS STARTED=== " ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    if($DNameBase){$InputSplat.DNameBase=$DNameBase};
    if($ManagedBy){$InputSplat.ManagedBy=$ManagedBy};
    #if($Description){$InputSplat.Description=$Description};
    if($Ticket){$InputSplat.Ticket=$Ticket};
    if($SiteOverride){$InputSplat.SiteOverride=$SiteOverride};
    if($Members){$InputSplat.Members=$Members};
    if($InetReceive){$InputSplat.InetReceive=$InetReceive};
    if($HiddenFromAddressLists){$InputSplat.HiddenFromAddressLists=$HiddenFromAddressLists};


    #-=-=-=-=-=-=-=-=
    # alias block switch on rcptype, handles ExOP|Exo|Exov2 variants with single aliased cmd assignements
    # pull onprem recipipent to drive balance of logic
    #rx10 -Verbose:$false ; 
    if($pltRX10){
        ReConnect-Ex2010 @pltRX10 ;
    } else { Reconnect-Ex2010 ; } ; 
    #$OpRcp = $xoRcp = $null ; 
    if($CloudFirst){$isCloud1st = $true } else { $isCloud1st = $false } ; 
    <#
    if(!$Room.identity){ 
        $smsg = "`$Room.Idenity is BLANK! Aborting to avoid returning *entire* recipient base!" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        _cleanup ; 
    } ; 
    if($OpRcp= get-recipient -id $Room.identity -ea 0 ){
        write-verbose "successful:get-recipient -id $($Room.identity) -ea 0" 
    } else {
        write-verbose "failed to get-recipient -id $($Room.identity) -ea 0 ; retry EXO (cloud1st)" 
        $xGRcp = (gcm get-*xo*recipient).name.tolower() | select -unique ; 
        $expr = "$($xGRcp) -id $Room.identity -ea STOP" ; 
        if($xoRcp= invoke-expression $expr ){
            $isCloud1st = $true ;
        } ;
    } ; 
    #>
    # aliased ExOP|EXO|EXOv2 cmdlets (permits simpler single code block for any of the three variants of targets & syntaxes)
    # each is '[aliasname];[exOcmd] (xOv2cmd & exop are converted from [exocmd])
    [array]$cmdletMaps = 'ps1GetxRcp;get-exorecipient;','ps1GetxMbx;get-exomailbox;','ps1SetxMbx;Set-exoMailbox;','ps1GetxUser;get-exoUser;',
        'ps1GetxMUsr;Get-exoMailUser','ps1SetxMUsr;Set-exoMailUser','ps1SetxCalProc;set-exoCalendarprocessing;',
        'ps1GetxCalProc;get-exoCalendarprocessing;','ps1GetxMbxFldrPerm;get-exoMailboxfolderpermission;',
        'ps1GetxMbxFldrPerm;get-exoMailboxfolderpermission','ps1AddxMbxPrm;Add-exoMailboxPermission','ps1GetxMbxPrm;Get-exoMailboxPermission',
        'ps1RmvxMbxPrm;Remove-exoMailboxPermission','ps1AddRcpPrm;Add-exoRecipientPermission','ps1GetRcpPrm;Get-exoRecipientPermission',
        'ps1RmvRcpPrm;Remove-exoRecipientPermission','ps1GetxAccDom;Get-exoAcceptedDomain;','ps1GetxRetPol;Get-exoRetentionPolicy',
        'ps1GetxDistGrp;get-exoDistributionGroup;','ps1GetxDistGrpMbr;get-exoDistributionGroupmember;','ps1GetxMsgTrc;get-exoMessageTrace;',
        'ps1GetxMsgTrcDtl;get-exoMessageTraceDetail;','ps1GetxMbxFldrStats;get-exoMailboxfolderStatistics','ps1GetxMContact;Get-exomailcontact;',
        'ps1SetxMContact;Set-exomailcontact;','ps1NewxMContact;New-exomailcontact','ps1TestxMapi;Test-exoMAPIConnectivity',
        'ps1GetxOrgCfg;Get-exoOrganizationConfig','ps1GetxMbxRegionCfg;Get-exoMailboxRegionalConfiguration',
        'ps1TestxOAuthConn;Test-exoOAuthConnectivity','ps1NewxDistGrp;new-exoDistributionGroup','ps1SetxDistGrp;set-exoDistributionGroup',
        'ps1AddxDistGrpMbr;Add-exoDistributionGroupMember','ps1RmvxDistGrpMbr;remove-exoDistributionGroupMember',
        'ps1GetxDDG;Get-exoDynamicDistributionGroup','ps1NewxDDG;New-exoDynamicDistributionGroup','ps1SetxDDG;Set-exoDynamicDistributionGroup' ;
    [array]$XoOnlyMaps = 'ps1GetxMsgTrcDtl','ps1TestxOAuthConn' ; # cmdlet alias names from above that are skipped for aliasing in EXOP
    # cmdlets from above that have diff names EXO v EXoP: these each have  schema: [alias];[xoCmdlet];[opCmdlet]; op Aliases use the opCmdlet as target
    [array]$XoRenameMaps = 'ps1GetxMsgTrc;get-exoMessageTrace;get-MessageTrackingLog','ps1AddRcpPrm;Add-exoRecipientPermission;Add-AdPermission',
            'ps1GetRcpPrm;Get-exoRecipientPermission;Get-AdPermission','ps1RmvRcpPrm;Remove-exoRecipientPermission;Remove-ADPermission' ;
    # code to summarize & indexed-hash the renamed cmdlets for variant processing
    $XoRenameMapNames = @() ; 
    $oxoRenameMaps = @{} ;
    $XoRenameMaps | foreach {     $XoRenameMapNames += $_.split(';')[0] ;     $name = $_.split(';')[0] ;     $oxoRenameMaps[$name] = $_.split(';')  ;  } ;
    # $isExOP = $isEXO = $false ; 
    # now need to accomodate cloud1st as well
    # filtering the above to subsets:
    $cmdletMapsFltrd = $cmdletmaps|?{$_.split(';')[1] -like '*DistributionGroup*'} ; 
    $cmdletMapsFltrd += $cmdletmaps|?{$_.split(';')[1] -like '*recipient'}
    #$cmdletMapsFltrd = $cmdletmaps # or use full set
    foreach($cmdletMap in $cmdletMapsFltrd){
        <# dbg code
        write-verbose $cmdletMap ;
        if($cmdletMap -eq 'ps1AddRcpPrm Add-exoRecipientPermission'){
            write-host "GOTCHA!" ;
        } ; 
        #>
        <#switch ($OpRcp.recipienttype){
            "MailUser" {
        #>
        #if(($OpRcp.recipienttype -eq 'MailUser') -OR ($xoRcp)){
        if($isCloud1st){
            $isExOP = $false ; $isEXO = $true ; 
            if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
            else { reconnect-EXO @pltRXO } ;
            # reconnect-exo @pltRXO ;
            if($script:useEXOv2){
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1].replace('-exo','-xo') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nAName = ($cmdletMap.split(';')[0]) ;
                if(-not(get-alias -name $naname -ea 0 |?{$_.Definition -eq $cmdlet.name})){
                    $nalias = set-alias -name $nAName -value ($cmdlet.name) -passthru ;
                    write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                } ;
            } else {
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nAName = ($cmdletMap.split(';')[0]);
                if(-not(get-alias -name $naname -ea 0 |?{$_.Definition -eq $cmdlet.name})){
                    $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                    write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                } ;
            } ;
        } else {
            $isExOP = $true ; $isEXO = $false ; 
            if($pltRX10){
                    ReConnect-Ex2010 @pltRX10 ;
            } else { Reconnect-Ex2010 ; } ; 
            if($XoOnlyMaps -contains $cmdletMap.split(';')[0]){
                write-verbose "$($cmdletMap.split(';')[1]) is an XO-Only cmdlet, skipping EXOP alias-creation" ;
            } else {
                if($XoRenameMapNames -contains $cmdletMap.split(';')[0]){
                    write-verbose "$($cmdletMap.split(';')[1]) is an XO-Renamed cmdlet, renaming for EXoP" ;
                    # sub -exoNOUN -> -NOUN using ExOP variant cmdlet
                    if(!($cmdlet= Get-Command $oxoRenameMaps[($cmdletMap.split(';')[0])][2] )){ throw "unable to gcm Alias definition!:$($oxoRenameMaps[($cmdletMap.split(';')[0])][2])" ; break }
                    $nAName = ($cmdletMap.split(';')[0]);
                    if(-not(get-alias -name $naname -ea 0 |?{$_.Definition -eq $cmdlet.name})){
                        $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                        write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                    } ;
                } else { 
                    # common cmdlets between all 3 systems
                    # sub -exoNOUN -> -NOUN
                    if(!($cmdlet= Get-Command $cmdletMap.split(';')[1].replace('-exo','-') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                    $nAName = ($cmdletMap.split(';')[0]);
                    if(-not(get-alias -name $naname -ea 0 |?{$_.Definition -eq $cmdlet.name})){
                        $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                        write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                    } ;
                } ; 

            } ; 
        } ;
        <#
            default { throw "Unrecognized recipienttype!:$($OpRcp.recipienttype)" }
        } ; 
        #>
    } ;  # loop-E
    #-=-=-=-=-=-=-=-=

    Write-Host -fore green "`nSpecified Base DL Name: $($InputSplat.DNameBase)" ;
    $error.clear() ;
    TRY {
        #if($ManagedBy){$oManagedBy = $ManagedBy | foreach-object {ps1GetxRcp -id $_ -ResultSize 1 -ea 'STOP' } | select -expand primarysmtpaddress  | select -unique ;} ; 
        if($ManagedBy){
            if($isCloud1st){
                #$oManagedBy = ps1GetxRcp -id $ManagedBy -ResultSize 1 -ea 'Continue' 
                #$oManagedBy = ps1GetxRcp -id $ManagedBy -ResultSize 25 -ea 'Continue' 
                $oManagedBy = $ManagedBy  | ps1GetxRcp -ResultSize 25 -ea 'Continue' 
            } else { 
                # resolving exo smtpaddresss could yield missing recips, pull -ea
                #$oManagedBy = get-recipient -id $ManagedBy -ResultSize 25 #-ea -ea 'Continue' 
                $oManagedBy = $ManagedBy | get-recipient  -ResultSize 25 -ea 'Continue' 
            } ;
        } ; 
    } CATCH {
        $ErrTrapd=$Error[0] ;
        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level warn } #Error|Warn|Debug 
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #-=-record a STATUSWARN=-=-=-=-=-=-=
        $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
        if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
        if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
        #-=-=-=-=-=-=-=-=
        $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
    } ; 

    if($isCloud1st){
        $DName=("ENT" + "-DL-" + $InputSplat.DNameBase) ;
    }else {
        $InputSplat.Add("Domain",$($oManagedBy[0].identity.tostring().split("/")[0]) ) ; 
        # force 1st ManagedBy's OU (if it's an array)
        $InputSplat.SiteCode=($oManagedBy[0].identity.tostring().split('/')[1]) ;
        if($domaincontroller){
            $InputSplat.Add("DomainController",$domaincontroller) ; 
        } ; 
        $pltNewDG.Add("DomainController",$domaincontroller) ; 
        $pltSetDG.Add("DomainController",$domaincontroller) ; 

        if($InputSplat.SiteOverride){
            $SiteCode=$InputSplat.SiteOverride;
            $InputSplat.SiteCode=$InputSplat.SiteOverride;
        } else {  
            $SiteCode=$InputSplat.SiteCode.tostring();
        } ;

        if($SiteOverride -eq 'ENT'){
            # ent-named OU, but park it in the ManagedBy's OU - no park it in LYN OU - less confusing if all ENT's are in one place
            $FindOU="^OU=Distribution\sGroups,";
            #$tmpSite = ($oManagedBy[0].identity.tostring().split('/')[1]) ;
            $tmpSite = 'LYN'
            if( ($pltNewDG.OrganizationalUnit = ((Get-ADObject -filter { ObjectClass -eq 'organizationalunit' } -ea continue | ?{($_.distinguishedname -match "$($FindOU).*OU=$($tmpSite),.*") } | select distinguishedname).distinguishedname.tostring()) )) { } else { _cleanup ; Exit ;} 
            $InputSplat.Add("SiteName", $SiteCode) ;
            $DName=($SiteCode + "-DL-" + $InputSplat.DNameBase) ;
        } else { 
            # put the DG obj in the ManagedBy's site
            $FindOU="^OU=Distribution\sGroups,";
            if( ($pltNewDG.OrganizationalUnit = ((Get-ADObject -filter { ObjectClass -eq 'organizationalunit' } -ea continue | ?{($_.distinguishedname -match "$($FindOU).*OU=$($InputSplat.SiteCode),.*") } | select distinguishedname).distinguishedname.tostring()) )) { } else { _cleanup ; Exit ;} 
            $InputSplat.Add("SiteName", $SiteCode) ;
            $DName=($SiteCode + "-DL-" + $InputSplat.DNameBase) ;
        } ;
    
    } ;

    $smsg = "`$Dname:$Dname" ; 
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    
    $pltNewDG.Name= $pltNewDG.DisplayName = $($DName);
    $pltNewDG.Alias=$($DName.replace(" ",""));
    # shift to get-admininitials
    $admininitials=get-AdminInitials ; 
    $pltNewDG.Notes="$((get-date -format "MM/dd/yyyy"))" ;
    if($($InputSplat.Ticket)){$pltNewDG.Notes+=" #$($InputSplat.Ticket)" };
    if($isCloud1st){
        $pltNewDG.remove('SamAccountName') ; 
        $pltNewDG.remove('OrganizationalUnit') ; 
    } else {
        $pltNewDG.SamAccountName =$($DName.replace(" ","").replace("-","")) ;
    } ; 
    $pltNewDG.Type = "Distribution";
    $pltNewDG.ManagedBy =$oManagedBy.primarysmtpaddress | select -unique  ;
    $pltNewDG.Notes+=" for $($pltNewDG.ManagedBy -join ',' ) -$($admininitials)" ;

    if($members){
        $pltNewDG.members = $members | ps1GetxRcp -ErrorAction Continue | select -expand primarysmtpaddress  | select -unique ;
    } ; 

    Write-Host -fore yellow "Checking for existing $($pltNewDG.DisplayName)..."  ;
    write-verbose "$((get-date).ToString("HH:mm:ss")):`$SGSrchName:$($SGSrchName)`n`$pltNewDG.DisplayName:$($pltNewDG.DisplayName)";
    $ADGSrchName=$($pltNewDG.DisplayName);

    if($isCloud1st){
        $oDL = (ps1GetxDistGrp -identity $pltNewDG.Alias -ea silentlycontinue)
    } else { 
        $oDL = (ps1GetxDistGrp -identity $pltNewDG.Alias -domaincontroller $($domaincontroller) -ea silentlycontinue)
    } ; 

    if($oDL){
        write-verbose "Existing found: `$oDL:$($oDL.primarysmtpaddress)" ;
        write-verbose "`$oDL.DN:$($oDL.DistinguishedName)" ;
    } else {
    
        $smsg = "$((get-alias ps1NewxDistGrp).definition) w`n$(($pltNewDG|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
       
            $Exit = 0 ; 
            Do {
                Try {
                    $oDL = ps1NewxDistGrp @pltNewDG ;
                    $Exit = $Retries ; 
                } Catch {
                    Start-Sleep -Seconds $RetrySleep ; 
                    $Exit ++ ; 
                    Write-Verbose "Failed to exec cmd because: $($Error[0])" ; 
                    Write-Verbose "Try #: $Exit" ; 
                    If ($Exit -eq $Retries) {Write-Warning "Unable to exec cmd!"} ; 
                } # try-E
            } Until ($Exit -eq $Retries) # loop-E

        if($whatif){
            $smsg = "SKIPPING EXEC: Whatif-only pass";
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } else {
            # have had sporadic resolution errors, pull it back again to ensure it's fully available
            if($isCloud1st){
                do {Write-Host "." -NoNewLine;Start-Sleep -s 1} until ($odl = ps1GetxDistGrp $oDL.primarysmtpaddress -ea silentlycontinue -resultsize 1)  ;
            } else { 
                do {Write-Host "." -NoNewLine;Start-Sleep -s 1} until ($odl = ps1GetxDistGrp $oDL.primarysmtpaddress -domaincontroller $domaincontroller -resultsize 1) ;
            } ; 
            $smsg = "`$oDL:$($oDL.primarysmtpaddress)" ;
            $smsg += "`n`$oDL.DN:$($oDL.DistinguishedName)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        }  # if-E
            
    } # if-E no DL obj

    if($oDL){
        $pltSetDG.Identity=$($oDL.alias) ;
        if($isCloud1st){
            $ExistMbrs = ps1GetxDistGrpMbr -Identity $oDL.primarysmtpaddress -ErrorAction 'Stop' | select -expand primarysmtpaddress ; 
        } else { 
            $ExistMbrs = ps1GetxDistGrpMbr -Identity $odl.SamAccountName -DomainController $domaincontroller -ErrorAction 'Stop' | select -expand primarysmtpaddress ; 
        } ; 

        $pltAddDGM=[ordered]@{
            identity=$pltSetDG.identity ;
            #Member= $mbr  ; 
            ErrorAction = 'Stop' ; 
            whatif=$($whatif) ; 
            DomainController= $domaincontroller
        } ;
        if($isCloud1st){
            $pltAddDGM.remove('DomainController') ; 
        } 
        $error.clear() ;
        TRY {
            foreach($Mbr in $pltNewDG.members){
                if ($ExistMbrs -notcontains $Mbr) {
                    $smsg = "ADD:$($mbr.samaccountname)"
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    ps1AddxDistGrpMbr @pltAddDGM -member $mbr ; 
                    
                } else {
                    $smsg = "SKIPPING:$($mbr) is already a member of $($oDL.samaccountname)"
                } ; 
            }; # loop-E

            if($InputSplat.InetReceive){
                $smsg = "-InetReceive:`$true:Updating RequireSenderAuthenticationEnabled to `$false" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $pltSetDG.add("RequireSenderAuthenticationEnabled",$false) ; 
            
            } ; 

            if($InputSplat.HiddenFromAddressLists){
                $smsg = "-HiddenFromAddressLists:`$true:Setting HiddenFromAddressListsEnabled `$true" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $pltSetDG.add("HiddenFromAddressListsEnabled",$true) ; 
            } ; 

            $smsg = "$((get-alias ps1SetxDistGrp).definition) w`n$(($pltSetDG|out-string).trim())" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            ps1SetxDistGrp @pltSetDG 

        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ; 

        do{     $smsg =  "REVIEW SETTINGS: " ;
            $smsg = "$("="*6)`n$((Get-Date -Format 'HH:mm:ss')):Results:";
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            if($isCloud1st){
                $oDL=ps1GetxDistGrp -id $odl.Alias -ErrorAction stop ;
            } else { 
                $oDL=ps1GetxDistGrp -id $odl.Alias -domaincontroller $domaincontroller -ErrorAction stop ;
            } ; 
            # 10:19 AM 4/4/2017 add RequireSenderAuthenticationEnabled
            $propsDG = "DisplayName","Alias","WindowsEmailAddress","ManagedBy","RequireSenderAuthenticationEnabled","HiddenFromAddressListsEnabled" ; 
            $smsg = "`n$(($oDL| fl $propsDG |out-string).trim())" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            if($isCloud1st){
                $oDLMbrs = ps1GetxDistGrpMbr -identity $oDL.alias  -ea 0 | select primarysmtpaddress ; 
            } else { 
                $oDLMbrs = ps1GetxDistGrpMbr -identity $oDL.alias -domaincontroller $($domaincontroller) -ea 0 | select distinguishedname;
            } ; 
            $smsg = "`n$(($oDL| fl $propsDG |out-string).trim())" ; 
            $smsg += "`nMembers:`n$(($oDLMbrs|out-string).trim())" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        
            if(-not($OutObject)){
                $bRet=Read-Host "Enter Y to Refresh Review (replication latency)." ;
            } ; 
        } until ($bRet -ne "Y" -OR $OutObject);
        # 1:07 PM 9/30/2021 rem-out the mailcontact creation code, needs debugging. 
        if($isCloud1st -and -not($whatif)){
            # check for onprem recipient on smtpaddr, if none, offer to build a MailContact in unreplicated ($($TenOrg)meta.UnreplicatedOU)
            if($UseExOP){
                Reconnect-Ex2010 @pltRX10 ; 
                if($existRcp = get-recipient -id $odl.primarysmtpaddress -domaincontroller $domaincontroller -ErrorAction 0){
                    $smsg = "(existing recipient object for $($odl.primarysmtpaddress) found:$($existRcp.recipienttypedetails) - skipping MContact creation)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } else {
                    $smsg = "No conflicting OnPrem recipient found with: $($odl.primarysmtpaddress)" ; 
                    $smsg += "`nDo you want to create an *unreplicated* OnPrem MailContact to point at the EXO object?" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #*======v PS Simple YYY Confirm Prompt - psb-PSPrompt.cbp v======
                    $bRet=Read-Host "Enter YYY to continue. Anything else will exit" 
                    if ($bRet.ToUpper() -eq "YYY") {
                         Write-host "Moving on"
                            
                            # new-mailcontact -DisplayName -Name -LastName -DomainController -WhatIf -ExternalEmailAddress -Alias -PrimarySmtpAddress -OrganizationalUnit
                            $pltNewMC=[ordered]@{
                                DisplayName = "$($odl.name)-MC" ;
                                Name = "$($odl.name)-MC" ;
                                LastName = "$($odl.name)-MC";
                                DomainController = $domaincontroller;
                                ExternalEmailAddress = $odl.primarysmtpaddress;
                                Alias =  "$($odl.name.replace(' ',''))_$((new-guid).tostring().split('-')[-1])";
                                OrganizationalUnit = "OU=Unreplicated Contacts,$( (Get-Variable  -name "$($TenOrg)Meta").value.UnreplicatedOU )"
                                ErrorAction = 'STOP';
                                WhatIf = $($whatif);
                            } ; 
                            $smsg = "New-MailContact w`n$(($pltNewMC|out-string).trim())" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            $error.clear() ;
                            TRY {
                                $nmc = new-mailcontact @pltNewMC ; 
                                $propsMC = 'name','alias','recipienttype','primarysmtpaddress' ;
                                $smsg = "`n$(($nmc|ft -a $propsMC|out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } CATCH {
                                $ErrTrapd=$Error[0] ;
                                $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #-=-record a STATUSWARN=-=-=-=-=-=-=
                                $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                                if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                                if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                                #-=-=-=-=-=-=-=-=
                                $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                            } ; 

                    } else {
                         Write-Host "Invalid response. Skipping Contact creation"
                         # exit <asserted exit error #>
                         ;;exit 1

                    } # if-block end

                }; 
            } ; 
        } ; 
        #

    } else {
        if(!($Whatif)){
            $smsg =   ("FIND/CREATION FAILURE: $($InputSplat.DNameBase) not found.`n") ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        }
        else {
            $smsg = "Whatif-pass completed";
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        }
    };

    _cleanup ; # pipeline, issue is test-transcribing et all are dumping a $true |write-output and trashing the pl, need to refactor the verb-logging content to fix
    # for now move the return below _cleanup

    $smsg += $sBnr.replace('=v','=^').replace('v=','^=') ;
    $smsg += "`n-----------------------"; 
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    
    if($OutObject){
        $smsg = "(-OutObject specified: returning DG object to pipeline)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        $oDL | write-output ; 
    } ; 
    
    #write-host "xxx"
}

#*------^ new-DgTor.ps1 ^------


#*------v new-xoDGFromProperty.ps1 v------
function new-xoDGFromProperty{
    <#
    .SYNOPSIS
    new-xoDGFromProperty.ps1 - expand a property (of a DDG) into a new DDG populated with the original property's recipients (aimed at transplanting AcceptMailOnlyFrom values into AcceptMailOnlyFromDLMember's leveraging a free-standing Helpdesk-maintainable DG
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-09-02
    FileName    : new-xoDGFromProperty
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite:	URL
    AddedTwitter:	URL
    REVISIONS
    *3:20 PM 12/30/2021 updated Resolve-xoRcps calls to use -get* rather than specifying rgx matches on rtds
    * 9:23 AM 12/3/2021 updated a few wv's to pswls support
    * 4:40 PM 9/14/2021 corrected synopsis/description
    * 9:45 AM 9/2/2021 rev: added CBH, fixed existing block: Add-DistributionGroupMember -> propr xo alias:ps1AddxDistGrpMbr
    .DESCRIPTION
    new-xoDGFromProperty.ps1 - expand a property (of a DDG) into a new DG populated with the original property's recipients (aimed at transplanting AcceptMailOnlyFrom values into AcceptMailOnlyFromDLMember's populated with a free-standing Helpdesk-maintainable DG object.
    Generally, one would specify to have the new DG inherit the matching ManagedBy of the DDG.
    .PARAMETER Members
    Array of Members to be resolved against current Exchange environment [-Members `$members ]
    .PARAMETER NewDGName
    Name to be used for New DG to be populated[-NewDGName (`"`$(`$preDDG.name)-ApprovedSenders`
    .PARAMETER ManagedBy (override; defaults to ManagedBy of specified DDG)# [-ManagedBy `$preDDG.ManagedBy]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER Whatif
    Parameter to run a Test no-change pass [-Whatif switch]
    .EXAMPLE
    PS> $pltNxoDGfP=[ordered]@{
        Members=$preDDG.AcceptMessagesOnlyFrom  ;
        NewDGName=("$($preDDG.name)-ApprovedSenders") ;
        ManagedBy=$preDDG.ManagedBy ;
        whatIf=$true ;
    } ;
    if($nDG = new-xoDGFromProperty @pltNxoDGfP){
        set-exoDynamicDistributionGroup -id $preDDG.primarysmtpaddress -AcceptMessagesOnlyFromDLMembers $nDG.primarysmtpaddress -AcceptMessagesOnlyFrom $null -whatif ;
    } ;
    Generate a new DG to host a transplanted recipients value (to shift static AcceptMessagesOnlyFrom to a setparte SD-managable DG).
    Then demo's updating a the source DDG, adding the new created DG onto the DDG.AcceptMessagesOnlyFromDLMembers,
    and blanking the original DDG.AcceptMessagesOnlyFrom.
    .LINK
    https://github.com/tostka/verb-Exo
    #>
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory=$False,HelpMessage="Array of Members to be resolved against current Exchange environment [-Members `$members ]")]
        [array]$Members,
        [Parameter(Mandatory=$True,HelpMessage="Name to be used for New DG to be populated[-NewDGName (`"`$(`$preDDG.name)-ApprovedSenders`" ;)]")]
        [string]$NewDGName,
        [Parameter(Mandatory = $false, HelpMessage = "ManagedBy (override; defaults to ManagedBy of specified DDG)# [-ManagedBy `$preDDG.ManagedBy]")]
        $ManagedBy,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2,
        [Parameter(HelpMessage="Whatif Flag (defaults true, override -whatif:`$false) [-whatIf]")]
        [switch]$whatIf
    )
    if ($script:useEXOv2) { reconnect-eXO2 }
    else { reconnect-EXO } ;
    [array]$cmdletMaps = 'ps1GetxRcp;get-exorecipient;','ps1GetxDistGrp;get-exoDistributionGroup',
        'ps1NewxDistGrp;new-exoDistributionGroup' ,'ps1SetxDistGrp;set-exoDistributionGroup',
        'ps1GetxDistGrpMbr;get-exoDistributionGroupMember','ps1RmvxDistGrpMbr;remove-exoDistributionGroupMember',
        'ps1AddxDistGrpMbr;Add-exoDistributionGroupMember','ps1GetxDDG;Get-exoDynamicDistributionGroup',
        'ps1NewxDDG;New-exoDynamicDistributionGroup','ps1SetxDDG;Set-exoDynamicDistributionGroup',
        'ps1GetxOrgCfg;Get-exoOrganizationConfig' ;
    foreach($cmdletMap in $cmdletMaps){
        if($script:useEXOv2){
            if(!($cmdlet= Get-Command $cmdletMap.split(';')[1].replace('-exo','-xo') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
            $nAName = ($cmdletMap.split(';')[0]) ;
            if(-not(get-alias -name $naname -ea 0 |Where-Object{$_.Definition -eq $cmdlet.name})){
                $nalias = set-alias -name $nAName -value ($cmdlet.name) -passthru ;
                $smsg = "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
        } else {
            if(!($cmdlet= Get-Command $cmdletMap.split(';')[1])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
            $nAName = ($cmdletMap.split(';')[0]);
            if(-not(get-alias -name $naname -ea 0 |Where-Object{$_.Definition -eq $cmdlet.name})){
                $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                $smsg = "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
        } ;
    } ;
    #if($ManagedBy){$oManagedBy = ps1GetxRcp $ManagedBy -ea 'STOP' | Select-Object -expand primarysmtpaddress  | Select-Object -unique ;} ;
    if($ManagedBy){
        <# [Set-DynamicDistributionGroup (ExchangePowerShell) | Microsoft Docs - docs.microsoft.com/](https://docs.microsoft.com/en-us/powershell/module/exchange/set-dynamicdistributiongroup?view=exchange-ps)
           [Set-DistributionGroup (ExchangePowerShell) | Microsoft Docs - docs.microsoft.com/](https://docs.microsoft.com/en-us/powershell/module/exchange/set-distributiongroup?view=exchange-ps)
            -ManagedBy
            A dynamic group can only have one owner
            A [distgroup] must have at least one owner & if you don'specify... the user account that created the group is the owner. 
            ... must be a mailbox, mailuser or mail-enabled security group
        #> 
        #$oManagedBy = (Resolve-xoRcps -Recipients $ManagedBy -MatchRecipientTypeDetails '(UserMailbox|MailUser|GuestMailUser)' -ea 'STOP' -Verbose:($VerbosePreference -eq 'Continue') )  | Select-Object -unique 
        $oManagedBy = (Resolve-xoRcps -Recipients $ManagedBy -getMailboxPrincipals -ea 'STOP' -Verbose:($VerbosePreference -eq 'Continue') )  | Select-Object -unique 
    }  ; 
    if($members){
        #$members = $members | ps1GetxRcp -ErrorAction Continue | Select-Object -expand primarysmtpaddress  | Select-Object -unique ;
        $members = $members 
         #$members = (Resolve-xoRcps -Recipients $members -MatchRecipientTypeDetails '(UserMailbox|MailUser|GuestMailUser|MailContact)' -Verbose:($VerbosePreference -eq 'Continue') -ErrorAction Continue)  ; 
         $members = (Resolve-xoRcps -Recipients $members -getRecipients -Verbose:($VerbosePreference -eq 'Continue') -ErrorAction Continue)  ; 
    } ;
    $pltNDG=[ordered]@{
        DisplayName=$NewDGName;
        Name=$NewDGName;
        Members=$members ;
        #DomainController=$domaincontroller;
        Alias=([System.Text.RegularExpressions.Regex]::Replace($NewDGName,"[^1-9a-zA-Z_]",""));
        ManagedBy=$oManagedBy;
        #OrganizationalUnit = (get-organizationalunit (($preDDG.DistinguishedName.tostring().split(",") | select -Skip 1) -join ",").tostring()).CanonicalName ;
        ErrorAction = 'Stop' ;
        whatif=$($whatif);
    } ;
    if($existDG=ps1GetxDistGrp -id $pltndg.alias -ResultSize 1 -ea 0){
        $pltSetDG=[ordered]@{
            identity = $existDG.primarysmtpaddress ;
            #Members=$members ; # not supported have to add-DistributionGroupMember them in on existings
            #DomainController=$domaincontroller;
            ManagedBy=$oManagedBy;
            whatif=$($whatif);
            ErrorAction = 'Stop' ;
        } ;
        $smsg = "UpdateExisting DG:$((get-alias ps1SetxDistGrp).definition)  w`n$(($pltSetDG|out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        ps1SetxDistGrp @pltSetDG ;
        # pre-purge
        $prembrs = ps1GetxDistGrpMbr -id $pltSetDG.identity ;
        $pltModDGMbr=[ordered]@{identity= $pltSetDG.identity ;whatif = $($whatif) ;erroraction = 'STOP'  ;confirm=$false ;}
        $smsg = "Clear existing members:$((get-alias ps1RmvxDistGrpMbr).definition) w`n$(($pltModDGMbr|out-string).trim())`n$(($prembrs |out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #$prembrs | %{ps1RmvxDistGrpMbr @$pltModDGMbr -Member $_.alias  } ;
        $prembrs.distinguishedname | ps1RmvxDistGrpMbr @pltModDGMbr ;
        # ps1GetxDistGrpMbr -id $pltSetDG.identity | ps1RmvxDistGrpMbr -id $pltSetDG.identity –whatif:$($whatif) -ea STOP ;
        # then add validated from scratch
        $smsg = "re-add VALIDATED members:add-DistributionGroupMember w`n$(($pltModDGMbr|out-string).trim())`n$(($members|out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $members | ps1AddxDistGrpMbr @pltModDGMbr ;
        $pdg =  ps1GetxDistGrp -id $pltSetDG.identity ;
    } else {
        $smsg = "$((get-alias ps1NewxDistGrp).definition)  w`n$(($pltNDG|out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $pdg = ps1NewxDistGrp @pltNDG ;
    } ;
    if(!$whatif){
        # was getting notfounds, trying to update the $pdg, so re-qry it from scratch, if it comes back it's *there* for updates
        $1F=$false ;Do {if($1F){Start-Sleep -s 5} ;  write-host "." -NoNewLine ; $1F=$true ; } Until ($existDG = ps1GetxDistGrp $pltNDG.alias -EA 0) ;
        # set hidden (can't be done with new-dg command): -HiddenFromAddressListsEnabled
        $pltSetDG=[ordered]@{
            identity = $existDG.primarysmtpaddress ;
            HiddenFromAddressListsEnabled = $true ;
            whatif=$($whatif);
            ErrorAction = 'Stop' ;
        } ;
        $smsg = "HiddenFromAddressListsEnabled:UpdateExisting DG:$((get-alias ps1SetxDistGrp).definition)  w`n$(($pltSetDG|out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        ps1SetxDistGrp @pltSetDG ;

        $pdg =  ps1GetxDistGrp -id $pltSetDG.identity ;
        $smsg = "Returning new DG object to pipeline" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $pdg | write-output ;

    } else {
        $smsg = "(-whatif: skipping balance of process)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $false | write-output ;
    }  ;

}

#*------^ new-xoDGFromProperty.ps1 ^------


#*------v Print-Details.ps1 v------
function Print-Details{
    <#
    .SYNOPSIS
    Print-Details.ps1 - localized verb-EXO vers of non-'$global:' helper funct from ExchangeOnlineManagement. The globals export fine, these don't and appear to need to be loaded manually
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 20201109-0833AM
    FileName    : Print-Details.ps1
    License     : [none specified]
    Copyright   : [none specified]
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell
    AddedCredit : Microsoft (edited version of published commands in the module)
    AddedWebsite:	https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
    REVISIONS
    * 8:34 AM 11/9/2020 init
    .DESCRIPTION
    Print-Details.ps1 - localized verb-EXO vers of non-'$global:' helper funct from ExchangeOnlineManagement. The globals export fine, these don't and appear to need to be loaded manually
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    Print-Details
    Stock call
    .LINK
    https://github.com/tostka/verb-EXO
    .LINK
    https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
    #>
    [CmdletBinding()]
    param()
    Write-Host -ForegroundColor Yellow ""
    Write-Host -ForegroundColor Yellow "----------------------------------------------------------------------------"
    Write-Host -ForegroundColor Yellow "The module allows access to all existing remote PowerShell (V1) cmdlets in addition to the 9 new, faster, and more reliable cmdlets."
    Write-Host -ForegroundColor Yellow ""
    Write-Host -ForegroundColor Yellow "|--------------------------------------------------------------------------|"
    Write-Host -ForegroundColor Yellow "|    Old Cmdlets                    |    New/Reliable/Faster Cmdlets       |"
    Write-Host -ForegroundColor Yellow "|--------------------------------------------------------------------------|"
    Write-Host -ForegroundColor Yellow "|    Get-CASMailbox                 |    Get-EXOCASMailbox                 |"
    Write-Host -ForegroundColor Yellow "|    Get-Mailbox                    |    Get-EXOMailbox                    |"
    Write-Host -ForegroundColor Yellow "|    Get-MailboxFolderPermission    |    Get-EXOMailboxFolderPermission    |"
    Write-Host -ForegroundColor Yellow "|    Get-MailboxFolderStatistics    |    Get-EXOMailboxFolderStatistics    |"
    Write-Host -ForegroundColor Yellow "|    Get-MailboxPermission          |    Get-EXOMailboxPermission          |"
    Write-Host -ForegroundColor Yellow "|    Get-MailboxStatistics          |    Get-EXOMailboxStatistics          |"
    Write-Host -ForegroundColor Yellow "|    Get-MobileDeviceStatistics     |    Get-EXOMobileDeviceStatistics     |"
    Write-Host -ForegroundColor Yellow "|    Get-Recipient                  |    Get-EXORecipient                  |"
    Write-Host -ForegroundColor Yellow "|    Get-RecipientPermission        |    Get-EXORecipientPermission        |"
    Write-Host -ForegroundColor Yellow "|--------------------------------------------------------------------------|"
    Write-Host -ForegroundColor Yellow ""
    Write-Host -ForegroundColor Yellow "To get additional information, run: Get-Help Connect-ExchangeOnline or check https://aka.ms/exops-docs"
    Write-Host -ForegroundColor Yellow ""
    Write-Host -ForegroundColor Yellow "Send your product improvement suggestions and feedback to exocmdletpreview@service.microsoft.com. For issues related to the module, contact Microsoft support. Don't use the feedback alias for problems or support issues."
    Write-Host -ForegroundColor Yellow "----------------------------------------------------------------------------"
    Write-Host -ForegroundColor Yellow ""
}

#*------^ Print-Details.ps1 ^------


#*------v Reconnect-EXO.ps1 v------
Function Reconnect-EXO {
   <#
    .SYNOPSIS
    Reconnect-EXO - Reestablish connection to Exchange Online (via EXO V2/V3 graph-api module)
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-07-29
    FileName    :
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    REVISIONS   :
    * 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
    * 12:51 PM 5/30/2023 Updates to support either -Credential, or -UserRole + -TenOrg, to support fully portable downstream credentials: 
        - Add -UserRole & explicit -TenOrg params
        - Drive TenOrg defaulted $global:o365_TenOrgDefault, or on $env:userdomain
        - use the combo thru get-TenantCredential(), then set result to $Credential
        - if using Credential, the above are backed out via get-TenantTag() on the $credential 
        - CBA identifiers are resolve always via $uRoleReturn = resolve-UserNameToUserRole -Credential $Credential ;
    * 2:02 PM 5/25/2023 updated CBH example to reflect use of $pltRXOC std conn splat
    * 3:24 PM 5/23/2023 disabled msal.ps load ; fixed typo (-eq vs =, dumping $false into pipe)     
    * 4:24 PM 5/22/2023 add missing pswlt cmd for winrm chkline
    * 10:15 AM 5/19/2023 defer to resolve-UserNameToUserRole -Credential $Credential; assign certtag from output
    # 3:40 PM 5/10/2023 ported in block of CBA-handling code at 387
    # 1:36 PM 5/2/2023 port over cxo2 update: pltCXO2 -> $pltCXO; connect-EXO2 -> connect-EXO; Disconnect-EXO2 -> Disconnect-EXO
    # 3:18 PM 4/19/2023 under EOM310: replc $xmod.version refs with $EOMMv...
    * 11:20 AM 4/18/2023 step debugs ;  consolidate reconnect-exo2 into reconnect-exo (alias reconnect-exo2 & rxo2)
    * 2:02 PM 4/17/2023 rev: $MinNoWinRMVersion from 2.0.6 => 3.0.0.
    # * 11:02 AM 4/4/2023 reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not
    * 3:14 pm 3/29/2023: REN'D $modname => $EOMModName
    * 11:01 AM 12/21/2022 moved $pltCXO2 def out to always occur (was only when !$bExistingEXOGood )
    * 3:59 PM 8/2/2022 got through dbugging EOM v205 SID interactive pass, working ; added -MinimumVersion & - MinNoWinRMVersion ; fully works from mybox w v206p6, cEOM connection, with functional prefix.
    * 3:30 PM 7/25/2022 tests against CBA & SID interactive creds on EOM v205, need to debug now against EOM v206p6, to accomodate PSSession-less connect & test code.
    * 3:54 PM 4/1/2022 add missing $silent param (had support, but no param)
    * 11:04 AM 3/30/2022 recode for ExchangeOnlineManagement v2.0.5, fundemental revisions, since prior v1.0.1
    # below here is orig rxo revs
    * 9:03 AM 12/14/2021 cleaned comments
    * 1:17 PM 8/17/2021 added -silent param
    * 3:20 PM 3/31/2021 fixed pssess typo
    * 8:30 AM 10/22/2020 added $TenOrg, swapped looping meta resolve with 1-liner approach ; added AcceptedDom caching to the middle status test (suppress one more get-exoaccepteddomain call if possible)
    * 1:30 PM 9/21/2020 added caching of AcceptedDomain, dynamically into XXXMeta - checks for .o365_AcceptedDomains, and pops w (Get-exoAcceptedDomain).domainname when blank. 
        As it's added to the $global meta, that means it stays cached cross-session, completely eliminates need to dyn query per rxo, after the first one, that stocks the value
    * 2:39 PM 8/4/2020 fixed -match "^(Session|WinRM)\d*" rgx (lacked ^, mismatched EXOv2 conns)
    * 10:35 AM 7/28/2020 tweaked retry loop to not retry-sleep 1st attempt
    * 3:24 PM 7/24/2020 updated to support tenant-alignment & sub'd out showdebug for verbose
    * 11:48 AM 5/27/2020 added func alias:rxo within the func
    * 2:38 PM 4/20/2020 added local $rgxExoPsHostName
    * 8:45 AM 3/3/2020 public cleanup
    * 9:52 PM 1/16/2020 cleanup
    * 1:07 PM 11/25/2019 added *tol/*tor/*cmw alias variants for connect & reconnect
    * 9:52 AM 11/20/2019 spliced in credential matl
    * 2:55 PM 10/11/2018 connect-exo: added pre sleep skip on tryno 1
    * 8:04 AM 11/20/2017 code in a loop in the reconnect-exo, until it hits or 100% times out
    # 8:47 AM 6/2/2017 cleaned up deadwood, simplified pshelp
    * 7:58 AM 3/15/2017 ren Disconnect/Connect/Reconnect-EXO => Disconnect/Connect/Reconnect-EXO, added pss, doing tweaks to put into prod use
    * 2/10/14 posted version
    .DESCRIPTION
    Reconnect-EXO - Reestablish connection to Exchange Online (via EXO V2/V3 graph-api module)
    .PARAMETER Credential
    Credential to use for this connection [-credential [credential obj variable]
     .PARAMETER MinimumVersion
    MinimumVersion required for ExchangeOnlineManagement module (defaults to '2.0.5')[-MinimumVersion '2.0.6']
    .PARAMETER MinNoWinRMVersion
    MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']
    .PARAMETER ProxyEnabled
    Use Proxy-Aware SessionOption settings [-ProxyEnabled]
    .PARAMETER UserRole
    Credential Optional User Role spec for credential discovery (wo -Credential)(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]
    .PARAMETER TenOrg
    Optional Tenant Tag (wo -Credential)[-TenOrg 'XYZ']
    .PARAMETER showDebug
    Debugging Flag [-showDebug]
    .PARAMETER silent
    Switch to specify suppression of all but warn/error echos.
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    PS>  Reconnect-EXO;
    Reconnect EXO connection self-locating creds
    .EXAMPLE
    PS>  Reconnect-EXO -credential $cred ;
    Reconnect EXO connection with explicit [pscredential] object credential specified
    .EXAMPLE
    reconnect-exo -UserRole SIDCBA -TenOrg ABC -verbose  ; 
    Demo use of UserRole (specifying a CBA variant), AND TenOrg spec, to connect (autoresolves against preconfigured credentials in profile)
    .EXAMPLE
    PS> $pltRXOC = [ordered]@{
    PS>     Credential = $Credential ;
    PS>     verbose = $($VerbosePreference -eq "Continue")  ;
    PS>     Silent = $silent ; 
    PS> } ;
    PS> if ($script:useEXOv2 -OR $useEXOv2) { reconnect-eXO2 @pltRXOC }
    PS> else { reconnect-EXO @pltRXOC } ;    
    Splatted example leveraging prefab $pltRXOC splat, derived from local variables & $VerbosePreference value.
    .EXAMPLE
    PS>  $batchsize = 10 ;
    PS>  $RecordCount=$mr.count #this is the array of whatever you are processing ;
    PS>  $b=0 #this is the initialization of a variable used in the do until loop below ;
    PS>  $mrs = @() ;
    PS>  do {
    PS>      Write-Progress -Activity "Getting move request statistics for all $wave move requests." -Status "Processing Records $b through $($b+$batchsize) of $RecordCount." -PercentComplete ($b/$RecordCount*100) ;
    PS>      $mrs += $mr | Select-Object -skip $b -first $batchsize | foreach-object {Reconnect-EXO; $_ | Get-OLMoveRequestStatistics} ;
    PS>      $b=$b+$batchsize ;
    PS>      } ;
    PS>  until ($b -gt $RecordCount) ;
    Demo use of a Reconnect-EXO call mid-looping process to ensure connection stays available for duration of long-running process.    
    .LINK
    Github      : https://github.com/tostka/verb-exo
    #>
    [CmdletBinding()]
    [Alias('rxo','reconnect-exo2','rxo2')]
    PARAM(
        [Parameter(HelpMessage = "MinimumVersion required for ExchangeOnlineManagement module (defaults to '2.0.5')[-MinimumVersion '2.0.6']")]
            [version] $MinimumVersion = '2.0.5',
        [Parameter(HelpMessage = "MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']")]
            [version] $MinNoWinRMVersion = '3.0.0',
        [Parameter(HelpMessage="Use Proxy-Aware SessionOption settings [-ProxyEnabled]")]
            [boolean]$ProxyEnabled = $False,
        [Parameter(HelpMessage="Credential to use for this connection [-credential [credential obj variable]")]
            [System.Management.Automation.PSCredential]$Credential,
            # = $global:credo365TORSID, # defer to TenOrg & UserRole resolution
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ; 
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ; 
                return $true ; 
            })]
            [string[]]$UserRole = @('SIDCBA','SID','CSVC'),
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
            [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
            [switch] $showDebug,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch]$silent
    ) ;
    BEGIN{
        $verbose = ($VerbosePreference -eq "Continue") ; 
        if(-not (get-variable rgxExoPsHostName -ea 0)){$rgxExoPsHostName="^(ps\.outlook\.com|outlook\.office365\.com)$" } ;
        if(-not (get-variable rgxCertThumbprint -ea 0)){$rgxCertThumbprint = '[0-9a-fA-F]{40}' ; } ;
        if(-not (get-variable rgxCertFNameSuffix -ea 0)){$rgxCertFNameSuffix = '-([A-Z]{3})$' ; } ; 

        <# 4:45 PM 7/7/2022 workaround msal.ps bug: always ipmo it FIRST: "Get-msaltoken : The property 'Authority' cannot be found on this object. Verify that the property exists."
        # admin/SID module auto-install code (myBoxes UID split-perm CU, all else t AllUsers)
        $modname = 'MSAL.PS' ;
        $error.clear() ;
        $pltIMod = @{Name = $modname ; ErrorAction = 'Stop' ; verbose=$false} ;
        # this forces a specific rev into the ipmo!
        if ($MinimumVersion) { $pltIMod.add('MinimumVersion', $MinimumVersion.tostring()) } ;
        $error.clear() ;
        Try { Get-Module $modname -ErrorAction Stop | out-null } Catch {
            $smsg = "Import-Module w`n$(($pltIMod|out-string).trim())" ;
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            Import-Module @pltIMod ;
        } ; # IsImported
        #>
        $EOMmodname = 'ExchangeOnlineManagement' ;
        
        #*------v PSS & GMO VARIS v------
        # get-pssession session varis
        $EXOv1ConfigurationName = $EXOv2ConfigurationName = $EXoPConfigurationName = "Microsoft.Exchange" ;

        if(-not (get-variable EXOv1ConfigurationName -ea 0)){$EXOv1ConfigurationName = "Microsoft.Exchange" };
        if(-not (get-variable EXOv2ConfigurationName -ea 0)){$EXOv2ConfigurationName = "Microsoft.Exchange" };
        if(-not (get-variable EXoPConfigurationName -ea 0)){$EXoPConfigurationName = "Microsoft.Exchange" };

        if(-not (get-variable EXOv1ComputerName -ea 0)){$EXOv1ComputerName = 'ps.outlook.com' };
        if(-not (get-variable EXOv1runspaceConnectionInfoAppName -ea 0)){$EXOv1runspaceConnectionInfoAppName = '/PowerShell-LiveID'  };
        if(-not (get-variable EXOv1runspaceConnectionInfoPort -ea 0)){$EXOv1runspaceConnectionInfoPort = '443' };

        if(-not (get-variable EXOv2ComputerName -ea 0)){$EXOv2ComputerName = 'outlook.office365.com' ;}
        if(-not (get-variable EXOv2Name -ea 0)){$EXOv2Name = "ExchangeOnlineInternalSession*" ; }
        if(-not (get-variable rgxEXoPrunspaceConnectionInfoAppName -ea 0)){$rgxEXoPrunspaceConnectionInfoAppName = '^/(exadmin|powershell)$'}; 
        if(-not (get-variable EXoPrunspaceConnectionInfoPort -ea 0)){$EXoPrunspaceConnectionInfoPort = '80' } ; 
        # gmo varis
        if(-not (get-variable rgxEXOv1gmoDescription -ea 0)){$rgxEXOv1gmoDescription = "^Implicit\sremoting\sfor\shttps://ps\.outlook\.com/PowerShell" }; 
        if(-not (get-variable EXOv1gmoprivatedataImplicitRemoting -ea 0)){$EXOv1gmoprivatedataImplicitRemoting = $true };
        if(-not (get-variable rgxEXOv2gmoDescription -ea 0)){$rgxEXOv2gmoDescription = "^Implicit\sremoting\sfor\shttps://outlook\.office365\.com/PowerShell" }; 
        if(-not (get-variable EXOv2gmoprivatedataImplicitRemoting -ea 0)){$EXOv2gmoprivatedataImplicitRemoting = $true } ;
        if(-not (get-variable rgxExoPsessionstatemoduleDescription -ea 0)){$rgxExoPsessionstatemoduleDescription = '/(exadmin|powershell)$' };
        if(-not (get-variable EXOv1GmoFilter -ea 0)){$EXOv1GmoFilter = 'tmp_*' } ; 
        if(-not (get-variable EXOv2GmoNoWinRMFilter -ea 0)){$EXOv2GmoNoWinRMFilter = 'tmpEXO_*' };
        #*------^ END PSS & GMO VARIS ^------

        # * 11:02 AM 4/4/2023 reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not
        #region EOMREV ; #*------v EOMREV Check v------
        #$EOMmodname = 'ExchangeOnlineManagement' ;
        $pltIMod = @{Name = $EOMmodname ; ErrorAction = 'Stop' ; verbose=$false} ;
        # do a gmo first, faster than gmo -list
        if([version]$EOMMv = (Get-Module @pltIMod| sort version | select -last 1 ).version){}
        elseif([version]$EOMMv = (Get-Module -ListAvailable @pltIMod| sort version | select -last 1 ).version){} 
        else { 
            $smsg = "$($EOMmodname) PowerShell v$($MinNoWinRMVersion) module is required, do you want to install it?" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
            else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $bRet=Read-Host "Enter YYY to continue. Anything else will exit"  ; 
            if ($bRet.ToUpper() -eq "YYY") {
                $smsg = "Installing $($EOMmodname) module..." ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Install-Module $EOMmodname -Repository PSGallery -AllowClobber -Force ; 
            } else {
                $smsg = "Please install $($EOMmodname) PowerShell v$($MinNoWinRMVersion)  module." ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                #exit 1
                break ; 
            }  ; 
        } ; 
        $smsg = "(Checking for WinRM support in this EOM rev...)" ;
        if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        if([version]$EOMMv -ge [version]$MinNoWinRMVersion){
            $MinNoWinRMVersion = $EOMMv.tostring() ;
            $IsNoWinRM = $true ; 
        }elseif([version]$EOMMv -lt [version]$MinimumVersion){
            $smsg = "Installed $($EOMmodname) is v$($MinNoWinRMVersion): This module is obsolete!" ; 
            $smsg += "`nAnd unsupported by this function!" ; 
            $smsg += "`nPlease install $($EOMmodname) PowerShell v$($MinNoWinRMVersion)  module!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            Break ; 
        } else {
            $IsNoWinRM = $false ; 
        } ; 
        [boolean]$UseConnEXO = [boolean]([version]$EOMMv -ge [version]$MinNoWinRMVersion) ; 
        #endregion EOMREV ; #*------^ END EOMREV Check  ^------

        if(-not $Credential){
            if($UserRole){
                $smsg = "Using specified -UserRole:$( $UserRole -join ',' )" ;
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else { $UserRole = @('SID','CSVC') } ;
            if($TenOrg){
                $smsg = "Using explicit -TenOrg:$($TenOrg)" ; 
            } else { 
                switch -regex ($env:USERDOMAIN){
                    ([regex]('(' + (( @($TORMeta.legacyDomain,$CMWMeta.legacyDomain)  |foreach-object{[regex]::escape($_)}) -join '|') + ')')).tostring() {$TenOrg = $env:USERDOMAIN.substring(0,3).toupper() } ;
                    $TOLMeta.legacyDomain {$TenOrg = 'TOL' }
                    default {throw "UNRECOGNIZED `$env:USERDOMAIN!:$($env:USERDOMAIN)" ; exit ; } ;
                } ;  
                $smsg = "Imputed `$TenOrg from logged on USERDOMAIN:$($TenOrg)" ;             
            } ; 
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;             
            
            $o365Cred = $null ;
            $pltGTCred=@{TenOrg=$TenOrg ; UserRole= $UserRole; verbose=$($verbose)} ;
            $smsg = "get-TenantCredentials w`n$(($pltGTCred|out-string).trim())" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            $o365Cred = get-TenantCredentials @pltGTCred ;

            if($o365Cred.credType -AND $o365Cred.Cred -AND $o365Cred.Cred.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                $smsg = "(validated `$o365Cred contains .credType:$($o365Cred.credType) & `$o365Cred.Cred.username:$($o365Cred.Cred.username)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $Credential = $o365Cred.Cred ;
            } else { 
                $smsg = "UNABLE TO RESOLVE FUNCTIONAL CredType/UserRole from specified explicit -Credential:$($Credential.username)!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 

                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                break ; 
            } ; 
            
        } else { 
            # test-exotoken only applies if $UseConnEXO  $false
            $TenOrg = get-TenantTag -Credential $Credential ;
        } ;
        # build the cred etc once, for all below:
        $pltCXO=[ordered]@{
            Credential = $Credential ;
            verbose = $($verbose) ; 
            erroraction = 'STOP' ;
        } ;
        if((gcm connect-EXO).Parameters.keys -contains 'silent'){
            $pltCXO.add('Silent',$false) ;
        } ;

        # defer to resolve-UserNameToUserRole -Credential $Credential
        <# need certtag further down, for credential align test
        if($credential.username -match $rgxCertThumbprint){
            $smsg =  "(UserName:Certificate Thumbprint detected)"
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            if($tcert = get-childitem -path "Cert:\CurrentUser\My\$($credential.username)"){
                $certUname = $tcert.friendlyname ; 
                $certTag = [regex]::match($certUname,$rgxCertFNameSuffix).captures[0].groups[1].value ; 
                $smsg = "(using CBA:cred:$($certTag):$([string]$tcert.friendlyname))" ; 
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else { 
                $smsg = "UNABLE TO RESOLVE `$TENORG:$($TenOrg) TO FUNCTIONAL `$$($TenOrg)meta.o365_TenantDomain!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                throw $smsg ; 
                Break ; 
            } ;
        } ; 
        #>
        $uRoleReturn = resolve-UserNameToUserRole -Credential $Credential ; 
        if($credential.username -match $rgxCertThumbprint){
            $certTag = $uRoleReturn.TenOrg ; 
        } ; 

    } ;  # BEG-E
    PROCESS{
        $bExistingEXOGood = $false ; 
        $exov2Good = $exov3Good = $null ; 
        if( $legXPSSession = Get-PSSession | where-object {$_.ConfigurationName -like "Microsoft.Exchange" -AND $_.Name -match "^(Session|WinRM)\d*" } ){
            # ignore state & Avail, close the conflicting legacy conn's
            $smsg = "(existing legacy-EXO or Broken connections found, closing)" ; 
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            Disconnect-Exo ; Disconnect-PssBroken ;Start-Sleep -Seconds 3;
            $bExistingEXOGood = $false ; 
        } ; 
        <# 3:50 PM 4/7/2022 ExchangeOnlinemanagement has a *bug*
        [Issue using ExchangeOnlineManagement v2.0.4 module to connect to Exchange Online remote powershell (EXO) and Exchange On-Prem remote powershell (EXOP) in same powershell window - Microsoft Q&A - docs.microsoft.com/](https://docs.microsoft.com/en-us/answers/questions/451786/issue-using-exchangeonlinemanagement-v204-module-t.html?childToView=804782#answer-804782)
        It *can't* cleanly reconnect the legacy EXO cmdlet dependant implicit-remote sessions, when they time out
        if there's an *existing* Exchange Onprem implicit remote session. 

        No fix, lame workaround: close all implicit remote sessions, before reopening EMO *first*, and then reconnecting EXOnPrem

        #>
        # check for existing implicit remote EXOnPrem sessions we have to kill first (and then post-reconnect)


        #clear invalid existing EXOv2 PSS's
       # fix typo from Name -eq to -like 
       # new token prop expir support:
       #((Get-PSSession | where Name -like ExchangeOnlineInternalSession*).TokenExpiryTime -lt (get-date ))
        #$exov2Broken = Get-PSSession | where-object {$_.ConfigurationName -like "Microsoft.Exchange" -AND (
        #    $_.Name -like "ExchangeOnlineInternalSession*") -AND $_.State -like "*Broken*"}
        # add token support clause: -AND ($_.TokenExpiryTime -lt (get-date )), leaving it out, may be a usecase with Broken but not post expiration
        # just fix the non-wildcard -like's w proper -eq's 
        $exov2Broken = Get-PSSession | where-object {$_.ConfigurationName -eq "Microsoft.Exchange" -AND (
            $_.Name -like "ExchangeOnlineInternalSession*") -AND $_.State -eq "Broken" }
        $exov2Closed = Get-PSSession | where-object {$_.ConfigurationName -like "Microsoft.Exchange" -AND (
            $_.Name -like "ExchangeOnlineInternalSession*") -AND $_.State -like "*Closed*"}
        
        #if ($exov2Broken.count -gt 0){for ($index = 0 ;$index -lt $exov2Broken.count ;$index++){Remove-PSSession -session $exov2Broken[$index]} };
        #if ($exov2Closed.count -gt 0){for ($index = 0 ;$index -lt $exov2Closed.count ; $index++){Remove-PSSession -session $exov2Closed[$index] } } ; 
        # sub full Disconnect-EXO for Remove-PSSession: dxo2 includes 'Clear-ActiveToken -TokenProvider $session.TokenProvider' in addition to remove-pssession
        $pltDXO2=[ordered]@{
            verbose = $($VerbosePreference -eq "Continue") ;        
            silent = $silent ; 
        } ;
        if ( ($exov2Broken.count -gt 0) -OR ($exov2Closed.count -gt 0)){
            $smsg = "Disconnect-EXO w`n$(($pltDXO2|out-string).trim())" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
             Disconnect-EXO @pltDXO2 ;
        };
        
        if($IsNoWinRM){
            # 9:44 AM 4/20/2023 missed $EOMMv ref upgrade
            if($EOMMv.major -ge 3) {
                if ((Get-ConnectionInformation).tokenStatus -eq 'Active') {
                    $exov3Good = $bExistingEXOGood = $true ; 
                } else { 
                    $exov3Good = $bExistingEXOGood = $false ; 
                } ; 
            } else { 

            }
        } else { 
            # appears MFA may not properly support passing back a session vari, so go right to strict hostname matches
            $exov2Good = Get-PSSession | where-object {$_.ConfigurationName -like "Microsoft.Exchange" -AND (
                $_.Name -like "ExchangeOnlineInternalSession*") -AND $_.State -like "*Opened*" -AND (
                $_.Availability -eq 'Available')} ; 
        } ; 
        if($exov2Good -OR $exov3Good ){
            if( get-command Get-xoAcceptedDomain -ea 0) {
                # add accdom caching
                #$TenOrg = get-TenantTag -Credential $Credential ;
                if(!(Get-Variable  -name "$($TenOrg)Meta").value.o365_AcceptedDomains){
                    set-Variable  -name "$($TenOrg)Meta" -value ( (Get-Variable  -name "$($TenOrg)Meta").value += @{'o365_AcceptedDomains' = (Get-xoAcceptedDomain).domainname} )
                } ;
                #if ((Get-xoAcceptedDomain).domainname.contains($Credential.username.split('@')[1].tostring())){
                if( ($credential.username -match $rgxCertThumbprint) -AND ((Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_Prefix -eq $certTag )){
                    # 9:59 AM 6/24/2022 need a case for CBA cert (thumbprint username)
                    # compare cert fname suffix to $xxxMeta.o365_Prefix
                    # validate that the connected EXO is to the CBA Cert tenant
                    $smsg = "(EXO Authenticated & Functional CBA cert:$($certTag),($($certUname)))" ;
                    if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                    $bExistingEXOGood = $isEXOValid = $true ;
                }elseif((Get-Variable  -name "$($TenOrg)Meta").value.o365_AcceptedDomains.contains($Credential.username.split('@')[1].tostring())){
                    # validate that the connected EXO is to the $Credential tenant    
                    $smsg = "(EXO Authenticated & Functional(AccDom):$($Credential.username.split('@')[1].tostring()))" ; 
                    if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    $bExistingEXOGood = $true ; 
                # issue: found fresh bug in cxo: svcacct UPN suffix @tenantname.onmicrosoft.com, but testing against AccepteDomain, it's not in there (tho @DOMAIN.mail.onmicrosoft.comis)
                }elseif((Get-Variable  -name "$($TenOrg)Meta").value.o365_TenantDomain -eq ($Credential.username.split('@')[1].tostring())){
                    $smsg = "(EXO Authenticated & Functional(TenDom):$($Credential.username.split('@')[1].tostring()))" ; 
                    if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $bExistingEXOGood = $true ;
                } else { 
                    $smsg = "(Credential mismatch:disconnecting from existing EXO:$($eEXO.Identity) tenant)" ; 
                    if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    Disconnect-EXO ; 
                    $bExistingEXOGood = $false ; 
                } ; 
            } else { 
                # capture outlier: shows a session wo the test cmdlet, force reset
                Disconnect-EXO ; 
                $bExistingEXOGood = $false ; 
            } ; 
        } ; 

        if($bExistingEXOGood -eq $false){
            
            $smsg = "connect-EXO w $($credential.username):`n$(($pltCXO|out-string).trim())" ; 
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            #connect-EXO -Credential $Credential -verbose:$($verbose) ; 
            connect-EXO @pltCXO ;               
        } ; 

    } ;  # PROC-E
    END {
        # if ( (get-module -name tmp_* | ForEach-Object { Get-Command -module $_.name -name 'Add-xoAvailabilityAddressSpace' -ea 0 }) -AND (test-EXOToken) ) {
        #if( (Get-PSSession | where-object {$_.ConfigurationName -like "Microsoft.Exchange" -AND $_.Name -like "ExchangeOnlineInternalSession*" -AND $_.State -like "*Opened*" -AND ($_.Availability -eq 'Available')}) -AND (test-EXOToken) ){ 
        $validated = $false ;
        if($UseConnEXO -AND $exov3Good  ){
            #connexo should smoothly recycle connections; only v1 requires manual detect & reconnect with basic auth creds
            $validated = $true ; 
        } else { 
            # cred is mandetory - err - in test-exotoken, push it through
            if( (Get-PSSession | where-object {
                    $_.ConfigurationName -like "Microsoft.Exchange" -AND $_.Name -like "ExchangeOnlineInternalSession*" -AND $_.State -like "*Opened*" -AND ($_.Availability -eq 'Available')
                }) -AND (test-EXOToken -Credential $pltCXO.credential) ){ 
                # implement caching of accepteddoms into the XXXMeta, in the session (cut back on queries to EXO on acceptedom)
                # non-looping
                $validated = $true ; 
            } 
        } ; 
        if($validated){
            if( get-command Get-xoAcceptedDomain -ea 0) {
                #$TenOrg = get-TenantTag -Credential $Credential ;
                if(!(Get-Variable  -name "$($TenOrg)Meta").value.o365_AcceptedDomains){
                    set-Variable  -name "$($TenOrg)Meta" -value ( (Get-Variable  -name "$($TenOrg)Meta").value += @{'o365_AcceptedDomains' = (Get-xoAcceptedDomain).domainname} )
                } ;
            } ; 
            <#
            $credDom = ($Credential.username.split("@"))[1] ;
            $Metas=(get-variable *meta|Where-Object{$_.name -match '^\w{3}Meta$'}) ;
            foreach ($Meta in $Metas){
                if( ($credDom -eq $Meta.value.legacyDomain) -OR ($credDom -eq $Meta.value.o365_TenantDomain) -OR ($credDom -eq $Meta.value.o365_OPDomain)){
                    if(!$Meta.value.o365_AcceptedDomains){
                        set-variable -Name $meta.name -Value ((get-variable -name $meta.name).value  += @{'o365_AcceptedDomains' = (Get-xoAcceptedDomain).domainname} )
                    } ; 
                    break ;
                } ;
            } ;
            #>
            #if ((Get-xoAcceptedDomain).domainname.contains($Credential.username.split('@')[1].tostring())){
            #if($Meta.value.o365_AcceptedDomains.contains($Credential.username.split('@')[1].tostring())){
            # splice in the #305 code again here, to handle CBA post-validation
            if( ($credential.username -match $rgxCertThumbprint) -AND ((Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_Prefix -eq $certTag )){
                    # 9:59 AM 6/24/2022 need a case for CBA cert (thumbprint username)
                    # compare cert fname suffix to $xxxMeta.o365_Prefix
                    # validate that the connected EXO is to the CBA Cert tenant
                    $smsg = "(EXO Authenticated & Functional CBA cert:$($certTag),($($certUname)))" ;
                    if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                    $bExistingEXOGood = $isEXOValid = $true ;
            }elseif((Get-Variable  -name "$($TenOrg)Meta").value.o365_AcceptedDomains.contains($Credential.username.split('@')[1].tostring())){
                # validate that the connected EXO is to the $Credential tenant    
                $smsg = "(EXOv2 Authenticated & Functional:$($Credential.username.split('@')[1].tostring()))" ; 
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $bExistingEXOGood = $true ; 
            # issue: found fresh bug in cxo: svcacct UPN suffix @tenantname.onmicrosoft.com, but testing against AccepteDomain, it's not in there (tho @DOMAIN.mail.onmicrosoft.comis)
            }elseif((Get-Variable  -name "$($TenOrg)Meta").value.o365_TenantDomain -eq ($Credential.username.split('@')[1].tostring())){
                $smsg = "(EXO Authenticated & Functional(TenDom):$($Credential.username.split('@')[1].tostring()))" ; 
                if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $bExistingEXOGood = $true ;
            } else { 
                $smsg = "(Credential mismatch:disconnecting from existing EXO:$($eEXO.Identity) tenant)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } 
                else{ write-ERROR "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Disconnect-EXO ; 
                $bExistingEXOGood = $false ; 
            } ;
        } ; 
    } ; # END-E 
}

#*------^ Reconnect-EXO.ps1 ^------


#*------v Reconnect-EXO2old.ps1 v------
Function Reconnect-EXO2old {
   <#
    .SYNOPSIS
    Reestablish connection to Exchange Online (via EXO V2 graph-api module)
    .NOTES
    Updated By: : Todd Kadrie
    Website:	http://toddomation.com
    Twitter:	@tostka http://twitter.com/tostka
    Based on original function Author: ExactMike Perficient, Global Knowl... (Partner)
    Website:	https://social.technet.microsoft.com/Forums/msonline/en-US/f3292898-9b8c-482a-86f0-3caccc0bd3e5/exchange-powershell-monitoring-remote-sessions?forum=onlineservicesexchange
    REVISIONS   :
    * 2:40 PM 12/10/2021 more cleanup 
    # 11:21 AM 3/31/2021 added TenDom test, after AccDom test ; 
    * 2:08 PM 11/10/2020 ren'd the older connect-ExchangeOnline-related version, to reconnect-exo2old, in favor of the name going on the NewEXOPSSessoin-based version.
    * 8:30 AM 10/22/2020 added $TenOrg, swapped looping meta resolve with 1-liner approach ; added AcceptedDom caching to the middle status test (suppress one more get-xoaccepteddomain call if possible)
    * 1:30 PM 9/21/2020 added caching of AcceptedDomain, dynamically into XXXMeta - checks for .o365_AcceptedDomains, and pops w (Get-exoAcceptedDomain).domainname when blank. 
        As it's added to the $global meta, that means it stays cached cross-session, completely eliminates need to dyn query per rxo, after the first one, that stocks the value
    * 1:45 PM 8/11/2020 added trailing test-EXOToken confirm
    * 2:39 PM 8/4/2020 fixed -match "^(Session|WinRM)\d*" rgx (lacked ^, mismatched EXOv2 conns)
    * 3:55 PM 7/30/2020 rewrite/port from reconnect-EXO to replace import-pssession with new connect-ExchangeOnline cmdlet (supports MFA natively) - #127 # *** LEFT OFF HERE 5:01 PM 7/29/2020 *** not sure if it supports allowclobber, if it's actually wrapping pssession, it sure as shit does!
    * 10:35 AM 7/28/2020 tweaked retry loop to not retry-sleep 1st attempt
    * 3:24 PM 7/24/2020 updated to support tenant-alignment & sub'd out showdebug for verbose
    * 11:48 AM 5/27/2020 added func alias:rxo within the func
    * 2:38 PM 4/20/2020 added local $rgxExoPsHostName
    * 8:45 AM 3/3/2020 public cleanup
    * 9:52 PM 1/16/2020 cleanup
    * 1:07 PM 11/25/2019 added *tol/*tor/*cmw alias variants for connect & reconnect
    * 9:52 AM 11/20/2019 spliced in credential matl
    * 2:55 PM 10/11/2018 connect-exo: added pre sleep skip on tryno 1
    * 8:04 AM 11/20/2017 code in a loop in the Reconnect-EXO2old, until it hits or 100% times out
    # 8:47 AM 6/2/2017 cleaned up deadwood, simplified pshelp
    * 7:58 AM 3/15/2017 ren Disconnect/Connect/Reconnect-EXO2old => Disconnect/Connect/Reconnect-EXO2old, added pss, doing tweaks to put into prod use
    * 2/10/14 posted version
    .DESCRIPTION
    I use this for routine test/reconnect of EXO. His orig use was within batches, to break up and requeue chunks of commands.
    Mike's original comment: Below is one
    example of how I batch items for processing and use the
    Reconnect-EXO2old function.  I'm still experimenting with how to best
    batch items and you can see here I'm using a combination of larger batches for
    Write-Progress and actually handling each individual item within the
    foreach-object script block.  I was driven to this because disconnections
    happen so often/so unpredictably in my current customer's environment:
    .PARAMETER  Credential
    Credential to use for this connection [-credential 'account@domain.com']
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    Reconnect-EXO2old;
    Reconnect EXO connection
    .EXAMPLE
    $batchsize = 10 ;
    $RecordCount=$mr.count #this is the array of whatever you are processing ;
    $b=0 #this is the initialization of a variable used in the do until loop below ;
    $mrs = @() ;
    do {
        Write-Progress -Activity "Getting move request statistics for all $wave move requests." -Status "Processing Records $b through $($b+$batchsize) of $RecordCount." -PercentComplete ($b/$RecordCount*100) ;
        $mrs += $mr | Select-Object -skip $b -first $batchsize | foreach-object {Reconnect-EXO2old; $_ | Get-OLMoveRequestStatistics} ;
        $b=$b+$batchsize ;
        } ;
    until ($b -gt $RecordCount) ;
    
    .LINK
    https://social.technet.microsoft.com/Forums/msonline/en-US/f3292898-9b8c-482a-86f0-3caccc0bd3e5/exchange-powershell-monitoring-remote-sessions?forum=onlineservicesexchange
    #>
    [CmdletBinding()]
    #[Alias('rxo2')]
    Param(
      [Parameter(HelpMessage="Use Proxy-Aware SessionOption settings [-ProxyEnabled]")]
      [boolean]$ProxyEnabled = $False,
      [Parameter(HelpMessage="Credential to use for this connection [-credential [credential obj variable]")]
      [System.Management.Automation.PSCredential]$Credential = $global:credo365TORSID,
      [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
      [switch] $showDebug
    ) ;
    BEGIN{
        $verbose = ($VerbosePreference -eq "Continue") ; 
        if(!$rgxExoPsHostName){$rgxExoPsHostName="^(ps\.outlook\.com|outlook\.office365\.com)$" } ;
        $modname = 'ExchangeOnlineManagement' ; 
        #Try {Get-Module $modname -listavailable -ErrorAction Stop | out-null } Catch {Install-Module $modname -scope CurrentUser ; } ;                 # installed
        Try {Get-Module $modname -ErrorAction Stop | out-null } Catch {Import-Module -Name $modname -MinimumVersion '1.0.1' -ErrorAction Stop -verbose:$false } ; # imported
        
        $TenOrg = get-TenantTag -Credential $Credential ;

    } ;  # BEG-E
    PROCESS{
        $bExistingEXOGood = $false ; 
        if( $legPSSession = Get-PSSession | where-object {$_.ConfigurationName -like "Microsoft.Exchange" -AND $_.Name -match "^(Session|WinRM)\d*" } ){
            # ignore state & Avail, close the conflicting legacy conn's
            Disconnect-Exo ; Disconnect-PssBroken ;Start-Sleep -Seconds 3;
            $bExistingEXOGood = $false ; 
        } ; 
        #clear invalid existing EXOv2 PSS's
        $exov2Broken = Get-PSSession | where-object {$_.ConfigurationName -like "Microsoft.Exchange" -AND $_.Name -eq "ExchangeOnlineInternalSession*" -AND $_.State -like "*Broken*"}
        $exov2Closed = Get-PSSession | where-object {$_.ConfigurationName -like "Microsoft.Exchange" -AND $_.Name -eq "ExchangeOnlineInternalSession*" -AND $_.State -like "*Closed*"}
        
        if ($exov2Broken.count -gt 0){for ($index = 0 ;$index -lt $exov2Broken.count ;$index++){Remove-PSSession -session $exov2Broken[$index]} };
        if ($exov2Closed.count -gt 0){for ($index = 0 ;$index -lt $exov2Closed.count ; $index++){Remove-PSSession -session $exov2Closed[$index] } } ; 
    
        # appears MFA may not properly support passing back a session vari, so go right to strict hostname matches
        $exov2Good = Get-PSSession | where-object {$_.ConfigurationName -like "Microsoft.Exchange" -AND (
            $_.Name -like "ExchangeOnlineInternalSession*") -AND $_.State -like "*Opened*" -AND (
            $_.Availability -eq 'Available')} ; 

        if($exov2Good){
            if( get-command Get-xoAcceptedDomain -ea 0) {
                # add accdom caching
                #$TenOrg = get-TenantTag -Credential $Credential ;
                if(!(Get-Variable  -name "$($TenOrg)Meta").value.o365_AcceptedDomains){
                    set-Variable  -name "$($TenOrg)Meta" -value ( (Get-Variable  -name "$($TenOrg)Meta").value += @{'o365_AcceptedDomains' = (Get-xoAcceptedDomain).domainname} )
                } ;
                #if ((Get-xoAcceptedDomain).domainname.contains($Credential.username.split('@')[1].tostring())){
                if((Get-Variable  -name "$($TenOrg)Meta").value.o365_AcceptedDomains.contains($Credential.username.split('@')[1].tostring())){
                    # validate that the connected EXO is to the $Credential tenant    
                    $smsg = "(EXO Authenticated & Functional(AccDom):$($Credential.username.split('@')[1].tostring()))" ; 
                    $bExistingEXOGood = $true ; 
                # issue: found fresh bug in cxo: svcacct UPN suffix @tenantname.onmicrosoft.com, but testing against AccepteDomain, it's not in there (tho @DOMAIN.mail.onmicrosoft.comis)
                }elseif((Get-Variable  -name "$($TenOrg)Meta").value.o365_TenantDomain -eq ($Credential.username.split('@')[1].tostring())){
                    $smsg = "(EXO Authenticated & Functional(TenDom):$($Credential.username.split('@')[1].tostring()))" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $bExistingEXOGood = $true ;
                } else { 
                    write-verbose "(Credential mismatch:disconnecting from existing EXO:$($eEXO.Identity) tenant)" ; 
                    DisConnect-EXO2 ; 
                    $bExistingEXOGood = $false ; 
                } ; 
            } else { 
                # capture outlier: shows a session wo the test cmdlet, force reset
                DisConnect-EXO2 ; 
                $bExistingEXOGood = $false ; 
            } ; 
        } ; 

        if($bExistingEXOGood -eq $false){
            connect-exo2 -Credential $Credential -verbose:$($verbose) ; 
        } ; 

    } ;  # PROC-E
    END {
        # if ( (get-module -name tmp_* | ForEach-Object { Get-Command -module $_.name -name 'Add-xoAvailabilityAddressSpace' -ea 0 }) -AND (test-EXOToken) ) {
        if( (Get-PSSession | where-object {$_.ConfigurationName -like "Microsoft.Exchange" -AND $_.Name -like "ExchangeOnlineInternalSession*" -AND $_.State -like "*Opened*" -AND ($_.Availability -eq 'Available')}) -AND (test-EXOToken) ){ 
            # implement caching of accepteddoms into the XXXMeta, in the session (cut back on queries to EXO on acceptedom)
            # non-looping
            
            if( get-command Get-xoAcceptedDomain -ea 0) {
                #$TenOrg = get-TenantTag -Credential $Credential ;
                if(!(Get-Variable  -name "$($TenOrg)Meta").value.o365_AcceptedDomains){
                    set-Variable  -name "$($TenOrg)Meta" -value ( (Get-Variable  -name "$($TenOrg)Meta").value += @{'o365_AcceptedDomains' = (Get-xoAcceptedDomain).domainname} )
                } ;
            } ; 
            <#
            $credDom = ($Credential.username.split("@"))[1] ;
            $Metas=(get-variable *meta|Where-Object{$_.name -match '^\w{3}Meta$'}) ;
            foreach ($Meta in $Metas){
                if( ($credDom -eq $Meta.value.legacyDomain) -OR ($credDom -eq $Meta.value.o365_TenantDomain) -OR ($credDom -eq $Meta.value.o365_OPDomain)){
                    if(!$Meta.value.o365_AcceptedDomains){
                        set-variable -Name $meta.name -Value ((get-variable -name $meta.name).value  += @{'o365_AcceptedDomains' = (Get-xoAcceptedDomain).domainname} )
                    } ; 
                    break ;
                } ;
            } ;
            #>
            #if ((Get-xoAcceptedDomain).domainname.contains($Credential.username.split('@')[1].tostring())){
            #if($Meta.value.o365_AcceptedDomains.contains($Credential.username.split('@')[1].tostring())){
            if((Get-Variable  -name "$($TenOrg)Meta").value.o365_AcceptedDomains.contains($Credential.username.split('@')[1].tostring())){
                # validate that the connected EXO is to the $Credential tenant    
                write-verbose "(EXOv2 Authenticated & Functional:$($Credential.username.split('@')[1].tostring()))" ; 
                $bExistingEXOGood = $true ; 
            # issue: found fresh bug in cxo: svcacct UPN suffix @tenantname.onmicrosoft.com, but testing against AccepteDomain, it's not in there (tho @DOMAIN.mail.onmicrosoft.comis)
            }elseif((Get-Variable  -name "$($TenOrg)Meta").value.o365_TenantDomain -eq ($Credential.username.split('@')[1].tostring())){
                $smsg = "(EXO Authenticated & Functional(TenDom):$($Credential.username.split('@')[1].tostring()))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $bExistingEXOGood = $true ;
            } else { 
                write-error "(Credential mismatch:disconnecting from existing EXO:$($eEXO.Identity) tenant)" ; 
                Disconnect-exo2 ; 
                $bExistingEXOGood = $false ; 
            } ;
        } ; 
    } ; # END-E 
}

#*------^ Reconnect-EXO2old.ps1 ^------


#*------v RemoveExistingEXOPSSession.ps1 v------
function RemoveExistingEXOPSSession() {
    <#
    .SYNOPSIS
    RemoveExistingEXOPSSession.ps1 - Tweaked version of the Exchangeonline module:RemoveExistingPSSession() to avoid purging CCMW sessions on connect. Intent is to permit *concurrent* EXO & CCMS sessions.
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 20201109-0833AM
    FileName    : RemoveExistingEXOPSSession.ps1
    License     : [none specified]
    Copyright   : [none specified]
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell
    AddedCredit : Microsoft (edited version of published commands in the module)
    AddedWebsite:	https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
    REVISIONS
    * 8:34 AM 11/9/2020 init
    .DESCRIPTION
    RemoveExistingEXOPSSession.ps1 - Tweaked version of the Exchangeonline module:RemoveExistingPSSession() to avoid purging CCMW sessions on connect. Intent is to permit *concurrent* EXO & CCMS sessions.
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    RemoveExistingEXOPSSession
    Stock call
    .LINK
    https://github.com/tostka/verb-EXO
    .LINK
    https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
    #>
    [CmdletBinding()]
    param()
    
    #$existingPSSession = Get-PSSession | Where-Object {$_.ConfigurationName -like "Microsoft.Exchange" -and $_.Name -like "ExchangeOnlineInternalSession*"}
    <# filter *ONLY* EXO sessions, exclude CCMS, they differ on ComputerName endpoint:
    #-=EXO-=-=-=-=-=-=-=
    ConfigurationName : Microsoft.Exchange
    ComputerName      : outlook.office365.com
    Name              : ExchangeOnlineInternalSession_2
    #-=CCMS-=-=-=-=-=-=-=
    ConfigurationName : Microsoft.Exchange
    ComputerName      : nam02b.ps.compliance.protection.outlook.com
    Name              : ExchangeOnlineInternalSession_1
    #-=-=-=-=-=-=-=-=
    #>
    $rgxExoPsHostName = "^(ps\.outlook\.com|outlook\.office365\.com)$"
    $existingPSSession = Get-PSSession | Where-Object {$_.ConfigurationName -like "Microsoft.Exchange" -and $_.Name -like "ExchangeOnlineInternalSession*" -AND $_.ComputerName -match$rgxExoPsHostName} ; 

        if ($existingPSSession.count -gt 0) 
        {
            for ($index = 0; $index -lt $existingPSSession.count; $index++)
            {
                $session = $existingPSSession[$index]
                Remove-PSSession -session $session

                Write-Host "Removed the PSSession $($session.Name) connected to $($session.ComputerName)"
            }
        }

        # Clear any left over PS tmp modules
        if ($global:_EXO_PreviousModuleName -ne $null)
        {
            Remove-Module -Name $global:_EXO_PreviousModuleName -ErrorAction SilentlyContinue
            $global:_EXO_PreviousModuleName = $null
        }
    }

#*------^ RemoveExistingEXOPSSession.ps1 ^------


#*------v RemoveExistingPSSessionTargeted.ps1 v------
function RemoveExistingPSSessionTargeted() {
    <#
    .SYNOPSIS
    RemoveExistingPSSessionTargeted.ps1 - Tweaked version of the Exchangeonline module:RemoveExistingPSSession() to avoid purging CCMW sessions on connect. Intent is to permit *concurrent* EXO & CCMS sessions.
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 20201109-0833AM
    FileName    : RemoveExistingPSSessionTargeted.ps1
    License     : [none specified]
    Copyright   : [none specified]
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell
    AddedCredit : Microsoft (edited version of published commands in the module)
    AddedWebsite:	https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
    REVISIONS
    * 8:34 AM 11/9/2020 init
    .DESCRIPTION
    RemoveExistingPSSessionTargeted.ps1 - Tweaked version of the Exchangeonline module:RemoveExistingPSSession() to avoid purging CCMW sessions on connect. Intent is to permit *concurrent* EXO & CCMS sessions.
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    RemoveExistingPSSessionTargeted
    Stock call
    .LINK
    https://github.com/tostka/verb-EXO
    .LINK
    https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
    #>
    [CmdletBinding()]
    param()
    
    #$existingPSSession = Get-PSSession | Where-Object {$_.ConfigurationName -like "Microsoft.Exchange" -and $_.Name -like "ExchangeOnlineInternalSession*"}
    <# filter *ONLY* EXO sessions, exclude CCMS, they differ on ComputerName endpoint:
    #-=EXO-=-=-=-=-=-=-=
    ConfigurationName : Microsoft.Exchange
    ComputerName      : outlook.office365.com
    Name              : ExchangeOnlineInternalSession_2
    #-=CCMS-=-=-=-=-=-=-=
    ConfigurationName : Microsoft.Exchange
    ComputerName      : nam02b.ps.compliance.protection.outlook.com
    Name              : ExchangeOnlineInternalSession_1
    #-=-=-=-=-=-=-=-=
    #>
    $rgxExoPsHostName = "^(ps\.outlook\.com|outlook\.office365\.com)$"
    $existingPSSession = Get-PSSession | Where-Object {$_.ConfigurationName -like "Microsoft.Exchange" -and $_.Name -like "ExchangeOnlineInternalSession*" -AND $_.ComputerName -match$rgxExoPsHostName} ; 

        if ($existingPSSession.count -gt 0) 
        {
            for ($index = 0; $index -lt $existingPSSession.count; $index++)
            {
                $session = $existingPSSession[$index]
                Remove-PSSession -session $session

                Write-Host "Removed the PSSession $($session.Name) connected to $($session.ComputerName)"
            }
        }

        # Clear any left over PS tmp modules
        if ($global:_EXO_PreviousModuleName -ne $null)
        {
            Remove-Module -Name $global:_EXO_PreviousModuleName -ErrorAction SilentlyContinue
            $global:_EXO_PreviousModuleName = $null
        }
    }

#*------^ RemoveExistingPSSessionTargeted.ps1 ^------


#*------v Remove-EXOBrokenClosed.ps1 v------
function Remove-EXOBrokenClosed(){
    <#
    .SYNOPSIS
    Remove-EXOBrokenClosed - Remove broken and closed exchange online PSSessions
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-03-03
    FileName    : 
    License     : 
    Copyright   : 
    Github      : https://github.com/tostka
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    AddedCredit : 
    AddedWebsite:	https://social.technet.microsoft.com/Forums/msonline/en-US/f3292898-9b8c-482a-86f0-3caccc0bd3e5/exchange-powershell-monitoring-remote-sessions?forum=onlineservicesexchange
    AddedTwitter:	
    REVISIONS   :
    * 9:29 AM 7/30/2020 lifted from EXO V2 connect-exchangeonline() as RemoveBrokenOrClosedPSSession()
    * 3:24 PM 7/24/2020 updated to support tenant-alignment & sub'd out showdebug for verbose
    * 11:50 AM 5/27/2020 added alias:dxo win func
    * 2:34 PM 4/20/2020 added local $rgxExoPsHostName
    * 8:45 AM 3/3/2020 public cleanup
    * 9:52 AM 11/20/2019 reviewed for credential matl, no way to see the credential on a given pssession, so there's no way to target and disconnect discretely. It's a shotgun close.
    # 10:27 AM 6/20/2019 switched to common $rgxExoPsHostName
    # 1:12 PM 11/7/2018 added Disconnect-PssBroken
    # 11:23 AM 7/10/2018: made exo-only (was overlapping with CCMS)
    # 8:47 AM 6/2/2017 cleaned up deadwood, simplified pshelp
    * 8:49 AM 3/15/2017 Disconnect-EXO: add Remove-PSTitleBar 'EXO' to clean up on disconnect
    * 2/10/14 posted version
    .DESCRIPTION
    Used to smoothly cleanup connections (at end, or when expired, to purge for a fresh pass).
    Mike's original notes:
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    Remove-EXOBrokenClosed;
    .LINK
    https://social.technet.microsoft.com/Forums/msonline/en-US/f3292898-9b8c-482a-86f0-3caccc0bd3e5/exchange-powershell-monitoring-remote-sessions?forum=onlineservicesexchange
    #>
    [CmdletBinding()]
    [Alias('dxob')]
    $exov2Broken = Get-PSSession | where-object {$_.ConfigurationName -like "Microsoft.Exchange" -and $_.Name -eq "ExchangeOnlineInternalSession*" -and $_.State -like "*Broken*"} ;
    $exov2Closed = Get-PSSession | where-object {$_.ConfigurationName -like "Microsoft.Exchange" -and $_.Name -eq "ExchangeOnlineInternalSession*" -and $_.State -like "*Closed*"} ;
    if ($exov2Broken.count -gt 0){for ($index = 0; $index -lt $exov2Broken.count; $index++) {Remove-PSSession -session $exov2Broken[$index] } } ;
    if ($exov2Closed.count -gt 0){for ($index = 0; $index -lt $exov2Closed.count; $index++) {Remove-PSSession -session $exov2Closed[$index] } } ;
}

#*------^ Remove-EXOBrokenClosed.ps1 ^------


#*------v remove-EXOLicense.ps1 v------
function remove-EXOLicense {
    <#
    .SYNOPSIS
    remove-EXOLicense.ps1 - Remove a temporary o365 license from specified MsolUser account. Returns updated MSOLUser object to pipeline.
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-07-13
    FileName    : remove-EXOLicense.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 4:25 PM 5/22/2023 scrapped, rewrote adapted from functional add-exoLicense(); 
     * 3:37 PM 5/17/2023 added pltRXO support
    * 12:10 PM 6/7/2022 updated cbh params
    * 5:17 PM 3/23/2022 retooling to remove msonline module dependance, and shift to AzureAD (crappy implementation GraphAPI) module
    * 12:57 PM 1/31/2022 addded -ea 0 to gv PassStatus_$($tenorg) (spurious error suppress)
    * 3:14 PM 1/18/2022 REM'D EXOP conn's (match add-exolic), this is pure msolu & exo. 
    * 1:02 PM 1/17/2022 port of add-EXOLicense to removal process
    .DESCRIPTION
    remove-EXOLicense.ps1 - Remove a temporary o365 license from specified MsolUser account. Returns updated MSOLUser object to pipeline.
    .PARAMETER users
    Array of UserPrincipalNames (or MSOLUser objects) to have a temporary Exchange License applied
    .PARAMETER Ticket
    Ticket Number [-Ticket '999999']
    .PARAMETER LicenseSkuKeys
    Array, in preference order, of XXXMeta global value LicenseSkuKey names (resolves SKUId from TenOrg global Meta vari ; runs full list removing all matches)[-LicenseSkuIds 'o365LicSkuExStd','o365LicSkuF1']
    .PARAMETER LicenseSkuIds
    Optional Array, in preference order, of LicenseSkuID (e.g. TenantName:SPE_F1) to be added, runs full list removing all matches (default process is to dynamically resolve id's from Meta LicenseSkuKeys specifications)[-LicenseSkuIds @(`$XXXMETA.o365LicSkuExStd,`$XXXMETA.o365LicSkuF1)]
    .PARAMETER Force
    switch to override normal 'skipped' license application to existing Mailbox (needed for licensed-Shared, or upgraded existing lic).
    .PARAMETER TenOrg
    TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER Credential
    Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]
    .PARAMETER UserRole
    Credential User Role spec (SID|CSID|UID|B2BI|CSVC)[-UserRole SID]
    .PARAMETER Credential
    Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]
    .PARAMETER silent
    Switch to specify suppression of all but warn/error echos.(unimplemented, here for cross-compat)
    .PARAMETER showDebug
    switch to show extended debugging output [-showdebug]
    .PARAMETER whatIf
    Whatif Flag  [-whatIf]
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    System.Object - returns summary report to pipeline
    .EXAMPLE
    PS> remove-EXOLicense -users 'Test@domain.com','Test2@domain.com' -ticket TICKETNUMBER -verbose  ;
    Process an array of users, with default 'hunting' -LicenseSkuIds array. 
    .EXAMPLE
    PS> $updatedMSOLU = remove-EXOLicense -users 'Test@domain.com','Test2@domain.com' -verbose -ticket TICKETNUMBER;
        if($updatedMSOLU.islicensed){'Y'} else { 'N'} ; 
    Process licnse removal for specified user, and post-test isLicensed status, using default license array configured on the -LicenseSkuIDs default value.
    .EXAMPLE
    PS> $whatif=$true ;
        $target = '99999,lynctest15@toro.com' ;
        if($target.contains(',')){
            $ticket,$trcp = $target.split(',') ;
            $updatedmsolu = remove-EXOLicense -users $trcp -Ticket $ticket -whatif:$($whatif) ;
            $props1 = 'UserPrincipalName','DisplayName','IsLicensed' ;
            $props2 = @{Name='Licenses';
            Expression={$_.licenses.accountskuid -join ', '}}  ;
            $smsg = "$((get-date).ToString('HH:mm:ss')):UpdatedMsolU: w`n$(($updatedmsolu| ft -auto $props1|out-string).trim())" ;
            $smsg += "`n$(($updatedmsolu| fl $props2 |out-string).trim())" ;
            write-host -foregroundcolor green $smsg ;
        } else { write-warning "`$target does *not* contain comma delimited ticket,UPN string!"} ;
    Fancier variant of above, with more post-confirm reporting
    .EXAMPLE
    PS> remove-EXOLicense -users 'Test@domain.com' -LicenseSkuIds $TORMETA.o365LicSkuExStd -ticket TICKETNUMBER;
    removal an explictly specified lic to a user (in this case, using the LicenseSku for EXCHANGESTANDARD, as stored in a global variable)
    .EXAMPLE
    PS> remove-EXOLicense -users 'Test@domain.com' -LicenseSkuIds $TORMETA.o365LicSkuF1 -ticket TICKETNUMBER;
    removal an explicitly specified lic to a user (in this case, using the LicenseSku for SPE_F1 - web-only o365 - lic as stored in a global variable)
    .EXAMPLE
    PS> remove-EXOLicense -users 'Test@domain.com' -LicenseSkuIds $TORMETA.o365LicSkuE3 -ticket TICKETNUMBER;
    removal an explicitly specified lic to a user (in this case, using the LicenseSku for ENTERPRISEPACK - E3 o365 - lic as stored in a global variable)
    .EXAMPLE
    PS> remove-EXOLicense -users 'Test@domain.com' -LicenseSkuIds 'TENANTNAME:EXCHANGESTANDARD' -ticket TICKETNUMBER;
    removal an explicitly specified lic to a user by specifying the Tenant-specific LicenseSkuID directly
    .EXAMPLE
    PS> remove-o365License -$MsoLUser.UserprincipalName -ticket TICKETNUMBER ;
    remove-o365License compatibility option
    .LINK
    https://github.com/tostka/verb-exo
    .LINK
    #>
    # migr to verb-exo, pull the dupe spec...
    #Requires -Modules AzureAD, MSOnline, ExchangeOnlineManagement, verb-AAD, verb-Auth, verb-IO, verb-logging, verb-Mods, verb-Text
    #Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\s\regex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    #[Alias('remove-o365License')]
    PARAM(
        [Parameter(Position=0,Mandatory=$False,ValueFromPipeline=$true,HelpMessage="Array of UserPrincipalNames (or AzureADUser objects) to have a temporary Exchange License applied")]
            #[ValidateNotNullOrEmpty()]
            #[Alias('ALIAS1', 'ALIAS2')]
            #[ValidatePattern("^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$")]
            [array]$users,
        [Parameter(Mandatory=$True,HelpMessage="Ticket Number [-Ticket '999999']")]
            [string]$Ticket,
        [Parameter(,HelpMessage="Array, in preference order, of XXXMeta global value LicenseSkuKey names (resolves SKUId from TenOrg global Meta vari ; first working lic assignment, will be applied)[-LicenseSkuIds 'o365LicSkuExStd','o365LicSkuF1']")]
            [ValidateNotNullOrEmpty()]
            [array]$LicenseSkuKeys=@('o365LicSkuExStd','o365LicSkuF1','o365LicSkuE3'),
         [Parameter(,HelpMessage="Optional Array, in preference order, of LicenseSkuID (e.g. TenantName:SPE_F1) to be added, runs full list removing all matches (default process is to dynamically resolve id's from Meta LicenseSkuKeys specifications)[-LicenseSkuIds @(`$XXXMETA.o365LicSkuExStd,`$XXXMETA.o365LicSkuF1)]")]
            #[ValidateNotNullOrEmpty()]
            [array]$LicenseSkuIds = @(), 
        [Parameter(HelpMessage="switch to override normal 'skipped' license application to existing Mailbox.[-Force]")]
            [switch] $Force,
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
            [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
            [switch] $useEXOv2=$true,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ; 
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ; 
                return $true ; 
            })]
            [string[]]$UserRole = @('SID','CSVC'),
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent,
        [Parameter(HelpMessage="switch to show extended debugging output [-showdebug]")]
            # included solely for backward compatibility with Removal-o365License()
            [switch] $showDebug,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
            [switch] $whatIf
    ) ;
    BEGIN{
        #region CONSTANTS-AND-ENVIRO #*======v CONSTANTS-AND-ENVIRO v======
        # function self-name (equiv to script's: $MyInvocation.MyCommand.Path) ;
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        # Get parameters this function was invoked with
        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
        $smsg = "(ParameterSetName $($PSCmdlet.ParameterSetName) is in effect)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        $rgxOPLic = '^CN\=ENT\-APP\-Office365\-(EXOK|F1|MF1)-DL$' ;
        $rgxXLic = '^CN\=ENT\-APP\-Office365\-(EXOK|F1|MF1)-DL$' ;

        # recycling the inbound above into next call in the chain
        $pltRXO = [ordered]@{
            Credential = $Credential ; 
            verbose = $($VerbosePreference -eq "Continue")  ; 
            silent = $silent ; 
        } ;

        $smsg = "Retrieve & build LicenseSkuIDS from global Meta vari" ;  
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        [array]$LicenseSkuIds = @() ; 
        $LicenseSkuKeys | foreach-object { $LicenseSkuIds += @((get-variable -name "$($tenorg)META").value[$_]) } ; 

        #$rgxEmailAddr = '^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$ '
 
        $sBnr="`n#*======v $(${CmdletName}) : v======" ;
        $smsg = $sBnr ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        $admin = "$env:username" ;

        # check if using Pipeline input or explicit params:
        if ($PSCmdlet.MyInvocation.ExpectingInput) {
            write-verbose "Data received from pipeline input: '$($InputObject)'" ;
        } else {
            # doesn't actually return an obj in the echo
            #write-verbose "Data received from parameter input: '$($InputObject)'" ;
        } ;

    } ;  # BEGIN-E
    PROCESS{
        
        $ttl = ($users|measure).count ; $Procd=0 ;
        [array]$Rpt =@() ;
        
        foreach ($usr in $users){

            switch($usr.GetType().FullName){
                'Microsoft.Online.Administration.User' {
                    #$smsg = "(-user:MsolU detected:$($usr.userprincipalname), extracting the UPN...)" ;
                    $smsg = "MSOLUSER OBJECT IS NO LONGER SUPPORTED BY THIS FUNCTION!" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $usr = $usr.userprincipalname ;
                } ;
                'Microsoft.Open.AzureAD.Model.User' {
                    $smsg = "(-user:AzureADU detected)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $usr = $usr.userprincipalname ;
                } ;
                'System.String'{
                    $smsg = "(-user:string detected)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    if($usr -match $rgxEmailAddress){

                        $smsg = "(-user:EmailAddress/UPN detected:$($usr))" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $usr = $usr ;
                    } else {
                        $smsg = "-Users: Unable to recognize either an AzureAD user object, or a UPN string, from the specified input:`n$($usr)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        break ; 
                    } ; 
                }
                default{
                    $smsg = "Unrecognized format for -User:$($usr)!. Please specify either a user UPN, or pass a full MsolUser object." ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Break ;
                }
            } ;
            #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            # Looks like 1/5/2022, there are no spare E3's, maybe shift to the F3 ($TORMETA.o365LicSkuF1 = works to get mbx back).
            # (below defaults to the 'office 365 F3', the E3 alt is:  $tormeta.o365LicSkuE3 )
            # 12:06 PM 1/11/2022 add ExOnly: EXCHANGESTANDARD # Office 365 Exchange Online Only (commonly used for App
            $tUPN=$usr ;
            #$LicenseSkuIds=$TORMETA.o365LicSkuF1; # dyn from global XXXmeta
            $error.clear() ;
            TRY {

                $Exit = 0 ;
                Do {
                    Try {
                        connect-aad @pltRXO ; 
                        $AADUser=$null ;
                        #$TenantShortName = ((Get-AzureADTenantDetail).verifieddomains |?{$_._default}).name.split('.')[0] ;
                        $pltGAADU=[ordered]@{ 
                            ObjectId = $tUPN ;
                            ErrorAction = 'STOP' ;
                            verbose = $($VerbosePreference -eq "Continue") ;
                        } ;
                        $AADUser = Get-AzureADUser @pltGAADU ;
                        $Exit = $Retries ;
                    } Catch {
                        Start-Sleep -Seconds $RetrySleep ;
                        $Exit ++ ;
                        $smsg = "Failed to exec cmd because: $($Error[0])" ;
                        $smsg += "`nTry #: $Exit" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        If ($Exit -eq $Retries) {
                            $smsg =  "Unable to exec cmd!" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ;
                        Continue ;
                    }  ;
                } Until ($Exit -eq $Retries) ;

                # 8:44 AM 12/21/2022 no, use the verb-EXO:test-EXOIsLicensed(): test-EXOIsLicensed -User $AADUser -verbose
                $IsExoLicensed = test-EXOIsLicensed -User $AADUser -Credential:$pltRXO.Credential -verbose:$pltRXO.verbose -silent:$pltRXO.silent ;
                $pltGLPList=[ordered]@{ 
                    TenOrg= $TenOrg;
                    verbose=$($VerbosePreference -eq "Continue") ;
                    credential= $pltRXO.credential ;
                    silent = $silent ; 
                } ;
                $smsg = "$($tenorg):get-AADlicensePlanList wn$(($pltGLPList|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $skus = $null ;
                $skus = get-AADlicensePlanList @pltGLPList ;

                $ombx = get-xomailbox -id $AADUser.UserPrincipalName -ea continue  ;
                $ombx = $ombx | ?{$_ -is [System.Management.Automation.PSObject]} # filtering any aberrant obj returned (legacy of prior problematic xow reliance to work around hybrid stepable pipeline bug)
                $AADLicDetails = get-AADUserLicenseDetails -UPNs $AADUser.userprincipalname -Credential:$pltRXO.Credential -verbose:$pltRXO.verbose -silent:$pltRXO.silent ; 
                #$AADLicDetails = get-AADUserLicenseDetails -UPNs $AADUser.userprincipalname -Verbose:$($VerbosePreference -eq "Continue")
                $smsg = "`nExisting Mbx:`n$(($ombx | ft -a 'RecipientType','RecipientTypeDetails'|out-string).trim())" ;
                $smsg += "`n`$AADLicDetails`n$(($AADLicDetails|out-string).trim())" ;
                if($ombx.RecipientTypeDetails -eq 'SharedMailbox'){
                    $smsg += "`nSharedMailbox does not *require* a license" ;
                } ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                #if( -not($Force) -AND $ombx){
                <#if( -not($Force) -AND ($ombx.RecipientTypeDetails -eq 'SharedMailbox') ){
                    $smsg += "`n -- SKIPPING EXO-RELATED LICENSE Removal! --" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                } else
                #>
                if( ($IsExoLicensed) -OR ($Force) ){
                    # not supported on aadu: defer to: verb-AAD:test-AADUserIsLicensed(): $isLicensed = test-AADUserIsLicensed -user $AzureADUser -verbose
                    if($IsAADIsLicensed = test-AADUserIsLicensed -user $AADUser -Verbose:($VerbosePreference -eq 'Continue')){
                        # has a bozo lic that doesn't support a mailbox
                        $smsg = "AADUser:$($tUPN):  isLicensed (has some form of license added), and has an EXO UserMailbox-supporting license!" ;
                        $smsg += "`n(or is being -Force upgraded to an elevated license)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $smsg="confirmed $($AADUser.UserPrincipalName):is licensed/overlicensed" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;


                    foreach($LicenseSkuId in $LicenseSkuIds){
                        if( $LicenseSkuId.contains(':') ){
                            $LicenseSkuId = $LicenseSkuId.split(':')[1] ;
                            # need the skuid, not the name, could pull another licplan list indexedonName, but can also post-filter the hashtable, and get it.
                            $LicenseSkuId = ($skus.values | ?{$_.SkuPartNumber -eq $LicenseSkuId}).skuid ;
                        } ;
                        #$smsg = "(attempting license:$($LicenseSkuId)...)" ;
                        $smsg = "(attempting license:$(($skus.values | ?{$_.Skuid -eq $LicenseSkuId}).SkuPartNumber):$($LicenseSkuId)...)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        $pltRAADUL=[ordered]@{
                            Users=$AADUser.UserPrincipalName ;
                            skuid=$LicenseSkuId ;
                            Credential = $pltRXO.Credential ; 
                            verbose = $pltRXO.verbose  ; 
                            silent = $false ; 
                            erroraction = 'STOP' ;
                            whatif = $($whatif) ;
                        } ;
                        $smsg = "remove-AADUserLicense w`n$(($pltRAADUL|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        $bRet = remove-AADUserLicense @pltRAADUL ;
                        if($bRet.Success){
                            $smsg = "remove-AADUserLicense removed Licenses:$($bRet.RemovedLicenses)" ;
                            # $AADUser.AssignedLicenses.skuid
                            $smsg += "`n$(($AADUser.AssignedLicenses.skuid|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            $smsg = "Detailed Return:`n$(($bRet|out-string).trim())" ;
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            #BREAK ; # process through all lic potential removals
                        } elseif($whatif){
                            $smsg = "(whatif pass, exec skipped), " ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } elseif( -not [boolean]($bRet.RemovedLicensess)){
                            # failed removal
                            $smsg = "Failed Lic Removal:$($LicenseSkuId) (moving on to next if avail...)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Continue ;
                        } else {
                            $smsg = "FAILED TO UPDATE !" ;
                            $smsg += "`n$(($bRet|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #$Report.FixedUsageLocation = $false ;
                            if(-not $whatif){
                                BREAK;
                            }
                        } ;

                    } ;  # loop-E $LicenseSkuIds

                    connect-aad @pltRXO ; 
                    $AADUser=$null ;
                    #$TenantShortName = ((Get-AzureADTenantDetail).verifieddomains |?{$_._default}).name.split('.')[0] ;
                    $pltGAADU=[ordered]@{ 
                        ObjectId = $tUPN ;
                        ErrorAction = 'STOP' ;
                        verbose = $($VerbosePreference -eq "Continue") ;
                    } ;
                    # refresh ADU post chgs & test xmbx lic stat
                    $AADUser = Get-AzureADUser @pltGAADU ;
                    if(-not $LicenseSkuIds){
                        # running explicit LicenseSkuIds may not have removed all EXO lic's, so no point in doing a followup confirm license-free
                        $IsExoLicensed = test-EXOIsLicensed -User $AADUser -Credential:$pltRXO.Credential -verbose:$pltRXO.verbose -silent:$pltRXO.silent ;
                        if($IsExoLicensed){
                            $smsg = "AADUser still coming back with mounted EXO-supporting license. `nRe-Running remove-EXOLicesnse pass..." ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            $pltRxLic=[ordered]@{
                                users=$AADUser.userprincipalname ;
                                ticket=$ticket ;
                                whatif=$($whatif) ;
                                Verbose=$($VerbosePreference -eq "Continue")
                                Credential = $pltRXO.Credential ;
                                silent = $false ; 
                            } ;
                            if($UserRole){
                                $smsg = "(recycle `$UserRole from script)" ; 
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                $pltRxLic.UserRole = $UserRole ; 
                            } ; 
                            #$smsg = "remove-EXOLicense w`n$(($pltRxLic|out-string).trim())" ;
                            #if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            #else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $bRet = remove-EXOLicense @pltRxLic ;
                            if($bRet) {$AADUser = $bRet } ; 
                        } else { 
                            $smsg = "Validated:$($AADUser.userprincipalname): is now EXO-unlicensed" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        } ; 
                    } elseif($whatif){
                        $smsg = "-whatif: skipping post-validation" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    } else { 
                        # running explicit LicenseSkuIds may not have removed all EXO lic's, so no point in doing a followup confirm license-free
                        $smsg = "-LicenseSkuId specified: Skipping broad test-ExoIsLicensed confirmations" ; 
                        $smsg += "`nsolely the licenses specified would have been removed," ; 
                        $smsg += "`nand may not be the complete EXO-license set" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    } ; 

                };  # if-E $ombx

            } CATCH {     
                $ErrTrapd=$Error[0] ;
                $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                Break ;
            } ;
            if(!$whatif){
                $smsg = "dawdling to ensure License change doesn't soft-delete mailbox..." ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $1F=$false ;
                Do {
                    if($1F){Sleep -s 30} ;
                    write-host "." -NoNewLine ;
                    $1F=$true ;
                #} Until (get-xomailbox -id $oMSUsr.userprincipalname -EA 0) ;
                } Until ($ombx = get-xomailbox -id $AADUser.userprincipalname -EA 0) ; # capture return (prevent from dropping into pipe)
                # get-xomailbox returns: System.Management.Automation.PSObject; not a real Mailbox object class
                $ombx = $ombx | ?{$_ -is [System.Management.Automation.PSObject]} ; # looks like an attempt to filter just the mailbox out of the pipeline return
                $smsg = "xo Mailbox confirmed!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;

            # return $AADUser to pipeline if populated

            $AADUser | write-output ;

            $smsg =  $sBnr.replace('=v','=^').replace('v=','^=') ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; # ($usr in $users)

    } # PROC-E
    END{
        <#
        $stopResults = stop-transcript ;
        $smsg = $stopResults ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #>
     } ;
 }

#*------^ remove-EXOLicense.ps1 ^------


#*------v Reset-xoMailboxFolderPermissionsRecursive.ps1 v------
function Reset-xoMailboxFolderPermissionsRecursive {
    <#
    .SYNOPSIS
    Reset-xoMailboxFolderPermissionsRecursive - Restores the default permissions for all user-accessible folders for a given mailbox. Can also be used to remove broken recipients. 
   .NOTES
    Version     : 1.0.0
    Author      : Vasil Michev
    Website     : https://www.michev.info/blog/post/2500/how-to-reset-mailbox-folder-permissions
    Twitter     :	
    CreatedDate : 2022-06-15
    FileName    : reset-XOMailboxAllFolderPerms.ps1
    License     : Not Asserted
    Copyright   : Not Asserted
    Github      : https://github.com/michevnew/PowerShell/blob/master/reset-XOMailboxAllFolderPerms.ps1
    Tags        : Powershell,ExchangeOnline,Mailbox,Delegate
    AddedCredit : Todd Kadrie
    AddedWebsite: http://www.toddomation.com
    AddedTwitter: @tostka / http://twitter.com/tostka
    REVISIONS
    * 1:44 PM 9/25/2023 debuged, whatif working; moved includedfolders, excludedfolders into targetable pre-populated params (as overriding code lists in a signed module is a mess; but a param can be done on the fly); 
         strip away outter wrapper script, in favor of descrete (verb-EXO-hosted) reusable functions; added $ThrottleMs fallback; expanded w-v, w-h & w-w into pswlt support
    * 4:43 PM 9/21/2023 works, used on 760151;  add option: We want to leave INTERNAL/EXTERNAL existing, but remove UNKNOWNS: neither is addressed by default below (INT/EXT are set to NONE, and UNKN is *ignored*).
        Add param: -RemoveUnresolveable -> targets usertype:UNKNOWN, including getr-adusere solvable, that lack populated msExchRecipientTypeDetails property
        Add param: -IgnoreInternal - skips reset of existing usertype:Internal to NONE
        Add param: -IgnoreExternal - skips reset of existing usertype:External to NONE
    * 3:35 PM 7/11/2023 works; ADD:$CalendarLimitedDetails param, to drive variant 
    default view (customized in our org), passed in via psboundparameters; 
    completely refactored ExchangeOnlineManagement ineraction to accomodate loss of 
    WinRM/PSSession connections in EOM3+; minor reformatting, added root CBH 
    * 6/15/22 vm posted version
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 12:53 PM 9/22/2023 reflect ren of ReturnFolderList -> get-XOMailboxFolderList; GetFolderPermissions -> get-XOMailboxFolderPermissionsSummary
    * 3:03 PM 7/11/2023 ADD:$CalendarLimitedDetails param, to drive variant default view (customized in our org), passed in via psboundparameters

    .DESCRIPTION
    Reset-xoMailboxFolderPermissionsRecursive - Restores the default permissions for all user-accessible folders for a given mailbox. Can also be used to remove broken recipients. 

    The Reset-xoMailboxFolderPermissionsRecursive cmdlet removes permissions for all user-accessible folders for the given mailbox(es), specified via the -Mailbox parameter. 
    The list of folders is generated via the get-XOMailboxFolderList function. 
    Configure the $includedfolders and $excludedfolders variables to granularly control the folder list.

    Default Actions:
    - wo use of ResetDefaultLevel, Existing Defaults are left unmodified
    - Existing Anonymous grants are also always left unmodified (it uses Continue, and skips any interaction with the grants).
    - If ResetDefaultLevel is used: 
        * This forces Default Calendar grants to AvailabilityOnly (MS Default) (or LimitedDetails, if CalendarLimitedDetails:$true): Set-MailboxPermission
        * and ANY OTHER Default is forced to NONE. 
        -> It strips all but Cal Default access.
    - ALL Internal & External usertype grants are REMOVED completely.

    If -Quiet is *not* used, modifications information is exported to a file in local directory named: 
    yyyy-MM-dd_HH-mm-ss_MailboxFolderPermissionsRemoved.csv (and the same info is returned as an object to pipeline)

    As originally written, this was *selective*, doesn't go after UNKNOWN "orphans" at all. clearly MV, as an MVP knows something that I don't, 
    to choose to leave UNKNOWN's unpurged while purging all existing non-Default/non-Anon Internal|External user-created entries.

    -----------
    ## Unable to find formal docs, taking a stab at _imputing_ the intent of the UserType variants:
    - Default is the generic 'class' grant for users that authenticated with the domain but don't have specific permission.
    - Anonymous is the generic 'class' grant for users that are NOT authenticated with the domain.
    - Internal appears to reflect manually-added (non-Default) grants to objects in the mailbox, that resolve to Recipient Objects
    - External appears to reflect manually-added (non-Default) grants to objects in the mailbox, that resolve to external Recipient Objects
    - Unknown appears (observed):
        - sometimes are named UserName references but consistently lack UserName (resolved RecipientPrincipal.guid.guid). 
        - frequently as broken SID references: NT:S-1-5-21-*
        - both deleted ADUser objects...
             Unable to resolve S-1-5-21-2222296782-158576315-1096482972-3663 to an existing ADUser object (likely deleted TERM)
        ... and ADUser objects that resolve in AD:
            #-=-=-=-=-=-=-=-=
            WARNING: 09:54:03:Resolved
             S-1-5-21-2222296782-158576315-1096482972-39941
             to an existing ADUser object:
            DistinguishedName : CN=FNAME LNAME,OU=Disabled,OU=Users,OU=SITE,DC=SUB,DC=SUB,DC=DOMAIN,DC=com
            enabled           : False
            samaccountname    :  ______x
            sid               : S-1-5-21-2222296782-158576315-1096482972-39941
            UserPrincipalName : FNAME.LNAME.Nelson@DOMAIN.com
            #-=-=-=-=-=-=-=-=
       - opinion: likely resolvable ADU are non-recipients: lacking in msex* attribs on ADU. But are still non-functional: confirm
            [PS]:D:\scripts $ get-aduser -id S-1-5-21-2222296782-158576315-1096482972-39941 -prop * | fl userp*,msex*
            UserPrincipalName            : FNAME.LNAME.Nelson@DOMAIN.com
            msExchALObjectVersion        : 3610
            msExchOmaAdminWirelessEnable : 4
            msExchWhenMailboxCreated     : 2/21/2011 5:24:16 AM
            -> all it's got is the 3 msex's above. Everything else is gone. Prob key test is going to be recipienttypedetails
            #-=-=-=-=-=-=-=-=
            msExchRecipientDisplayType : -2147483642
            msExchRecipientTypeDetails : 2147483648
            msExchRemoteRecipientType  : 4
            msExchSafeRecipientsHash   : {142, 23, 177, 78}
            #-=-=-=-=-=-=-=-=
        => Test get-aduser -prop * | msExchRecipientTypeDetails: if doesn't resolve, purge the NT:S-1-5-21-* entry
        -----------
    And there's a brand new EOM31+ version available today:
    [Managing mailbox folder permissions in bulk in Microsoft 365 - Blog](https://www.michev.info/blog/post/5763/managing-mailbox-folder-permissions-in-bulk-in-microsoft-365)
    # September 20, 2023	Vasil Michev

    --
    [How to reset mailbox folder permissions - Blog](https://www.michev.info/blog/post/2500/how-to-reset-mailbox-folder-permissions)

    what is the best (or at least a proper) way to "reset" folder level 
    permissions, with the added challenge of doing it in bulk

    First of all, if you simply want to "reset" the permissions on a given, 
    "known" folder, the task is easy. Say we have the user JohnSmith and we want to 
    remove any permissions on his Calendar folder

    Next, we need to exclude the "default" permissions entries, as in the 
    ones configured for the Default and Anonymous security principals. 
 
    There are many additional factors that we need to address, such as the actual 
    folder names, as depending on the localization, the Calendar folder might be 
    renamed to Kalender or whatnot. Then, what if we want to include all folders in 
    the mailbox, not just Calendar? And there are things to consider when removing 
    the permissions as well, such as dealing with orphaned entries, external 
    permissions, published Calendars 

    the building blocks we need to put together:
 
    - Account for the type of User, and depending on it handle things accordingly. 
    In other words, for each permission entry, look at the _$entry.User.UserType.Value_.
    Available values will include _Internal_, _External_ and _Unknown_ 
    and all of these will have to be handled differently

    - Utilize the _Get-MailboxFolderStatistics_ cmdlet to get a list of the 
    localized folder names and trim the list to only include folders you care about.
    There's no point in adjusting permissions on Purges folder for example

    - If you are using the above method to get the localized folder names 
    across multiple mailboxes, you need to start to account for throttling!
 
    - Decide what you want to do with the Default (and Anonymous) permission level. 
    The regex we used in the above example can be generalized to exclude other 
    entries as well, if needed


    --- Stock setting: 
    Check calendar folder permissions using Get-MailboxFolderPermission user:\calendar 
    and see if Default user has None permissions. Default user should have "AvailabilityOnly"(MS Default) or "LimitedDetails" (TTC)
    --- 
    Relevent discussion on the need/desire to purge broken SID NT:S-1... entries (in public folders in this case: breaks cloud migration).
    https://techcommunity.microsoft.com/legacyfs/online/media/2019/01/FB_Errors.FixesV6.pdf

    ---

    [Correcting Public Folder Permissions before an Office 365 Migration | Practical365](https://practical365.com/correcting-public-folder-permissions-before-an-office-365-migration/)
    Written By Steve Goodman Post published:April 1, 2020
    ...
    > Microsoft's [Source Side Validation 
    script](https://www.microsoft.com/en-us/download/confirmation.aspx?id=100414), 
    described in the blog post above, will generate a log file showing amongst 
    other things, orphaned ACLs you need to remove. However, it doesn't go as far 
    as to assist with the removal itself

    Within the file we'll see lines saying this folder <foldername> permission 
    needs to be removed for NT User:<SID>

    These lines are showing an orphaned ACL. The orphaned ACL occurs when a 
    user is deleted from Active Directory, but the permission is not removed from 
    the Public Folder. This leaves just the security identifier (the SID) showing 
    because it cannot be resolved to an actual user account

    This is a problem because when the folder is migrated to Office 365, the 
    permission cannot be re-applied as the user doesn't exist anymore

    The guidance on the Microsoft blog post doesn't provide you much detail 
    on how to use the log file to remove the permissions, and the guidance it does 
    give doesn't work on Exchange 2010. This is where the 
    Remove-PFPermissionsFromSSV script comes in.   

    The script takes the lines from the log file, and for each line with a 
    permission listed, it uses a command like the one below togGet the folder 
    permissions, find the offending permission entry, and then remove it:
 
    Get-PublicFolderClientPermission -Identity <Folder>| Where {$_.User -like 
    <SID>} | Remove-PublicFolderClientPermission -Confirm:$False 

    The story would end here if Microsoft's script was perfect, and unfortunately 
    on a recent migration I encountered a scenario where it didn't pick up all 
    problem ACLs

    The scenario in question was one where my customer, after migration, was 
    converting leaver's mailboxes to shared mailboxes. Quite rightly they were 
    following [this support 
    article](https://support.microsoft.com/en-gb/help/2710029/shared-mailboxes-are-unexpectedly-converted-to-user-mailboxes-after-di) 
    from Microsoft which recommends setting the _msExchRecipientTypeDetails_ to a 
    particular value. The result of that corrupted the way the permissions are 
    evaluated on the Public Folder permissions, so that they do not appear to be 
    "ACLable" (assignable as permissions)

    Upon further investigation, this also applies in another scenario – where 
    you remove Exchange attributes from a Mailbox but keep the underlying Active 
    Directory account (i.e. you run _Disable-Mailbox_). In that scenario the 
    permission also shows in the same way and cannot be applied on the destination 
    – nor can it be used by a user

    When this occurs the permission shows like this when examining it using 
    _Get-PublicFolderClientPermission_ or by using _ExFolders_:
 
    ![Correcting Public Folder Permissions before an Office 365 
    Migration](https://www.practical365.com/wp-content/uploads/2020/04/image-5.png)
 
    As you can see in the above example, it is prefixed with _NT User:_ and the 
    account name, rather than resolving to a Mailbox, Remote Mailbox or other 
    recipient

    To search for and then resolve this scenario, I've created a simple 
    script called _Remove-NTUSER.ps1_, which you can [download from my GitHub](https://github.com/spgoodman/p365scripts/blob/master/Remove-NTUSER.ps1).


    #-=-=-=-=-=-=-=-=

    .PARAMETER Mailbox
    Use the -Mailbox parameter to designate the mailbox. Any valid Exchange mailbox identifier can be specified. Multiple mailboxes can be specified in a comma-separated list or array, see examples below.
    .PARAMETER ResetDefaultLevel
    Switch to specify reset to *include* default permissions (e.g. coerce Default SecPrin to 'LimitedDetails' & Anonymous:None)
    .PARAMETER CalendarLimitedDetails
    Switch to default Calendar folder view to customized LimitedDetails (vs default AvailabilityOnly)
    .PARAMETER RemoveUnresolveable
    Switch to Remove broken-SID/non-ADUser-resolvable entries targets usertype:UNKNOWN, including getr-adusere solvable, that lack populated msExchRecipientTypeDetails property
    .PARAMETER IgnoreInternal
    Switch to ignore/leave-intact any pre-existing usertype:Internal folder grants
    PARAMETER IgnoreExternal
    Switch to ignore/leave-intact any pre-existing usertype:External folder grants
    .PARAMETER Ticket
    Ticket number
    .PARAMETER Quiet
    Use the -Quiet switch if you want to suppress output to the console.
    .PARAMETER includedfolders
    Configurable string array of folder names to be *included* in processing (generally defaults to these; override to use customize/targed list)[-includedfolders @('Inbox','Calendar')]
    .PARAMETER excludedfolders
    Configurable string array of folder names to be *excluded* from processing (generally defaults to these; override to use customize/targed list)[-excludedfolders @('Inbox','Calendar')]
    .PARAMETER Verbose
    The -Verbose switch provides additional details on the cmdlet progress, it can be useful when troubleshooting issues.
     .INPUTS
    A mailbox identifier.
    .OUTPUTS
    Array of Mailbox address, Folder name and User.
    .EXAMPLE
    PS> Reset-xoMailboxFolderPermissionsRecursive -Mailbox emailaddress@domain.com -ResetDefaultLevel -verbose -whatif:$true
    Typical single user FULL RESET pass , with Whatif & verbose. Includes RESET of all Default role grants to stock UNMODIFIED settings:
    - Effectively WIPES ALL USER-MODIFICATIONS from all user/publicl-accessible folders of the mailbox, 
    - Resets Calendar(s):Default role to 'LimitedDetails' (TTC, MS Default 'AvailabilityOnly' can be set using -CalendarLimitedDetails:$false) & Anonymous role:None. 
    - All other modifications perms are removed, including user configured Internal & External grants. 
    .EXAMPLE
    PS> Reset-xoMailboxFolderPermissionsRecursive -Mailbox 
    Typical single-user pass no ResetDefaultLevel (any user-modifications to the Default & Anonymous roles are left intact), commit updates.
    .EXAMPLE
    PS> Reset-xoMailboxFolderPermissionsRecursive -Mailbox emailaddress@domain.com -ticket 123456 -RemoveUnresolveable -IgnoreInternal -IgnoreExternal -whatif:$false  ; 
    Single user pass, no Default Rest, targets removal of Unresolvable 'broken' grants (NT:S-1-5-21-...) from all user/public-accessible mailbox folders.
    .EXAMPLE
    PS> Reset-xoMailboxFolderPermissionsRecursive -Mailbox emailaddress@domain.com -ticket 123456 -IgnoreInternal -IgnoreExternal -whatif:$false  ; 
    Single user pass, no Default Rest, specifies to ignore both External & Internal user-added grants (left intact). 
    Effectively, this does nothing. Defaults are left unreset. Unknown/broken aren't targeted. and even default Internal/Externals are left untargeted.
    .EXAMPLE
    PS> Reset-xoMailboxFolderPermissionsRecursive -Mailbox @('emailaddress@domain.com','emailaddres2s@domain.com') -ResetDefaultLevel -verbose -whatif:$true
    Typical two-user pass as array, using specifying to include reset of all Default role grants to stock unmoidifed settings, with Whatif & verbose. 
    .EXAMPLE
    PS> Reset-xoMailboxFolderPermissionsRecursive -Mailbox @('emailaddress@domain.com','emailaddres2s@domain.com') -CalendarLimitedDetails:$false ;
    Demo override CalendarLimitedDetails (use the MS default Calendar visibility, 'AvailabilityOnly' (vs this script's default variant 'LimitedDetails').
    .EXAMPLE
    PS> Get-ADPermission -Identity "Christopher Payne" | ?{$_.user -like "S-1-5-21*"} | Remove-ADPermission
    Remove orphaned SID with Exchange Onprem PowerShell
    .EXAMPLE
    Reset-xoMailboxFolderPermissionsRecursive -Mailbox (Get-Mailbox -RecipientTypeDetails RoomMailbox) -Verbose
    This command removes permissions on all user-accessible folders in ALL Room mailboxes in the organization.
    .LINK
    https://github.com/tostka/powershell
    #>
    #Requires -Version 3.0
    [CmdletBinding(SupportsShouldProcess)] #Make sure we can use -WhatIf and -Verbose
    #[CmdletBinding()
    PARAM(
        [Parameter(Mandatory=$False,HelpMessage="Ticket Number [-Ticket '999999']")]
            [string]$Ticket,
        [Parameter(Mandatory=$true,ValueFromPipeline=$false,HelpMessage="Use the -Mailbox parameter to designate the mailbox. Any valid Exchange mailbox identifier can be specified. Multiple mailboxes can be specified in a comma-separated list or array, see examples below.")]
            [ValidateNotNullOrEmpty()]
            [Alias("Identity")]
            [String[]]$Mailbox,
        [Parameter(HelpMessage="Switch to specify reset to *include* default permissions")]
            [switch]$ResetDefaultLevel,
        # "AvailabilityOnly" v LimitedDetails custom
        [Parameter(HelpMessage="Switch to default Calendar folder view to customized LimitedDetails (vs default AvailabilityOnly)")]
            [switch]$CalendarLimitedDetails=$true,
        [Parameter(HelpMessage="Switch to Remove broken-SID/non-ADUser-resolvable entries")]
            [switch]$RemoveUnresolveable,
        [Parameter(HelpMessage="Switch to ignore/leave-intact any pre-existing usertype:Internal folder grants[-IgnoreInternal]")]
            [switch]$IgnoreInternal,
        [Parameter(HelpMessage="Switch to ignore/leave-intact any pre-existing usertype:External folder grants[-IgnoreInternal]")]
            [switch]$IgnoreExternal,
            [switch]$Quiet,
        [Parameter(HelpMessage="Configurable string array of folder names to be *included* in processing (generally defaults to these; override to use customize/targed list)[-includedfolders @('Inbox','Calendar'))")]        
            [string[]]$includedfolders = @("Root","Inbox","Calendar","Contacts","DeletedItems","Drafts","JunkEmail","Journal","Notes","Outbox","SentItems","Tasks","CommunicatorHistory","Clutter","Archive"), 
        [Parameter(HelpMessage="Configurable string array of folder names to be *excluded* from processing (generally defaults to these; override to use customize/targed list)[-excludedfolders @('Inbox','Calendar')]")]        
            [string[]]$excludedfolders = @("News Feed","Quick Step Settings","Social Activity Notifications","Suggested Contacts", "SearchDiscoveryHoldsUnindexedItemFolder", "SearchDiscoveryHoldsFolder","Calendar Logging")
        #[Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
        #    [switch] $whatIf
    ) ; 
    # $CalendarLimitedDetails isn't coming through clean, force it up and move on for now
    BEGIN{
        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
        write-verbose "`$PSBoundParameters:`n$(($PSBoundParameters|out-string).trim())" ;
        $Verbose = ($VerbosePreference -eq 'Continue') ; 
        if($WhatIfPreference){
            $whatif = $true ; 
        } else { $whatif = $false } ; 

        $DefaultRoleUserNames = @("Default","Anonymous","Owner@local","Member@local") ; 
        if(!$ThrottleMs){$ThrottleMs = 500} ; 

        if($CalendarLimitedDetails){$CalPermsDefault = 'LimitedDetails' }
        else {$CalPermsDefault = 'AvailabilityOnly' }

        #$includedfolders = @("Root","Inbox","Calendar", "Contacts", "DeletedItems", "Drafts", "JunkEmail", "Journal", "Notes", "Outbox", "SentItems", "Tasks", "CommunicatorHistory", "Clutter", "Archive") ; 
        #$includedfolders = @("Root","Inbox","Calendar", "Contacts", "DeletedItems", "SentItems", "Tasks") #Trimmed down list of default folders
        #Exclude additional Non-default folders created by Outlook or other mail programs. Folder NAMES, not types! So make sure to include translations too!
        #Exclude SearchDiscoveryHoldsFolder and SearchDiscoveryHoldsUnindexedItemFolder as they're not marked as default folders #Exclude "Calendar Logging" on older Exchange versions
        #$excludedfolders = @("News Feed","Quick Step Settings","Social Activity Notifications","Suggested Contacts", "SearchDiscoveryHoldsUnindexedItemFolder", "SearchDiscoveryHoldsFolder","Calendar Logging") ; 
        $prpADU = 'DistinguishedName','enabled','samaccountname','sid','UserPrincipalName' ; 

        #region ENVIRO_DISCOVER ; #*------v ENVIRO_DISCOVER v------
        #if ($PSScriptRoot -eq "") {
        # 8/29/2023 fix logic break on psv2 ISE (doesn't test PSScriptRoot -eq '' properly, needs $null test).
        #if( -not (get-variable -name PSScriptRoot -ea 0) -OR ($PSScriptRoot -eq '')){
        if( -not (get-variable -name PSScriptRoot -ea 0) -OR ($PSScriptRoot -eq '') -OR ($PSScriptRoot -eq $null)){
            if ($psISE) { $ScriptName = $psISE.CurrentFile.FullPath } 
            elseif($psEditor){
                if ($context = $psEditor.GetEditorContext()) {$ScriptName = $context.CurrentFile.Path } 
            } elseif ($host.version.major -lt 3) {
                $ScriptName = $MyInvocation.MyCommand.Path ;
                $PSScriptRoot = Split-Path $ScriptName -Parent ;
                $PSCommandPath = $ScriptName ;
            } else {
                if ($MyInvocation.MyCommand.Path) {
                    $ScriptName = $MyInvocation.MyCommand.Path ;
                    $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                } else {throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" } ;
            };
            if($ScriptName){
                $ScriptDir = Split-Path -Parent $ScriptName ;
                $ScriptBaseName = split-path -leaf $ScriptName ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($ScriptName) ;
            } ; 
        } else {
            if($PSScriptRoot){$ScriptDir = $PSScriptRoot ;}
            else{
                write-warning "Unpopulated `$PSScriptRoot!" ; 
                $ScriptDir=(Split-Path -parent $MyInvocation.MyCommand.Definition) + "\" ;
            }
            if ($PSCommandPath) {$ScriptName = $PSCommandPath } 
            else {
                $ScriptName = $myInvocation.ScriptName
                $PSCommandPath = $ScriptName ;
            } ;
            $ScriptBaseName = (Split-Path -Leaf ((& { $myInvocation }).ScriptName))  ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
        } ;
        if(-not $ScriptDir){
            write-host "Failed `$ScriptDir resolution on PSv$($host.version.major): Falling back to $MyInvocation parsing..." ; 
            $ScriptDir=(Split-Path -parent $MyInvocation.MyCommand.Definition) + "\" ;
            $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ; 
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;     
        } else {
            if(-not $PSCommandPath ){
                $PSCommandPath  = $ScriptName ; 
                if($PSCommandPath){ write-host "(Derived missing `$PSCommandPath from `$ScriptName)" ; } ;
            } ; 
            if(-not $PSScriptRoot  ){
                $PSScriptRoot   = $ScriptDir ; 
                if($PSScriptRoot){ write-host "(Derived missing `$PSScriptRoot from `$ScriptDir)" ; } ;
            } ; 
        } ; 
        if(-not ($ScriptDir -AND $ScriptBaseName -AND $ScriptNameNoExt)){ 
            throw "Invalid Invocation. Blank `$ScriptDir/`$ScriptBaseName/`ScriptNameNoExt" ; 
            BREAK ; 
        } ; 

        $smsg = "`$ScriptDir:$($ScriptDir)" ;
        $smsg += "`n`$ScriptBaseName:$($ScriptBaseName)" ;
        $smsg += "`n`$ScriptNameNoExt:$($ScriptNameNoExt)" ;
        $smsg += "`n`$PSScriptRoot:$($PSScriptRoot)" ;
        $smsg += "`n`$PSCommandPath:$($PSCommandPath)" ;  ;
        write-verbose $smsg ; 
        #endregion ENVIRO_DISCOVER ; #*------^ END ENVIRO_DISCOVER ^------        
        write-verbose "checking depednant function availability..." ; 
        $depCmdlets = @('get-XOMailboxFolderList','get-XOMailboxFolderPermissionsSummary') ; 
        $depCmdlets | foreach-object{if(get-command $_ ){write-verbose "gcm'd:dependant function:$($_)"} else { $smsg = "Missing dependant function:$($_)" ; write-warning $smsg ; throw $smsg ; }} ;
        # EOM3+ NO PSS SUPP
        #if (-not ((Get-ConnectionInformation).tokenstatus -eq 'Active')){ Write-Error "No active Exchange connection detected, please connect first. To connect to ExO: https://technet.microsoft.com/en-us/library/jj984289(v=exchg.160).aspx" -ErrorAction Stop ;} ; 
        #Prepare the list of mailboxes
        $smsg = "Parsing the Mailbox parameter..."
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        $SMTPAddresses = @{}
        foreach ($mb in $Mailbox) {
            Start-Sleep -Milliseconds 80 #Add some delay to avoid throttling...
            #Make sure a matching mailbox is found and return its Primary SMTP Address
            #$SMTPAddress = (Invoke-Command -Session $session -ScriptBlock { Get-Mailbox $using:mb | Select-Object -ExpandProperty PrimarySmtpAddress } -ErrorAction SilentlyContinue).Address
            # eom3+ direct no pss
            #$SMTPAddress = Get-xoMailbox $mb | Select-Object -ExpandProperty PrimarySmtpAddress -ErrorAction SilentlyContinue;
            #*======v BP Wrapper for running EXO dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp) v======
            # define the splat of all params:
            $pltGMbx = [ordered]@{identity =  $mb ; erroraction = 'STOP'; verbose = $($VerbosePreference -eq "Continue") ;} ;
            $cmdlet = 'get-Mailbox' ; $verb,$noun = $cmdlet.split('-') ;  #Spec cmdletname (VERB-NOUN), & split v/n
            TRY{$xoS = Get-ConnectionInformation -ErrorAction STOP }CATCH{reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP }
            TRY{
                if((-not $xos) -OR ($xoS | ?{$_.tokenstatus -notmatch 'Active|Expired' -AND $_.State -ne 'Connected'} )){reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP } ; 
                if($xos){
                    $xcmd = "$verb-$($xoS.ModulePrefix)$noun `@pltGMbx" ; # build cmdline w splat, then echo:
                    $smsg = "$($([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value)) w`n$(($pltGMbx|out-string).trim())" ;
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    $SMTPAddress  = invoke-expression $xcmd  | 
                        Select-Object -ExpandProperty PrimarySmtpAddress -ErrorAction SilentlyContinue;
                    if($SMTPAddress){
                        $smsg = "(confirmed valid $([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value) output)" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                    }
                } else { 
                    $smsg = "Missing `$xos EXO connection!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    throw $smsg ; BREAK ; 
                } 
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            } ; 
            <# version 12:43 PM 9/21/2023 moved cixo up to 1st, won't have prefix if not populated, also needs to fail/retry to ensure conn;  
            11:48 AM 9/20/2023 minor tweaks ; 3:01 PM 9/19/2023 initial 
            ## this runs: 1) connection status check, w rxo on demand; 2) splat wrapper with integrated prefix support; 3) try/catch on exec; 
            useful alias: cixo => get-connectioninformation;
            #>
            #*======^ END BP wrapper for running dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp)  ^======
            if (-not $SMTPAddress) { if (-not $Quiet) { 
                $smsg = "Mailbox with identifier $mb not found, skipping..." ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; }; 
                continue 
            } elseif (($SMTPAddress.count -gt 1) -or ($SMTPAddresses[$mb]) -or ($SMTPAddresses.ContainsValue($SMTPAddress))) { 
                $smsg = "Multiple mailboxes matching the identifier $mb found, skipping..."; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                continue 
            }else { $SMTPAddresses[$mb] = $SMTPAddress } ; 
        }
        if (-not $SMTPAddresses -or ($SMTPAddresses.Count -eq 0)) { Throw "No matching mailboxes found, check the parameter values." } ; 
        $smsg = "The following list of mailboxes will be used: ""$($SMTPAddresses.Values -join ", ")""" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
        $smsg = "List of default folder TYPES that will be used: ""$($includedfolders -join ", ")""" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
        $smsg = "List of folder NAMES that will be excluded: ""$($excludedfolders -join ", ")""" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
    }
    PROCESS{
        $out = @() ; 
        foreach ($smtp in $SMTPAddresses.Values) {
            $smsg = $sBnrS="`n#*------v PROCESSING Mailbox: $($smtp)... v------" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H2 } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            Start-Sleep -Milliseconds 800  ; #Add some delay to avoid throttling...
            $smsg = "Obtaining folder list for mailbox ""$smtp""..." ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            $folders = get-XOMailboxFolderList $smtp ; 
            $smsg = "A total of $($folders.count) folders found for $($smtp)." ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            if (-not $folders) {
                $smsg = "No matching folders found for $($smtp), skipping..." ; 
                continue  ; 
            } ; 
            #Cycle over each folder we are interested in
            foreach ($folder in $folders) {
                $smsg = "`n==PROCESSING:$($folder.name)`n" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H3 } 
                else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                #"Fix" for folders with "/" characters, treat the Root folder separately
                if ($folder.FolderType -eq "Root") { $foldername = $smtp }
                else { $foldername = $folder.Identity.ToString().Replace([char]63743,"/").Replace($smtp,$smtp + ":") } ; 
                $fPermissions = get-XOMailboxFolderPermissionsSummary $foldername
                if (-not $ResetDefaultLevel) { 
                    $smsg = "no -ResetDefaultLevel: exempting username:$($DefaultRoleUserNames -join '|') from processing" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;  ; 
                    $fPermissions = $fPermissions | ? {$_.UserName -notin @("Default","Anonymous","Owner@local","Member@local")}
                    #$fPermissions = $fPermissions | ? {$_.UserName -notin @($($DefaultRoleUserNames)))}
                }  ; #filter out default permissions -> doesn't process defaults, leaves them intact
                if (-not $fPermissions) { 
                    $smsg = "No permission entries found for $($foldername), skipping..." ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    continue  ; 
                } ; 

                #Remove the folder permissions for each delegate
                foreach ($u in $fPermissions) {
                    $smsg = "`n" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    if ($u.UserType -eq "Default") {
                        <# effectively: This forcec Default Cal to AvailOnly (or LtdDetails), and any other Default to NONE. -> It strips all but Cal Default access.
                         Details: 
                            Default perms only get here if $ResetDefaultLevel:$true, this forces xxx:\Calendar Defaults to $CalPermsDefaul (AvailabilityOnly (MS default) or LimitedDetails (local Org), depending on specification)
                            Non Cal folders get set to NONE
                        #>
                        #UserType enumeration https://docs.microsoft.com/en-us/previous-versions/office/developer/exchange-server-2010/ff319704(v%3Dexchg.140) hardcoded solely: Default|Anonymous|Internal|External|Unknown
                        if ($ResetDefaultLevel) {
                            <# https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes?view=powershell-7.3#the-using-scope-modifier
                                scope $using: - Used to access variables defined in another scope while running scripts via cmdlets like Start-Job and Invoke-Command.

                            #>
                            TRY {
                                $smsg = "Resetting permissions on ""$foldername"" for principal ""Default""." ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
                                else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                if ($folder.FolderType -eq "Calendar") {
                                    # force any Calendar folder Default grant to AvailOnly (or LtdDetails)
                                    #if (($u.AccessRights -join ",") -ne "AvailabilityOnly") {
                                    # TTC customizes the view as LimitedDetails: $CalPermsDefault
                                    if (($u.AccessRights -join ",") -ne $CalPermsDefault) {
                                        #Invoke-Command -Session $session -ScriptBlock { Set-MailboxFolderPermission -Identity $Using:foldername -User Default -AccessRights AvailabilityOnly -WhatIf:$using:WhatIfPreference -Confirm:$false } -ErrorAction Stop -HideComputerName ;
                                        # can't use -session $session with EOM3+, try direct calls; should work
                                        #Set-xoMailboxFolderPermission -Identity $foldername -User Default -AccessRights AvailabilityOnly -WhatIf:$WhatIfPreference -Confirm:$false -ErrorAction Stop ;
                                        #Set-xoMailboxFolderPermission -Identity $foldername -User Default -AccessRights $CalPermsDefault -WhatIf:$WhatIfPreference -Confirm:$false -ErrorAction Stop ;
                                        #*======v BP Wrapper for running EXO dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp) v======
                                        # define the splat of all params:
                                        $pltSMbxFP = [ordered]@{
                                            Identity =$foldername ;
                                            User ='Default' ;
                                            AccessRights =$CalPermsDefault ;
                                            WhatIf =$WhatIfPreference ;
                                            Confirm =$false ;
                                            ErrorAction = 'Stop' ; 
                                            verbose = $($VerbosePreference -eq "Continue") ;
                                        } ;
                                        $cmdlet = 'Set-MailboxFolderPermission' ; $verb,$noun = $cmdlet.split('-') ;  #Spec cmdletname (VERB-NOUN), & split v/n
                                        TRY{$xoS = Get-ConnectionInformation -ErrorAction STOP }CATCH{reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP }
                                        TRY{
                                            if((-not $xos) -OR ($xoS | ?{$_.tokenstatus -notmatch 'Active|Expired' -AND $_.State -ne 'Connected'} )){reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP } ; 
                                            if($xos){
                                                $xcmd = "$verb-$($xoS.ModulePrefix)$noun `@pltSMbxFP" ; # build cmdline w splat, then echo:
                                                $smsg =  "$($([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value)) w`n$(($pltSMbxFP|out-string).trim())" ;
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                                $RET = invoke-expression $xcmd  ;
                                                if($RET){
                                                    $smsg = "(confirmed valid $([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value) output)" ; 
                                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                                }
                                            } else { 
                                                $smsg = "Missing `$xos EXO connection!" ; 
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                                throw $smsg ; BREAK ; 
                                            } 
                                        } CATCH {
                                            $ErrTrapd=$Error[0] ;
                                            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                        } ; 
                                        <# version 12:43 PM 9/21/2023 moved cixo up to 1st, won't have prefix if not populated, also needs to fail/retry to ensure conn;  
                                        11:48 AM 9/20/2023 minor tweaks ; 3:01 PM 9/19/2023 initial 
                                        ## this runs: 1) connection status check, w rxo on demand; 2) splat wrapper with integrated prefix support; 3) try/catch on exec; 
                                        useful alias: cixo => get-connectioninformation;
                                        #>
                                        #*======^ END BP wrapper for running dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp)  ^======
                                    } else { continue } ; 
                                    $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $folder.name;"User" = $u.UserName;"AccessRights" = "AvailabilityOnly"}) ; 
                                } else {
                                    # force any non-calendar folder with a Default grant, to NONE
                                    if (($u.AccessRights -join ",") -ne "None") {
                                        #Invoke-Command -Session $session -ScriptBlock { Set-MailboxFolderPermission -Identity $Using:foldername -User Default -AccessRights None -WhatIf:$using:WhatIfPreference -Confirm:$false } -ErrorAction Stop -HideComputerName 
                                        # eom3+ no pss
                                        #Set-xoMailboxFolderPermission -Identity $Using:foldername -User Default -AccessRights None -WhatIf:$using:WhatIfPreference -Confirm:$false -ErrorAction Stop ;
                                    
                                        #*======v BP Wrapper for running EXO dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp) v======
                                        # define the splat of all params:
                                        $pltSMbxFP = [ordered]@{
                                            Identity =$foldername ;
                                            User ='Default' ;
                                            AccessRights = 'None' ;
                                            WhatIf =$WhatIfPreference ;
                                            Confirm =$false ;
                                            ErrorAction = 'Stop' ; 
                                            verbose = $($VerbosePreference -eq "Continue") ;
                                        } ;
                                        $cmdlet = 'Set-MailboxFolderPermission' ; $verb,$noun = $cmdlet.split('-') ;  #Spec cmdletname (VERB-NOUN), & split v/n
                                        TRY{$xoS = Get-ConnectionInformation -ErrorAction STOP }CATCH{reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP }
                                        TRY{
                                            if((-not $xos) -OR ($xoS | ?{$_.tokenstatus -notmatch 'Active|Expired' -AND $_.State -ne 'Connected'} )){reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP } ; 
                                            if($xos){
                                                $xcmd = "$verb-$($xoS.ModulePrefix)$noun `@pltSMbxFP" ; # build cmdline w splat, then echo:
                                                $smsg = "$($([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value)) w`n$(($pltSMbxFP|out-string).trim())" ;
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                                $RET = invoke-expression $xcmd  ;
                                                if($RET){$smsg = "(confirmed valid $([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value) output)" ; if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; }
                                            } else { 
                                                $smsg = "Missing `$xos EXO connection!" ; 
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                                throw $smsg ; BREAK ; 
                                            } 
                                        } CATCH {
                                            $ErrTrapd=$Error[0] ;
                                            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                        } ; 
                                        <# version 12:43 PM 9/21/2023 moved cixo up to 1st, won't have prefix if not populated, also needs to fail/retry to ensure conn;  
                                        11:48 AM 9/20/2023 minor tweaks ; 3:01 PM 9/19/2023 initial 
                                        ## this runs: 1) connection status check, w rxo on demand; 2) splat wrapper with integrated prefix support; 3) try/catch on exec; 
                                        useful alias: cixo => get-connectioninformation;
                                        #>
                                        #*======^ END BP wrapper for running dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp)  ^======
                                    }
                                    else { continue } ; 
                                    $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $folder.name;"User" = $u.UserName;"AccessRights" = "None"}) ; 
                                } ; 
                                $out += $outtemp; if (-not $Quiet -and -not $WhatIfPreference) { 
                                    #$outtemp 
                                    $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                }  ; #Write output to the console unless the -Quiet parameter is used
                            } CATCH {
                                #$_ | fl * -Force; continue
                                $smsg = "`n$(($_ | fl *|out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                continue
                            }  ; #catch-all for any unhandled errors
                        } else { continue } ; 

                    } elseif ($u.UserType -eq "Anonymous") { 
                        $smsg = "$($u.username):UserType:Anonymous, skipping processing" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        continue 
                        #Maybe set them all to none when $resetdefault is used?

                    } elseif ($u.UserType -eq "Unknown") { 
                        <# Add param: -RemoveUnresolveable -> targets usertype:UNKNOWN, including getr-adusere solvable, that lack populated msExchRecipientTypeDetails property
                        Add param: -IgnoreInternal - skips reset of existing usertype:Internal to NONE
                        Add param: -IgnoreExternal - skips reset of existing usertype:External to NONE
                        Switch to ignore/leave-intact any pre-existing usertype:Internal folder grants
                        Switch to ignore/leave-intact any pre-existing usertype:External folder grants
                        #>
                        $smsg = "'UNKNOWN entry':" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        $DoRemove = $false ; 
                        if($RemoveUnresolveable -AND ($u.UserName -match '^NT:S-1-5-21-')){
                            $smsg = "(entry UserName appears to be a BROKEN SID (SECURITY IDENTIFYER == DELETED USER OBJECT/NON-RECIPIENT)" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        
                            $smsg = "(attempting: get-aduser -id $($u.UserName.replace('NT:','')) )" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

                            $DoRemove = $false ; 
                            TRY{
                                if($ADU =  get-aduser -id ($u.UserName.replace('NT:','')) -ErrorAction SilentlyContinue -prop msExchRecipientTypeDetails){
                                    $smsg = "Resolved`n $($u.UserName.replace('NT:',''))`n to an existing ADUser object:`n$(($adu | fl $prpADU |out-string).trim())" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                }else {
                                    $DoRemove = $true ; 
                                    $smsg = "Unable to resolve $($u.UserName.replace('NT:','')) to an existing ADUser object: => REMOVE Grant!" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                    $DoRemove = $true ; 
                                } ; 
                            } CATCH [Microsoft.ActiveDirectory.Management.ADIdentityNotFoundException]{
                                $smsg = "Unable to resolve $($u.UserName.replace('NT:','')) to an existing ADUser object: => REMOVE Grant!" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                $DoRemove = $true ;
                            } CATCH {
                                $smsg = "$(($_ | fl * |out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                continue 
                            };#catch-all for any unhandled errors
                            if($ADU){
                                $smsg = "Test for EX recipient: populated  msExchRecipientTypeDetail" ; 
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                if($ADU.msExchRecipientTypeDetails){
                                    $smsg = "Found ADUser:$($ADU.userprincipalname) *has* populated msExchRecipientTypeDetail:$($ADU.msExchRecipientTypeDetail)`n*LEAVING EXISTING GRANT IN PLACE!" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                    $DoRemove = $false ; 
                                } else { 
                                    $smsg = "Found ADUser:$($ADU.userprincipalname) has *NO* populated msExchRecipientTypeDetail:$($ADU.msExchRecipientTypeDetail)`n*=> Non-Recipient Security Principal: REMOVE Grant!" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                    $DoRemove = $true ; 
                                } ; 
                             } ;    
                            
                        } elseif($RemoveUnresolveable -AND ($u.User -eq $null)){
                            # non-guid likely still has blank User/user.RecipientPrincipa.guid.guid ($_.user.RecipientPrincipal.value resolve)
                            $smsg = "entry UserName is populated non SID but User is blank (reflects unresolved underlying RecipientPrincipa.guid.guid)" ; 
                            $smsg += "`n$(($u | fl *|out-string).trim())" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                            $smsg += "`n(Setting `$DoRemove:`$true)" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            $DoRemove = $true ; 
                        } else { 
                            $DoRemove = $false ; 
                            # 12:19 PM 9/25/2023 the DC, entry falls through here, it's got no 
                            $smsg = "Skipping orphaned permissions entry: $($u.UserName)";
                            $smsg += "`n$(($u | fl *|out-string).trim())" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
                            else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            continue  ; 
                        } ; 

                        # removal handling here on $DoRemove spec
                        if($DoRemove){
                            $smsg = "`nREMOVING NON-FUNCTIONAL GRANT!"
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                            # eom3+ no pss
                            #Remove-xoMailboxFolderPermission -Identity $foldername -User $u.User -WhatIf:$WhatIfPreference -Confirm:$false -ErrorAction Stop ;
                            <#
                            # Expand the full name out of the above:
                            Get-exoMailboxFolderPermission -Identity "$($TMBX):\Calendar" | select -expand User | select -expand displayname
                            # out: 
                            NT:S-1-5-21-2222296782-158576315-1096482972-20544
                            #
                            # Target it for removal:(can use the name displayed):
                            Remove-xoMailboxFolderPermission -Identity "$($tmbx):\Calendar” -User "NT:S-1-5-21-2222296782-158576315-1096482972-20544" -whatif ; 
                            => use the populated $u.UserName from this script as -User
                            #>
                            #*======v BP Wrapper for running EXO dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp) v======
                            # define the splat of all params:
                            $pltRMbxFP = [ordered]@{
                                Identity =$foldername ;
                                #User =$u.User ; # user is blank on UNKNOWN's so use username
                                User = $u.UserName ; 
                                #AccessRights = 'None' ;
                                WhatIf =$WhatIfPreference ;
                                Confirm =$false ;
                                ErrorAction = 'Stop' ; 
                                verbose = $($VerbosePreference -eq "Continue") ;
                            } ;
                            $cmdlet = 'Remove-MailboxFolderPermission' ; $verb,$noun = $cmdlet.split('-') ;  #Spec cmdletname (VERB-NOUN), & split v/n
                            TRY{$xoS = Get-ConnectionInformation -ErrorAction STOP }CATCH{reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP }
                            TRY{
                                if((-not $xos) -OR ($xoS | ?{$_.tokenstatus -notmatch 'Active|Expired' -AND $_.State -ne 'Connected'} )){reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP } ; 
                                if($xos){
                                    $xcmd = "$verb-$($xoS.ModulePrefix)$noun `@pltRMbxFP" ; # build cmdline w splat, then echo:
                                    $smsg = "$($([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value)) w`n$(($pltRMbxFP|out-string).trim())" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                    $RET = invoke-expression $xcmd  ;
                                    if($RET){$smsg = "(confirmed valid $([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value) output)" ; if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; }
                                } else { 
                                    $smsg = "Missing `$xos EXO connection!" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                    throw $smsg ; BREAK ; 
                                } 
                            } CATCH {
                                $ErrTrapd=$Error[0] ;
                                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                            } ; 
                            <# version 12:43 PM 9/21/2023 moved cixo up to 1st, won't have prefix if not populated, also needs to fail/retry to ensure conn;  
                            11:48 AM 9/20/2023 minor tweaks ; 3:01 PM 9/19/2023 initial 
                            ## this runs: 1) connection status check, w rxo on demand; 2) splat wrapper with integrated prefix support; 3) try/catch on exec; 
                            useful alias: cixo => get-connectioninformation;
                            #>
                            #*======^ END BP wrapper for running dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp)  ^======
                            $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $folder.name;"User" = $u.UserName}) ;
                            #Write output to the console unless the -Quiet parameter is used 
                            $out += $outtemp; if (-not $Quiet -and -not $WhatIfPreference) { 
                                #$outtemp 
                                $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            }  ; #Write output to the console unless the -Quiet parameter is used
                        } else { 
                            $smsg = "`$DoRemove:$($DoRemove): skipping removal of usertype:UNKNOWN grant" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        } ; 

                    } else {
                        # other: External|Internal wind up here
                        if ($u.UserType -eq "External") { $u.User = $u.UserName }
                        <#
                        Add param: -IgnoreInternal - skips reset of existing usertype:Internal to NONE
                        Add param: -IgnoreExternal - skips reset of existing usertype:External to NONE
                        #>
                        if($u.UserType -eq "External" -AND $IgnoreExternal){
                            $smsg = "UserType:External with -IgnoreExternal specified: *SKIPPING* default purge of EXTERNAL Grant:" ;
                            $smsg += "`n`n$(($u | ft -a identity,user,usertype,username,accessrights|out-string).trim())" ;  
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            Continue 
                        } 
                        if($u.UserType -eq "Internal" -AND $IgnoreInternal){ 
                            $smsg = "UserType:Internal with -IgnoreInternal specified: *SKIPPING* default purge of INTERNAL Grant:" ; 
                            $smsg += "`n`n$(($u | ft -a identity,user,usertype,username,accessrights|out-string).trim())" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            Continue 
                        } 
                        TRY {
                            if (-not $u.User) { continue } ; 
                            $smsg = "Removing permissions on ""$foldername"" for principal ""$($u.UserName)""." ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
                            else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            #Invoke-Command -Session $session -ScriptBlock { Remove-MailboxFolderPermission -Identity $Using:foldername -User $Using:u.User -WhatIf:$using:WhatIfPreference -Confirm:$false } -ErrorAction Stop -HideComputerName ;
                            # eom3+ no pss
                            #Remove-xoMailboxFolderPermission -Identity $foldername -User $u.User -WhatIf:$WhatIfPreference -Confirm:$false -ErrorAction Stop ;
                            #*======v BP Wrapper for running EXO dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp) v======
                            # define the splat of all params:
                            $pltRMbxFP = [ordered]@{
                                Identity =$foldername ;
                                User =$u.User ;
                                #AccessRights = 'None' ;
                                WhatIf =$WhatIfPreference ;
                                Confirm =$false ;
                                ErrorAction = 'Stop' ; 
                                verbose = $($VerbosePreference -eq "Continue") ;
                            } ;
                            $smsg = "Spec cmdletname (VERB-NOUN), then convert cmdlet & splat to `$xcmd string" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            $cmdlet = 'Remove-MailboxFolderPermission' ; $verb,$noun = $cmdlet.split('-') ;  #Spec cmdletname (VERB-NOUN), & split v/n
                            TRY{$xoS = Get-ConnectionInformation -ErrorAction STOP }CATCH{reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP }
                            TRY{
                                if((-not $xos) -OR ($xoS | ?{$_.tokenstatus -notmatch 'Active|Expired' -AND $_.State -ne 'Connected'} )){reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP } ; 
                                if($xos){
                                    $xcmd = "$verb-$($xoS.ModulePrefix)$noun `@pltRMbxFP" ; # build cmdline w splat, then echo:
                                    $smsg = "$($([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value)) w`n$(($pltRMbxFP|out-string).trim())" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                    $RET = invoke-expression $xcmd  ;
                                    if($RET){$smsg = "(confirmed valid $([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value) output)" ; if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; }
                                } else { 
                                    $smsg = "Missing `$xos EXO connection!" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                    throw $smsg ; BREAK ; 
                                } 
                            } CATCH {
                                $ErrTrapd=$Error[0] ;
                                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                            } ; 
                            <# version 12:43 PM 9/21/2023 moved cixo up to 1st, won't have prefix if not populated, also needs to fail/retry to ensure conn;  
                            11:48 AM 9/20/2023 minor tweaks ; 3:01 PM 9/19/2023 initial 
                            ## this runs: 1) connection status check, w rxo on demand; 2) splat wrapper with integrated prefix support; 3) try/catch on exec; 
                            useful alias: cixo => get-connectioninformation;
                            #>
                            #*======^ END BP wrapper for running dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp)  ^======
                            $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $folder.name;"User" = $u.UserName}) ;
                            #Write output to the console unless the -Quiet parameter is used 
                            $out += $outtemp; if (-not $Quiet -and -not $WhatIfPreference) { 
                                #$outtemp 
                                $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            }  ; #Write output to the console unless the -Quiet parameter is used
                        } CATCH [System.Management.Automation.RemoteException] {
                            if (-not $Quiet) {
                                if ($_.CategoryInfo.Reason -eq "UserNotFoundInPermissionEntryException") { 
                                    $smsg = "WARNING: No existing permissions entry found on ""$foldername"" for principal ""$($u.UserName)""" 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                }elseif ($_.CategoryInfo.Reason -eq "CannotChangePermissionsOnFolderException") { 
                                    $smsg = "ERROR: Folder permissions for ""$foldername"" CANNOT be changed!" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                }elseif ($_.CategoryInfo.Reason -eq "CannotRemoveSpecialUserException") { 
                                    $smsg = "ERROR: Folder permissions for ""$($u.UserName)"" CANNOT be changed!" 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                }elseif ($_.CategoryInfo.Reason -eq "ManagementObjectNotFoundException") { 
                                    $smsg = "ERROR: Folder ""$foldername"" not found, this should not happen..."
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                }elseif ($_.CategoryInfo.Reason -eq "InvalidInternalUserIdException") { 
                                    $smsg = "ERROR: ""$($u.UserName)"" is not a valid security principal for folder-level permissions..."
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                }else {
                                    $smsg = "`n$(($_ | fl *|out-string).trim())" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                                    continue
                                }  ; #catch-all for any unhandled errors
                            } ;  # if-E !quiet
                        } catch {$_ | fl * -Force; continue} ;#catch-all for any unhandled errors
                    } # if-E
                }  ; # ACE loop-E
            } ;  # FOLDERS loop-E
            $smsg = $sBnrS.replace('-v','-^').replace('v-','^-')
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H2 } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success

        }  # MBX loop-E
    } ; # PROC-E
    END{
        if ($out) {
            #$out | Export-Csv -Path "$((Get-Date).ToString('yyyy-MM-dd_HH-mm-ss'))_MailboxFolderPermissionsRemoved.csv" -NoTypeInformation -Encoding UTF8 -UseCulture ;
            #$opath = "$((Get-Date).ToString('yyyy-MM-dd_HH-mm-ss'))_MailboxFolderPermissionsRemoved.csv" ; 
            #$smsg = "Exporting results to the CSV file...`n$($opath)" ;
            #$out | Export-Csv -Path $opath -NoTypeInformation -Encoding UTF8 -UseCulture ;
            [string]$opath = $null ; 
            if($ticket){$opath += "$($TICKET)-" }
            # $opath += "$($item)_MailboxFolderPermissionsRemoved-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ; 
            if(($SMTPAddresses.Values |  measure | select -expand count ) -gt 3){
                $opath += "$($SMTPAddresses.Values[0]),xxx_MailboxFolderPermissionsRemoved-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ; 
            } else { 
                $opath += "$($SMTPAddresses.Values -join ',')_MailboxFolderPermissionsRemoved-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ; 
            } ; 
            $oPath = join-path -path (join-path -path $ScriptDir -childpath "logs") -ChildPath $opath ; 
            $smsg = "Exporting results to the CSV file...`n$($opath)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            TRY{
                $out | Export-Csv -Path $opath -NoTypeInformation -Encoding UTF8 -UseCulture ;
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
            #Write output to the console unless the -Quiet parameter is used
            #if (-not $Quiet -and -not $WhatIfPreference) { return $out | Out-Default }  ; 
            if (-not $Quiet -and -not $WhatIfPreference) { return $out  }  ; # above is returning as an array of text with no fields; output the object and aggregate it
        } else { 
            $smsg = "Output is empty, skipping the export to CSV file..." ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
            else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
        } ;
        $smsg = "Finish..." ;
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
    }
}

#*------^ Reset-xoMailboxFolderPermissionsRecursive.ps1 ^------


#*------v resolve-Name.ps1 v------
Function resolve-Name {
    <#
    .SYNOPSIS
    resolve-Name.ps1 - Port 7nlu to a verb-EXO function. Resolves a displayname into Exchange Online/Exchange Onprem mailbox/MsolUser/AzureADUser/ADUser info, and licensing status. Detect's cross-org hybrid AD objects as well. 
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-06-09
    FileName    : resolve-Name.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-EXO
    Tags        : Powershell,ExchangeOnline,Exchange,MsolUser,AzureADUser,ADUser
    REVISIONS
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 2:40 PM 12/10/2021 more cleanup 
    * 1:17 PM 6/10/2021 added missing $exMProps add lic grp memberof check for aadu, for x-hyb users; add missing $rgxLicGrp, as $rgxLicGrpDN & $rgxLicGrpDName (aduser & aaduser respectively); pulled datestamps on echo's, simplified echo's (removed "$($smsg)")
    * 4:00 PM 6/9/2021 added alias 'nlu' (7nlu is still ahk macro) ; fixed typo; expanded echo for $lic;flipped -displayname to -identifier, and handle smtpaddr|alias|displayname lookups ; init; 
    .DESCRIPTION
    resolve-Name.ps1 - Port 7nlu to a verb-EXO function. Resolves a mailbox user Identifier into Exchange Online/Exchange Onprem mailbox/MsolUser/AzureADUser info, and licensing status. Detect's cross-org hybrid AD objects as well. 
    .PARAMETER TenOrg
    Tenant Org designator (defaults to TOR)
    .PARAMETER Identifier
    User Displayname|UPN|alias to be resolved[-Identifier 'Some Username'
    .PARAMETER Ticket
    Ticket # [-Ticket nnnnn]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    .EXAMPLE
    resolve-Name -Identifier 'Some User'
    Command-line resolve displayname to summary details.
    .EXAMPLE
    resolve-Name -Identifier 'Some.User@domain.com'
    Command-line resolve email address to summary details.
    .EXAMPLE
    resolve-Name -Identifier 'alias'
    Command-line resolve mail alias value to summary details.
    .EXAMPLE
    resolve-Name
    Where no -Identifier is specified, defaults to checking clipboard for a Identifier equivelent.
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    ##Requires -Modules ActiveDirectory,AzureAD,MSOnline,verb-Auth,verb-IO,verb-Mods,verb-Text,verb-AAD,verb-ADMS,verb-Ex2010,verb-logging
    # 2:49 PM 3/8/2022 pull verb-ex2010 ref - I think it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    #Requires -Modules ActiveDirectory,AzureAD,MSOnline,verb-Auth,verb-IO,verb-Mods,verb-Text,verb-AAD,verb-ADMS,verb-logging
    [CmdletBinding()]
    [Alias('nlu')]
    PARAM(
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOR']")]
        $TenOrg = 'TOR',
        [Parameter(Position=0,Mandatory=$False,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="User Identifier to be resolved[-Identifier 'Some Username'")]        
        $Identifier,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2
    ) ;
    BEGIN {
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        
        #$propsXmbx = 'UserPrincipalName','Alias','ExchangeGuid','Database','ExternalDirectoryObjectId','RemoteRecipientType'
        #$propsOPmbx = 'UserPrincipalName','SamAccountName','RecipientType','RecipientTypeDetails' ; 
        $exMProps='samaccountname','alias','windowsemailaddress','DistinguishedName''RecipientType','RecipientTypeDetails' ;

        #$adprops = "samaccountname", "msExchRemoteRecipientType", "msExchRecipientDisplayType", "msExchRecipientTypeDetails", "userprincipalname" ;
        $adprops = "samaccountname","UserPrincipalName","memberof","msExchMailboxGuid","msexchrecipientdisplaytype","msExchRecipientTypeDetails","msExchRemoteRecipientType"
        
        [regex]$rgxDname = "^[\w'\-,.][^0-9_!?????/\\+=@#$%?&*(){}|~<>;:[\]]{2,}$"
        # below doesn't encode cleanly, mainly black diamonds - better w alt font (non-lucida console)
        #"^[a-zA-Z??????acce????ei????ln??????????uu??zz??c????????ACCEE????????ILN??????????UU??ZZ????C???? ,.'-]+$"
        [regex]$rgxEmailAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$"
        [regex]$rgxCMWDomain = $CMWMeta.rgxCMWDomain ;
        [regex]$rgxExAlias = "^[0-9a-zA-Z-._+&]{1,64}$" ;
        # used for adu.memberof
        [regex]$rgxLicGrpDN = $TorMeta.rgxLicGrpDN ;  ; 
        # used for taadu memberof
        [regex]$rgxLicGrpDName = $CMWMeta.rgxLicGrpDName ;
        #XXXX" ;  
        # cute, we've got cmw AAD grps with trailing spaces: 'XXX-XXX-E3-DL ', pull trailing $

        if(!$Identifier -AND (gcm get-clipboard) -AND (get-clipboard)){
            $Identifier = get-clipboard ;
            #$cb = get-clipboard ; 
        } elseif($Identifier){


        } else {
            write-warning "No Identifier specified, and clipboard did not match 'Identifier' content" ; 
            Break ;
        } ; 

        <#[regex]$rgxDname = "^[\w'\-,.][^0-9_!?????/\\+=@#$%?&*(){}|~<>;:[\]]{2,}$"
        # below doesn't encode cleanly, mainly black diamonds
        #"^[a-zA-Z??????acce????ei????ln??????????uu??zz??c????????ACCEE????????ILN??????????UU??ZZ????C???? ,.'-]+$"
        [regex]$rgxEmailAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$"
        #>
        $IdentifierType = $null ; 
        switch -regex ($Identifier){
            $rgxExAlias {
                write-verbose "(`$Identifier appears to be an Alias)" ;
                $IdentifierType = "Alias" ;
                #$Displayname = $Identifier.split('@')[0].replace('.',' ')
                #$nameparts = $Identifier.split('@')[0].replace('.',' ').split(' ')
                $nameparts = $Identifier.split(' ')
                break;
            } ;
            $rgxDname {
                write-verbose "(`$Identifier appears to be a DisplayName)" ;
                $IdentifierType = "DisplayName" ;
                $nameparts = $Identifier.split(' ')
                break;
            }
            $rgxEmailAddr {
                write-verbose "(`$Identifier appears to be an SmtpAddress)" ;
                $IdentifierType = "SmtpAddress" ;
                #$Displayname = $Identifier.split('@')[0].replace('.',' ')
                $nameparts = $Identifier.split('@')[0].replace('.',' ').split(' ')
                break;
            } ;
            default {
                write-warning "Unable to resolve -Identifier ($($Identifier)) into a proper DisplayName|EmailAddress|Alias string" ;
                $IdentifierType = $null ;
                break ;
            }
        } ;
        #if($Identifier -match $rgxDname){
        #        $nameparts = $Identifier.split(' ')
        switch (($nameparts|measure).count){
            "1" {
                # it's an alias
                #Identifier = vString 
                $fname = "" 
                $lname = $nameparts
            }
            "2" {
                <#/*
                RegExMatch(vString, "^\w*\s\w*$", displayname)
                RegExMatch(vString, "\w*(?=[\s])", fname)
                RegExMatch(vString, "(?<=\s)\w*$", lname)
                */
                #>
                #displayname = vString 
                $fname = $nameparts[0] ;
                $lname = $nameparts[1] ;
            }
            default{
                # assume the last 2/* are the last name ( concat no space for searches).
                #displayname = vString 
                $fname = $nameparts[0] ; 
                $lname = $nameparts[1..[int]($nameparts.getupperbound(0))] -join ' ' ;
            }
        } ;
        #} ; 
        
        $sBnr="===v Input (& splits): '$($Identifier)' | '$($fname)' | '$($lname)' v===" ;
        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr)" ;
        #-=-=configure EXO EMS aliases to cover useEXOv2 requirements-=-=-=-=-=-=
        # have to preconnect, as it gcm's the targets
        if ($script:useEXOv2) { reconnect-eXO2 -verbose:$($verbose)}
        else { reconnect-EXO -verbose:$($verbose)} ;
        # in this case, we need an alias for EXO, and non-alias for EXOP
        [array]$cmdletMaps = 'ps1GetxRcp;get-exorecipient;','ps1GetxMbx;get-exomailbox;','ps1GetxUser;get-exoUser;'
        foreach($cmdletMap in $cmdletMaps){
            if($script:useEXOv2){
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1].replace('-exo','-xo') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
            } else {
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;                
                write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
            } ;
        } ;
    
        # shifting from ps1 to a function: need updates self-name:
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;

        #$sBnr="#*======v START PASS:$($ScriptBaseName) v======" ; 
        <#$sBnr="#*======v START PASS:$(${CmdletName}) v======" ; 
        $smsg= $sBnr ;   
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green $smsg } ;
        #>
        
        
        $UseOP=$true ; 

        $useEXO = $true ; # non-dyn setting, drives variant EXO reconnect & query code
        if($useEXO){
            #*------v GENERIC EXO CREDS & SVC CONN BP v------
            # o365/EXO creds
            <### Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile* 
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
            Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
            Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
            Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            ###>
            $o365Cred=$null ;
            if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -UserRole 'CSVC','SID' -verbose:$($verbose))){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                if(get-Variable -Name cred$($tenorg) -scope Script -ea 0){remove-variable -Name cred$($tenorg) -scope Script} ; 
                New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
                $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ; 
                write-verbose $smsg  ;
            } else {
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
                write-verbose $smsg  ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                Break ;
            } ;
            <### CALLS ARE IN FORM: (cred$($tenorg))
            $pltRXO = @{Credential = $Credential ; verbose = $($verbose) ; }
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                verbose = $($verbose) ; } ; 
            if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
            else { reconnect-EXO @pltRXO } ;
            # or with Tenant-specific cred($Tenorg) lookup
            #$pltRXO creds & .username can also be used for AzureAD connections 
            Connect-AAD @pltRXO ; 
            ###>
            # configure splat for connections: (see above useage)
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                verbose = $($verbose) ; } ; 
            #
            #*------^ END GENERIC EXO CREDS & SVC CONN BP ^------
        } # if-E $useEXO

        if($UseOP){
            #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
            # do the OP creds too
            $OPCred=$null ;
            # default to the onprem svc acct
            $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC','SID'; verbose=$($verbose)} ;
            if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                if(get-Variable -Name "cred$($tenorg)OP" -scope Script -ea 0){remove-variable -Name "cred$($tenorg)OP" -scope Script} ; 
                New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ; 
                write-verbose $smsg  ;
            } else {
                $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                write-verbose $smsg  ;
                throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                Break ;
            } ;
            $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;  
            write-verbose $smsg  ; 
            <# CALLS ARE IN FORM: (cred$($tenorg))
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                verbose = $($verbose) ; }
            ReConnect-Ex2010XO @pltRX10 ; # cross-prem conns
            Reconnect-Ex2010 @pltRX10 ; # local org conns
            #$pltRx10 creds & .username can also be used for local ADMS connections
            #>
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                verbose = $($verbose) ; } ;     
            # TEST
        
            # defer cx10/rx10, until just before get-recipients qry
            #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
            # connect to ExOP X10
            if($pltRX10){
                #ReConnect-Ex2010XO @pltRX10 ;
                ReConnect-Ex2010 @pltRX10 ;
            } else { Reconnect-Ex2010 ; } ; 
        } ;  # if-E $useEXOP

        <# already confirmed in modloads
        # load ADMS
        $reqMods += "load-ADMS".split(";") ;
        if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
        #>
        write-verbose "(loading ADMS...)" ;
        # 2:12 PM 6/9/2021 load-ADMS is returning boolean, capture it
        $bRet = load-ADMS -verbose:$($verbose) ;

        if($UseOP){
            # resolve $domaincontroller dynamic, cross-org
            # setup ADMS PSDrives per tenant 
            if(!$global:ADPsDriveNames){
                $smsg = "(connecting X-Org AD PSDrives)" ;
                write-verbose $smsg  ;
                $global:ADPsDriveNames = mount-ADForestDrives -verbose:$($verbose) ;
            } ; 
            if(($global:ADPsDriveNames|measure).count){
                $useEXOforGroups = $false ; 
                $smsg = "Confirming ADMS PSDrives:`n$(($global:ADPsDriveNames.Name|%{get-psdrive -Name $_ -PSProvider ActiveDirectory} | ft -auto Name,Root,Provider|out-string).trim())" ;
                write-verbose $smsg  ;
                # returned object
                #         $ADPsDriveNames
                #         UserName                Status Name        
                #         --------                ------ ----        
                #         DOM\Samacctname   True  [forestname wo punc] 
                #         DOM\Samacctname   True  [forestname wo punc]
                #         DOM\Samacctname   True  [forestname wo punc]
        
            } else { 
                #-=-record a STATUS=-=-=-=-=-=-=
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                #-=-=-=-=-=-=-=-=
                $smsg = "Unable to detect POPULATED `$global:ADPsDriveNames!`n(should have multiple values, resolved to $()"
                write-warning $smsg  ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                Break ;
            } ; 
        } ; 
        #if (!$domaincontroller) { $domaincontroller = get-gcfast } ;
        #if(!$domaincontroller){ if(test-path function:get-gcfast){$domaincontroller=get-gcfast} else { throw "no get-gcfast()!" } ;} else {"(existing `$domaincontroller:$($domaincontroller))"} ;
        # use new get-GCFastXO cross-org dc finde
        # default to Op_ExADRoot forest from $TenOrg Meta
        $domaincontroller = get-GCFastXO -TenOrg $TenOrg -subdomain ((gv -name "$($TenOrg)Meta").value['OP_ExADRoot']) -verbose:$($verbose) |?{$_.length};


        # MSOL CONNECTION
        $reqMods += "connect-msol".split(";") ;
        if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
        write-verbose "(loading AAD...)" ;
        #connect-msol ;
        connect-msol @pltRXO ; 
        #

        # AZUREAD CONNECTION
        $reqMods += "Connect-AAD".split(";") ;
        if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
        write-verbose "(loading AAD...)" ;
        #connect-msol ;
        Connect-AAD @pltRXO ; 
        #


        #
        <# EXO connection
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            verbose = $($verbose) ; } ; 
        if($VerbosePreference = "Continue"){
            $VerbosePrefPrior = $VerbosePreference ;
            $VerbosePreference = "SilentlyContinue" ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ; 
        #disconnect-exo ;
        if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
        else { reconnect-EXO @pltRXO } ;
        # reenable VerbosePreference:Continue, if set, during mod loads 
        if($VerbosePrefPrior -eq "Continue"){
            $VerbosePreference = $VerbosePrefPrior ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        #>

        
        # 3:00 PM 9/12/2018 shift this to 1x in the script ; - this would need to be customized per tenant, not used (would normally be for forcing UPNs, but CMW uses brand UPN doms)
        

        # Clear error variable
        $Error.Clear() ;
        

    } ;  # BEGIN-E
    PROCESS {
        <#$IdentifierType = "DisplayName" ;
        $IdentifierType = "SmtpAddress" ;
        $IdentifierType = "Alias" ;
        #>
        $pltGetxUser=[ordered]@{
            ErrorAction = 'STOP' ;
        } ;
        switch -regex($IdentifierType){
            '(Alias|SmtpAddress)'{
                $pltGetxUser.add('Identity',$Identifier) ;
            }
            'DisplayName'{
                $fltr = "displayname -like '$Identifier'" ; 
                $pltGetxUser.add('filter',$fltr) ;
            }
            default {
                write-warning "Unable to resolve `$IdentifierType ($($IdentifierType)) into a recognized value" ;
                break ;
            }
        } ;

        write-verbose "$((get-alias ps1GetxUser).definition) w`n$(($pltGetxUser|out-string).trim())" ;         
        #rxo ; cmsol ; caad ; rx10 ;
        $error.clear() ;
        TRY {
            $txUser =ps1GetxUser @pltGetxUser ;
            if($msolu = get-msoluser -user $txUser.UserPrincipalName |?{$_.islicensed}){
            #if($msolu = get-msoluser -user $txUser.UserPrincipalName ){
                $tAADu = get-AzureAdUser -objectID $msolu.UserPrincipalName |?{($_.provisionedplans.service -eq 'exchange')} ;
                if($taadu.extensionproperty.onPremisesDistinguishedName -match $rgxCMWDomain){
                    $bCmwAD=$true ;
                    write-host -fo yellow "ADUser is onprem CMW hybrid!:`n$($taadu.extensionproperty.onPremisesDistinguishedName)" ; 
                } elseif($taadu.DirSyncEnabled -AND $taadu.ImmutableId) {
                    #$tadu = get-aduser -filter {UserPrincipalName -eq $txUser.UserPrincipalName }
                    # no use the converted immutableid
                    $guid=New-Object -TypeName guid (,[System.Convert]::FromBase64String($taadu.ImmutableId)) ;
                    $tadu = get-aduser -Identity $guid.guid ; 
                };
            } else { 
                write-warning "No matching licensed MSolu:(get-msoluser -user $txUser.UserPrincipalName)" ; 
            } ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            write-warning $smsg ;
        } ; 
        switch ($txUser.Recipienttype){
            'UserMailbox'{
                $error.clear() ;
                TRY {$xmbx = ps1GetxMbx -id $txUser.UserPrincipalName -ea stop }
                CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    write-warning $smsg ;
                } ; 
            }
            'MailUser'{
                $error.clear() ;
                TRY {$opmbx = get-mailbox -id $txUser.UserPrincipalName -ea stop }
                CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    write-warning $smsg ;
                } ; 
            } ;
            default {write-warning "non-mailbox/mailuser object"} 
        } ; 
        if($txUser){
            if($tadu){"=get-ADUser:>`n$(($tadu |fl samaccountn*,userpr*,msRTCSIP-PrimaryU*,msRTCSIP-L*,msRTCSIP-Usere*,tit*|out-string).trim())" 
            } else {
                write-host "=get-ADUser:>(Non-local AD user)`n=$((get-alias ps1GetxUser).definition):`n$(($txUser|fl userpr*,tit*,Offi*,Compa*|out-string).trim())" 
            } ;
            if($xmbx){"=get-Xmbx>:`n$(($xmbx| fl ($exMProps |?{$_ -notmatch '(samaccountname|DistinguishedName)'})|out-string).trim())" } ;
            if($opmbx){"=get-OPmbx>:`n$(($opmbx| fl $exMProps |out-string).trim())" };
            if($msolu){
                write-host "$(($msolu|fl @{Name='HasLic';Expression={$_.IsLicensed }},@{Name='LicIssue';Expression={$_.LicenseReconciliationNeeded }}|out-string).trim())" ; 
            "Licenses Assigned:`n$((($msolu.licenses.AccountSkuId) -join ";" | out-string).trim())" ;
                if(!($bCmwAD)){
                    if($LicGrp = $tadu.memberof -match $rgxLicGrpDN){
                        write-host "LicGrp(AD):$(($LicGrp|out-string).trim())" ; 
                    } else { 
                        write-host "LicGrp(AD):(no ADUser.memberof matched pattern:`n$($rgxLicGrpDN.tostring())" ; 
                    } ; 
                } else {
                    write-host -fo yellow  "Unable to expand ADU, user is hybrid AD from $($CMWMeta.adforestname) domain`nproxying AzureADUser memberof" ; 
                    if($taadu){
                        $mbrof = $taadu | Get-AzureADUserMembership | select DisplayName,DirSyncEnabled,MailEnabled,SecurityEnabled,Mail,objectid ;
                        if($LicGrp = $mbrof.displayname -match $rgxLicGrpDName){
                            write-host "LicGrp(AAD):$(($LicGrp|out-string).trim())" ; 
                        } else { 
                            write-host "LicGrp(AAD):(no ADUser.memberof matched pattern:`n$($rgxLicGrpDName.tostring())" ; 
                        } ; 
                    } else { 
                        write-warning "(unpopulated AzureADUser: skipping memberof)" ; 
                    }
                } ; 
            }else {
                write-warning "Unable to find matching MsolU for $Identifier" ; 
            } ; 
        } ; 
        
    } ;  # PROC-E
    END {
        # =========== wrap up Tenant connections
        <# suppress VerbosePreference:Continue, if set, during mod loads (VERY NOISEY)
        if($VerbosePreference = "Continue"){
            $VerbosePrefPrior = $VerbosePreference ;
            $VerbosePreference = "SilentlyContinue" ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        if($script:useEXOv2){
            disconnect-exo2 -verbose:$($verbose) ;
        } else {
            disconnect-exo -verbose:$($verbose) ;
        } ;
        # aad mod *does* support disconnect (msol doesen't!)
        #Disconnect-AzureAD -verbose:$($verbose) ;
        # reenable VerbosePreference:Continue, if set, during mod loads
        if($VerbosePrefPrior -eq "Continue"){
            $VerbosePreference = $VerbosePrefPrior ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        #>
        # clear the script aliases
        write-verbose "clearing ps1* aliases in Script scope" ; 
        get-alias -scope Script |Where-Object{$_.name -match '^ps1.*'} | ForEach-Object{Remove-Alias -alias $_.name} ;

        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr.replace('=v','=^').replace('v=','^='))" ;
        
        write-verbose "(explicit EXIT...)" ;
        Break ;


    } ;  # END-E
}

#*------^ resolve-Name.ps1 ^------


#*------v resolve-user.ps1 v------
function resolve-user {
    <#
    .SYNOPSIS
    resolve-user.ps1 - Resolve specified array of -users (displayname, emailaddress, samaccountname) to mail asset, lic & ticket descriptors
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-07-13
    FileName    : resolve-user.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 4:28 PM 2/27/2024 updated path-detect code (was discovering into the Mods dir);  updated CBH, quota mbx size, LegalHold example; add additional reporting/detecting to LegalHold status; fixed borked/non-dumping $prpMbxHold = ...@{n="InPlaceHolds";e={ ($_.inplaceholds (*KEY* indicator of a hold in place); updated prompts to echo DiscoveryHolds folder & it's newestItem (both indicate LHs, and if not curr, when it was disabled)
    * 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
    * 12:22 PM 9/26/2023 nesting limit loop, pulled vxo & vx2010  reqs
    * 3:59 PM 9/25/2023 working, ready to drop back into vxo finished in-port of get-xoMailboxQuotaStatus support, now functional, also expanded the mbxstat filter to cover room|shared|Equip recipienttypedetails variants; 
        appears I spliced over $getQuotaUsage support from get-xoMailboxQuotaStatus, looks like it needs to be debugged.
    * 12:43 PM 9/18/2023 re-removed the obsolete xow support: EOM31+ doesn't need it.
    * 3:47 PM 12/14/2022 spliced in xow support. Works on initial pass.
    # 3:57 PM 6/29/2022 fundemental retool for exov2 requirements; pulled all 
        aliasing (wasn't functional for exov2, didn't want to rewrite, and with hard 
        mfa req, exov2 is only way forward, there'll never be verb-EXOnoun use again, 
        due to MS fundemental seizure of the prefix for their 13 'special' cmdlets. 
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 3:55 PM 2/22/2022 extended the cloud federate test code, to include an INT block (though there's no hybrid to arbitrate, the users are onprem in AD at INT)
    * 12:24 PM 2/1/2022 updated CBH, added a crlf on the console echo (headers weren't lining up); added -getMobile & get-exoMobileDeviceStats support, with conditional md output block; added full aliased xo cmds, implementing full -exov2 support.
    * 2:51 PM 12/27/2021 flipped DN & Desc from md tbl to fl (drops a crlf) ; 
         flipped $propsMailx output to md fmt split lines (condensed output vertically) ; 
         added forward props to propsMailx, and test & echo to tag forwarded mbxs; wrapped $prop* vari's for legibility
    * 11:02 AM 12/13/2021 #11111:had $hsum IsADDisabled, typo: to IsAADDisabled
    * 2:40 PM 12/10/2021 more cleanup ; added $hsum.isDirSynced, for further bulk filter/profiling
        flipped $hsum.isUnlicensed -> Islicensed & added msol.Islicensed test to pop ; 
        appears to work in console - output a stack of filterable objects into collection variable.
        further tweaking and nobrain t-shooting outputs ; added 
        output switches: 
        isNoBrain,isSplitBrain,isUnlicensed,IsDisabledOU,IsADDisabled,IsAADDisabled for 
        postfiltering large collections in bulk, to identify patterns ; reformulated 
        nobrain detec, to have an unlic'd block as well as a licensed - with deadwood 
        offboard nobrains, they'll never have a lic. 
    * 4:19 PM 12/9/2021 improved pipeline support; fixed pipeline param mbinding fails ; added supoort for resolving
        baddomain users or op.mailusers where need to resolve aadu.immutableid to
        aduser, to *ensure* we have a hardmatch of problem objects (resolving baddomain
        DDG-DL-AllDOMAIN recipients to internal NoBrain etc. Still doesn't seem to be
        setting $hsum.NoBrain properly in outputs, but is dropping direct to pipe. May
        have borked single-indiceent xml object dumps tho.
    * 10:30 AM 11/8/2021 fixed CBH/HelpMessage tagging on -outobject
    * 3:30 PM 10/12/2021 added new Name:ObjName_guid support (new hires turn up with aduser named this way); added some marginal multi xoRcp & xoMailbox handling (loops outputs on the above, and the mapiTest), but doesn't do full AzureAD,Msoluser,MailUser,Guest lookups for these. It's really about error-suppression, and notifying the issue more than returning the full picture
    * 1:04 PM 9/28/2021 added:$AADUserManager lookup and dump of UPN, OpDN & mail (for correlating what email pol a user should have -> the one their manager does)
    * 1:52 PM 9/17/2021 moved $props to top ; test enabled/acctenabled, licRecon & mapi test results and use ww on issues ; flipped caad's to -silent (match cmsol 1st echo's to confirm tenant, rest silent); ren $xMProps -> $propsMailx, $XMFedProps-> $propsXMFed, $lProps -> $propsLic,$adprops -> $propsADU, $aaduprops -> $propsAADU, $aaduFedProps -> $propsAADUfed, $RcpPropsTbl -> $propsRcpTbl, $pltgM-> $pltGMailObj, $pltgMU -> $pltgMsoUsr
    * 4:33 PM 9/16/2021 fixed typo in get-AzureAdUser call, reworked output (aadu into markdown delimited wide layout), moved user detaiil reporting to below aadu, and output the federated AD remote DN, (proxied through AADU ext prop)
    * 10:56 AM 9/9/2021 force-resolve xoMailbox, added AADUser pop to the msoluser pop block; added test-xxMapiConnectivity as well; expanded ADU outputs - description, when*, Enabled, to look for terms/recent-hires/disabled accts
    * 3:05 PM 9/3/2021 fixed bugs introduced trying to user MaxResults (msol|aad), which come back param not recog'd when actually used - had to implement as postfiltering to assert open set return limits. ; Also implemented $xxxMeta.rgxOPFederatedDom check to resolve obj primarysmtpaddress to federating AD or AAD.
    * 11:20 AM 8/30/2021 added $MaxResults (shutdown return-all recips in addr space, on failure to match oprcp or xorcp ; fixed a couple of typos; minior testing/logic improvements. Still needs genercized 7pswlt support.
    * 1:30 PM 8/27/2021 new sniggle: CMW user that has EXOP mbx, remote: Added xoMailUser support, failed through DName lookups to try '*lname*' for near-missies. Could add trailing 'lnamne[0-=3]* searches, if not rcp/xrcps found...
    * 9:16 AM 8/18/2021 $xMProps: add email-drivers: CustomAttribute5, EmailAddressPolicyEnabled
    * 12:40 PM 8/17/2021 added -outObject, outputs a full descriptive object for each resolved recipient ; added a $hSum hash and shifted all the varis into mountpoints in the hash, with -outObject, the entire hash is conv'd to an obj and appended to $Rpt ; renamed most of the varis/as objects very clearly for what they are, as sub-props of the output objects. Wo -outobject, the usual comma-delim'd string of addresses is output.
    * 3:26 PM 7/29/2021 had sorta bug (AD context was xxxx:, gadu failing throwing undefined error), but debugging added extensive verbose echos, and an AD-specific try/catch to trap AD notfound errors (notorious, they throw terminating fails, unlike other modules; which crashes out processing even when using -EA continue). So it hardens up the fail recovery process.
    * 12:55 PM 7/19/2021 added guest & exo-mailcontact support (resolving missing ext-federated addresses), retolled logic down to grcp & gxrcp to drive balance of tests.
    * 12:05 PM 7/14/2021 rem'd requires: verb-exo  rem'd requires version 5 (gen'ing 'version' is specified more than once.); rem'd the $rgxSamAcctName, gen's parsing errors compiling into mod ;  added alias 'ulu'; added mailcontact excl on init grcp, to force those to exombx qry ; init vers
    .DESCRIPTION
    resolve-user.ps1 - Resolve specified array of -users (displayname, emailaddress, samaccountname) to mail asset, lic & ticket descriptors

    Key parameter options: 

    -getMobile parameter, to return details on xo MobileDevices in use with the EXO mailbox

    -getQuotaUsage parameter, returns details on xo MailboxFolderStatistics and effective Quota, 
        used with users with mailbox size issues (and/or LegalHold symptoms)

        Note: use of -getQuotaUsage also does an extensive check for LegalHold signs in the mailbox. including reporting on:
            - xoMailbox.LitigationHoldEnabled
            - xoMailbox.InPlaceHolds, 
            - xoMailbox.ComplianceTagHoldApplied
            - xoMailbox.DelayHoldApplied 
            - xoMailbox.DelayReleaseHoldApplied 
            - checks if xoMailboxFolderStats 'DiscoveryHolds' folder has ItemsInFolder -gt 0


    .PARAMETER  users
    Array of user descriptors: displayname, emailaddress, UPN, samaccountname (checks clipboard where unspecified)
    .PARAMETER Ticket
    Ticket number[-ticket 123456]
    .PARAMETER getMobile
    switch to return mobiledevice info for target XO Mailbox (not supported for onprem mailboxes)[-getMobile]
    .PARAMETER getQuotaUsage
    switch to return Quota & MailboxFolderStatistics & LegalHold analysis (XO-only)[-getQuotaUsage]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER outObject
    switch to return a system.object summary to the pipeline[-outObject]
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    System.Object - returns summary report to pipeline
    .EXAMPLE
    PS> resolve-user 
    Default, no user identifier specified: attempts to parse a user descriptor from clipboard contents
    .EXAMPLE
    PS> resolve-user -users 'John Public'
    Process user displayname
    .EXAMPLE
    PS> resolve-user -users 'Test@domain.com','User Name','Alias','ExternalContact@emaildomain.com','confroom@tenant.onmicrosoft.com' -verbose ;
    Process an array of descriptors
    .EXAMPLE
    PS> $results = resolve-user -outobject -users 'Test@domain.com','John Public','Alias','ExternalContact@emaildomain.com','confroom@tenant.onmicrosoft.com''  ;
    PS> $feds = $results| group federator | select -expand name ;
    PS> write-verbose "echo filtered subsets" ;
    PS> ($results| ?{$_.federator -eq $feds[1] }).xomailbox
    PS> ($results| ?{$_.federator -eq $feds[1] }).xomailbox.primarysmtpaddress
    PS> write-verbose "profile results:" ; 
    PS> $analysis = foreach ($data in $resolved_objects){
    PS>     $Rpt = [ordered]@{
    PS>         PrimarySmtpAddress = $data.xorcp.primarysmtpaddress ; 
    PS>         ADUser_UPN = $data.aduser.userprincipalname ; 
    PS>         AADUser_UPN = $data.aaduser.UserPrincipalName ; 
    PS>         isDirSynced = $data.isDirSynced ; 
    PS>         IsNoBrain = $data.IsNoBrain ; 
    PS>         isSplitBrain = $data.isSplitBrain;
    PS>         IsLicensed = $data.IsLicensed;
    PS>         IsDisabledOU = $data.IsDisabledOU;
    PS>         IsADDisabled = $data.IsADDisabled; 
    PS>         IsAADDisabled = $data.IsAADDisabled;
    PS>     } ; 
    PS>     [pscustomobject]$Rpt ; 
    PS> } ; 
    PS> write-verbose "output tabular results" ; 
    PS> $analysis | ft -auto ;
    
    Demo does the following: 
        - Process array of users, specify return detailed object (-outobject), for post-processing & filtering,
        - Group results on federation sources,
        - Output summary of EXO mailboxes for the second federator
        - Then output the primary smtpaddress for all EXO mailboxes resolved to that federator
        - Then create a summary object of the is* properties and UPN, primarySmtpAddress, 
        - Finally display the summary as a console table
    .EXAMPLE
    PS> $rptNNNNNN_FName_LName_Domain_com = ulu -o -users 'FName.LName@Domain.com' ;  $rpt655692_FName_LName_Domain_com | xxml .\logs\rpt655692_FName_LName_Domain_com.xml
    Example (from ahk 7uluo! macro parser output) that creates a variable based on ticketnumber & email address (with underscores for alphanums), from the output, and then exports the variable content to xml. 
    Assigns to an immediately parsable inmem variable, along with the canned .xml that can be reloaded in future, or attached to a ticket.
    .EXAMPLE
    PS> resolve-user -users 'John Public' -getmobile
    Example that includes the -getMobile parameter, to return details on xo MobileDevices in use with the EXO mailbox
    .EXAMPLE
    PS> $999999Rpt = resolve-user fname.lname@toro.com -Ticket 99999 -getQuotaUsage -outObject ; 

        10:39:53:===v (1/1):Input: 'FNAME.LNAME@toro.com' | 'FNAME' | 'LNAME' v===(EML)
        get-Rmbx/xMbx: (Rmbx)(TOR USER, fed:ad.toro.com)
        SamAccountName | WindowsEmailAddress
        LNAMEFI         | FNAME.LNAME@toro.com
        Office | RecipientTypeDetails | RemoteRecipientType | IsDirSynced
                | RemoteUserMailbox    | Migrated            |
        ExternalDirectoryObjectId | CustomAttribute5 | EmailAddressPolicyEnabled
                                    |                  | True
        Outlook (xoMAPI) Access Test Result:Success
        xoMailboxStats Count:1
        10:39:56: INFO:  (-getQuotaUsage:running lengthy Get-xoMailboxFolderStatistics...)
        =get-AADuser FNAME.LNAME@toro.com>:
        =get-AADuserManager FNAME.LNAME@toro.com>:
        ===$hSum.ADUser: 
        UPN                 | DName      | FName | LName | Title                             
        FNAME.LNAME@toro.com | FNAME LNAME | FNAME | LNAME  | Supervisor II, Distribution Center
        Company | Dept                            | Ofc          
                | Operations Distribution El Paso | El Paso-D, TX
        Street | City | State | Zip | Phone           | Mobile
                |      |       |     | +1 915 231 7404 |
        Enabled | DN                                                          
        True    | CN=FNAME LNAME,OU=Users,OU=ELP,DC=global,DC=ad,DC=toro,DC=com
        whenCreated          | whenChanged         
        8/18/2017 4:13:54 PM | 2/23/2024 8:23:33 AM
        Desc : 8/21/17 FT for FNAME LNAME 146294 -bk
        LicenseGroup:(direct-assigned E3)
        ===$hSum.AADUserMgr: 
        UserPrincipalName       | Mail                   
        FNAME.LNAME@toro.com | FNAME.LNAME@toro.com
        OpOU : OU=Users,OU=ELP,DC=global,DC=ad,DC=toro,DC=com
        10:40:06: PROMPT:  UserPrincipalName       | Mail                   
        FNAME.LNAME@toro.com | FNAME.LNAME@toro.com
        OpOU : OU=Users,OU=ELP,DC=global,DC=ad,DC=toro,DC=com

        Licenses::
        MCOEV, FLOW_FREE, MCOPSTNC, ENTERPRISEPACK, POWER_BI_STANDARD, EMS, Microsoft_Teams_Audio_Conferencing_select_dial_out

        which specify the following size limits:
        IssueWarningQuotaMB        : 14336
        ProhibitSendQuotaMB        : 15360
        ProhibitSendReceiveQuotaMB : 17408
        (UseDatabaseQuotaDefaults:False)

        Current TotalMailboxSizeMB: 10912.2

        10:40:06: PROMPT:  QuotaStatus: Mailbox is below mandated SendReceiveQuotaMB by 4,447.80 megabytes
        10:40:06: PROMPT:  
        With the following non-zero folder metrics

        Folder                                                               Items SizeMB  OldestItem NewestItem          FolderType               
        ------                                                               ----- ------  ---------- ----------          ----------               
        annnnnnn-nbne-nnnn-anne-necncannbnnn\Inbox                           23774 5764.38 20230111   02/27/2024 16:37:25 Inbox                    
        annnnnnn-nbne-nnnn-anne-necncannbnnn\Deleted Items                   12434 4599.58 20220323   02/27/2024 16:35:34 DeletedItems             
        ...
        annnnnnn-nbne-nnnn-anne-necncannbnnn\Top of Information Store        1     0                                      Root
        10:40:06: INFO:  
        ===output to::
        D:\scripts\logs\823795-FNAME.LNAME@toro.com-folder-sizes-NONHIDDEN-NONZERO-run20240227-1039AM.xml

        10:40:09: WARNING:  
        10:40:09: WARNING:  
        10:40:09: WARNING:  EVIDENCE OF LEGAL HOLD DETECTED!:
        10:40:09: WARNING:  LitigationHoldEnabled    : False
        10:40:09: WARNING:  
        10:40:09: WARNING:  InPlaceHolds             : UniHnbnednbn-bndn-nnnf-nddn-annndnndnnae, UniHnnnneene-ndnd-naae-annn-nnnnnnnnnncn
        10:40:09: WARNING:  
        10:40:09: WARNING:  ComplianceTagHoldApplied : False
        10:40:09: WARNING:  
        10:40:09: WARNING:  DelayHoldApplied         : False
        10:40:09: WARNING:  
        10:40:09: WARNING:  DelayReleaseHoldApplied  : False
        10:40:09: WARNING:  
        10:40:09: WARNING:  
        10:40:09: WARNING:  Folder          Items    SizeMB OldestItem NewestItem          FolderType                    
        10:40:09: WARNING:  
        10:40:09: WARNING:  ------          -----    ------ ---------- ----------          ----------                    
        10:40:09: WARNING:  
        10:40:09: WARNING:  DiscoveryHolds 267225 101967.69            02/21/2024 08:42:57 RecoverableItemsDiscoveryHolds
        10:40:09: WARNING:  
        10:40:09: WARNING:  
        10:40:09: WARNING:  - DiscoveryHolds folder: If In-Place Hold is enabled or if a Microsoft 365 or Office 365 retention policy is assigned to the mailbox, this subfolder contains all items that meet the hold query parameters and are hard deleted.
        10:40:09: WARNING:  - DiscoveryHolds folder.NewestItem: Will reflect *last time LegalHold captured an item* (e.g. if/when LH was disabled and stopped holding traffic, if in the past)
        10:40:09: WARNING:  
    
    Example that includes the -getQuotaUsage parameter, to return details on xo MailboxFolderStatistics and effective Quota, around users with mailbox size issues, and assigns the returned summary to the variable `$999999Rpt
    Note: use of -getQuotaUsage also does an extensive check for LegalHold signs in the mailbox. including reporting on:
        - xoMailbox.LitigationHoldEnabled
        - xoMailbox.InPlaceHolds, 
        - xoMailbox.ComplianceTagHoldApplied
        - xoMailbox.DelayHoldApplied 
        - xoMailbox.DelayReleaseHoldApplied 
        - checks if xoMailboxFolderStats 'DiscoveryHolds' folder has ItemsInFolder -gt 0
    .LINK
    https://github.com/tostka/verb-exo
    #>

    # 2:49 PM 3/8/2022 pull verb-ex2010 ref - I think it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    # 12:19 PM 9/26/2023 pull verb-exo ref "
    #Requires -Modules ActiveDirectory, MSOnline, AzureAD, ExchangeOnlineManagement, verb-AAD, verb-ADMS, verb-Auth, verb-IO, verb-logging
    #Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("(lyn|bcc|spb|adl)ms6(4|5)(0|1).(china|global)\.ad\.DOMAIN\.com")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    [Alias('ulu')]
    PARAM(
        #[Parameter(Position=0,Mandatory=$False,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Array of user descriptors: displayname, emailaddress, UPN, samaccountname (checks clipboard where unspecified)")]
        # failing to map pipeline to $users, reduce to Value from Pipeline
        [Parameter(Position=0,Mandatory=$False,ValueFromPipeline=$true,HelpMessage="Array of user descriptors: displayname, emailaddress, UPN, samaccountname (checks clipboard where unspecified)")]
            #[ValidateNotNullOrEmpty()]
            #[Alias('ALIAS1', 'ALIAS2')]
            [array]$users,
        [Parameter(Mandatory=$False,HelpMessage="Ticket Number [-Ticket '999999']")]
            [string]$Ticket,
        [Parameter(HelpMessage="switch to return mobiledevice info for target user[-getMobile]")]
            [switch] $getMobile,
        [Parameter(HelpMessage="switch to return Quota & MailboxFolderStatistics & LegalHold analysis (XO-only)[-getQuotaUsage]")]
            [switch]$getQuotaUsage,
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
        [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ;
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ;
                return $true ;
            })]
            [string[]]$UserRole = @('SID','CSVC'),
            # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
            [switch] $useEXOv2=$true,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent,
        [Parameter(HelpMessage="switch to return a system.object summary to the pipeline[-outObject]")]
            [switch] $outObject
    ) ;
    BEGIN{
        #region CONSTANTS_AND_ENVIRO #*======v CONSTANTS_AND_ENVIRO v======
        # Debugger:proxy automatic variables that aren't directly accessible when debugging (must be assigned and read back from another vari) ; 
        $rPSCmdlet = $PSCmdlet ; 
        $rPSScriptRoot = $PSScriptRoot ; 
        $rPSCommandPath = $PSCommandPath ; 
        $rMyInvocation = $MyInvocation ; 
        $rPSBoundParameters = $PSBoundParameters ; 
        [array]$score = @() ; 
        if($rPSCmdlet.MyInvocation.InvocationName){
            if($rPSCmdlet.MyInvocation.InvocationName -match '\.ps1$'){
                $score+= 'ExternalScript' 
            }elseif($rPSCmdlet.MyInvocation.InvocationName  -match '^\.'){
                write-warning "dot-sourced invocation detected!:$($rPSCmdlet.MyInvocation.InvocationName)`n(will be unable to leverage script path etc from MyInvocation objects)" ; 
                # dot sourcing is implicit scripot exec
                $score+= 'ExternalScript' ; 
            } else {$score+= 'Function' };
        } ; 
        if($rPSCmdlet.CommandRuntime){
            if($rPSCmdlet.CommandRuntime.tostring() -match '\.ps1$'){$score+= 'ExternalScript' } else {$score+= 'Function' }
        } ; 
        $score+= $rMyInvocation.MyCommand.commandtype.tostring() ; 
        $grpSrc = $score | group-object -NoElement | sort count ;
        if( ($grpSrc |  measure | select -expand count) -gt 1){
            write-warning  "$score mixed results:$(($grpSrc| ft -a count,name | out-string).trim())" ;
            if($grpSrc[-1].count -eq $grpSrc[-2].count){
                write-warning "Deadlocked non-majority results!" ;
            } else {
                $runSource = $grpSrc | select -last 1 | select -expand name ;
            } ;
        } else {
            write-verbose "consistent results" ;
            $runSource = $grpSrc | select -last 1 | select -expand name ;
        };
        write-host "Calculated `$runSource:$($runSource)" ;
        'score','grpSrc' | get-variable | remove-variable ; # cleanup temp varis

        # function self-name (equiv to script's: $MyInvocation.MyCommand.Path) ;
        ${CmdletName} = $rPSCmdlet.MyInvocation.MyCommand.Name ;
        $PSParameters = New-Object -TypeName PSObject -Property $rPSBoundParameters ;
        write-verbose "`$rPSBoundParameters:`n$(($rPSBoundParameters|out-string).trim())" ;
        $Verbose = ($VerbosePreference -eq 'Continue') ; 
        # pre psv2, no $rPSBoundParameters autovari to check, so back them out:
        if($rPSCmdlet.MyInvocation.InvocationName){
            if($rPSCmdlet.MyInvocation.InvocationName  -match '^\.'){
                $smsg = "detected dot-sourced invocation: Skipping `$PSCmdlet.MyInvocation.InvocationName-tied cmds..." ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            } else { 
                write-verbose 'Collect all non-default Params (works back to psv2 w CmdletBinding)'
                $ParamsNonDefault = (Get-Command $rPSCmdlet.MyInvocation.InvocationName).parameters | Select-Object -expand keys | Where-Object{$_ -notmatch '(Verbose|Debug|ErrorAction|WarningAction|ErrorVariable|WarningVariable|OutVariable|OutBuffer)'} ;
            } ; 
        } else { 
            $smsg = "(blank `$rPSCmdlet.MyInvocation.InvocationName, skipping Parameters collection)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; 
        #region ENVIRO_DISCOVER ; #*------v ENVIRO_DISCOVER v------
        <#
        # Debugger:proxy automatic variables that aren't directly accessible when debugging ; 
        $rPSScriptRoot = $PSScriptRoot ; 
        $rPSCommandPath = $PSCommandPath ; 
        $rMyInvocation = $MyInvocation ; 
        $rPSBoundParameters = $PSBoundParameters ; 
        #>
        $ScriptDir = $scriptName = '' ;     
        if($ScriptDir -eq '' -AND ( (get-variable -name rPSScriptRoot -ea 0) -AND (get-variable -name rPSScriptRoot).value.length)){
            $ScriptDir = $rPSScriptRoot
        } ; # populated rPSScriptRoot
        if( (get-variable -name rPSCommandPath -ea 0) -AND (get-variable -name rPSCommandPath).value.length){
            $ScriptName = $rPSCommandPath
        } ; # populated rPSCommandPath
        if($ScriptDir -eq '' -AND $runSource -eq 'ExternalScript'){$ScriptDir = (Split-Path -Path $rMyInvocation.MyCommand.Source -Parent)} # Running from File
        # when $runSource:'Function', $rMyInvocation.MyCommand.Source is empty,but on functions also tends to pre-hit from the rPSCommandPath entFile.FullPath ;
        if( $scriptname -match '\.psm1$' -AND $runSource -eq 'Function'){
            write-host "MODULE-HOMED FUNCTION:Use `$CmdletName to reference the running function name for transcripts etc (under a .psm1 `$ScriptName will reflect the .psm1 file  fullname)"
            if(-not $CmdletName){write-warning "MODULE-HOMED FUNCTION with BLANK `$CmdletNam:$($CmdletNam)" } ;
        } # Running from .psm1 module
        if($ScriptDir -eq '' -AND (Test-Path variable:psEditor)) {
            write-verbose "Running from VSCode|VS" ; 
            $ScriptDir = (Split-Path -Path $psEditor.GetEditorContext().CurrentFile.Path -Parent) ; 
                if($ScriptName -eq ''){$ScriptName = $psEditor.GetEditorContext().CurrentFile.Path }; 
        } ;
        if ($ScriptDir -eq '' -AND $host.version.major -lt 3 -AND $rMyInvocation.MyCommand.Path.length -gt 0){
            $ScriptDir = $rMyInvocation.MyCommand.Path ; 
            write-verbose "(backrev emulating `$rPSScriptRoot, `$rPSCommandPath)"
            $ScriptName = split-path $rMyInvocation.MyCommand.Path -leaf ;
            $rPSScriptRoot = Split-Path $ScriptName -Parent ;
            $rPSCommandPath = $ScriptName ;
        } ;
        if ($ScriptDir -eq '' -AND $rMyInvocation.MyCommand.Path.length){
            if($ScriptName -eq ''){$ScriptName = $rMyInvocation.MyCommand.Path} ;
            $ScriptDir = $rPSScriptRoot = Split-Path $rMyInvocation.MyCommand.Path -Parent ;
        }
        if ($ScriptDir -eq ''){throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$rMyInvocation IS BLANK!" } ;
        if($ScriptName){
            if(-not $ScriptDir ){$ScriptDir = Split-Path -Parent $ScriptName} ; 
            $ScriptBaseName = split-path -leaf $ScriptName ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($ScriptName) ;
        } ; 
        # blank $cmdlet name comming through, patch it for Scripts:
        if(-not $CmdletName -AND $ScriptBaseName){
            $CmdletName = $ScriptBaseName
        }
        # last ditch patch the values in if you've got a $ScriptName
        if($rPSScriptRoot.Length -ne 0){}else{ 
            if($ScriptName){$rPSScriptRoot = Split-Path $ScriptName -Parent }
            else{ throw "Unpopulated, `$rPSScriptRoot, and no populated `$ScriptName from which to emulate the value!" } ; 
        } ; 
        if($rPSCommandPath.Length -ne 0){}else{ 
            if($ScriptName){$rPSCommandPath = $ScriptName }
            else{ throw "Unpopulated, `$rPSCommandPath, and no populated `$ScriptName from which to emulate the value!" } ; 
        } ; 
        if(-not ($ScriptDir -AND $ScriptBaseName -AND $ScriptNameNoExt  -AND $rPSScriptRoot  -AND $rPSCommandPath )){ 
            throw "Invalid Invocation. Blank `$ScriptDir/`$ScriptBaseName/`ScriptNameNoExt" ; 
            BREAK ; 
        } ; 
        # echo results dyn aligned:
        $tv = 'runSource','CmdletName','ScriptName','ScriptBaseName','ScriptNameNoExt','ScriptDir','PSScriptRoot','PSCommandPath','rPSScriptRoot','rPSCommandPath' ; 
        $tvmx = ($tv| Measure-Object -Maximum -Property Length).Maximum * -1 ; 
        $tv | get-variable | %{  write-verbose ("`${0,$tvmx} : {1}" -f $_.name,$_.value) } ; 
        'tv','tvmx'|get-variable | remove-variable ; # cleanup temp varis
        
        #endregion ENVIRO_DISCOVER ; #*------^ END ENVIRO_DISCOVER ^------

        if(-not $DoRetries){$DoRetries = 4 } ;    # # times to repeat retry attempts
        if(-not $RetrySleep){$RetrySleep = 10 } ; # wait time between retries
        if(-not $RetrySleep){$DawdleWait = 30 } ; # wait time (secs) between dawdle checks
        if(-not $DirSyncInterval){$DirSyncInterval = 30 } ; # AADConnect dirsync interval
        if(-not $ThrottleMs){$ThrottleMs = 50 ;}
        if(-not $rgxDriveBanChars){$rgxDriveBanChars = '[;~/\\\.:]' ; } ; # ;~/\.:,
        if(-not $rgxCertThumbprint){$rgxCertThumbprint = '[0-9a-fA-F]{40}' } ; # if it's a 40char hex string -> cert thumbprint  
        if(-not $rgxSmtpAddr){$rgxSmtpAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ; } ; # email addr/UPN
        if(-not $rgxDomainLogon){$rgxDomainLogon = '^[a-zA-Z][a-zA-Z0-9\-\.]{0,61}[a-zA-Z]\\\w[\w\.\- ]+$' } ; # DOMAIN\samaccountname 
        if(-not $exoMbxGraceDays){$exoMbxGraceDays = 30} ; 

        $rgxEmailAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ;
        # added support for . fname lname delimiter (supports pasted in dirname of email addresses, as user)
        $rgxDName = "^([a-zA-Z]{2,}(\s|\.)[a-zA-Z]{1,}'?-?[a-zA-Z]{2,}\s?([a-zA-Z]{1,})?)" ;
        #"^([a-zA-Z]{2,}\s[a-zA-Z]{1,}'?-?[a-zA-Z]{2,}\s?([a-zA-Z]{1,})?)" ;
        $rgxObjNameNewHires = "^([a-zA-Z]{2,}(\s|\.)[a-zA-Z]{1,}'?-?[a-zA-Z]{2,}\s?([a-zA-Z]{1,})?)_[a-z0-9]{10}"  # Name:Fname LName_f4feebafdb (appending uniqueness guid chunk)
        $rgxSamAcctNameTOR = "^\w{2,20}$" ; # up to 20k, the limit prior to win2k
        #$rgxSamAcctName = "^[^\/\\\[\]:;|=,+?<>@?]+$" # no char limit ;
        $MaxRecips = 25 ; # max number of objects to permit on a return resultsize/,ResultSetSize, to prevent empty set return of everything in the addressspace

        # props dyn filtering: write-host "=get-xMbx:>`n$(($hSum.xoMailbox |fl ($xMprops |?{$_ -notmatch '(sam.*|dist.*)'})|out-string).trim())`n-Title:$($hSum.xoUser.Title)";
        # $propsMailx: add email-drivers: CustomAttribute5, EmailAddressPolicyEnabled
        # 11:01 AM 12/27/2021 add forwarding settings (critical to bounce/block tracking for RM)
        #$propsMailx='samaccountname','windowsemailaddress','DistinguishedName','Office','RecipientTypeDetails','RemoteRecipientType','IsDirSynced','ExternalDirectoryObjectId','CustomAttribute5','EmailAddressPolicyEnabled' ;
        $propsMailx='samaccountname','windowsemailaddress','DistinguishedName','Office','RecipientTypeDetails','RemoteRecipientType',
            'IsDirSynced','ExternalDirectoryObjectId','CustomAttribute5','EmailAddressPolicyEnabled',
            'DeliverToMailboxAndForward','DeliverToMailboxAndForward','ForwardingSmtpAddress' ;
        # pulls: 'ImmutableId',
        # 1:41 PM 12/27/2021 add multiline md tbl output
        $propsMailxL1 = 'SamAccountName','WindowsEmailAddress' ; 
        $propsMailxL2 = 'Office','RecipientTypeDetails','RemoteRecipientType', 'IsDirSynced' ;
        $propsMailxL3 = 'ExternalDirectoryObjectId','CustomAttribute5','EmailAddressPolicyEnabled' ; 
        $propsMailxL4 = 'DistinguishedName' ; 
        $propsMailxL5 = 'ForwardingAddress','ForwardingSmtpAddress','DeliverToMailboxAndForward' ;        
        $propsXMFed = 'samaccountname','windowsemailaddress','DistinguishedName','Office','RecipientTypeDetails','RemoteRecipientType',
            'ImmutableId','ExternalDirectoryObjectId','CustomAttribute5','EmailAddressPolicyEnabled' ;
        $propsLic = @{Name='HasLic'; Expression={$_.IsLicensed }},@{Name='LicIssue'; Expression={$_.LicenseReconciliationNeeded }} ;
        $propsADU = 'UserPrincipalName','DisplayName','GivenName','Surname','Title','Company','Department','PhysicalDeliveryOfficeName',
            'StreetAddress','City','State','PostalCode','TelephoneNumber','MobilePhone','Enabled','DistinguishedName',
            'Description','whenCreated','whenChanged'
        #'samaccountname','UserPrincipalName','distinguishedname','Description','title','whenCreated','whenChanged','Enabled','sAMAccountType','userAccountControl' ;
        $propsADUsht = 'Enabled','Description','whenCreated','whenChanged','Title' ;
        $propsAADU = 'UserPrincipalName','DisplayName','GivenName','Surname','Title','Company','Department','PhysicalDeliveryOfficeName',
            'StreetAddress','City','State','PostalCode','TelephoneNumber','MobilePhone','Enabled','DistinguishedName' ;
        #'UserPrincipalName','name','ImmutableId','DirSyncEnabled','LastDirSyncTime','AccountEnabled' ;

        $propsAADUfed = 'UserPrincipalName','name','ImmutableId','DirSyncEnabled','LastDirSyncTime' ;
        $propsRcpTbl = 'Alias','PrimarySmtpAddress','RecipientType','RecipientTypeDetails' ;
        # line1-X AADU outputs
            #$propsMailx='samaccountname','windowsemailaddress','DistinguishedName','Office','RecipientTypeDetails','RemoteRecipientType','IsDirSynced','ImmutableId','ExternalDirectoryObjectId','CustomAttribute5','EmailAddressPolicyEnabled' ;
        <# full size
        $propsADL1 = 'UserPrincipalName','DisplayName','GivenName','Surname','Title' ;
        $propsADL2 = 'Company','Department','PhysicalDeliveryOfficeName' ;
        $propsADL3 = 'StreetAddress','City','State','PostalCode','TelephoneNumber','MobilePhone' ;
        # non-ADU props
        #$propsADL4 = 'DirSyncEnabled','ImmutableId','LastDirSyncTime','UsageLocation' ;
        #$propsADL5 = 'ObjectType','UserType' ;
        #>
        # abbreviated:
        $propsADL1 = @{Name='UPN';Expression={$_.UserPrincipalName }}, @{Name='DName';Expression={$_.DisplayName }}, 
            @{Name='FName';Expression={$_.GivenName }},@{Name='LName';Expression={$_.Surname }},
            @{Name='Title';Expression={$_.Title }};
        $propsADL2 = @{Name='Company';Expression={$_.Company }},@{Name='Dept';Expression={$_.Department }},
            @{Name='Ofc';Expression={$_.PhysicalDeliveryOfficeName }} ;
        $propsADL3 = @{Name='Street';Expression={$_.StreetAddress }}, 'City','State',
            @{Name='Zip';Expression={$_.PostalCode }}, @{Name='Phone';Expression={$_.TelephoneNumber }}, 
            @{Name='Mobile';Expression={$_.MobilePhone }} ;
        $propsADL4 = 'Enabled',@{Name='DN';Expression={$_.DistinguishedName }} ;
        #$propsADL4 = @{Name='Dsync';Expression={$_.DirSyncEnabled }}, @{Name='ImutID';Expression={$_.ImmutableId }}, @{Name='LastDSync';Expression={$_.LastDirSyncTime }}, @{Name='UseLoc';Expression={$_.UsageLocation }};
        #$propsADL5 = 'ObjectType','UserType' ;
        $propsADL5 = 'whenCreated','whenChanged' ; 
        $propsADL6 = @{Name='Desc';Expression={$_.Description }} ;

        # line1-5 AADU outputs
        <# full size
        $propsAADL1 = 'UserPrincipalName','DisplayName','GivenName','Surname','JobTitle' ;
        $propsAADL2 = 'CompanyName','Department','PhysicalDeliveryOfficeName' ;
        $propsAADL3 = 'StreetAddress','City','State','PostalCode','TelephoneNumber','Mobile' ;
        $propsAADL4 = 'DirSyncEnabled','ImmutableId','LastDirSyncTime','UsageLocation' ;
        $propsAADL5 = 'ObjectType','UserType' ;
        #>
        # abbreviated:
        $propsAADL1 = @{Name='UPN';Expression={$_.UserPrincipalName }}, @{Name='DName';Expression={$_.DisplayName }}, 
            @{Name='FName';Expression={$_.GivenName }},@{Name='LName';Expression={$_.Surname }},
            @{Name='Title';Expression={$_.JobTitle }};
        $propsAADL2 = @{Name='Company';Expression={$_.CompanyName }},@{Name='Dept';Expression={$_.Department }},
            @{Name='Ofc';Expression={$_.PhysicalDeliveryOfficeName }} ;
        $propsAADL3 = @{Name='Street';Expression={$_.StreetAddress }}, 'City','State',
            @{Name='Zip';Expression={$_.PostalCode }}, @{Name='Phone';Expression={$_.TelephoneNumber }}, 'Mobile' ;
        $propsAADL4 = @{Name='Dsync';Expression={$_.DirSyncEnabled }}, @{Name='ImutID';Expression={$_.ImmutableId }}, 
            @{Name='LastDSync';Expression={$_.LastDirSyncTime }}, @{Name='UseLoc';Expression={$_.UsageLocation }};
        $propsAADL5 = 'ObjectType','UserType', @{Name='Enabled';Expression={$_.AccountEnabled }} ;

        #$propsAADMgr = 'UserPrincipalName','Mail',@{Name='OpDN';Expression={$_.ExtensionProperty.onPremisesDistinguishedName }} ;
        # get mgr OU, not DN: ExtensionProperty.onPremisesDistinguishedName.split(',') | select -skip 1 ) -join ','
        $propsAADMgr = 'UserPrincipalName','Mail',
            @{Name='OpOU';Expression={($_.ExtensionProperty.onPremisesDistinguishedName.split(',') | select -skip 1) -join ',' }} ;
        $propsAADMgrL1 = 'UserPrincipalName','Mail' ;
        $propsAADMgrL2 = @{Name='OpOU';Expression={($_.ExtensionProperty.onPremisesDistinguishedName.split(',') | select -skip 1) -join ',' }} ;

        if($getMobile){
            # mobile device props
            #$MDtbl=[ordered]@{NoDashRow=$true } ; # out-markdowntable splat
            #$propsMobDevStats = 'DeviceFriendlyName','DeviceType','DeviceOS','ClientType','DeviceID',
            #    'FirstSyncTime','LastSyncAttemptTime','LastSuccessSync','NumberOfFoldersSynced' ; 
            $propsMobL1 = @{Name='FriendlyName';Expression={$_.DeviceFriendlyName }},@{Name='DevType';Expression={$_.DeviceType }},
                @{Name='DevOs';Expression={$_.DeviceOS }},@{Name='ClntType';Expression={$_.ClientType }},
                @{Name='DevID';Expression={$_.DeviceID }} ; 
            # shorten times: (get-date '6/20/2021 1:45:34 AM' -format 'M/d/yy H:mmtt');
            $propsMobL2 = @{Name='1stSyncTime';Expression={(get-date $_.FirstSyncTime -format 'M/d/yy H:mmtt') }},
                @{Name='LastSyncTime';Expression={(get-date $_.LastSyncAttemptTime -format 'M/d/yy H:mmtt') }},
                @{Name='LastSuccSync';Expression={(get-date $_.LastSuccessSync -format 'M/d/yy H:mmtt') }},
                @{Name='#Folders';Expression={$_.NumberOfFoldersSynced }} ; 
        } ; 
        if($getQuotaUsage){

            # 12:54 PM 9/18/2023 adds for MbxFolderStats, Quota & LegalHold eval:
            $prpStat = 'DisplayName',@{n="DBIssueWarningQuotaMB";e={[math]::round($_.DatabaseIssueWarningQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                @{n="DBProhibitSendQuotaMB";e={[math]::round($_.DatabaseProhibitSendQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                @{n="DBProhibitSendReceiveQuotaMB";e={[math]::round($_.DatabaseProhibitSendReceiveQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                @{n="TotalMailboxSizeMB";e={[math]::round($_.TotalItemSize.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                'LastLogonTime' ,'LastLogoffTime' ;

            $prpFldr = @{Name='Folder'; Expression={$_.Identity.tostring()}},@{Name="Items"; Expression={$_.ItemsInFolder}}, 
                @{n="SizeMB"; e={[math]::round($_.FolderSize.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}}, 
                @{Name="OldestItem"; Expression={get-date $_.OldestItemReceivedDate -f "yyyyMMdd"}}, 
                @{Name="NewestItem"; Expression={$_.NewestItemReceivedDate -f "yyyyMMdd"}},"FolderType" ;

            # 10:01 AM 2/27/2024 new spec for reporting on LegalHold symptom folders
            $prpFldrLH = @{Name='Folder'; Expression={$_.Name.tostring()}},@{Name="Items"; Expression={$_.ItemsInFolder}}, 
                @{n="SizeMB"; e={[math]::round($_.FolderSize.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}}, 
                @{Name="OldestItem"; Expression={get-date $_.OldestItemReceivedDate -f "yyyyMMdd"}}, 
                @{Name="NewestItem"; Expression={$_.NewestItemReceivedDate -f "yyyyMMdd"}},"FolderType" ;
                
            # 9:41 AM 2/27/2024 fixed borked InPlaceHolds expansion (was empty, and the prop is where JanelS holds actually *appear*)
$prpMbxHold = 'LitigationHoldEnabled',@{n="InPlaceHolds";e={ ($_.inplaceholds ) -join ', '}},
                'ComplianceTagHoldApplied','DelayHoldApplied','DelayReleaseHoldApplied' ; 

            $rgxHiddn = '.*\\(Versions|SubstrateHolds|DiscoveryHolds|Yammer.*|Social\sActivity\sNotifications|Suggested\sContacts|Recipient\sCache|PersonMetadata|Audits|Calendar\sLogging|Purges)$' ; 

        } ; 
        $rgxOPLic = '^CN\=ENT\-APP\-Office365\-(EXOK|F1|MF1)-DL$' ;
        $rgxXLic = '^CN\=ENT\-APP\-Office365\-(EXOK|F1|MF1)-DL$' ;

        #endregion CONSTANTS_AND_ENVIRO ; #*------^ END CONSTANTS_AND_ENVIRO ^------

        <# if we want pipeline to work have to move the clipboard grab out or down into process{}, where pipeline binding will be actually populated
        if(!$users){
            $users= (get-clipboard).trim().replace("'",'').replace('"','') ;
            if($users){
                write-verbose "No -users specified, detected value on clipboard:`n$($users)" ;
            } else {
                write-warning "No -users specified, nothing matching dname, emailaddress or samaccountname, found on clipboard. EXITING!" ;
                Break ;
            } ;
        } else {
            write-verbose "($(($users|measure).count)) user(s) specified:`n'$($users -join "','")'" ;
        } ;
        #>

        # pre psv2, no $PSBoundParameters autovari to check, so back them out:
        write-verbose 'Collect all non-default Params (works back to psv2 w CmdletBinding)'
        $ParamsNonDefault = (Get-Command $PSCmdlet.MyInvocation.InvocationName).parameters | Select-Object -expand keys | Where-Object{$_ -notmatch '(Verbose|Debug|ErrorAction|WarningAction|ErrorVariable|WarningVariable|OutVariable|OutBuffer)'} ;

        #if ($PSScriptRoot -eq "") {
        if( -not (get-variable -name PSScriptRoot -ea 0) -OR ($PSScriptRoot -eq '')){
            if ($psISE) { $ScriptName = $psISE.CurrentFile.FullPath } 
            elseif($psEditor){
                if ($context = $psEditor.GetEditorContext()) {$ScriptName = $context.CurrentFile.Path } 
            } elseif ($host.version.major -lt 3) {
                $ScriptName = $MyInvocation.MyCommand.Path ;
                $PSScriptRoot = Split-Path $ScriptName -Parent ;
                $PSCommandPath = $ScriptName ;
            } else {
                if ($MyInvocation.MyCommand.Path) {
                    $ScriptName = $MyInvocation.MyCommand.Path ;
                    $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                } else {throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" } ;
            };
            if($ScriptName){
                $ScriptDir = Split-Path -Parent $ScriptName ;
                $ScriptBaseName = split-path -leaf $ScriptName ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($ScriptName) ;
            } ; 
        } else {
            if($PSScriptRoot){$ScriptDir = $PSScriptRoot ;}
            else{
                write-warning "Unpopulated `$PSScriptRoot!" ; 
                $ScriptDir=(Split-Path -parent $MyInvocation.MyCommand.Definition) + "\" ;
            }
            if ($PSCommandPath) {$ScriptName = $PSCommandPath } 
            else {
                $ScriptName = $myInvocation.ScriptName
                $PSCommandPath = $ScriptName ;
            } ;
            $ScriptBaseName = (Split-Path -Leaf ((& { $myInvocation }).ScriptName))  ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
        } ;
        if(-not $ScriptDir){
            write-host "Failed `$ScriptDir resolution on PSv$($host.version.major): Falling back to $MyInvocation parsing..." ; 
            $ScriptDir=(Split-Path -parent $MyInvocation.MyCommand.Definition) + "\" ;
            $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ; 
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;     
        } else {
            if(-not $PSCommandPath ){
                $PSCommandPath  = $ScriptName ; 
                if($PSCommandPath){ write-host "(Derived missing `$PSCommandPath from `$ScriptName)" ; } ;
            } ; 
            if(-not $PSScriptRoot  ){
                $PSScriptRoot   = $ScriptDir ; 
                if($PSScriptRoot){ write-host "(Derived missing `$PSScriptRoot from `$ScriptDir)" ; } ;
            } ; 
        } ; 
        if(-not ($ScriptDir -AND $ScriptBaseName -AND $ScriptNameNoExt)){ 
            throw "Invalid Invocation. Blank `$ScriptDir/`$ScriptBaseName/`ScriptNameNoExt" ; 
            BREAK ; 
        } ; 

        $smsg = "`$ScriptDir:$($ScriptDir)" ;
        $smsg += "`n`$ScriptBaseName:$($ScriptBaseName)" ;
        $smsg += "`n`$ScriptNameNoExt:$($ScriptNameNoExt)" ;
        $smsg += "`n`$PSScriptRoot:$($PSScriptRoot)" ;
        $smsg += "`n`$PSCommandPath:$($PSCommandPath)" ;  ;
        write-verbose $smsg ; 

        if(-not $DoRetries){$DoRetries = 4 } ;    # # times to repeat retry attempts
        if(-not $RetrySleep){$RetrySleep = 10 } ; # wait time between retries
        if(-not $RetrySleep){$DawdleWait = 30 } ; # wait time (secs) between dawdle checks
        if(-not $DirSyncInterval){$DirSyncInterval = 30 } ; # AADConnect dirsync interval
        if(-not $ThrottleMs){$ThrottleMs = 50 ;}
        if(-not $rgxDriveBanChars){$rgxDriveBanChars = '[;~/\\\.:]' ; } ; # ;~/\.:,
        if(-not $rgxCertThumbprint){$rgxCertThumbprint = '[0-9a-fA-F]{40}' } ; # if it's a 40char hex string -> cert thumbprint  
        if(-not $rgxSmtpAddr){$rgxSmtpAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ; } ; # email addr/UPN
        if(-not $rgxDomainLogon){$rgxDomainLogon = '^[a-zA-Z][a-zA-Z0-9\-\.]{0,61}[a-zA-Z]\\\w[\w\.\- ]+$' } ; # DOMAIN\samaccountname 
        if(-not $exoMbxGraceDays){$exoMbxGraceDays = 30} ; 


        # 3:19 PM 6/23/2022: for exo2, this is going to have to be rearranged, if not shifted into smarter cxo2.
        <#rx10 -Verbose:$false ;
        rxo  -Verbose:$false ;
        cmsol  -Verbose:$false ;
        #>
        <#dx10 ; 
        rxo2 ; 
        rx10 ; 
        caad ;
        #>

        # 1:00 PM 9/18/2023 splice in modern svcconns
        #region SERVICE_CONNECTIONS #*======v SERVICE_CONNECTIONS v======
        # PRETUNE STEERING separately *before* pasting in balance of region
        #*------v STEERING VARIS v------
        $useO365 = $true ;
        $useEXO = $true ; 
        $UseOP=$true  ; 
        $UseExOP=$true ;
        $useForestWide = $true ; # flag to trigger cross-domain/forest-wide code in AD & EXoP
        $UseOPAD = $true ; 
        $UseMSOL = $false ; # should be hard disabled now in o365
        $UseAAD = $true  ; 
        $useO365 = [boolean]($useO365 -OR $useEXO -OR $UseMSOL -OR $UseAAD)
        $UseOP = [boolean]($UseOP -OR $UseExOP -OR $UseOPAD) ;
        #*------^ END STEERING VARIS ^------
        #*------v EXO V2/3 steering constants v------
        $EOMModName =  'ExchangeOnlineManagement' ;
        $EOMMinNoWinRMVersion = $MinNoWinRMVersion = '3.0.0' ; # support both names
        #*------^ END EXO V2/3 steering constants ^------
        # assert Org from Credential specs (if not param'd)
        # 1:36 PM 7/7/2023 and revised again -  revised the -AND, for both, logic wasn't working
        if($TenOrg){    
            $smsg = "Confirmed populated `$TenOrg" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } elseif(-not($tenOrg) -and $Credential){
            $smsg = "(unconfigured `$TenOrg: asserting from credential)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $TenOrg = get-TenantTag -Credential $Credential ;
        } else { 
            # if not using Credentials or a TargetTenants/TenOrg loop, default the $TenOrg on the $env:USERDOMAIN
            $smsg = "(unconfigured `$TenOrg & *NO* `$Credential: fallback asserting from `$env:USERDOMAIN)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            switch -regex ($env:USERDOMAIN){
                ([regex]('(' + (( @($TORMeta.legacyDomain,$CMWMeta.legacyDomain)  |foreach-object{[regex]::escape($_)}) -join '|') + ')')).tostring() {$TenOrg = $env:USERDOMAIN.substring(0,3).toupper() } ;
                $TOLMeta.legacyDomain {$TenOrg = 'TOL' }
                default {throw "UNRECOGNIZED `$env:USERDOMAIN!:$($env:USERDOMAIN)" ; exit ; } ;
            } ; 
        } ; 
        #region useO365 ; #*------v useO365 v------
        #$useO365 = $false ; # non-dyn setting, drives variant EXO reconnect & query code
        #if($CloudFirst){ $useO365 = $true } ; # expl: steering on a parameter
        if($useO365){
            #region GENERIC_EXO_CREDS_&_SVC_CONN #*------v GENERIC EXO CREDS & SVC CONN BP v------
            # o365/EXO creds
            <### Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile*
            $o365Cred = get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
            Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred = get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
            Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred = get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
            Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            ###>
            $o365Cred = $null ;
            if($Credential){
                $smsg = "`Credential:Explicit credentials specified, deferring to use..." ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                 # get-TenantCredentials() return format: (emulating)
                 $o365Cred = [ordered]@{
                    Cred=$Credential ; 
                    credType=$null ; 
                } ; 
                $uRoleReturn = resolve-UserNameToUserRole -UserName $Credential.username -verbose:$($VerbosePreference -eq "Continue") ; # Username
                #$uRoleReturn = resolve-UserNameToUserRole -Credential $Credential -verbose = $($VerbosePreference -eq "Continue") ;   # full Credential support
                if($uRoleReturn.UserRole){
                    $o365Cred.credType = $uRoleReturn.UserRole ; 
                } else { 
                    $smsg = "Unable to resolve `$credential.username ($($credential.username))"
                    $smsg += "`nto a usable 'UserRole' spec!" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    throw $smsg ;
                    Break ;
                } ; 
            } else { 
                $pltGTCred=@{TenOrg=$TenOrg ; UserRole=$null; verbose=$($verbose)} ;
                if($UserRole){
                    $smsg = "(`$UserRole specified:$($UserRole -join ','))" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $pltGTCred.UserRole = $UserRole; 
                } else { 
                    $smsg = "(No `$UserRole found, defaulting to:'CSVC','SID' " ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    $pltGTCred.UserRole = 'CSVC','SID' ; 
                } ; 
                $smsg = "get-TenantCredentials w`n$(($pltGTCred|out-string).trim())" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $o365Cred = get-TenantCredentials @pltGTCred
            } ; 
            if($o365Cred.credType -AND $o365Cred.Cred -AND $o365Cred.Cred.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                #$smsg = "(Resolved credentials CredType/UserRole as: $($o365Cred.credType)" ; 
                $smsg = "(validated `$o365Cred contains .credType:$($o365Cred.credType) & `$o365Cred.Cred.username:$($o365Cred.Cred.username)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else { 
                $smsg = "UNABLE TO RESOLVE FUNCTIONAL CredType/UserRole from specified explicit -Credential:$($Credential.username)!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 

                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                break ; 
            } ; 
            if($o365Cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                if(get-Variable -Name cred$($tenorg) -scope Script -ea 0 ){ remove-Variable -Name cred$($tenorg) -scope Script } ;
                New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
                $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatettus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                Break ;
            } ;
            # configure splat for connections: (see above useage)
            # downstream commands
            $pltRXO = [ordered]@{
                Credential = $Credential ;
                verbose = $($VerbosePreference -eq "Continue")  ;
            } ;
            if((gcm Reconnect-EXO).Parameters.keys -contains 'silent'){
                $pltRxo.add('Silent',$silent) ;
            } ;
            # default connectivity cmds - force silent false
            $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$true) ; 
            if((gcm Reconnect-EXO).Parameters.keys -notcontains 'silent'){
                $pltRxo.remove('Silent') ;
            } ; 
            #region EOMREV ; #*------v EOMREV Check v------
            #$EOMmodname = 'ExchangeOnlineManagement' ;
            $pltIMod = @{Name = $EOMmodname ; ErrorAction = 'Stop' ; verbose=$false} ;
            # do a gmo first, faster than gmo -list
            if([version]$EOMMv = (Get-Module @pltIMod| sort version | select -last 1).version){}
            elseif([version]$EOMMv = (Get-Module -ListAvailable @pltIMod| sort version | select -last 1).version){}
            else {
                $smsg = "$($EOMmodname) PowerShell v$($MinNoWinRMVersion) module is required, do you want to install it?" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $bRet = Read-Host "Enter YYY to continue. Anything else will exit"  ;
                if ($bRet.ToUpper() -eq "YYY") {
                    $smsg = "Installing $($EOMmodname) module..." ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Install-Module $EOMmodname -Repository PSGallery -AllowClobber -Force ;
                } else {
                    $smsg = "Please install $($EOMmodname) PowerShell v$($MinNoWinRMVersion)  module." ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #exit 1
                    break ;
                }  ;
            } ;
            $smsg = "(Checking for WinRM support in this EOM rev...)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            if([version]$EOMMv -ge [version]$MinNoWinRMVersion){
                $MinNoWinRMVersion = $EOMMv.tostring() ;
                $IsNoWinRM = $true ;
            }elseif([version]$EOMMv -lt [version]$MinimumVersion){
                $smsg = "Installed $($EOMmodname) is v$($MinNoWinRMVersion): This module is obsolete!" ;
                $smsg += "`nAnd unsupported by this function!" ;
                $smsg += "`nPlease install $($EOMmodname) PowerShell v$($MinNoWinRMVersion)  module!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Break ;
            } else {
                $IsNoWinRM = $false ;
            } ;
            [boolean]$UseConnEXO = [boolean]([version]$EOMMv -ge [version]$MinNoWinRMVersion) ;
            #endregion EOMREV ; #*------^ END EOMREV Check  ^------
            #-=-=-=-=-=-=-=-=
            <### CALLS ARE IN FORM: (cred$($tenorg))
            # downstream commands
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; 
            } ;
            if((gcm Reconnect-EXO).Parameters.keys -contains 'silent'){
                $pltRxo.add('Silent',$false) ;
            } ; 
            # default connectivity cmds - force silent false
            $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$true) ;
            if((gcm Reconnect-EXO).Parameters.keys -notcontains 'silent'){
                $pltRxo.remove('Silent') ;
            } ; 
            #$pltRXO creds & .username can also be used for AzureAD connections:
            #Connect-AAD @pltRXOC ;
            ###>
            #endregion GENERIC_EXO_CREDS_&_SVC_CONN #*------^ END GENERIC EXO CREDS & SVC CONN BP ^------

        } else {
            $smsg = "(`$useO365:$($useO365))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; # if-E if($useO365 ){
        #endregion useO365 ; #*------^ END useO365 ^------

        #region useEXO ; #*------v useEXO v------
        # 1:29 PM 9/15/2022 as of MFA & v205, have to load EXO *before* any EXOP, or gen get-steppablepipeline suffix conflict error
        if($useEXO){
            if ($script:useEXOv2 -OR $useEXOv2) { reconnect-eXO2 @pltRXOC }
            else { reconnect-EXO @pltRXOC } ;
        } else {
            $smsg = "(`$useEXO:$($useEXO))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; # if-E 
        #endregion  ; #*------^ END useEXO ^------
        
        #region GENERIC_EXOP_CREDS_&_SRVR_CONN #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
        # steer all onprem code on $XXXMeta.ExOPAccessFromToro & Ex10Server values
        #$UseOP=$true ; 
        #$UseExOP=$true ;
        #$useForestWide = $true ; # flag to trigger cross-domain/forest-wide code in AD & EXoP
        <# no onprem dep
        if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
            $UseOP = $UseExOP = $true ;
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ;
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        } else {
            $UseOP = $UseExOP = $false ;
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ;
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        } ;
        #>
        if($UseOP){
            #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
            # do the OP creds too
            $OPCred=$null ;
            # default to the onprem svc acct
            # userrole='ESVC','SID'
            #$pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC','SID'; verbose=$($verbose)} ;
            # userrole='SID','ESVC'
            $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='SID','ESVC'; verbose=$($verbose)} ;
            $smsg = "get-HybridOPCredentials w`n$(($pltGHOpCred|out-string).trim())" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                if(get-Variable -Name "cred$($tenorg)OP" -scope Script -ea 0 ){ remove-Variable -Name "cred$($tenorg)OP" -scope Script } ;
                New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                Break ;
            } ;
            $smsg= "Using OnPrem/EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            <### CALLS ARE IN FORM: (cred$($tenorg))
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; 
            } ;
            $1stConn = $false ; # below uses silent suppr for both x10 & xo!
            if($1stConn){
                $pltRX10.silent = $pltRXO.silent = $false ;
            } else {
                $pltRX10.silent = $pltRXO.silent =$true ;
            } ;
            if($pltRX10){ReConnect-Ex2010 @pltRX10 }
            else {ReConnect-Ex2010 }
            #$pltRx10 creds & .username can also be used for local ADMS connections
            ###>
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; 
            } ;
            if((gcm Reconnect-Ex2010).Parameters.keys -contains 'silent'){
                $pltRX10.add('Silent',$false) ;
            } ;

            # defer cx10/rx10, until just before get-recipients qry
            #endregion GENERIC_EXOP_CREDS_&_SRVR_CONN #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
            # connect to ExOP X10
            if($useEXOP){
                if($pltRX10){
                    #ReConnect-Ex2010XO @pltRX10 ;
                    ReConnect-Ex2010 @pltRX10 ;
                } else { Reconnect-Ex2010 ; } ;
                #Add-PSSnapin -Name 'Microsoft.Exchange.Management.PowerShell.SnapIn'
                #TK: add: test Exch & AD functional connections
                TRY{
                    if(get-command -module (get-module |?{$_.name -like 'tmp_*'}).name -name 'get-OrganizationConfig'){} else {
                        $smsg = "(mangled Ex10 conn: dx10,rx10...)" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        disconnect-ex2010 ; reconnect-ex2010 ; 
                    } ; 
                    if(-not ($OrgName = ((get-OrganizationConfig).DistinguishedName.split(',') |?{$_ -like 'DC=*'}) -join '.' -replace 'DC=','')){
                        $smsg = "Missing Exchange Connection! (no (Get-OrganizationConfig).name returned)" ; 
                        throw $smsg ; 
                        $smsg | write-warning  ; 
                    } ; 
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = $ErrTrapd ;
                    $smsg += "`n";
                    $smsg += $ErrTrapd.Exception.Message ;
                    if ($logging) { _write-log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    CONTINUE ;
                } ;
            } else { 
            
            } ; 
            if($useForestWide){
                #region  ; #*------v OPTIONAL CODE TO ENABLE FOREST-WIDE NATIVE EXCHANGE SUPPORT v------
                $smsg = "(`$useForestWide:$($useForestWide)):Enabling EXoP Forestwide)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $smsg = 'Set-AdServerSettings -ViewEntireForest `$True' ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Set-AdServerSettings -ViewEntireForest $True ;
                #endregion  ; #*------^ END OPTIONAL CODE TO ENABLE FOREST-WIDE NATIVE EXCHANGE SUPPORT ^------
            } ;
        } else {
            $smsg = "(`$useOP:$($UseOP))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        }  ;  # if-E $UseOP

        #region UseOPAD #*------v UseOPAD v------
        if($UseOP -OR $UseOPAD){
            #region GENERIC_ADMS_CONN_&_XO #*------v GENERIC ADMS CONN & XO  v------
            $smsg = "(loading ADMS...)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # always capture load-adms return, it outputs a $true to pipeline on success
            $ADMTLoaded = load-ADMS -Verbose:$FALSE ;
            # 9:32 AM 4/20/2023 trimmed disabled/fw-borked cross-org code
            TRY {
                if(-not(Get-ADDomain  -ea STOP).DNSRoot){
                    $smsg = "Missing AD Connection! (no (Get-ADDomain).DNSRoot returned)" ; 
                    throw $smsg ; 
                    $smsg | write-warning  ; 
                } ; 
                $objforest = get-adforest -ea STOP ; 
                # Default new UPNSuffix to the UPNSuffix that matches last 2 elements of the forestname.
                $forestdom = $UPNSuffixDefault = $objforest.UPNSuffixes | ?{$_ -eq (($objforest.name.split('.'))[-2..-1] -join '.')} ; 
                if($useForestWide){
                    #region  ; #*------v OPTIONAL CODE TO ENABLE FOREST-WIDE AD GC QRY SUPPORT v------
                    $smsg = "(`$useForestWide:$($useForestWide)):Enabling AD Forestwide)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $smsg = 'Set-AdServerSettings -ViewEntireForest `$True' ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #TK 9:44 AM 10/6/2022 need org wide for rolegrps in parent dom (only for onprem RBAC, not EXO)
                    $GcFwide = "$((Get-ADDomainController -Discover -Service GlobalCatalog).hostname):3268" ;        
                    #endregion  ; #*------^ END  OPTIONAL CODE TO ENABLE FOREST-WIDE AD GC QRY SUPPORT  ^------
                } ;    
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = $ErrTrapd ;
                $smsg += "`n";
                $smsg += $ErrTrapd.Exception.Message ;
                if ($logging) { _write-log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                CONTINUE ;
            } ;        
            #endregion GENERIC_ADMS_CONN_&_XO #*------^ END GENERIC ADMS CONN & XO ^------
        } else {
            $smsg = "(`$UseOP:$($UseOP))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        }  ;
        #if (!$domaincontroller) { $domaincontroller = get-gcfast } ;
        #if(!$domaincontroller){ if(test-path function:get-gcfast){$domaincontroller = get-gcfast} else { throw "no get-gcfast()!" } ;} else {"(existing `$domaincontroller:$($domaincontroller))"} ;
        # use new get-GCFastXO cross-org dc finde
        # default to Op_ExADRoot forest from $TenOrg Meta
        #if($UseOP -AND -not $domaincontroller){
        if($UseOP -AND -not (get-variable domaincontroller -ea 0)){
            #$domaincontroller = get-GCFastXO -TenOrg $TenOrg -subdomain ((gv -name "$($TenOrg)Meta").value['OP_ExADRoot']) -verbose:$($verbose) |?{$_.length};
            # need to debug the above, credential issue?
            # just get it done
            $domaincontroller = get-GCFast
        }  else { 
            # have to defer to get-azuread, or use EXO's native cmds to poll grp members
            # TODO 1/15/2021
            $useEXOforGroups = $true ; 
            $smsg = "$($TenOrg):HAS NO ON-PREM ACTIVEDIRECTORY, DEFERRING ALL GROUP ACCESS & MGMT TO NATIVE EXO CMDS!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
        if($useForestWide -AND -not $GcFwide){
            #region  ; #*------v OPTIONAL CODE TO ENABLE FOREST-WIDE ACTIVEDIRECTORY SUPPORT: v------
            $smsg = "`$GcFwide = Get-ADDomainController -Discover -Service GlobalCatalog" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $GcFwide = "$((Get-ADDomainController -Discover -Service GlobalCatalog).hostname):3268" ;
            $smsg = "Discovered `$GcFwide:$($GcFwide)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #endregion  ; #*------^ END OPTIONAL CODE TO ENABLE FOREST-WIDE ACTIVEDIRECTORY SUPPORT ^------
        } ;
        #endregion UseOPAD #*------^ END UseOPAD ^------

        #region MSOL_CONNECTION ; #*------v  MSOL CONNECTION v------
        #$UseMSOL = $false 
        if($UseMSOL){
            #$reqMods += "connect-msol".split(";") ;
            #if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
            $smsg = "(loading MSOL...)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #connect-msol ;
            connect-msol @pltRXOC ;
        } else {
            $smsg = "(`$UseMSOL:$($UseMSOL))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ;
        #endregion MSOL_CONNECTION ; #*------^  MSOL CONNECTION ^------

        #region AZUREAD_CONNECTION ; #*------v AZUREAD CONNECTION v------
        #$UseAAD = $false 
        if($UseAAD){
            #$reqMods += "Connect-AAD".split(";") ;
            #if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
            $smsg = "(loading AAD...)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Connect-AAD @pltRXOC ;
        } else {
            $smsg = "(`$UseAAD:$($UseAAD))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ;
        #endregion AZUREAD_CONNECTION ; #*------^ AZUREAD CONNECTION ^------
        
        <# defined above
        # EXO connection
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            verbose = $($verbose) ; } ;
        #>
        <#
        if($VerbosePreference = "Continue"){
            $VerbosePrefPrior = $VerbosePreference ;
            $VerbosePreference = "SilentlyContinue" ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        disconnect-exo ;
        if ($script:useEXOv2) { reconnect-eXO2 @pltRXOC }
        else { reconnect-EXO @pltRXOC } ;
        # reenable VerbosePreference:Continue, if set, during mod loads
        if($VerbosePrefPrior -eq "Continue"){
            $VerbosePreference = $VerbosePrefPrior ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        #>
        #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        #endregion SERVICE_CONNECTIONS #*======^ END SERVICE_CONNECTIONS ^======
    

        # finally if we're using pipeline, and aggregating, we need to aggreg outside of the process{} block
        if($PSCmdlet.MyInvocation.ExpectingInput){
            # pipeline instantiate an aggregator here
        } ;

        # check if using Pipeline input or explicit params:
        if ($PSCmdlet.MyInvocation.ExpectingInput) {
            $smsg = "Data received from pipeline input: '$($InputObject)'" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } else {
            # doesn't actually return an obj in the echo
            #$smsg = "Data received from parameter input: '$($InputObject)'" ;
            #if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            #else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ;


    }
    PROCESS{
        # ps1 faked: #region PROCESS ; #*------v PROCESS:$($identity -join ',') v------

        #$dname= 'Todd Kadrie' ;
        #$dname = 'Stacy Sotelo'

        if(-not $users){
            $users= (get-clipboard).trim().replace("'",'').replace('"','') ;
            if($users){
                write-verbose "No -users specified, detected value on clipboard:`n$($users)" ;
            } else {
                write-warning "No -users specified, nothing matching dname, emailaddress or samaccountname, found on clipboard. EXITING!" ;
                Break ;
            } ;
        } else {
            write-verbose "($(($users|measure).count)) user(s) specified:`n'$($users -join "','")'" ;
        } ;

        $ttl = ($users|measure).count ; $Procd=0 ;
        [array]$Rpt =@() ;
        # with pipeline input, the pipeline evals as either $_ (if unmapped to a param in binding), or iterating on the mapped value.
        #     the foreach loop below doesn't actually loop. Process{} is the loop with a pipeline-fed param, and the bound - $users - variable once per pipeline bound element - per array item on an array -
        #     is run with the $users value populated with each element in turn. IOW, the foreach is a single-run pass, and the Process{} block is the loop.
        # you need both a bound $users at the top - to handle explicit assigns resolve-user -users $variable.
        # with a process {} block to handle any pipeline passed input. The pipeline still maps to the bound param: $users, but the entire process{} is run per element, rather than iteratign the internal $users foreach.
        foreach ($usr in $users){
            
            #region START-LOG #*======v START-LOG OPTIONS v======
            #region START-LOG-HOLISTIC #*------v START-LOG-HOLISTIC v------
            # Single log for script/function example that accomodates detect/redirect from AllUsers scope'd installed code, and hunts a series of drive letters to find an alternate logging dir (defers to profile variables)
            #${CmdletName} = $rPSCmdlet.MyInvocation.MyCommand.Name ;
            if(!(get-variable LogPathDrives -ea 0)){$LogPathDrives = 'd','c' };
            foreach($budrv in $LogPathDrives){if(test-path -path "$($budrv):\scripts" -ea 0 ){break} } ;
            if(!(get-variable rgxPSAllUsersScope -ea 0)){
                $rgxPSAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps(((d|m))*)1|dll)$" ;
            } ;
            if(!(get-variable rgxPSCurrUserScope -ea 0)){
                $rgxPSCurrUserScope="^$([regex]::escape([Environment]::GetFolderPath('MyDocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps((d|m)*)1|dll)$" ;
            } ;
            $pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($whatif) ;} ;
            # if using [CmdletBinding(SupportsShouldProcess)] + -WhatIf:$($WhatIfPreference):
            #$pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($WhatIfPreference) ;} ;
            $pltSL.Tag = $null ; # $CmdletName # $ModuleName ; 
            if($script:rPSCommandPath){ $prxPath = $script:rPSCommandPath }
            elseif($script:PSCommandPath){$prxPath = $script:PSCommandPath}
            if($rMyInvocation.MyCommand.Definition){$prxPath2 = $rMyInvocation.MyCommand.Definition }
            elseif($MyInvocation.MyCommand.Definition){$prxPath2 = $MyInvocation.MyCommand.Definition } ; 
            if($prxPath){
                if(($prxPath -match $rgxPSAllUsersScope) -OR ($prxPath -match $rgxPSCurrUserScope)){
                    $bDivertLog = $true ; 
                    switch -regex ($prxPath){
                        $rgxPSAllUsersScope{$smsg = "AllUsers"} 
                        $rgxPSCurrUserScope{$smsg = "CurrentUser"}
                    } ;
                    $smsg += " context script/module, divert logging into [$budrv]:\scripts" 
                    write-verbose $smsg  ;
                    if($bDivertLog){
                        if((split-path $prxPath -leaf) -ne $cmdletname){
                            # function in a module/script installed to allusers|cu - defer name to Cmdlet/Function name
                            $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
                        } else {
                            # installed allusers|CU script, use the hosting script name
                            $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $prxPath -leaf)) ;
                        }
                    } ;
                } else {
                    $pltSL.Path = $prxPath ;
                } ;
           }elseif($prxPath2){
                if(($prxPath2 -match $rgxPSAllUsersScope) -OR ($prxPath2 -match $rgxPSCurrUserScope) ){
                     $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $prxPath2 -leaf)) ;
                } elseif(test-path $prxPath2) {
                    $pltSL.Path = $prxPath2 ;
                } elseif($cmdletname){
                    $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
                } else {
                    $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$CMDLETNAME, FROM WHICH TO BUILD A START-LOG.PATH!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    BREAK ;
                } ; 
            } else{
                $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$CMDLETNAME, FROM WHICH TO BUILD A START-LOG.PATH!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                BREAK ;
            }  ;
            write-verbose "start-Log w`n$(($pltSL|out-string).trim())" ; 
            $logspec = start-Log @pltSL ;
            $error.clear() ;
            TRY {
                if($logspec){
                    $logging=$logspec.logging ;
                    $logfile=$logspec.logfile ;
                    $transcript=$logspec.transcript ;
                    $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                    if($stopResults){
                        $smsg = "Stop-transcript:$($stopResults)" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    } ; 
                    $startResults = start-Transcript -path $transcript ;
                    if($startResults){
                        $smsg = "start-transcript:$($startResults)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ; 
                } else {throw "Unable to configure logging!" } ;
            } CATCH [System.Management.Automation.PSNotSupportedException]{
                if($host.name -eq 'Windows PowerShell ISE Host'){
                    $smsg = "This version of $($host.name):$($host.version) does *not* support native (start-)transcription" ; 
                } else { 
                    $smsg = "This host does *not* support native (start-)transcription" ; 
                } ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
            #endregion START-LOG-HOLISTIC #*------^ END START-LOG-HOLISTIC ^------
            #region LOGBUILD ; #*------v LOGBUILD v------
            # building an outputfile name dynamically using paremeters
            #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            # start by rebuilding from base of start-log(): $logfile: 'D:\scripts\logs\get-ExOPSmtpReceiveTLSReport-SERVER50'
            # *first* reset $ofile; it's picking the filename up from the OS
            $ofile = $null;
            [array]$ofile = $ofile ;
            #$ofile += ("$($_.Name)-$($_.value)" -join ',' );
            #$ofile=".\$($ticket)-$($usr)-folder-sizes-NONHIDDEN-NONZERO-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
            $ofile += @("$($ticket)-$($usr)") ; 
            $ofile += "REPORT" ; 
            $ofile += "run$(get-date -format 'yyyyMMdd-HHmmtt')" ; 
            [string]$ofile = $ofile -join '-' ; 
            [string]$ofile += ".xml" ; 
            # split existing logfile path out: e.g. D:\scripts\logs\update-xoRetiringConfRmWindows-(TOR)-LASTPASS
            #[string]$ofile = join-path -path ($logfile -split '-LOG-BATCH-')[0]  -childpath $ofile ; 
            # raw path, no cmdletname prefix
            [string]$ofile = join-path -path (split-path $logfile) -childpath $ofile ; 
            

            #$fname = $lname = $dname = $OPRcp = $OPMailbox = $OPRemoteMailbox = $ADUser = $xoRcp = $xoMailbox = $xoUser = $xoMemberOf = $MsolUser = $LicenseGroup = $null ;
            $isEml=$isDname=$isSamAcct=$isXORcpMulti  = $false ;


            $hSum = [ordered]@{
                dname = $null ;
                fname = $null ;
                lname = $null ;
                OPRcp = $null ;
                xoRcp = $null ;
                OPMailbox = $null ;
                OPRemoteMailbox = $null ;
                ADUser = $null ;
                Federator = $null ;
                xoMailbox = $null ;
                xoMUser = $null ;
                xoUser = $null ;
                xoMemberOf = $null ;
                txGuest = $null ;
                OPMapiTest = $null ;
                xoMapiTest = $null ;
                MsolUser = $null ;
                AADUser = $null ; # added for MailUser variant
                AADUserMgr = $null ;
                AADUserLics = $null ; 
                LicenseGroup = $null ;
                isDirSynced = $null 
                isNoBrain = $false ;
                isSplitBrain = $false;
                #isUnlicensed = $false ;
                IsLicensed = $false ; 
                IsDisabledOU = $false ; 
                IsADDisabled = $false ; 
                IsAADDisabled = $false ; 
            } ;
            $procd++ ;
            write-verbose "processing:$($usr)" ;
            if($getMobile){
                $smsg = "(-getMobile:retrieving user xo MobileDevices)" ; 
                if($verbose){
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-verbose $smsg } ; 
                } ; 
                $hsum.add('xoMobileDeviceStats',$null) ; 
            } ; 
            if($getQuotaUsage){
                $smsg = "(-getQuotaUsage:retrieving user xo Mailbox*Statistics & Effective Quotas)" ; 
                if($verbose){
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-verbose $smsg } ; 
                } ; 
                $hsum.add('xoMailboxStats',$null) ; 
                $hsum.add('xoMailboxFolderStats',$null) ; 
                $hsum.add('xoEffectiveQuotas',$null) ; 
                $hsum.add('xoNetOfSendReceiveQuotaMB',$null) ; 
                [string]$ofMbxFolderStats = $ofile.replace('REPORT',"folder-sizes-NONHIDDEN-NONZERO") ; 

            } ; 

            switch -regex ($usr){
                $rgxEmailAddr {
                    $hSum.fname,$hSum.lname = $usr.split('@')[0].split('.') ;
                    $hSum.dname = $usr ;
                    write-verbose "(detected user ($($usr)) as EmailAddr)" ;
                    $isEml = $true ;
                    Break ;
                }
                $rgxObjNameNewHires{
                    write-verbose "(detected user ($($usr)) as ObjNameNewHires)" ;
                    $hSum.fname,$hSum.lname = $usr.split('_')[0].split(' ');
                    $hSum.dname = $usr.split('_')[0] ;
                    write-verbose "(detected user ($($usr)) as DisplayName)" ;
                    $isObjName = $true ;
                    Break ;
                }
                $rgxDName {
                    if($usr.contains('.')){
                        write-verbose "(replacing period in DName)" ;
                        $usr = $usr.replace('.',' ') ;
                    };
                    $hSum.fname,$hSum.lname = $usr.split(' ') ;
                    $hSum.dname = $usr ;
                    write-verbose "(detected user ($($usr)) as DisplayName)" ;
                    $isDname = $true ;
                    Break ;
                }
                $rgxSamAcctNameTOR {
                    $hSum.lname = $usr ;
                    write-verbose "(detected user ($($usr)) as SamAccountName)" ;
                    $isSamAcct  = $true ;
                    Break ;
                }
                default {
                    write-warning "$((get-date).ToString('HH:mm:ss')):No -user specified, nothing matching dname, emailaddress or samaccountname, found on clipboard. EXITING!" ;
                    #Break ;
                } ;
            } ;

            $sBnr="===v ($($Procd)/$($ttl)):Input: '$($usr)' | '$($hSum.fname)' | '$($hSum.lname)' v===" ;
            if($isEml){$sBnr+="(EML)"}
            elseif($isDname){$sBnr+="(DNAM)"}
            elseif($isObjName){$sBnr+="(ONAM)"}
            elseif($isSamAcct){$sBnr+="(SAM)"}
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr)" ;

            write-host -foreground yellow "get-Rmbx/xMbx: " -nonewline;


            # $isEml=$isDname=$isSamAcct=$false ;
            $MDtbl=[ordered]@{NoDashRow=$true } ; # out-markdowntable splat
            $pltGMailObj=[ordered]@{
                ResultSize = $MaxRecips ;
            } ;
            if($isEml -OR $isSamAcct){
                write-verbose "processing:'identity':$($usr)" ;
                $pltGMailObj.add('identity',$usr) ;
            } ;
            if($isObjName){
                # filter on Name, (not dname)
                $dname = $hSum.dname
                $fltr = "name -like '$usr'" ;
                write-verbose "processing:'filter':$($fltr)" ;
                $pltGMailObj.add('filter',$fltr) ;
            } ;
            if($isDname){
                # interestinb bug: switched to $hSum.dname: ISE is fine, but ConsoleHost fails to expand the $fltr properly.
                # standard is: Variables: Enclose variables that need to be expanded in single quotation marks (for example, '$User'). Don't use curly-brackets (impedes expansion)
                # workaround: looks like have to proxy the $hsum.Dname, to provide a single non-dotted variable name
                $dname = $hSum.dname
                $fltr = "displayname -like '$dname'" ;
                write-verbose "processing:'filter':$($fltr)" ;
                $pltGMailObj.add('filter',$fltr) ;
            } ;

            $error.clear() ;

            #write-verbose "get-[exo]Recipient w`n$(($pltGMailObj|out-string).trim())" ;
            #write-verbose "get-recipient w`n$(($pltGMailObj|out-string).trim())" ;
            # exclude contacts, they don't represent real onprem mbx assoc, and we need to refer those to EXO mbx qry anyway.
            write-verbose "get-recipient w`n$(($pltGMailObj|out-string).trim())" ;
            rx10 -Verbose:$false -silent ;
            if($hSum.OPRcp=get-recipient @pltGMailObj -ea 0 | select -first $MaxRecips | ?{$_.recipienttypedetails -ne 'MailContact'}){
                write-verbose "`$hSum.OPRcp found" ;
                switch ($hSum.OPRcp.recipienttypedetails){
                    'RemoteUserMailbox' {write-host "(Rmbx)" -nonewline}
                    'UserMailbox' {write-host "(Mbx)" -nonewline}
                    # no rmbx, but remote obj?
                    'MailUser' {
                        $smsg = "MAILUSER WO RMBX DETECTED! - POSSIBLE NOBRAIN?"
                        write-warning $smsg
                        #$hsum.isNoBrain = $true ;
                    }
                    'MailUniversalDistributionGroup' {write-host "(DG)" -nonewline}
                    'DynamicDistributionGroup'  {write-host "(DDG)" -nonewline}
                    'MailContact' {write-host "(MC)" -nonewline]}
                    default{}
                }
            } elseif($isDname -and $hsum.lname) {
                $smsg = "Failed:RETRY: detected 'LName':$($hsum.lname) for near matches..." ;
                write-host $smsg ;
                $lname = $hsum.lname ;
                $fltrB = "displayname -like '*$lname*'" ;
                write-verbose "RETRY:get-recipient -filter {$($fltr)}" ;
                if($hSum.OPRcp=get-recipient -filter $fltr -ea 0 | select -first $MaxRecips |?{$_.recipienttypedetails -ne 'MailContact'}){
                    write-verbose "`$hSum.OPRcp found" ;
                } ;
            };

            if(!$hsum.OpRcp){
                $smsg = "(Failed to OP:get-recipient on:$($usr))"
                if($isDname){$smsg += " or *$($hsum.lname )*"}
                write-host $smsg ;
            } else {
                write-verbose "`$hSum.OPRcp:`n$(($hSum.OPRcp|out-string).trim())" ;
            } ;


            #write-verbose "$((get-alias ps1GetxRcp).definition) w`n$(($pltGMailObj|out-string).trim())" ;
            write-verbose "get-xorecipient  w`n$(($pltGMailObj|out-string).trim())" ;
            #rxo  -Verbose:$false -silent ;
            if($hSum.xoRcp=get-xorecipient @pltGMailObj -ea 0 | select -first $MaxRecips ){
                write-verbose "`$hSum.xoRcp found" ;
            } elseif($isDname -and $hsum.lname) {
                $smsg = "Failed:RETRY: detected 'LName':$($hsum.lname) for near matches..." ;
                write-host $smsg ;
                $lname = $hsum.lname ;
                $fltrB = "displayname -like '*$lname*'" ;
                write-verbose "RETRY:get-recipient -filter {$($fltr)}" ;
                if($hSum.xoRcp=get-xorecipient -filter $fltr -ea 0 -ResultSize $MaxRecips |?{$_.recipienttypedetails -ne 'MailContact'}){
                    write-verbose "`$hSum.xoRcp found" ;
                } ;
            }
            if(!$hsum.xoRcp){
                #$smsg = "Failed to $((get-alias ps1GetxRcp).definition) on:$($usr)"
                $smsg = "get-xorecipient on:$($usr)"
                if($isDname){$smsg += " or *$($hsum.lname )*"} ;
                write-host $smsg ;
            } else {
                $smsg =  "`$hSum.xoRcp:`n$(($hSum.xoRcp|out-string).trim())" ;
                write-verbose $smsg ;
                if($hSum.xoRcp -is [system.array]){
                    write-warning "Multiple matching xoRcps!:$($smsg)`nTHIS WILL NOT RETURN FULL AADUSER ETC FOR BOTH OBJECTS!`nUSE TARGETED UPN ETC TO DUMP VARIANT OBJECTS!" ;
                    $isXORcpMulti = $true ;
                } ;
            } ;

            if($hSum.OPRcp){
                $error.clear() ;
                TRY {
                    switch -regex ($hSum.OPRcp.recipienttype){
                        "UserMailbox" {
                            write-verbose "'UserMailbox':get-mailbox $($hSum.OPRcp.identity)"
                            if($hSum.OPMailbox=get-mailbox $hSum.OPRcp.identity -resultsize $MaxRecips | select -first $MaxRecips ){ ;
                                #write-verbose "`$hSum.OPMailbox:`n$(($hSum.OPMailbox|out-string).trim())" ;
                                if($outObject){

                                } else {
                                    $Rpt += $hSum.OPMailbox.primarysmtpaddress ;
                                } ;
                                write-verbose "'UserMailbox':Test-MAPIConnectivity -identity $($hSum.OPMailbox.userprincipalname)"
                                $hSum.OPMapiTest = Test-MAPIConnectivity -identity $hSum.OPMailbox.userprincipalname ;
                                $smsg = "Outlook (MAPI) Access Test Result:$($hsum.OPMapiTest.result)" ;
                                if($hsum.OPMapiTest.result -eq 'Success'){
                                    write-host -foregroundcolor green $smsg ;
                                } else {
                                    write-WARNING $smsg ;
                                } ;
                            } ;
                        }
                        "MailUser" {
                            write-verbose "'MailUser':get-remotemailbox $($hSum.OPRcp.identity)"
                            if($hSum.OPRemoteMailbox=get-remotemailbox $hSum.OPRcp.identity -resultsize $MaxRecips -ea 0 | select -first $MaxRecips){
                                write-verbose "`$hSum.OPRemoteMailbox:`n$(($hSum.OPRemoteMailbox|out-string).trim())" ;
                            }else{
                                $smsg = "RecipientTypeDetails:MailUser with NO Rmbx! (NoBrain?)" ;
                                write-warning $smsg ;
                                if($hsum.xoRcp.ExternalDirectoryObjectId){
                                    # of course has match to AADU  - always does - we're going to need the AADU before we can lookup the ADU
                                    # $pltGadu.identity = $hSum.AADUser.ImmutableId | convert-ImmuntableIDToGUID | select -expand guid ;
                                    caad  -Verbose:$false -silent ;
                                    write-verbose "OPRcp:Mailuser, ensure GET-ADUSER pulls AADUser.matched object for cloud recipient:`nfallback:get-AzureAdUser  -objectid $($hsum.xoRcp.ExternalDirectoryObjectId)" ;
                                    # have to postfilter, if want specific count -maxresults catch's with no $error[0]
                                    $hSum.AADUser  = get-AzureAdUser  -objectid $hsum.xoRcp.ExternalDirectoryObjectId | select -first $MaxRecips;  ;
                                } else {
                                    throw "Unsupported object, blank `$hsum.xoRcp.ExternalDirectoryObjectId!" ;
                                } ;
                            }
                            if($outObject){

                            } else {
                                $Rpt += $hSum.OPRemoteMailbox.primarysmtpaddress ;
                            } ;
                        } ;
                        default {
                            write-warning "$((get-date).ToString('HH:mm:ss')):Unsupported RecipientType:($hSum.OPRcp.recipienttype). EXITING!" ;
                            Break ;
                        }
                    }
                    <# get-aduser docs say REsultSetSize is documented,
                    [Get-ADUser (ActiveDirectory) | Microsoft Docs - docs.microsoft.com/](https://docs.microsoft.com/en-us/powershell/module/activedirectory/get-aduser?view=windowsserver2019-ps)
                     but use of it throws: Parameter set cannot be resolved using the specified named parameters.
                     pull it and post filter to 1...
                    #>
                    #ResultSetSize = $MaxRecips
                    #$pltGadu=[ordered]@{Identity = $null ; Properties='*' ;errorAction='STOP' ; } ;
                    $pltGadu=[ordered]@{Identity = $null ; Properties=$propsADU ;errorAction='STOP' ; } ;
                    if($hSum.OPRemoteMailbox ){
                        # get-aduser dox but doesn't really support ResultSetSize, post filter for it.
                        $pltGadu.identity = $hSum.OPRemoteMailbox.samaccountname ;
                    }elseif($hSum.OPMailbox){
                        $pltGadu.identity = $hSum.OPMailbox.samaccountname ;
                    } else {
                        # cloud-first or no brain, neither oprmbx or opmailbox;  should have populated $hSum.AADUser above, use immutable lookup
                        if($hSum.AADUser.DirSyncEnabled){
                            $smsg = "Falling back to AADU Immutable lookup to locate replicated adu source" ;
                            if($pltGadu.identity = $hSum.AADUser.ImmutableId | convert-ImmuntableIDToGUID | select -expand guid){
                                $smsg = "(Resolved AADU.Immutable ->GUID:$($pltGadu.identity))" ;
                                write-verbose $smsg ;
                            }else {
                                $smsg = "UNABLE TO RESOLVE ADU.IMMUTABLEID TO ADU GUID!"
                                write-warning $smsg ;
                                throw $smsg ;
                            }
                        } else {
                            $smsg = "$AADUsuer not DirSyncEnabled: CLOUD FIRST!"
                            write-warning $smsg ;
                            #throw $smsg ;
                        } ;
                    };
                    if($pltGadu.identity){
                        <# this is throwing a blank fail
                        WARNING: 15:04:18:Failed processing .
                        Error Message:
                        Error Details:
                        # and dumping balance of processing
                        issue: was in adms drive: :xxxx, gadu was searching root domain only
                        so it was a search fail, throwing an error, but didn't return details. Still good idea to trap not found and echo it
                        #>
                        #$hSum.ADUser =Get-ADUser @pltGadu ;
                        write-verbose "Get-ADUser w`n$(($pltGadu|out-string).trim())" ;
                        # try a nested local trycatch, against a missing result
                        Try {
                            #Get-ADUser $DN -ErrorAction Stop ;
                            $hSum.ADUser =Get-ADUser @pltGadu | select -first $MaxRecips ;
                        } Catch [Microsoft.ActiveDirectory.Management.ADIdentityNotFoundException] {
                            write-warning "(no matching ADuser found:$($pltGadu.identity))" ;
                        } catch {
                            $ErrTrapd=$Error[0] ;
                            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Continue ;
                        } ;

                        write-verbose "`$hSum.ADUser:`n$(($hSum.ADUser|fl $propsADU| out-string).trim())" ;
                        $smsg = "(TOR USER, fed:$($TORMeta.adforestname))" ;
                        $hSum.Federator = $TORMeta.adforestname ;
                        write-host -Fore yellow $smsg ;
                        
                        <#
                        if($hSum.OPRemoteMailbox){
                            $smsg = "$(($hSum.OPRemoteMailbox |fl $propsMailx|out-string).trim())"
                        } ;
                        if($hSum.OPMailbox){
                            $smsg =  "$(($hSum.OPMailbox |fl $propsMailx|out-string).trim())" ;
                        } ;
                        #>
                        # swap to md tbl fmt
                        if($hSum.OPRemoteMailbox){$MailRecip = $hSum.OPRemoteMailbox } ; 
                        if($hSum.OPMailbox){$MailRecip = $hSum.OPMailbox } ; 
                        $smsg = "$(($MailRecip| select $propsMailxL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                        $smsg += "`n$(($MailRecip|select $propsMailxL2 |out-markdowntable @MDtbl|out-string).trim())" ;
                        $smsg += "`n$(($MailRecip|select $propsMailxL3 |out-markdowntable @MDtbl|out-string).trim())" ;
                        #$smsg += "`n$(($MailRecip|select $propsMailxL4 |out-markdowntable @MDtbl|out-string).trim())" ;
                        #$smsg += "`n$(($MailRecip|select $propsMailxL4 | fl |out-string).trim())" ;
                        # drop L4 it's DN, which is already in ADU md tbl
                        # flip dn L4 to fl (suppress crlf)

                        write-host $smsg ;
                        #if($MailRecip.ForwardingAddress){
                        #    $smsg += "`n$(($MailRecip|select $propsMailxL5 |out-markdowntable @MDtbl|out-string).trim())" ;
                        #} ; 
                        <#
                        if($hSum.OPRemoteMailbox -AND $hSum.OPRemoteMailbox.ForwardingAddress){
                            write-host $smsg ; # write pending primary (using ww on next)
                            #$smsg = "==FORWARDED rMBX!:`n$(($hSum.OPRemoteMailbox  |ft -a ForwardingAddress,DeliverToMailboxAndForward,ForwardingSmtpAddress|out-string).trim())" ;
                            $smsg = "==FORWARDED rMBX!:" ; 
                            $smsg += "`n$(($MailRecip|select $propsMailxL5 |out-markdowntable @MDtbl|out-string).trim())" ;
                        } ;
                        if($hSum.OPMailbox -AND $hSum.OPMailbox.ForwardingAddress){
                            write-host $smsg ; # write pending primary (using ww on next)
                            $smsg = "==FORWARDED opMBX!:`n$(($hSum.OPMailbox |ft -a ForwardingAddress,DeliverToMailboxAndForward,ForwardingSmtpAddress|out-string).trim())" ;
                        } ;
                        #>
                        if($hSum.OPRemoteMailbox.ForwardingAddress -OR $hSum.OPMailbox.ForwardingAddress){
                            write-host $smsg ; # echo pending, using ww below
                            $smsg = "==FORWARDED rMBX!:" ; 
                            $smsg += "`n$(($MailRecip|select $propsMailxL5 |out-markdowntable @MDtbl|out-string).trim())" ;
                            write-warning $smsg ;
                        } ; 

                        #$smsg += "`n$(($hSum.ADUser |fl $propsADUsht  |out-string).trim())"
                        # these are already in the ADU md tbl dump, drop them
                        #$smsg = "$(($hSum.ADUser |fl $propsADUsht  |out-string).trim())"
                        #write-host $smsg ;
                    } ;
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Continue ;
                } ;
            }elseif($hSum.xoRcp){
                foreach($txR in $hSum.xoRcp){
                    TRY {
                        switch -regex ($txR.recipienttypedetails){
                            "UserMailbox" {
                                #write-verbose "$((get-alias ps1GetxMbx).definition) w`n$(($pltGMailObj|out-string).trim())" ;
                                write-verbose "get-exomailbox w`n$(($pltGMailObj|out-string).trim())" ;
                                if($hSum.xoMailbox=get-xomailbox @pltGMailObj -ea 0 | select -first $MaxRecips ){
                                    write-verbose "`$hSum.xoMailbox:`n$(($hSum.xoMailbox|out-string).trim())" ;
                                    if($outObject){

                                    } else {
                                        $Rpt += $hSum.xoMailbox.primarysmtpaddress ;
                                    } ;
                                    if($hSum.xoMailbox -is [system.array]){
                                        write-warning "Multiple mailboxes matched!" ;
                                    } ;
                                    # accomodate array returned (multiple matches):
                                    $ino = 0 ;
                                    foreach($xmbx in $hSum.xoMailbox){
                                        $ino++ ;
                                        if($hSum.xoMailbox -isnot [system.array]){
                                            $smsg = "xmbx$($ino):$($xmbx.userprincipalname)" ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        } ;
                                        write-verbose "'xoUserMailbox':Test-exoMAPIConnectivity $($xmbx.userprincipalname)"
                                        $hSum.xoMapiTest = Test-xoMAPIConnectivity -identity $xmbx.userprincipalname ;
                                        $smsg = "Outlook (xoMAPI) Access Test Result:$($hsum.xoMapiTest.result)" ;
                                        if($hsum.xoMapiTest.result -eq 'Success'){
                                            write-host -foregroundcolor green $smsg ;
                                        } else {
                                            write-WARNING $smsg ;
                                        } ;
                                        if($getMobile){
                                            # $devstats = Get-exoMobileDeviceStatistics -Mailbox UPN
                                            #$smsg = "'xoMobileDeviceStats':$((get-alias ps1GetxMobilDevStats).definition) -Mailbox $($xmbx.userprincipalname)"
                                            $smsg = "'xoMobileDeviceStats':Get-xoMobileDeviceStatistics -Mailbox $($xmbx.userprincipalname)"
                                            if($verbose){
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                else{ write-verbose $smsg } ; 
                                            } ; 
                                            $hsum.xoMobileDeviceStats = Get-xoMobileDeviceStatistics -Mailbox $xmbx.userprincipalname -ea STOP ; 
                                            $smsg = "xoMobileDeviceStats Count:$(($hsum.xoMapiTest|measure).count)" ;
                                            write-host -foregroundcolor green $smsg ;
                                        } ; 
                                        if($getQuotaUsage){
                                            $pltGMbxStatX=[ordered]@{
                                                identity = $hSum.xoMailbox.exchangeguid ;
                                                ErrorAction = 'STOP' ; 
                                            } ;
                                            $smsg = "Get-xoMailboxStatistics  w`n$(($pltGMbxStatX|out-string).trim())"
                                            if($verbose){
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                else{ write-verbose $smsg } ; 
                                            } ; 
                                            $hSum.xoMailboxStats = Get-xoMailboxStatistics @pltGMbxStatX | select $prpStat;
                                            $smsg = "xoMailboxStats Count:$(($hsum.xoMapiTest|measure).count)" ;
                                            write-host -foregroundcolor green $smsg ;

                                            If($hSum.xoMailbox.UseDatabaseQuotaDefaults){
                                                $hSum.xoEffectiveQuotas = $hSum.xoMailboxStats | select @{N ='IssueWarningQuotaMB'; e={$_.DBIssueWarningQuotaMB}},
                                                @{n='ProhibitSendQuotaMB'; e={$_.DBProhibitSendQuotaMB}},
                                                @{n='ProhibitSendReceiveQuotaMB';e={$_.DBProhibitSendReceiveQuotaMB}}; 
                                            } else {
                                                $hSum.xoEffectiveQuotas = $hSum.xoMailbox | select @{n="IssueWarningQuotaMB";e={[math]::round($_.IssueWarningQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                                                @{n="ProhibitSendQuotaMB";e={[math]::round($_.ProhibitSendQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                                                @{n="ProhibitSendReceiveQuotaMB";e={[math]::round($_.ProhibitSendReceiveQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}} ;
                                            } ;  
                                            $hSum.xoNetOfSendReceiveQuotaMB = $hSum.xoEffectiveQuotas.ProhibitSendQuotaMB - $hSum.xoMailboxStats.TotalMailboxSizeMB ; 

                                            $pltGMbxStatX.add('IncludeOldestAndNewestItems',$true) ; 
                                            $smsg = "Get-xoMailboxFolderStatistics  w`n$(($pltGMbxStatX|out-string).trim())" ;
                                            if($verbose){
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                else{ write-verbose $smsg } ; 
                                            } ; 
                                            TRY{
                                                $hsum.xoMailboxFolderStats = Get-xoMailboxFolderStatistics @pltGMbxStatX  ;

                                                $smsg = "Export FolderStats to`n$(($ofMbxFolderStats|out-string).trim())" ;
                                                if($verbose){
                                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                    else{ write-verbose $smsg } ; 
                                                } ; 
                                                $hsum.xoMailboxFolderStats | ?{$_.ItemsInFolder -gt 0 -AND $_.identity -notmatch $rgxHiddn } | 
                                                    select $prpFldr | sort SizeMB -desc | export-csv  -path $ofMbxFolderStats -notype ;

                                            } CATCH {
                                                $ErrTrapd=$Error[0] ;
                                                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                                write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                                            } ; 
                                        } ; 
                                    } ;
                                    break ;
                                } ;
                            }
                            "MailUser" {
                                # external mail recipient, *not* in TTC - likely in other rgs, and migrated to remote EXOP enviro
                                #$hSum.OPRemoteMailbox=get-remotemailbox $txR.identity  ;
                                caad -silent -verbose:$false ;
                                #write-verbose "`$txR | $((get-alias ps1GetxMUsr).definition)..." ;
                                write-verbose "`$txR | Get-xoMailUser..." ;
                                $hSum.xoMUser = $txR | Get-xoMailUser -ResultSize $MaxRecips | select -first $MaxRecips ;
                                #write-verbose "`$txR | $((get-alias ps1GetxUser).definition)..." ;
                                write-verbose "`$txR | get-xoUser ..." ;
                                $hSum.xoUser = $txR | get-xouser -ResultSize $MaxRecips | select -first $MaxRecips ;
                                write-verbose "`$hSum.xoUser:`n$(($hSum.xoUser|out-string).trim())" ;
                                #write-verbose "get-AzureAdUser  -objectid $($hSum.xoUser.userPrincipalName)" ;
                                #$hSum.AADUser  = get-AzureAdUser  -objectid $hSum.xoMUser.userPrincipalName -Top $MaxRecips ;
                                write-verbose "`$hSum.xoMUser:`n$(($hSum.xoMUser|out-string).trim())" ;
                                #$Rpt += $hSum.OPRemoteMailbox.primarysmtpaddress ;
                                write-host "$($txR.ExternalEmailAddress): matches a MailUser object with UPN:$($hSum.xoMUser.userPrincipalName)" ;
                                if($outObject){

                                } else {
                                    $Rpt += $hSum.xoMUser.primarysmtpaddress ;
                                } ;
                                break ;
                            } ;
                            "GuestMailUser" {
                                #$hSum.OPRemoteMailbox=get-remotemailbox $txR.identity  ;
                                caad -silent -verbose:$false ;
                                #write-verbose "`$txR | $((get-alias ps1GetxUser).definition)..." ;
                                write-verbose "`$txR | get-xoUser..." ; 
                                $hSum.xoUser = $txR | get-xouser -ResultSize $MaxRecips | select -first $MaxRecips ;
                                write-verbose "`$hSum.xoUser:`n$(($hSum.xoUser|out-string).trim())" ;
                                write-verbose "get-AzureAdUser  -objectid $($hSum.xoUser.userPrincipalName)" ;
                                $hSum.txGuest = get-AzureAdUser  -objectid $hSum.xoUser.userPrincipalName -Top $MaxRecips | select -first $MaxRecips ;
                                write-verbose "`$hSum.txGuest:`n$(($hSum.txGuest|out-string).trim())" ;
                                #$Rpt += $hSum.OPRemoteMailbox.primarysmtpaddress ;
                                write-host "$($txR.ExternalEmailAddress): matches a Guest object with UPN:$($hSum.xoUser.userPrincipalName)" ;
                                if($hSum.txGuest.EmailAddresses -eq $null){
                                    write-warning "Guest appears to have damage from conficting replicated onprem MailContact, as it's EmailAddresses property is *blank*" ;
                                } ;
                                break ;
                            } ;
                            "MailContact" {
                                #$hSum.OPRemoteMailbox=get-remotemailbox $txR.identity  ;
                                #$Rpt += $hSum.OPRemoteMailbox.primarysmtpaddress ;
                                write-host "$($txR.primarysmtpaddress): matches an EXO MailContact with external Email: $($txR.primarysmtpaddress)" ;
                                break ;
                            } ;
                            "MailUniversalSecurityGroup" {
                                #$hSum.OPRemoteMailbox=get-remotemailbox $txR.identity  ;
                                #$Rpt += $hSum.OPRemoteMailbox.primarysmtpaddress ;
                                write-host "$($txR.primarysmtpaddress): matches an EXO MailUniversalSecurityGroup with Dname: $($txR.displayname)" ;
                                break ;
                            } ;
                            default {
                                write-warning "$((get-date).ToString('HH:mm:ss')):Unsupported RecipientType:($hSum.OPRcp.recipienttype). EXITING!" ;
                                Break ;
                            }
                        }
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Continue ;
                    } ;
                }  # loop-E $txR
                # contacts and guests won't drop with $hSum.OPRemoteMailbox or $hSum.OPMailbox populated
                TRY {
                    $pltGadu=[ordered]@{Identity = $null ; Properties='*' ;errorAction='SilentlyContinue'} ;
                    if($hSum.OPRemoteMailbox ){
                        $pltGadu.identity = $hSum.OPRemoteMailbox.samaccountname;
                    }elseif($hSum.OPMailbox){
                        $pltGadu.identity = $hSum.OPMailbox.samaccountname ;
                    } ;
                    if($pltGadu.identity){
                        write-verbose "Get-ADUser w`n$(($pltGadu|out-string).trim())" ;
                        # try a nested local trycatch, against a missing result
                        Try {
                            #Get-ADUser $DN -ErrorAction Stop ;
                            $hSum.ADUser =Get-ADUser @pltGadu | select -first $MaxRecips ;
                        } Catch [Microsoft.ActiveDirectory.Management.ADIdentityNotFoundException] {
                            write-warning "(no matching ADuser found:$($pltGadu.identity))" ;
                        } catch {
                            $ErrTrapd=$Error[0] ;
                            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Continue ;
                        } ;

                        write-verbose "`$hSum.ADUser:`n$(($hSum.ADUser|fl $propsADU | out-string).trim())" ;
                        $smsg = "(TOR USER, fed:$($TORMeta.adforestname))" ;
                        $hSum.Federator = $TORMeta.adforestname ;
                        write-host -Fore yellow $smsg ;
                        if($hSum.OPRemoteMailbox){
                            $smsg = "$(($hSum.OPRemoteMailbox |fl $propsMailx|out-string).trim())"
                            #$smsg += "`n-Title:$($hSum.ADUser.Title)"
                            $smsg += "`n$(($hSum.ADUser |fl 'Enabled','Description','whenCreated','whenChanged','Title' |out-string).trim())"
                        } ;
                        if($hSum.OPMailbox){
                            $smsg =  "$(($hSum.OPMailbox |fl $propsMailx|out-string).trim())" ;
                            $smsg += "`n$(($hSum.ADUser |fl 'Enabled','Description','whenCreated','whenChanged','Title' |out-string).trim())"
                        } ;
                        write-host $smsg ;
                    } ;
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Continue ;
                } ;

                if($outObject){

                } else {
                    $Rpt += $hSum.xoMailbox.primarysmtpaddress ;
                } ;
                $ino = 0 ;
                foreach($xmbx in $hSum.xoMailbox){
                    $ino++;
                    if($hSum.xoMailbox -isnot [system.array]){
                        $smsg = "xmbx$($ino):$($xmbx.userprincipalname)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    if($xmbx.isdirsynced){
                        # can be federated to VEN|CMW|Toro
                        switch -regex ($xmbx.primarysmtpaddress.split('@')[1]){
                            $CMWMeta.rgxOPFederatedDom {
                                $smsg="(CMW USER, fed:$($CMWMeta.adforestname))" ;
                                $hSum.Federator = $CMWMeta.adforestname ;
                            }
                            $TORMeta.rgxOPFederatedDom {
                                $smsg="(TOR USER, fed:$($TORMeta.adforestname))" ;
                                $hSum.Federator = $TORMeta.adforestname ;
                            }
                            $VENMeta.rgxOPFederatedDom {
                                $smsg="(VEN USER, fed:$($venmeta.o365_TenantLabel))" ;
                                $hSum.Federator = $VENMETA.o365_TenantLabel ;
                            }
                            $INTMeta.rgxOPFederatedDom {
                                $smsg="(INT USER, fed:$($INTmeta.o365_TenantLabel))" ;
                                $hSum.Federator = $INTMETA.o365_TenantLabel ;
                            }

                        } ;
                    } elseif($hSum.xoMuser.IsDirSynced){
                        switch -regex ($xmbx.primarysmtpaddress.split('@')[1]){
                            $CMWMeta.rgxOPFederatedDom {
                                $smsg="(CMW USER, fed:$($CMWMeta.adforestname))" ;
                                $hSum.Federator = $CMWMeta.adforestname ;
                            }
                            $TORMeta.rgxOPFederatedDom {
                                $smsg="(TOR USER, fed:$($TORMeta.adforestname))" ;
                                $hSum.Federator = $TORMeta.adforestname ;
                            }
                            $VENMeta.rgxOPFederatedDom {
                                $smsg="(VEN USER, fed:$($venmeta.o365_TenantLabel))" ;
                                $hSum.Federator = $VENMETA.o365_TenantLabel ;
                            }
                            $INTMeta.rgxOPFederatedDom {
                                $smsg="(INT USER, fed:$($INTmeta.o365_TenantLabel))" ;
                                $hSum.Federator = $INTMETA.o365_TenantLabel ;
                            }
                        } ;
                    }else{
                        [regex]$rgxTenDom = [regex]::escape("@$($tormeta.o365_TenantDomain)")
                        if($hsum.xoRcp.primarysmtpaddress -match $rgxTenDom){
                                $smsg="(CLOUD-1ST ACCT, unfederated)" ;
                                $hSum.Federator = $TORMeta.o365_TenantDom ;

                        } else {
                            $smsg="(CLOUD-1ST ACCT, unfederated)" ;
                            $hSum.Federator = $TORMeta.o365_TenantDom ;
                        } ;
                    } ;
                } ;  # loop-E
                write-host -Fore yellow $smsg ;
                # skip user lookup if guest already pulled it
                if(!$hSum.xoUser){
                    $ino = 0 ;
                    foreach($xmbx in $hSum.xoMailbox){
                        #write-verbose "$((get-alias ps1GetxUser).definition) -id $($xmbx.UserPrincipalName)"
                        write-verbose "get-xoUser -id $($xmbx.UserPrincipalName)"
                        $hSum.xoUser += get-xouser -id $xmbx.UserPrincipalName -ResultSize $MaxRecips ;
                        write-verbose "`$hSum.xoUser:`n$(($hSum.xoUser|out-string).trim())" ;
                    } ;
                }
                if($hSum.xoMailbox){
                    $ino = 0 ;
                    foreach($xmbx in $hSum.xoMailbox){
                        $ino++ ;
                        if($hSum.xoMailbox -isnot [system.array]){
                            $smsg = "xmbx$($ino):$($xmbx.userprincipalname)" ;
                            write-host $smsg ;
                        } ;
                        write-host -foreground yellow "=get-xMbx:> " -nonewline;
                        write-host "$(($hSum.xoMailbox |fl ($propsMailx |?{$_ -notmatch '(sam.*|dist.*)'})|out-string).trim())`n-Title:$($hSum.xoUser.Title)";
                    } ;

                    if($getMobile){
                        write-host -foreground yellow "===`$hsum.xoMobileDeviceStats: " #-nonewline;
                        $ino = 0 ;
                        foreach($xmob in $hsum.xoMobileDeviceStats){
                            $ino++ ;
                            <#if($hsum.xoMobileDeviceStats -isnot [system.array]){
                                $smsg = "xmob$($ino):$($xmob.userprincipalname)" ;
                                write-host $smsg ;
                            } ;
                            write-host -foreground yellow "=get-xMob:> " -nonewline;
                            write-host "$(($xmob.userprincipalname |fl ($propsMailx |?{$_ -notmatch '(sam.*|dist.*)'})|out-string).trim())`n-Title:$($hSum.xoUser.Title)";
                            #>
                            if($hsum.xoMobileDeviceStats -is [system.array]){
                                 write-host -foreground yellow "=get-xMob$($ino):> " #-nonewline;
                            } else { 
                                write-host -foreground yellow "=get-xMobileDev:> " #-nonewline;
                            } ; 
                            $smsg = "$(($xmob | select $propsMobL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                            $smsg += "`n$(($xmob | select $propsMobL2 |out-markdowntable @MDtbl |out-string).trim())" ;
                            write-host $smsg ;
                        } ;

                    } ; 

                }elseif($hSum.xoMUser){
                    write-host "=get-xMUSR:>`n$(($hSum.xoMUser |fl ($propsMailx |?{$_ -notmatch '(sam.*|dist.*)'})|out-string).trim())`n-Title:$($hSum.xoUser.Title)";
                }elseif($hSum.txGuest){
                    write-host "=get-AADU:>`n$(($hSum.txGuest |fl userp*,PhysicalDeliveryOfficeName,JobTitle|out-string).trim())"
                } ;
                TRY {
                    #write-verbose "$((get-alias ps1GetxRcp).definition) -Filter {Members -eq '$($hSum.xoUser.DistinguishedName)'}`n -RecipientTypeDetails GroupMailbox,MailUniversalDistributionGroup,MailUniversalSecurityGroup"
                    write-verbose "get-xorecipient -Filter {Members -eq '$($hSum.xoUser.DistinguishedName)'}`n -RecipientTypeDetails GroupMailbox,MailUniversalDistributionGroup,MailUniversalSecurityGroup"
                    $hSum.xoMemberOf = get-xorecipient -Filter "Members -eq '$($hSum.xoUser.DistinguishedName)'" -RecipientTypeDetails GroupMailbox,MailUniversalDistributionGroup,MailUniversalSecurityGroup ;
                    write-verbose "`$hSum.xoMemberOf:`n$(($hSum.xoMemberOf|out-string).trim())" ;
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Continue ;
                } ;
            } else {
                write-warning "(no matching EXOP or EXO recipient object:$($usr))"
                # do near Lname[0-3]* searches for comparison
                if($hSum.lname){
                    write-warning "Lname ($($hSum.lname) parsed from input),`nattempting similar LName g-rcp:...`n(up to `$MaxRecips:$($MaxRecips))" ;
                    $lname = $hsum.lname ;
                    #$fltrB = "displayname -like '*$lname*'" ;
                    #write-verbose "RETRY:get-recipient -filter {$($fltr)}" ;
                    #get-recipient "$($txusr.lastname.substring(0,3))*"| sort name
                    $substring = "$($hSum.lname.substring(0,3))*"

                    write-host "get-recipient -id $($substring) -ea 0 |?{$_.recipienttypedetails -ne 'MailContact'} :"
                    if($hSum.Rcp=get-recipient -id $substring -ea 0 -ResultSize $MaxRecips | select -first $MaxRecips |?{$_.recipienttypedetails -ne 'MailContact'}){
                        #$hSum.Rcp | write-output ;
                        # $propsRcpTbl
                        write-host -foregroundcolor yellow "`n$(($hSum.Rcp | ft -a $propsRcpTbl |out-string).trim())" ;
                    } ;
                    #write-host "$((get-alias ps1GetxRcp).definition) -id $($substring) -ea 0 |?{$_.recipienttypedetails -ne 'MailContact'} : "
                    write-host "get-xorecipient -id $($substring) -ea 0 |?{$_.recipienttypedetails -ne 'MailContact'} : "
                    if($hSum.xoRcp=get-xorecipient -id $substring -ea 0 -ResultSize $MaxRecips | select -first $MaxRecips |?{$_.recipienttypedetails -ne 'MailContact'}){
                        #$hSum.xoRcp | write-output ;
                        write-host -foregroundcolor yellow "`n$(($hSum.xoRcp | ft -a $propsRcpTbl |out-string).trim())" ;
                    } ;


                } ;


            } ; # don't break, doesn't continue loop

            # 10:42 AM 9/9/2021 force populate the xoMailbox, ALWAYS - need for xbrain ids
            #if($hSum.xoRcp.recipienttypedetails -eq 'UserMailbox' -AND -not($hSum.xoMailbox)){
            # accomodate array xorcp
            if(($hSum.xoRcp|?{$_.recipienttypedetails -eq 'UserMailbox'}) -AND -not($hSum.xoMailbox)){
                #write-verbose "$((get-alias ps1GetxMbx).definition) w`n$(($pltGMailObj|out-string).trim())" ;
                write-verbose "get-xomailbox w`n$(($pltGMailObj|out-string).trim())" ;
                if($hSum.xoMailbox=get-xomailbox @pltGMailObj -ea 0| select -first $MaxRecips ){
                    $ino = 0 ;
                    $mapiResults = @() ;
                    foreach($xmbx in $hSum.xoMailbox){
                        $ino++ ;
                        if($hSum.xoMailbox -is [system.array]){
                            $msgprefix = "xmbx$($ino):" ;
                        } else { $msgprefix = $null } ;
                        $smsg = $msgprefix, "`$hSum.xoMailbox:`n$(($xmbx|out-string).trim())" -join ' ' ;
                        write-verbose $smsg ;
                        $smsg = $msgprefix,"'xoUserMailbox':Test-exoMAPIConnectivity $($xmbx.userprincipalname)"  -join ' ' ;
                        write-verbose $smsg ;
                       $mapiResults += Test-xoMAPIConnectivity -identity $xmbx.userprincipalname ;
                        $smsg = "Outlook (xoMAPI) Access Test Result:$($mapiResults[$ino - 1].result)" ;
                        if($mapiResults[$ino - 1].result -eq 'Success'){
                            write-host -foregroundcolor green $smsg ;
                        } else {
                            write-WARNING $smsg ;
                        } ;
                    } ;
                    $hSum.xoMapiTest = $mapiResults ;
                } ;
            } ;
            # 3:42 PM 9/25/2023 bring in new quota support as well - it's not populated in the oprcp first test
            if($getQuotaUsage){
                if(($hSum.xoRcp|?{$_.recipienttypedetails -match 'UserMailbox|SharedMailbox|RoomMailbox|EquipmentMailbox'}) -AND -not($hSum.xoMailboxStats)){
                    $pltGMbxStatX=[ordered]@{
                        identity = $hSum.xoMailbox.exchangeguid ;
                        ErrorAction = 'STOP' ; 
                    } ;
                    $smsg = "Get-xoMailboxStatistics  w`n$(($pltGMbxStatX|out-string).trim())"
                    if($verbose){
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-verbose $smsg } ; 
                    } ; 
                    $hSum.xoMailboxStats = Get-xoMailboxStatistics @pltGMbxStatX | select $prpStat;
                    $smsg = "xoMailboxStats Count:$(($hsum.xoMapiTest|measure).count)" ;
                    write-host -foregroundcolor green $smsg ;

                    If($hSum.xoMailbox.UseDatabaseQuotaDefaults){
                        $hSum.xoEffectiveQuotas = $hSum.xoMailboxStats | select @{N ='IssueWarningQuotaMB'; e={$_.DBIssueWarningQuotaMB}},
                        @{n='ProhibitSendQuotaMB'; e={$_.DBProhibitSendQuotaMB}},
                        @{n='ProhibitSendReceiveQuotaMB';e={$_.DBProhibitSendReceiveQuotaMB}}; 
                    } else {
                        $hSum.xoEffectiveQuotas = $hSum.xoMailbox | select @{n="IssueWarningQuotaMB";e={[math]::round($_.IssueWarningQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                        @{n="ProhibitSendQuotaMB";e={[math]::round($_.ProhibitSendQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                        @{n="ProhibitSendReceiveQuotaMB";e={[math]::round($_.ProhibitSendReceiveQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}} ;
                    } ;  
                    $hSum.xoNetOfSendReceiveQuotaMB = $hSum.xoEffectiveQuotas.ProhibitSendQuotaMB - $hSum.xoMailboxStats.TotalMailboxSizeMB ; 

                    $pltGMbxStatX.add('IncludeOldestAndNewestItems',$true) ; 
                    $smsg = "Get-xoMailboxFolderStatistics  w`n$(($pltGMbxStatX|out-string).trim())" ;
                    if($verbose){
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-verbose $smsg } ; 
                    } ; 
                    $smsg = "(-getQuotaUsage:running lengthy Get-xoMailboxFolderStatistics...)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    TRY{
                        $hsum.xoMailboxFolderStats = Get-xoMailboxFolderStatistics @pltGMbxStatX  ;

                        $smsg = "Export FolderStats to`n$(($ofMbxFolderStats|out-string).trim())" ;
                        if($verbose){
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-verbose $smsg } ; 
                        } ; 
                        $hsum.xoMailboxFolderStats | ?{$_.ItemsInFolder -gt 0 -AND $_.identity -notmatch $rgxHiddn } | 
                            select $prpFldr | sort SizeMB -desc | export-csv  -path $ofMbxFolderStats -notype ;

                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                        write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                    } ; 
                    
                }
            } ; 

            #$pltgMsoUsr=@{UserPrincipalName=$null ; MaxResults= $MaxRecips; ErrorAction= 'STOP' } ;
            # maxresults is documented:
            # but causes a fault with no $error[0], doesn't seem to be functional param, post-filter
            # ren refs of $pltgMsoUsr -> $pltgAADUsr
            $pltgAADUsr=@{UserPrincipalName=$null ; ErrorAction= 'STOP' } ;
            if($hSum.ADUser){$pltgAADUsr.UserPrincipalName = $hSum.ADUser.UserPrincipalName }
            elseif($hSum.xoMailbox){$pltgAADUsr.UserPrincipalName += $hsum.xoMailbox.UserPrincipalName }
            elseif($hSum.xoMUser){$pltgAADUsr.UserPrincipalName = $hSum.xoMUser.UserPrincipalName }
            elseif($hSum.txGuest){$pltgAADUsr.UserPrincipalName = $hSum.txGuest.userprincipalname }
            else{} ;

            if($pltgAADUsr.UserPrincipalName){

                if(-not($hSum.AADUser)){
                    write-host -foregroundcolor yellow "=get-AADuser $($pltgAADUsr.UserPrincipalName)>:" ;
                    TRY{
                        caad  -Verbose:$false -silent ;
                        write-verbose "get-AzureAdUser  -objectid $($pltgAADUsr.UserPrincipalName)" ;
                        # have to postfilter, if want specific count -maxresults catch's with no $error[0]
                        $hSum.AADUser  = get-AzureAdUser  -objectid $pltgAADUsr.UserPrincipalName  | select -first $MaxRecips;  ;
                        <# for remote federated, AADU brings in summary of remote ADUser:
                            $hsum.aaduser.ExtensionProperty
                            Key                                                       Value
                            ---                                                       -----
                            odata.metadata                                            https://graph.windows.net/.../$metadata#directoryObjects/@Element
                            odata.type                                                Microsoft.DirectoryServices.User
                            createdDateTime                                           1/13/2021 4:14:48 PM
                            employeeId
                            onPremisesDistinguishedName                               CN=XXX,OU=XXX,...
                            thumbnailPhoto@odata.mediaEditLink                        directoryObjects/.../Microsoft.DirectoryServices.User/thumbnailPhoto
                            thumbnailPhoto@odata.mediaContentType                     image/Jpeg
                            userIdentities                                            []
                            extension_9d88b2c96135413e88afff067058e860_employeeNumber 8621
                             $hsum.aaduser.ExtensionProperty.onPremisesDistinguishedName
                            CN=XXX,OU=XXX,...
                        #>
                        #write-verbose "`$hSum.AADUser:`n$(($hSum.AADUser|out-string).trim())" ;
                        # ObjectId                             DisplayName   UserPrincipalName      UserType

                        #lic pull: $hSum.AADUser | Get-AzureADUserLicenseDetail -ea STOP | select -exp SkuPartNumber
                        write-verbose "`$hsum.AADUserLics = AADU | Get-AzureADUserLicenseDetail -ea STOP | select -exp SkuPartNumber" ;
                        $hsum.AADUserLics =  $hSum.AADUser | Get-AzureADUserLicenseDetail -ea STOP | select -exp SkuPartNumber ; 

                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Continue ;
                    } ;

                } ;

                if(-not($hSum.AADUserMgr) -AND $hSum.AADUser ){
                    write-host -foregroundcolor yellow "=get-AADuserManager $($hSum.AADUser.UserPrincipalName)>:" ;
                    TRY{
                        caad  -Verbose:$false -silent ;
                        write-verbose "get-AzureAdUserManager  -objectid $($hSum.AADUser.UserPrincipalName)" ;
                        # have to postfilter, if want specific count -maxresults catch's with no $error[0]
                        $hSum.AADUserMgr  = get-AzureAdUserManager  -objectid $hSum.AADUser.UserPrincipalName  | select -first $MaxRecips;  ;
                        #write-verbose "`$hSum.AADUserMgr:`n$(($hSum.AADUserMgr|out-string).trim())" ;
                        # (returns a full AADUser obj for the mgr)
                        # we can output the DN: $hSum.AADUserMgr.ExtensionProperty.onPremisesDistinguishedName
                        # useful for determining what 'org' user should be for email address assigns - they get same addr dom as their mgr
                        # |ft -a  $propsaadmgr
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Continue ;
                    } ;

                } ;

                # display user info:
                if(-not($hSum.ADUser)){
                    # remote fed, use AADU to proxy remote AD hybrid info:
                    write-host -foreground yellow "===`$hSum.AADUser: " #-nonewline;
                    $smsg = "$(($hSum.AADUser| select $propsAADL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                    $smsg += "`n$(($hSum.AADUser|select $propsAADL2 |out-markdowntable @MDtbl|out-string).trim())" ;
                    $smsg += "`n$(($hSum.AADUser|select $propsAADL3 |out-markdowntable @MDtbl|out-string).trim())" ;
                    $smsg += "`n$(($hSum.AADUser|select $propsAADL4 |out-markdowntable @MDtbl|out-string).trim())" ;
                    $smsg += "`n$(($hSum.AADUser|select $propsAADL5 |out-markdowntable @MDtbl|out-string).trim())" ;
                    #$hsum.aaduser.ExtensionProperty.onPremisesDistinguishedName
                    if($hSum.Federator -ne $TORMeta.adforestname){
                        $smsg += "`n$($hSum.Federator):Remote ADUser.DN:`n$(($hsum.aaduser.ExtensionProperty.onPremisesDistinguishedName|out-string).trim())" ;
                    }  ;

                    write-host $smsg

                    # assert the real names from the user obj
                    $hSum.dname = $hSum.AADUser.DisplayName ;
                    $hSum.fname = $hSum.AADUser.GivenName ;
                    $hSum.lname = $hSum.AADUser.Surname ;

                } else {
                    #write-verbose "`$hSum.AADUser:`n$(($hSum.AADUser| ft -auto ObjectId,DisplayName,UserPrincipalName,UserType |out-string).trim())" ;
                    # defer to ADUser details
                    #"$(($hSum.ADUser |fl $propsMailx |out-markdowntable @MDtbl|out-string).trim())"
                    <#$propsADL1 = 'UserPrincipalName','DisplayName','GivenName','Surname','Title' ;
                    $propsADL2 = 'Company','Department','PhysicalDeliveryOfficeName' ;
                    $propsADL3 = 'StreetAddress','City','State','PostalCode','TelephoneNumber','MobilePhone' ;
                    #>
                    write-host -foreground yellow "===`$hSum.ADUser: " #-nonewline;
                    $smsg = "$(($hSum.ADUser| select $propsADL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                    $smsg += "`n$(($hSum.ADUser|select $propsADL2 |out-markdowntable @MDtbl|out-string).trim())" ;
                    $smsg += "`n$(($hSum.ADUser|select $propsADL3 |out-markdowntable @MDtbl|out-string).trim())" ;
                    $smsg += "`n$(($hSum.ADUser|select $propsADL4 |out-markdowntable @MDtbl|out-string).trim())" ;
                    <# $propsADL5 = 'whenCreated','whenChanged' ; 
                    $propsADL6 = @{Name='Desc';Expression={$_.Description }} ;
                    #>
                    $smsg += "`n$(($hSum.ADUser|select $propsADL5 |out-markdowntable @MDtbl|out-string).trim())" ;
                    # stick desc on trailing line $propsADL5
                    #$smsg += "`n$(($hSum.ADUser|select $propsADL5 |out-markdowntable @MDtbl|out-string).trim())" ;
                    # flip L5 to fl (suppress crlf wrap)
                    $smsg += "`n$(($hSum.ADUser|select $propsADL6 |Format-List|out-string).trim())" ;

                    # moved DN into adl4, w enabled
                    #$smsg += "`n`$ADUser.DN:`n$(($hsum.aduser.DistinguishedName|out-string).trim())" ;
                    #$smsg += "`n$($hSum.ADUser|select Enabled,distinguishedname| convertTo-MarkdownTable -NoDashRow -Border) `$ADUser.DN:`n$(($hsum.aduser.DistinguishedName|out-string).trim())" ;
                    write-host $smsg ;

                    # assert the real names from the user obj
                    $hSum.dname = $hSum.ADUser.DisplayName ;
                    $hSum.fname = $hSum.ADUser.GivenName ;
                    $hSum.lname = $hSum.ADUser.Surname ;
                } ;

                # acct enabled/disabled: .aduser.Enbabled & .aaduser.AccountEnabled
                if($hSum.aduser){
                    if($hSum.aduser.Enabled){} else {
                        $smsg = "ADUser:$($hSum.ADUser.userprincipalname) AD Account is *DISABLED!*"
                        write-warning $smsg ;
                    } ;
                } ;
                # acct enabled/disabled: .aduser.Enbabled & .aaduser.AccountEnabled
                if($hSum.AADUser){
                    if($hSum.aaduser.AccountEnabled){} else {
                        $smsg = "AADUser:$($hSum.AADUser.userprincipalname) AAD Account is *DISABLED!*"
                        write-warning $smsg ;
                    } ;
                } ;
                if($hSum.ADUser){$hSum.LicenseGroup = $hSum.ADUser.memberof |?{$_ -match $rgxOPLic }}

                if($hSum.ADUser){$hSum.LicenseGroup = $hSum.ADUser.memberof |?{$_ -match $rgxOPLic }}
                elseif($hSum.xoMemberOf){$hSum.LicenseGroup = $hSum.xoMemberOf.Name |?{$_ -match $rgxXLic}}
                #if(!($hSum.LicenseGroup) -AND ($hSum.MsolUser.licenses.AccountSkuId -contains "$($TORMeta.o365_TenantDom.tolower()):ENTERPRISEPACK")){$hSum.LicenseGroup = '(direct-assigned E3)'} ;
                # $hSum.AADUser ; $aadu | Get-AzureADUserLicenseDetail  | select -exp SkuPartNumber
                #if(!($hSum.LicenseGroup) -AND ( $hsum.AADUserLics  -contains "$($TORMeta.o365_TenantDom.tolower()):ENTERPRISEPACK")){$hSum.LicenseGroup = '(direct-assigned E3)'} ;
                # no dom, with aadu licenses
                if(!($hSum.LicenseGroup) -AND ( $hsum.AADUserLics  -contains "ENTERPRISEPACK")){$hSum.LicenseGroup = '(direct-assigned E3)'} ;
                if($hSum.LicenseGroup){$smsg = "LicenseGroup:$($hSum.LicenseGroup)"}
                else{$smsg = "LicenseGroup:(unresolved, direct-assigned other?)" } ;
                write-host $smsg ;

                if($hSum.AADUserMgr){
                    #($hSum.AADUserMgr) |ft -a  $propsaadmgr
                    #$smsg += "`nAADUserMgr:`n$(($hSum.AADUserMgr|select $propsAadMgr |out-markdowntable @MDtbl|out-string).trim())" ;
                    # $propsAADMgrL1, $propsAADMgrL2
                    write-host -foreground yellow "===`$hSum.AADUserMgr: " #-nonewline;
                    $smsg = "$(($hSum.AADUserMgr| select $propsAADMgrL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                    #$smsg += "`n$(($hSum.AADUserMgr|select $propsAADMgrL2 |out-markdowntable @MDtbl|out-string).trim())" ;
                    $smsg += "`n$(($hSum.AADUserMgr|Format-List $propsAADMgrL2|out-string).trim())" ;
                    #$smsg += "`n$(($hSum.AADUserMgr|select $propsADL3 |out-markdowntable @MDtbl|out-string).trim())" ;
                } else {
                    $smsg += "(AADUserMgr was blank, or unresolved)" ;
                } ;
                write-host $smsg ;

                if($getQuotaUsage -AND $hSum.xoMailbox){

                    $smsg += "`n`nLicenses::`n$(($hsum.AADUserLics -join ', ' |out-string).trim())`n`n" ; 
                    $smsg += "`nwhich specify the following size limits:`n$(($hSum.xoEffectiveQuotas| fl |out-string).trim())`n(UseDatabaseQuotaDefaults:$($hSum.xoMailbox.UseDatabaseQuotaDefaults))" ; 
                    $smsg += "`n`nCurrent TotalMailboxSizeMB: $($hSum.xoMailboxStats.TotalMailboxSizeMB)`n`n" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success

                    if($hSum.xoNetOfSendReceiveQuotaMB -lt 0){
                        $smsg = "`n`n*** QuotaStatus: Mailbox is *OVER* mandated SendReceiveQuotaMB by $(($hSum.xoNetOfSendReceiveQuotaMB * -1).tostring("N")) megabytes ***`n`n" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                    } else { 
                        $smsg = "QuotaStatus: Mailbox is below mandated SendReceiveQuotaMB by $(($hSum.xoNetOfSendReceiveQuotaMB).tostring("N")) megabytes" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    } ;

                    $smsg = "`nWith the following non-zero folder metrics`n`n$((import-csv $ofMbxFolderStats | ft -auto |out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success

                    $smsg = "`n===`output to::`n$($ofMbxFolderStats)`n" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    
                    # 10:08 AM 2/27/2024: Add: .xoMailboxFolderStats DiscoveryHolds folder only has ItemsInFolder -gt 0 if there's a hold
                    if($hSum.xoMailbox.LitigationHoldEnabled -OR $hSum.xoMailbox.InPlaceHolds -OR $hSum.xoMailbox.ComplianceTagHoldApplied -OR $hSum.xoMailbox.DelayHoldApplied -OR $hSum.xoMailbox.DelayReleaseHoldApplied -OR ($hSum.xoMailboxFolderStats | ?{$_.name -match 'DiscoveryHolds' -AND $_.ItemsInFolder -gt 0})  ){
                        $smsg = "`n`nEVIDENCE OF LEGAL HOLD DETECTED!:`n$(($hSum.xoMailbox | fl $prpMbxHold|out-string).trim())`n`n" ; 
                        if($hSum.xoMailboxFolderStats | ?{$_.name -match 'DiscoveryHolds' -AND $_.ItemsInFolder -gt 0}){
                            $smsg += "`n$(($hSum.xoMailboxFolderStats | ?{$_.name -match '^DiscoveryHolds$'} | ft -a $prpFldrLH|out-string).trim())`n`n" ; 
                            $smsg += "`n- DiscoveryHolds folder: If In-Place Hold is enabled or if a Microsoft 365 or Office 365 retention policy is assigned to the mailbox, this subfolder contains all items that meet the hold query parameters and are hard deleted." ; 
                            $smsg += "`n- DiscoveryHolds folder.NewestItem: Will reflect *last time LegalHold captured an item* (e.g. if/when LH was disabled and stopped holding traffic, if in the past)`n"; 
                        } 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                    } else {
                        $smsg = "`n`n*No* evidence Of Legal Hold detected:`n$(($hSum.xoMailbox | fl $prpMbxHold|out-string).trim())`n`n" ; 
                        $smsg = "`n$(($hSum.xoMailboxFolderStats | ?{$_.name -match 'DiscoveryHolds'} | ft -a $prpFldrLH|out-string).trim())`n`n" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success

                    } ;  

                    $hsInfo = @"

## System Folder Types and purposes:

- Recoverable Items: Items in the Recoverable Items folder aren't calculated toward the user's mailbox quota. In Exchange Online, the Recoverable Items folder has its own quota. In Exchange Online, the quota for the Recoverable Items folder (in the user's primary mailbox) is automatically increased to 100 GB when a mailbox is placed on Litigation Hold or In-Place Hold. 

    ### Subfolders of Recoverable Items:
    
    *  Deletions: This subfolder contains all items deleted from the Deleted Items folder. (In Outlook, a user can soft delete an item by pressing Shift+Delete.) This subfolder is available to users through the Recover Deleted Items feature in Outlook and Outlook on the web.
    
    *  Versions: If In-Place Hold, Litigation Hold, or a Microsoft 365 or Office 365 retention policy is enabled, this subfolder contains the original copy of the item and also if the item is modified multiple times, a copy of the item before modification is saved.
    
    *  Purges: If either Litigation Hold or single item recovery is enabled, this subfolder contains all items that are hard deleted. 
    
    *  Audits: If mailbox audit logging is enabled for a mailbox, this subfolder contains the audit log entries. 
    
    *  DiscoveryHolds: If In-Place Hold is enabled or if a Microsoft 365 or Office 365 retention policy is assigned to the mailbox, this subfolder contains all items that meet the hold query parameters and are hard deleted.

## Deleted item retention
  An item is considered to be soft deleted in the following cases:
    • A user deletes an item or empties all items from the Deleted Items folder.
    • A user presses Shift+Delete to delete an item from any other mailbox folder.
    
  Soft-deleted items are moved to the Deletions subfolder of the Recoverable Items folder. This provides an additional layer of protection so users can recover deleted items without requiring Help desk intervention. Users can use the Recover Deleted Items feature in Outlook or Outlook on the web to recover a deleted item. Users can also use this feature to permanently delete an item. 
  
  Items remain in the Deletions subfolder until the deleted item retention period is reached. The deleted item retention period for Exchange Online is 30 days (Toroco). In addition to a deleted item retention period, the Recoverable Items folder is also subject to quotas. 
  
  When the deleted item retention period expires, the item is completely removed from Exchange Online.

"@ ; 
                    write-host $hsInfo ;   

                } ; 
            } ;

            # do a split-brain/nobrain check
            # switch ($hSum.OPRcp.recipienttypedetails){
            <#
            AD - Users (more effective)
            (sAMAccountType=805306368)
            AD - Users - disabled
            (&(sAMAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=2))
            AD - Users - dont require password
            (&(sAMAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=32))
            AD - Users - mail enabled
            (&(sAMAccountType=805306368)(mailNickname=*))
            AD - Users - password never expires
            (&(sAMAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=65536))

            Select ($hSum.ADUser.sAMAccountType){
                '0'  { $SAType = "SAM_DOMAIN_OBJECT"}
                '268435456' { $SAType = "SAM_GROUP_OBJECT"}
                '268435457' { $SAType = "SAM_NON_SECURITY_GROUP_OBJECT"}
                '536870912' { $SAType = "SAM_ALIAS_OBJECT"}
                '536870913' { $SAType = "SAM_NON_SECURITY_ALIAS_OBJECT"}
                '805306368' { $SAType = "SAM_NORMAL_USER_ACCOUNT"}
                '805306369' { $SAType = "SAM_MACHINE_ACCOUNT"}
                '805306370' { $SAType = "SAM_TRUST_ACCOUNT"}
                '1073741824' { $SAType = "SAM_APP_BASIC_GROUP"}
                '1073741825' { $SAType = "SAM_APP_QUERY_GROUP"}
                '2147483647' { $SAType = "SAM_ACCOUNT_TYPE_MAX"}
                default { $SAType = "UNKNOWN" }
            } ;
            #>
            # ($hSum.ADUser.sAMAccountType -eq '805306368')

            if($hsum.ADUser){
                $hsum.IsADDisabled = [boolean]($hsum.ADUser.Enabled -eq $true) ; 
             } else {
                write-verbose "(no ADUser found)" ;
            } ;
            if($hsum.AADUser){
                $hsum.IsAADDisabled = [boolean]($hsum.AADUser.AccountEnabled -eq $true) ; 
                $hsum.isDirSynced = [boolean]($hsum.AADUser.DirSyncEnabled  -eq $True)
            } else {
                write-verbose "(no AADUser found)" ;
            } ;
            # shift test to aadu
            if($hSum.AADUser){
                $hsum.IsLicensed = [boolean]($hSum.AADUser.assignedlicenses.count -gt 0)
            } else {
                write-verbose "(no AADUser found)" ;
            } ;

            $smsg = "`n"
            if(($hsum.xoRcp.RecipientTypeDetails -match '(UserMailbox|MailUser)') -AND $hsum.IsLicensed -AND $hSum.xomailbox -AND $hSum.OPMailbox){
                <#OPRcp, xorcp, OPMailbox, OPRemoteMailbox, xoMailbox#>
                $smsg += "SPLITBRAIN!:$($hSum.ADUser.userprincipalname).IsLic'd & has *BOTH* xoMbx & opMbx!" ;
                $hsum.IsSplitBrain = $true ;
            }elseif(($hsum.xoRcp.RecipientTypeDetails -match '(UserMailbox|MailUser)') -AND -not($hsum.IsLicensed) -AND $hSum.xomailbox -AND $hSum.OPMailbox){
                <#OPRcp, xorcp, OPMailbox, OPRemoteMailbox, xoMailbox#>
                $smsg += "SPLITBRAIN!:$($hSum.ADUser.userprincipalname).IsLic'd & has *BOTH* xoMbx & opMbx!`nAND is *UNLICENSED!*" ;
                $hsum.IsSplitBrain = $true ;
            } elseif(($hsum.xoRcp.RecipientTypeDetails -match '(UserMailbox|MailUser)') -AND $hsum.IsLicensed -AND -not($hSum.xomailbox) -AND -not($hSum.OPMailbox)){
                $smsg += "NOBRAIN! W LICENSE!:$($hSum.ADUser.userprincipalname).IsLic'd &  has *NEITHER* xoMbx OR opMbx!" ;
                $hsum.IsNoBrain = $true ;
            } elseif (($hsum.xoRcp.RecipientTypeDetails -match '(UserMailbox|MailUser)') -AND -not($hsum.IsLicensed) -AND -not($hSum.xomailbox) -AND -not($hSum.OPMailbox)){
                $smsg += "NOBRAIN! *WO* LICENSE! (TERM?):$($hSum.ADUser.userprincipalname) NOT licensed'd &  has *NEITHER* xoMbx OR opMbx!" ;
                $hsum.IsNoBrain = $true ;
            } elseif($hsum.IsLicensed -eq $false){
                $smsg += "$($hSum.ADUser.userprincipalname) Is *UNLICENSED*!" ;
                
                $hsum.IsLicensed = $false ;
            } ELSE { } ;

            if($hsum.IsSplitBrain -OR $hsum.IsNoBrain -OR -not $hsum.IsLicensed){
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            } else { 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            } ; 

            if($hsum.IsNoBrain){
                switch ($hSum.Federator) {
                    $TORMeta.adforestname {$rgxTermOU = $TORMeta.rgxTermUserOUs }
                    $CMWMeta.adforestname  {$rgxTermOU = $CMWMeta.rgxTermUserOUs }
                    $VENMETA.o365_TenantLabel  {$rgxTermOU = $NULL }
                    $TORMeta.o365_TenantDom   {$rgxTermOU = $NULL }
                    default {
                        write-warning "UNRECOGNIZED `$hsum.FEDERATOR!:$($hSum.Federator)" ;
                    }
                }

                if($rgxTermOU -AND $hsum.ADUser){
                    if($hsum.ADUser.distinguishedname -match $rgxTermOU){
                        $hsum.IsDisabledOU = $true ;
                        $smsg += "`n--ADUser:$($hsum.ADUser.samaccountname) is within a *DISABLED* OU (likely TERM)" ;
                    } else {
                        $hsum.IsDisabledOU = $false ;
                        $smsg += "`n--ADUser:$($hsum.ADUser.samaccountname) is *NOT* in a DISABLED OU (improperly offboarded TERM?)" ;
                    } ;
                } else {
                    $smsg +=  "`n--Cloud-only or other non-AD-resolvable host" ;
                }
                if($hsum.ADUser){
                    $smsg += "`n----$($hsum.ADUser.distinguishedname)" ;
                    $smsg += "`n--ADUser.Description:$($hsum.ADUser.Description)" ;
                    if($hsum.IsADDisabled){
                        $smsg += "`n--ADUser:$($hsum.ADUser.samaccountname) is *DISABLED* for logon (likely TERM)" ;
                    } else {
                        $smsg += "`n--ADUser:$($hsum.ADUser.samaccountname) is *UN-DISABLED* for logon (improperly offboarded TERM?)" ;
                    } ;
                } else {
                    write-verbose "(no ADUser found)" ;
                } ;
                if($hsum.IsAADDisabled){
                    $smsg += "`n--AADUser:$($hsum.AADUser.UserPrincipalName) is *DISABLED* for logon (likely TERM)" ;
                } else {
                    $smsg += "`n--AADUser:$($hsum.AADUser.UserPrincipalName) is *UN-DISABLED* for logon (improperly offboarded TERM?)" ;
                } ;
                $smsg += "`n"
                write-warning $smsg ;
            } ;



            if($outObject){
                if($PSCmdlet.MyInvocation.ExpectingInput){
                    write-verbose "(pipeline input, skipping aggregator, dropping into pipeline)" ;
                    New-Object PSObject -Property $hSum | write-output  ;
                } else {
                    $Rpt += New-Object PSObject -Property $hSum ;
                } ;
            } ELSE {
                # 3:59 PM 9/18/2023 else export to report file 
                $Rpt += New-Object PSObject -Property $hSum ;
                $Rpt | export-clixml -Path $ofile -Depth 100 ;
            } ;
            write-host -foregroundcolor green $sBnr.replace('=v','=^').replace('v=','^=') ;
        } ;

    } # PROC-E
    END{
        <## cleanup XO aliases
        get-alias -scope Script |?{$_.name -match '^ps1.*'} | %{Remove-Alias -alias $_.name} ; 
        #>

        if($outObject -AND -not ($PSCmdlet.MyInvocation.ExpectingInput)){
            $Rpt | write-output ;
            write-host "(-outObject: Output summary object to pipeline)"
        }elseif($outObject -AND ($PSCmdlet.MyInvocation.ExpectingInput)){
            write-verbose "(pipeline input, individual objects dropped into pipeline)" ;
        } else {
            $oput = ($Rpt | select-object -unique) -join ',' ;
            $oput | out-clipboard ;
            write-host "(output copied to clipboard)"
            $oput |  write-output ;
        } ;

     } ;
 }

#*------^ resolve-user.ps1 ^------


#*------v resolve-xoRcps.ps1 v------
function Resolve-xoRcps {
    <#
    .SYNOPSIS
    Resolve-xoRcps.ps1 - run a get-exorecipient to re-resolve an array of Recipients into the matching primarysmtpaddress
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-09-02
    FileName    : Resolve-xoRcps
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite:	URL
    AddedTwitter:	URL
    REVISIONS
    *3:20 PM 12/30/2021 expanded, added params: getGroups, getRecipients, getMailboxPrincipals, PreviewThreshold, UpdateInterval, returnObject;
        expanded verbose echos and reporting, the above -get* params shift the complicated regexes internally, where one of the three types is desired. 
    * 9:16 AM 12/3/2021 added pswlt support
    * 8/30/21 init vers
    .DESCRIPTION
    Resolve-xoRcps.ps1 - run a get-exorecipient to re-resolve an array of Recipients into the matching primarysmtpaddress
    
    Backing out the RecipientTypeDetails combos for various niches (to use on the (Match|Block)RecipientTypeDetails param)

    [Get-Recipient (ExchangePowerShell) | Microsoft Docs - docs.microsoft.com/](https://docs.microsoft.com/en-us/powershell/module/exchange/get-recipient?view=exchange-ps)
    -RecipientType
        The RecipientType parameter filters the results by the specified recipient type. Valid values are:
        'DynamicDistributionGroup','MailContact','MailNonUniversalGroup','MailUniversalDistributionGroup',
            'MailUniversalSecurityGroup','MailUser','PublicFolder','UserMailbox'
    -RecipientTypeDetails
        'DiscoveryMailbox','DynamicDistributionGroup','EquipmentMailbox','GroupMailbox','GuestMailUser',
            'LegacyMailbox','LinkedMailbox','LinkedRoomMailbox','MailContact','MailForestContact','MailNonUniversalGroup',
            'MailUniversalDistributionGroup','MailUniversalSecurityGroup','MailUser','PublicFolder','PublicFolderMailbox',
            'RemoteEquipmentMailbox','RemoteRoomMailbox','RemoteSharedMailbox','RemoteTeamMailbox','RemoteUserMailbox',
            'RoomList','RoomMailbox','SchedulingMailbox','SharedMailbox','TeamMailbox','UserMailbox'

    # run the RTD set, pulling one of each type and dumping back the rt|rtd combos, to build rgxs:
    $rtds = 'DiscoveryMailbox','DynamicDistributionGroup','EquipmentMailbox','GroupMailbox','GuestMailUser',
        'LegacyMailbox','LinkedMailbox','LinkedRoomMailbox','MailContact','MailForestContact','MailNonUniversalGroup',
        'MailUniversalDistributionGroup','MailUniversalSecurityGroup','MailUser','PublicFolder','PublicFolderMailbox',
        'RemoteEquipmentMailbox','RemoteRoomMailbox','RemoteSharedMailbox','RemoteTeamMailbox','RemoteUserMailbox',
        'RoomList','RoomMailbox','SchedulingMailbox','SharedMailbox','TeamMailbox','UserMailbox' ; 
    $rtypes = @() ; 
    foreach($rtd in $rtds){
        write-host "==rtd:$($rtd)" ; 
        $rtypes += get-exorecipient -filter "Recipienttypedetails -eq '$rtd'" -ResultSize 1 ; 
    } ; 
    $rtypes | sort RecipientType,RecipientTypeDetails | ft -auto alias,primarys*,recipientt*

    Sanitized Output: (clearly our Tenant did not have quite a few of the RTD types queried)
    ObjType                                                      RecipientType                  RecipientTypeDetails
    -----                                                        -------------                  --------------------
    [DYNAMICDISTRIBUTIONGROUP]                                   DynamicDistributionGroup       DynamicDistributionGroup
    [MAILCONTACT]                                                MailContact                    MailContact
    [UNIFIEDGROUP]                                               MailUniversalDistributionGroup GroupMailbox
    [DISTRIBUTIONGROUP]                                          MailUniversalDistributionGroup MailUniversalDistributionGroup
    [ROOMLIST-DISTRIBUTIONGROUP]                                 MailUniversalDistributionGroup RoomList
    [MAIL-ENABLED SECURITYGROUP]                                 MailUniversalSecurityGroup     MailUniversalSecurityGroup
    [GUEST]                                                      MailUser                       GuestMailUser
    [MAILUSER]                                                   MailUser                       MailUser
    [DISCOVERYSEARCH MAILBOX]                                    UserMailbox                    DiscoveryMailbox
    [EQUIPMENTMAILBOX]                                           UserMailbox                    EquipmentMailbox
    [ROOMMAILBOX]                                                UserMailbox                    RoomMailbox
    [MS BOOKING APP MBX]                                         UserMailbox                    SchedulingMailbox
    [SHAREDMAILBOX]                                              UserMailbox                    SharedMailbox
    [USERMAILBOX]                                                UserMailbox                    UserMailbox

    # all the variant RTDs for 'group' rt's:
    $rtype = $rtypes |?{$_.RecipientType -like '*group*'} | select -expand RecipientTypeDetails | select -Unique
    [regex]$rgx = ('(' + (($rtype |%{[regex]::escape($_)}) -join '|') + ')') ;
    $rgx.tostring() ;
    # 'groups' rtd rgx : (groupmailbox covers UnifiedGrps)
    $_.RecipientTypeDetails -match '(DynamicDistributionGroup|GroupMailbox|MailUniversalDistributionGroup|MailUniversalSecurityGroup|RoomList)'

    # now do secprins: RecipientType: UserMailbox, MailUser
    $rtype = $rtypes |?{$_.RecipientType -like '*user*'} | select -expand RecipientTypeDetails | select -Unique ;
    [regex]$rgx = ('(' + (($rtype |%{[regex]::escape($_)}) -join '|') + ')') ;
    $rgx.tostring() ;
    # 'core' secprin rtd rgx:
    $_.RecipientTypeDetails -match '(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)' ; 

    # sender/recipients (approved|blocked targets):  Valid values for this parameter are individual senders in your organization (mailboxes, mail users, and mail contacts) 
    # RecipientType: UserMailbox, MailUser, MailContact
    $rtype = $rtypes |?{$_.RecipientType -match '(User|Contact)'} | select -expand RecipientTypeDetails | select -Unique ;
    [regex]$rgx = ('(' + (($rtype |%{[regex]::escape($_)}) -join '|') + ')') ;
    $rgx.tostring() ;
    # sender/recipients rtd rgx:
    $_.RecipientTypeDetails -match '(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailContact|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)'
    - DiscoveryMailbox discovery are for eDisc, not mail delivery
    
    # moderated by:  must be a mailbox, mail user, or mail contact: RecipientType: UserMailbox, MailUser, MailContact (same as above ☝🏻 )

    # mailbox secprins: required to do accessgrant on a mailbox
    [Add-MailboxPermission (ExchangePowerShell) | Microsoft Docs - docs.microsoft.com/](https://docs.microsoft.com/en-us/powershell/module/exchange/add-mailboxpermission?view=exchange-ps)
        You can specify the following types of users or groups (security principals) for this parameter:
            Mailbox users
            Mail users
            Security groups
    
        -- those phrases are RecipientType values, with spaces added - but not sure they really mean "anything of those specific RT's"...?
        -- though you might be able to use a *licensed* sharedmailbox to open another mailbox (?), they won't be able to do it natively, esp with disabled User logon. 
        -- rooms are disabled for logon. like shared, & equipment
        -- prob should exclude non-interactive logon & system in theory: DiscoveryMailbox|SchedulingMailbox|SharedMailbox|EquipmentMailbox|RoomMailbox
        -- CORRECTION: looped through full set of RT:UserMailbox types in the Tenant, *every* one of them added wo complaint using add-mailboxpermission & add-recipientpermission, 
            although many - unlicensed - would likely be unable to actually open another mailbox. 
        -- so technically, it appears should use the entire set, as they *technically* add wo complaint
    $rtype = $rtypes |?{$_.RecipientType -match '(User|MailUniversalSecurityGroup)'} | select -expand RecipientTypeDetails | select -Unique;
    [regex]$rgx = ('(' + (($rtype |%{[regex]::escape($_)}) -join '|') + ')') ;
    $rgx.tostring() ;
    # mailbox secprins (perm grants)
    $_.RecipientTypeDetails -match '(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailUniversalSecurityGroup|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)' 

    .PARAMETER Recipients
    Array of Recipients to be resolved against current Exchange environment [-Recipients `$ModeratedBy ]
    .PARAMETER MatchRecipientTypeDetails
    Regex for RecipientTypeDetails value to require for matched Recipients [-MatchRecipientTypeDetails '(UserMailbox|MailUser)']
    .PARAMETER BlockRecipientTypeDetails
    Regex for RecipientTypeDetails value to filter out of matched Recipients [-Block '(MailContact|GuestUser)']
    .PARAMETER getGroups
    Switch that specifies the return of solely 'group' recipients (RecipientTypeDetails matching:(DynamicDistributionGroup|GroupMailbox|MailUniversalDistributionGroup|MailUniversalSecurityGroup|RoomList)) [-getGroup]
    .PARAMETER getRecipients
    Switch that specifies the return of solely 'recipient' objects (RecipientTypeDetails matching:(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailContact|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)) [-getRecipients]
    .PARAMETER getMailboxPrincipals
    Switch that specifies the return of solely 'Mailbox Security Principal' recipients (RecipientTypeDetails matching:'(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailUniversalSecurityGroup|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)') [-getRecipients]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER PreviewThreshold
    Maximum number of preview resolved to display in console (defaults to 25)[-PreviewThreshold 10]
    .PARAMETER UpdateInterval
    Dot crawl update interval (one dot per `$UpdateInterval processed recipients - defaults to 3)[-UpdateInterval 10]
    .PARAMETER returnObject
    Switch to return full Recipient object to pipeline for each resolved recipient (rather than default, PrimarySmtpAddress property) [-returnObject]
    .EXAMPLE
    PS> $pltSDdg.RejectMessagesFrom = (Resolve-xoRcps -Recipients $srcDg.RejectMessagesFrom -MatchRecipientTypeDetails -MatchRecipientTypeDetails '(UserMailbox|MailUser|GuestMailUser|MailContact)' -Verbose:($VerbosePreference -eq 'Continue') -ErrorAction Continue)  ; 
    Resolve mail sender/recipient recip designators on the RejectMessagesFrom varito EXO recipient objects, with -ErrorAction:Continue (echo lookup fails, continue looping), and return the primarysmtpaddresses as an array
    .EXAMPLE
    PS> $pltSDdg.RejectMessagesFrom = (Resolve-xoRcps -Recipients $srcDg.RejectMessagesFrom -MatchRecipientTypeDetails -MatchRecipientTypeDetails '(UserMailbox|MailUser|GuestMailUser)' -Verbose:($VerbosePreference -eq 'Continue') -ErrorAction Continue)  ; 
    Resolve mail 'Security Principal' recip designators on the RejectMessagesFrom varito EXO recipient objects, with -ErrorAction:Continue (echo lookup fails, continue looping), and return the primarysmtpaddresses as an array
    .EXAMPLE
    PS> $pltSDdg.AcceptMessagesOnlyFromDLMembers = (Resolve-xoRcps -Recipients $ApprovedSenderDLs -MatchRecipientTypeDetails '(MailUniversalDistributionGroup|DynamicDistributionGroup|GroupMailbox)' -Verbose:$($VerbosePreference -eq 'Continue') )  ;
    Resolve mail recipient 'group' objects (covers DG| DDG| UnifiedGrp)
    .EXAMPLE
    PS> if($pltSDdg.RejectMessagesFrom){
            $pltSDdg.RejectMessagesFrom = (Resolve-xoRcps -Recipients $srcDg.RejectMessagesFrom -MatchRecipientTypeDetails '(UserMailbox|MailUser|GuestMailUser|MailContact)' -Verbose:($VerbosePreference -eq 'Continue') )  ; 
        } ;
    Resolve recip designators on the RejectMessagesFrom value, to EXO recipient objects, and return the primarysmtpaddress
    .EXAMPLE
    PS> $pltSDdg.AcceptMessagesOnlyFromDLMembers = (Resolve-xoRcps -Recipients $ApprovedSenderDLs -getGroups -Verbose:$($VerbosePreference -eq 'Continue') )  ;
    Resolve mail recipient 'group' objects using the -getGroups parameter (covers DG| DDG| UnifiedGrp)
    .EXAMPLE
    PS> $pltSDdg.AcceptMessagesOnlyFrom = (Resolve-xoRcps -Recipients $ApprovedSenderDLs -getRecipients -Verbose:$($VerbosePreference -eq 'Continue') )  ;
    Resolve mail recipient 'recipient' objects (senders/recipients) using the -getRecipients parameter.
    .EXAMPLE
    PS> $pltSDdg.AcceptMessagesOnlyFrom = (Resolve-xoRcps -Recipients $ApprovedSenderDLs -getRecipients -Verbose:$($VerbosePreference -eq 'Continue') )  ;
    Resolve mail Security Principal recipients (Those that can be used with add-mailboxpermission & add-recipientpermission) using the -getMailboxPrincipals parameter
    (covers DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailUniversalSecurityGroup|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)
    .EXAMPLE
    PS> $FullRecipientArray = (Resolve-xoRcps -Recipients $ApprovedSenderDLs -getRecipients -returnObject -Verbose:$($VerbosePreference -eq 'Continue') )  ;
    Resolve mail recipient 'recipient' objects (senders/recipients) using the -getRecipients parameter, and return the full Recipient object for each, to the pipeline.                
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory=$True,HelpMessage="Array of Recipients to be resolved against current Exchange environment [-Recipients `$ModeratedBy ]")]
        [array]$Recipients,
        [Parameter(ParameterSetName='MatchRecipients',HelpMessage="Regex for RecipientTypeDetails value to require for matched Recipients [-MatchRecipientTypeDetails '(UserMailbox|MailUser)']")]
        [string]$MatchRecipientTypeDetails,
        [Parameter(HelpMessage="Regex for RecipientTypeDetails value to filter out of matched Recipients [-Block '(MailContact|GuestUser)']")]
        [string]$BlockRecipientTypeDetails,
        [Parameter(ParameterSetName='groups',HelpMessage="Switch that specifies the return of solely 'group' recipients (RecipientTypeDetails matching:(DynamicDistributionGroup|GroupMailbox|MailUniversalDistributionGroup|MailUniversalSecurityGroup|RoomList)) [-getGroup]")]
        [switch] $getGroups,
        [Parameter(ParameterSetName='recipients',HelpMessage="Switch that specifies the return of solely 'recipient' objects (RecipientTypeDetails matching:(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailContact|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)) [-getRecipients]")]
        [switch] $getRecipients,
        [Parameter(ParameterSetName='secprincipals',HelpMessage="Switch that specifies the return of solely 'Mailbox Security Principal' recipients (RecipientTypeDetails matching:(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailUniversalSecurityGroup|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)) [-getRecipients]")]
        [switch] $getMailboxPrincipals,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2,
        [Parameter(HelpMessage="Maximum number of preview resolved to display in console (defaults to 25)[-PreviewThreshold 10]")]
        [int] $PreviewThreshold = 25,
        [Parameter(HelpMessage="Dot crawl update interval (one dot per `$UpdateInterval processed recipients - defaults to 3)[-UpdateInterval 10]")]
        [int] $UpdateInterval = 3,
        [Parameter(HelpMessage="Switch to return full Recipient object to pipeline for each resolved recipient (rather than default, PrimarySmtpAddress property) [-returnObject]")]
        [switch] $returnObject
    ) 
    <# Can capture the ErrorAction (not necessary, just like -verbose, if call is made with -erroraction specified, it auto-applies to *all* cmds run in the advanced function, that support the -ea param 
    - it's effectively setting $ErrorActionPreference for the func)
    Most useful purp would be if you want to echo status back.
    #>
    #$vErrorAction = $PSBoundParameters["ErrorAction"] ; 
    $verbose = ($VerbosePreference -eq "Continue") ;

    if($getGroups){$MatchRecipientTypeDetails = '(DynamicDistributionGroup|GroupMailbox|MailUniversalDistributionGroup|MailUniversalSecurityGroup|RoomList)'} 
    elseif($getRecipients){$MatchRecipientTypeDetails = '(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailContact|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)'} 
    elseif($getMailboxPrincipals){$MatchRecipientTypeDetails = '(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailUniversalSecurityGroup|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)'} 
    
    if ($script:useEXOv2) { reconnect-eXO2 }
    [array]$cmdletMaps = 'ps1GetxRcp;get-exorecipient;' ;
    foreach($cmdletMap in $cmdletMaps){
        if($script:useEXOv2){
            if(!($cmdlet= Get-Command $cmdletMap.split(';')[1].replace('-exo','-xo') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
            $nAName = ($cmdletMap.split(';')[0]) ; 
            if(!($nalias = get-alias -name $nAName -ea 0 )){
                $nalias = set-alias -name $nAName -value ($cmdlet.name) -passthru ;
                $smsg = "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            } ;
        } else {
            if(!($cmdlet= Get-Command $cmdletMap.split(';')[1])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
            $nAName = ($cmdletMap.split(';')[0]);
            if(!($nalias = get-alias -name $nAName -ea 0 )){
                $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                $smsg = "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

            } ; 
        } ;
    } ;
    if ($script:useEXOv2) { reconnect-eXO2 }
    else { reconnect-EXO } ;
    if($Recipients){
        $Procd = 0 ; 
        $smsg = "(Resolving recipients...)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        $resolvedRecipients = $Recipients | foreach-object {
            # use the EA if spec'd
            ps1GetxRcp -identity $_ ;
            $Procd ++ ; 
            if(-not($Procd % $UpdateInterval)){
                write-host "." -NoNewline ; 
            } ; 
        } ; 
        write-host "" ; 
        if($MatchRecipientTypeDetails){
            $smsg = "(Resolve-xoRcps:($(($resolvedRecipients|measure).count)) PRE MatchRecipientTypeDetails:"
            if(($resolvedRecipients|measure).count -lt $PreviewThreshold){
                $smsg += "`n$(($resolvedRecipients.primarysmtpaddress|out-string).trim()))" ; 
            } else { 
                $smsg += "`n$(($resolvedRecipients.primarysmtpaddress | select -first $PreviewThreshold |out-string).trim()))`n..." ; 
            } ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            $resolvedRecipients = $resolvedRecipients |?{$_.RecipientTypeDetails -match $MatchRecipientTypeDetails} ; 
            $smsg = "(Resolve-xoRcps:($(($resolvedRecipients|measure).count)) POST MatchRecipientTypeDetails:`n$(($resolvedRecipients.primarysmtpaddress|out-string).trim()))" ; 
            if(($resolvedRecipients|measure).count -lt $PreviewThreshold){
                $smsg += "`n$(($resolvedRecipients.primarysmtpaddress|out-string).trim()))" ; 
            } else { 
                $smsg += "`n$(($resolvedRecipients.primarysmtpaddress | select -first $PreviewThreshold |out-string).trim()))`n..." ; 
            } ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ; 
        if($BlockRecipientTypeDetails){
            $smsg = "(Resolve-xoRcps:($(($resolvedRecipients|measure).count)) PRE BlockRecipientTypeDetails:`n$(($resolvedRecipients.primarysmtpaddress|out-string).trim()))" ; 
            if(($resolvedRecipients|measure).count -lt $PreviewThreshold){
                $smsg += "`n$(($resolvedRecipients.primarysmtpaddress|out-string).trim()))" ; 
            } else { 
                $smsg += "`n$(($resolvedRecipients.primarysmtpaddress | select -first $PreviewThreshold |out-string).trim()))`n..." ; 
            } ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            $resolvedRecipients = $resolvedRecipients |?{$_.RecipientTypeDetails -notmatch $BlockRecipientTypeDetails} ; 
            $smsg = "(Resolve-xoRcps:($(($resolvedRecipients|measure).count)) POST BlockRecipientTypeDetails:`n$(($resolvedRecipients.primarysmtpaddress|out-string).trim()))" ; 
            if(($resolvedRecipients|measure).count -lt $PreviewThreshold){
                $smsg += "`n$(($resolvedRecipients.primarysmtpaddress|out-string).trim()))" ; 
            } else { 
                $smsg += "`n$(($resolvedRecipients.primarysmtpaddress | select -first $PreviewThreshold |out-string).trim()))`n..." ; 
            } ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ; 
        if($returnObject){
            $smsg = "(-Returnobject: returning full recipient object array to pipeline)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            $resolvedRecipients |write-output ;
        } else { 
            $resolvedRecipients.primarysmtpaddress |write-output ;
        } ; 
        $smsg = "(Resolve-xoRcps:returning:($(($resolvedRecipients|measure).count))`n$(($resolvedRecipients.primarysmtpaddress|out-string).trim()))" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    } else { 
        $smsg = "Resolve-xoRcps:No Recipients specified" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $null | write-output ;
    } ; 
}

#*------^ resolve-xoRcps.ps1 ^------


#*------v rxocmw.ps1 v------
function rxocmw {
    <#
    .SYNOPSIS
    rxocmw - wrapper for Connect-EXO to connect to specified Tenant
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-07-29
    FileName    : rxocmw.ps1
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    REVISIONS   :
    * 11:32 AM 4/18/2023 alias into rxocmw, retiring
    .DESCRIPTION
    rxocmw - wrapper for Connect-EXO to connect to specified Tenant
    .EXAMPLE
    rxocmw
    #>
    [CmdletBinding()]
    [Alias('cxo2cmw' )]
    PARAM()
    ReConnect-EXO -cred $credO365CMWCSID -Verbose:$($VerbosePreference -eq 'Continue') ; 
}

#*------^ rxocmw.ps1 ^------


#*------v rxotol.ps1 v------
function rxoTOL {
    <#
    .SYNOPSIS
    rxoTOL - wrapper for Connect-EXO to connect to specified Tenant
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-07-29
    FileName    : rxoTOL.ps1
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    REVISIONS   :
    * 11:32 AM 4/18/2023 alias into rxoTOL, retiring
    .DESCRIPTION
    rxoTOL - wrapper for Connect-EXO to connect to specified Tenant
    .EXAMPLE
    rxoTOL
    #>
    [CmdletBinding()]
    [Alias('cxo2TOL' )]
    PARAM()
    ReConnect-EXO -cred $credO365TOLCSID -Verbose:$($VerbosePreference -eq 'Continue') ; 
}

#*------^ rxotol.ps1 ^------


#*------v rxotor.ps1 v------
function rxoTOR {
    <#
    .SYNOPSIS
    rxoTOR - wrapper for Connect-EXO to connect to specified Tenant
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-07-29
    FileName    : rxoTOR.ps1
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    REVISIONS   :
    * 11:32 AM 4/18/2023 alias into rxoTOR, retiring
    .DESCRIPTION
    rxoTOR - wrapper for Connect-EXO to connect to specified Tenant
    .EXAMPLE
    rxoTOR
    #>
    [CmdletBinding()]
    [Alias('cxo2TOR' )]
    PARAM()
    ReConnect-EXO -cred $credO365TORCSID -Verbose:$($VerbosePreference -eq 'Continue') ; 
}

#*------^ rxotor.ps1 ^------


#*------v rxoVEN.ps1 v------
function rxoVEN {
    <#
    .SYNOPSIS
    rxoVEN - wrapper for Connect-EXO to connect to specified Tenant
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-07-29
    FileName    : rxoVEN.ps1
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    REVISIONS   :
    * 11:32 AM 4/18/2023 alias into rxoVEN, retiring
    .DESCRIPTION
    rxoVEN - wrapper for Connect-EXO to connect to specified Tenant
    .EXAMPLE
    rxoVEN
    #>
    [CmdletBinding()]
    [Alias('cxo2VEN' )]
    PARAM()
    ReConnect-EXO -cred $credO365VENCSID -Verbose:$($VerbosePreference -eq 'Continue') ; 
}

#*------^ rxoVEN.ps1 ^------


#*------v test-EXOConnection.ps1 v------
function test-EXOv2Connection {
    <#
    .SYNOPSIS
    test-EXOv2Connection.ps1 - Validate EXO connection, and that the proper Tenant is connected (as per provided Credential)
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2022-06-24
    FileName    : test-EXOv2Connection.ps1
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-EXO
    Tags        : Powershell
    REVISIONS
    * 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
    * 11:20 AM 4/25/2023 added -CertTag param (passed by connect-exo; used for validating credential alignment w Tenant)
    * 10:28 AM 4/18/2023 #372: added -ea 0 to gv calls (not found error suppress)
    * 2:02 PM 4/17/2023 rev: $MinNoWinRMVersion from 2.0.6 => 3.0.0.
    * 3:58 PM 4/4/2023 reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not; 
    fixed flipped $IsNoWinRM ; supports EMOv2 v EMOv3 pss/no-pss connections, adds support for get-connectioninformation()
    * 3:14 pm 3/29/2023: REN'D $modname => $EOMModName
    * 3:54 PM 11/29/2022:  force the $MinNoWinRMVersion value to the currnet highest loaded:; 
    * 3:59 PM 8/2/2022 got through dbugging EOM v205 SID interactive pass, working ; fully works from mybox w v206p6, cEOM connection, with functional prefix. need to code in divert on cxo2 etc to avoid redundant tests and just do them here.
    * 3:30 PM 7/25/2022 fixed missing else for if #152; works in tests against CBA & SID interactive creds on EOM v205, need to debug now against EOM v206p6, to accomodate PSSession-less connect & test code.
    * 10:18 AM 6/24/2022 init ; ren test-EXOConnection -> test-EXOv2Connection, as this only validates EXOversion2 connections, not basic-auth-based EXOv1
    .DESCRIPTION
    test-EXOv2Connection.ps1 - Validate EXO connection, and that the proper Tenant is connected (as per provided Credential)
    .PARAMETER Credential
    Credential to be used for connection
    .PARAMETER CertTag
    Cert FriendlyName Suffix to be used for validating credential alignment(Optional but required for CBA calls)[-CertTag `$certtag]
    .PARAMETER MinNoWinRMVersion
    MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']
    .OUTPUT
    System.Boolean
    .EXAMPLE
    PS> $oRet = test-EXOv2Connection -Credential $cred -verbose ; 
    PS> if($oRet.Valid){
    PS>     $pssEXOv2 = $oRet.PsSession ; 
    PS>     write-host 'Validated EXOv2 Connected to Tenant aligned with specified Credential'
    PS> } else { 
    PS>     write-warning 'NO EXO USERMAILBOX TYPE LICENSE!'
    PS> } ; 
    Evaluate EXOv2 connection status & Tenant:Credential alignment, with verbose output
    .EXAMPLE
    PS> $TenOrg = get-TenantTag -Credential $Credential ;
    PS> if($Credential){
    PS>     $uRoleReturn = resolve-UserNameToUserRole -Credential $Credential
    PS> } elseif($UserPrincipalName){
    PS>     $uRoleReturn = resolve-UserNameToUserRole -UserName $UserPrincipalName
    PS> } ; 
    PS> if($uRoleReturn.TenOrg){
    PS>     $CertTag = $uRoleReturn.TenOrg
    PS> } ; 
    PS> if($CertTag -ne $null){
    PS>     $smsg = "(specifying detected `$CertTag:$($CertTag))" ;
    PS>     if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
    PS>     else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
    PS>     $oRet = test-EXOv2Connection -Credential $credential -CertTag $CertTag -verbose:$($verbose) ;
    PS> } else {
    PS>     $oRet = test-EXOv2Connection -Credential $credential -verbose:$($verbose) ;
    PS> } ;
    PS> if($oRet.Valid){
    PS>     $pssEXOv2 = $oRet.PsSession ;
    PS>     $IsNoWinRM = $oRet.IsNoWinRM ;
    PS>     $smsg = "(Validated EXOv2 Connected to Tenant aligned with specified Credential)" ;
    PS>     if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
    PS>     else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
    PS> } else {
    PS>     $smsg = "NO VALID EXOV2/3 PSSESSION FOUND! (DISCONNECTING...)"
    PS>     if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
    PS>     else{ write-host -ForegroundColor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    PS>     # capture outlier: shows a session wo the test cmdlet, force reset
    PS>     DisConnect-EXO ;
    PS>     $bExistingEXOGood = $false ;
    PS> } ;    
    Fancier demo using a variety of verb-Auth & verb-xo cmdlets
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    #Requires -Version 3
    ##Requires -Modules AzureAD, verb-Text
    ##Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\sregex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    [CmdletBinding()]
     Param(
        [Parameter(Mandatory=$True,HelpMessage="Credentials [-Credentials [credential object]]")]
        [System.Management.Automation.PSCredential]$Credential = $global:credo365TORSID,
        [Parameter(HelpMessage = "Cert FriendlyName Suffix to be used for validating credential alignment(Optional but required for CBA calls)[-CertTag `$certtag]")]
        [string]$CertTag,
        [Parameter(HelpMessage = "MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']")]
        [version] $MinNoWinRMVersion = '3.0.0'
    )
    BEGIN {
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        if(-not $rgxCertFNameSuffix){$rgxCertFNameSuffix = '-([A-Z]{3})$' } ; 
        #*------v PSS & GMO VARIS v------
        # get-pssession session varis
        # select key differentiating properties:
        $pssprops = 'Id','ComputerName','ComputerType','State','ConfigurationName','Availability', 
            'Description','Guid','Name','Path','PrivateData','RootModuleModule', 
            @{name='runspace.ConnectionInfo.ConnectionUri';Expression={$_.runspace.ConnectionInfo.ConnectionUri} },  
            @{name='runspace.ConnectionInfo.ComputerName';Expression={$_.runspace.ConnectionInfo.ComputerName} },  
            @{name='runspace.ConnectionInfo.Port';Expression={$_.runspace.ConnectionInfo.Port} },  
            @{name='runspace.ConnectionInfo.AppName';Expression={$_.runspace.ConnectionInfo.AppName} },  
            @{name='runspace.ConnectionInfo.Credentialusername';Expression={$_.runspace.ConnectionInfo.Credential.username} },  
            @{name='runspace.ConnectionInfo.AuthenticationMechanism';Expression={$_.runspace.ConnectionInfo.AuthenticationMechanism } },  
            @{name='runspace.ExpiresOn';Expression={$_.runspace.ExpiresOn} } ; 
        $EXOv1ConfigurationName = $EXOv2ConfigurationName = $EXoPConfigurationName = "Microsoft.Exchange" ;

        if(-not $EXOv1ConfigurationName){$EXOv1ConfigurationName = "Microsoft.Exchange" };
        if(-not $EXOv2ConfigurationName){$EXOv2ConfigurationName = "Microsoft.Exchange" };
        if(-not $EXoPConfigurationName){$EXoPConfigurationName = "Microsoft.Exchange" };

        if(-not $EXOv1ComputerName){$EXOv1ComputerName = 'ps.outlook.com' };
        if(-not $EXOv1runspaceConnectionInfoAppName){$EXOv1runspaceConnectionInfoAppName = '/PowerShell-LiveID'  };
        if(-not $EXOv1runspaceConnectionInfoPort){$EXOv1runspaceConnectionInfoPort = '443' };

        if(-not $EXOv2ComputerName){$EXOv2ComputerName = 'outlook.office365.com' ;}
        if(-not $EXOv2Name){$EXOv2Name = "ExchangeOnlineInternalSession*" ; }
        if(-not $rgxEXoPrunspaceConnectionInfoAppName){$rgxEXoPrunspaceConnectionInfoAppName = '^/(exadmin|powershell)$'}; 
        if(-not $EXoPrunspaceConnectionInfoPort){$EXoPrunspaceConnectionInfoPort = '80' } ; 
        # gmo varis
        if(-not $rgxEXOv1gmoDescription){$rgxEXOv1gmoDescription = "^Implicit\sremoting\sfor\shttps://ps\.outlook\.com/PowerShell" }; 
        if(-not $EXOv1gmoprivatedataImplicitRemoting){$EXOv1gmoprivatedataImplicitRemoting = $true };
        if(-not $rgxEXOv2gmoDescription){$rgxEXOv2gmoDescription = "^Implicit\sremoting\sfor\shttps://outlook\.office365\.com/PowerShell" }; 
        if(-not $EXOv2gmoprivatedataImplicitRemoting){$EXOv2gmoprivatedataImplicitRemoting = $true } ;
        if(-not $rgxExoPsessionstatemoduleDescription){$rgxExoPsessionstatemoduleDescription = '/(exadmin|powershell)$' };
        if(-not $PSSStateOK){$PSSStateOK = 'Opened' };
        if(-not $PSSAvailabilityOK){$PSSAvailabilityOK = 'Available' };
        if(-not $EXOv1GmoFilter){$EXOv1GmoFilter = 'tmp_*' } ; 
        if(-not $EXOv2GmoNoWinRMFilter){$EXOv2GmoNoWinRMFilter = 'tmpEXO_*' };
        $EOMmodname = 'ExchangeOnlineManagement' ;
        # reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not
        #region EOMREV ; #*------v EOMREV Check v------
        #$EOMmodname = 'ExchangeOnlineManagement' ;
        $pltIMod = @{Name = $EOMmodname ; ErrorAction = 'Stop' ; verbose=$false} ;
        if($xmod = Get-Module $EOMmodname -ErrorAction Stop| sort version | select -last 1 ){ } else {
            $smsg = "Import-Module w`n$(($pltIMod|out-string).trim())" ;
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            Try {
                Import-Module @pltIMod | out-null ;
                $xmod = Get-Module $EOMmodname -ErrorAction Stop | sort version | select -last 1 ;
            } Catch {
                $ErrTrapd=$Error[0] ;
                $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $smsg = $ErrTrapd.Exception.Message ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Break ;
            } ;
        } ; # IsImported
        if([version]$xmod.version -ge $MinNoWinRMVersion){
            $MinNoWinRMVersion = $xmod.version.tostring() ;
            $IsNoWinRM = $true ; 
        }
        [boolean]$UseConnEXO = [boolean]([version]$xmod.version -ge $MinNoWinRMVersion) ; 
        #endregion EOMREV ; #*------^ END EOMREV Check  ^------

    } ;  # if-E BEGIN    
    PROCESS {
        $oReturn = [ordered]@{
            PSSession = $null ; 
            IsNoWinRM = $false ; 
            Valid = $false ; 
        } ; 
        $isEXOValid = $false ;
        # corrected $EXoPConfigurationName -> $EXOv2ConfigurationName; same value, but vari name should indicate purpose, as well as contents
        if($pssEXOv2 = Get-PSSession | 
                where-object {$_.ConfigurationName -like $EXOv2ConfigurationName -AND (
                    $_.Name -like $EXOv2Name) -AND (
                    $_.ComputerName -eq $EXOv2ComputerName) } ){
                    <# rem'd state/avail tests, run separately below: -AND (
                    $_.State -eq $PSSStateOK)  -AND (
                    $_.Availability -eq $PSSAvailabilityOK)
                    #>
            $smsg = "`n`nEXOv2 PSSessions:`n$(($pssEXOv2 | fl $pssprops|out-string).trim())" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

            if($pssEXOv2 | ?{ ($_.State -eq $PSSStateOK)  -AND (
                    $_.Availability -eq $PSSAvailabilityOK)}){

                # verify the exov2 cmdlets actually imported as a tmp_ module w specifid prefix & 1st cmdlet
                # below won't work with updated token support/MFA & loss of test|clear-ActiveToken from EOM (breaking change)
                # but it's needed when using EOM205, which still falls to basicauth! (readded down below)
                # revise for exov2 -cred support (where get-msaltoken gets used)
                # test-EXOToken & it's dependancy EOM:test-ActiveToken, *doesn't exist* after EOM v205!, if out the block
                if(-not $IsNoWinRM){
                    # Credential
                    $plttXT=[ordered]@{
                        Credential = $Credential ;
                        verbose = $($VerbosePreference -eq "Continue") ;
                    } ;
                    $smsg = "test-EXOToken w`n$(($plttXT|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ; 
                if ( (get-module -name $EXOv1GmoFilter | ForEach-Object {
                     Get-Command -module $_.name -name 'Add-xoAvailabilityAddressSpace' -ea 0 }) -AND (
                        test-EXOToken @plttXT)) {
                    $smsg = "(EXOv1Gmo Basic-Auth PSSession module detected)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $bExistingEXOGood = $true ;
                    # need as well, to get through if/then ahead of credential/tenant align check
                    $isEXOValid = $true ; 
                }elseif ( (get-module -name $EXOv2GmoNoWinRMFilter | ForEach-Object {
                    Get-Command -module $_.name -name 'Add-xoAvailabilityAddressSpace' -ea 0 }) -AND (
                        test-EXOToken @plttXT)) {
                    $smsg = "(EXOv2GmoNoWinRM module detected)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $bExistingEXOGood = $true ;
                    # need as well, to get through if/then ahead of credential/tenant align check
                    $isEXOValid = $true ; 
                } else { $bExistingEXOGood = $false ; }
                
                
            } else{
                # pss but disconnected state
                rxo2 ; 
            } ; 
            
        } elseif($IsNoWinRM -AND ((get-module $EXOv2GmoNoWinRMFilter) -AND (get-module $EOMmodname))){
            # no PSS and IsNoWinRM == v206+ PSS-less connection
            # verify the exov2 cmdlets actually imported as a tmp_ module w specifid prefix & 1st cmdlet

            # test-EXOToken() won't work with PSSession-less - it obtains the critical TokenExpireTime from the open PSSession
            # need to recode for these using get-aadtoken

            # 12:22 PM 8/1/2022 issue with get-msaltoken: it will auth EXO client app (by guid), but it doesn't support the key -prefix param, to make them verb-XOnoun; so you can't use it with hybrid onprem connections.
            # => looks like I'll have to either skip it, or test for cmdlets loaded, to verify. get-msaltoken actually runs an auth session, doesn't just validate one's present. 
            <# [PowerShell Gallery | MSAL.PS.psd1 4.1.0.2 - www.powershellgallery.com/](https://www.powershellgallery.com/packages/MSAL.PS/4.1.0.2/Content/MSAL.PS.psd1)
             nope, it's referring to 'virtual network address prefix'f
            #>
            # EOM v3 adds Get-ConnectionInformation, which has .tokenStatus -eq 'Active'

            if($xmod | Where-Object {$_.version -like "3.*"} ){
                $smsg = "EOM v3+ connection detected" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                if ((Get-ConnectionInformation).tokenStatus -eq 'Active') {
                    #write-host 'Connecting to Exchange Online' -ForegroundColor Cyan
                    #Connect-ExchangeOnline -UserPrincipalName $adminUPN
                    $bExistingEXOGood = $isEXOValid = $true ;
                }
            } else {  
                $smsg = "EOM v205p6+ connection detected" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                # it seamlessly reauths, wo prompts, so just validate a core cmdlet is loaded, plust the above
                if([boolean](get-command -name Get-xoOrganizationConfig)){
                    $smsg = "(`IsNoWinRM:`$true`nget-module:$($EXOv2GmoNoWinRMFilter)`nget-module:$($EOMmodname)`ngcm:Get-xoOrganizationConfig`n=>Appears Valid)" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

                    $bExistingEXOGood = $isEXOValid = $true ;
                    #$IsNoWinRM = $true ; # already tested above
                } else { 
                    $bExistingEXOGood = $isEXOValid = $false ;
                } ; 

            } ;
        } else { 
            $smsg = "Unable to detect EXOv2 or EXOv3 PSSession!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-host -ForegroundColor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            #throw $smsg ;
            #Break ; 
            $bExistingEXOGood = $isEXOValid = $false ; 
        } ; 

        if($bExistingEXOGood -ANd $isEXOValid){
            # implement caching of accepteddoms into the XXXMeta, in the session (cut back on queries to EXO on acceptedom)
            if( get-command Get-xoAcceptedDomain) {
                    #$TenOrg = get-TenantTag -Credential $Credential ;
                if(-not (Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_AcceptedDomains){
                    set-Variable  -name "$($TenOrg)Meta" -value ( (Get-Variable  -name "$($TenOrg)Meta" -ea 0).value += @{'o365_AcceptedDomains' = (Get-xoAcceptedDomain).domainname} )
                } ;
            } ;
            
            $smsg = "(validating Tenant:Credential alignment)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            
            if($credential.username -match $rgxCertThumbprint -AND $certTag -eq $null){
                $smsg = "CBA Certificate Thumprint cred uname detected, but -CertTag was *not* pass thru in call!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                break ; 
            } 
            if( ($credential.username -match $rgxCertThumbprint) -AND ((Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_Prefix -eq $certTag )){
                # 9:59 AM 6/24/2022 need a case for CBA cert (thumbprint username)
                # compare cert fname suffix to $xxxMeta.o365_Prefix
                # validate that the connected EXO is to the CBA Cert tenant
                $smsg = "(EXO Authenticated & Functional CBA cert:$($certTag),($($certUname)))" ;
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                $bExistingEXOGood = $isEXOValid = $true ;
            }elseif((Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_AcceptedDomains.contains($Credential.username.split('@')[1].tostring())){
                # validate that the connected EXO is to the $Credential tenant
                $smsg = "(EXO Authenticated & Functional:$($Credential.username.split('@')[1].tostring())),($($Credential.username))" ;
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $bExistingEXOGood = $isEXOValid = $true ;
            # issue: found fresh bug in cxo: svcacct UPN suffix @tenantname.onmicrosoft.com, but testing against AccepteDomain, it's not in there (tho @DOMAIN.mail.onmicrosoft.comis)
            }elseif((Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_TenantDomain -eq ($Credential.username.split('@')[1].tostring())){
                $smsg = "(EXO Authenticated & Functional(TenDom):$($Credential.username.split('@')[1].tostring()))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $bExistingEXOGood = $isEXOValid = $true ;
            } else {
                $smsg = "(Credential mismatch:disconnecting from existing EXO:$($eEXO.Identity) tenant)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                Disconnect-exo ;
                $bExistingEXOGood = $isEXOValid = $false ;
            } ;

            if($bExistingEXOGood -AND $isEXOValid){
                $oReturn.PSSession = $pssEXOv2 ; 
                if( ($IsNoWinRM -eq $true) -AND -not $pssEXOv2){
                    $smsg = "IsNoWinRM & no detected EXO PsSession:" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    $oReturn.IsNoWinRM = $IsNoWinRM
                }
                $oReturn.Valid = $isEXOValid ; 
            } else {
                $smsg = "(invalid session `$bExistingEXOGood:$($bExistingEXOGood) -OR `$isEXOValid:$($isEXOValid))" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                Disconnect-exo ;
            } ;  ; 
        } else { 
            $oReturn.PSSession = $pssEXOv2 ; 
            $oReturn.Valid = $isEXOValid ; 
        } ; 

    }  # PROC-E
    END{
        <# $oReturn = [ordered]@{
            PSSession = $null ; 
            Valid = $false ; 
        } ; 
        #>
        $smsg = "Returning `$oReturn:`n$(($oReturn|out-string).trim())" ; 
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        New-Object PSObject -Property $oReturn | write-output ; 
    } ;
}

#*------^ test-EXOConnection.ps1 ^------


#*------v test-EXOIsLicensed.ps1 v------
function test-EXOIsLicensed {
    <#
    .SYNOPSIS
    test-EXOIsLicensed.ps1 - Evaluate IsLicensed status, to indicate license support for Exchange online UserMailbox type, on passed in AzureADUser object
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2022-03-22
    FileName    : 
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    REVISIONS
    * 3:52 PM 5/23/2023 implemented @rxo @rxoc split, (silence all connectivity, non-silent feedback of functions); flipped all r|cxo to @pltrxoC, and left all function calls as @pltrxo; 
    * 9:13 AM 5/22/2023 added Silent back, for broad call compatibility (pltrxo consistency); 
    * 2:39 PM 5/17/2023 add pltrxo support
    * 3:15 PM 5/15/2023:test-EXOIsLicensed() works w latest aad/exo-eom updates
    * 1:06 PM 4/4/2022 updated CBH example to reflect $AADU obj, not UPN input
    3:08 PM 3/23/2022 init
    .DESCRIPTION
    test-EXOIsLicensed.ps1 - Evaluate IsLicensed status, to indicate license support for Exchange online UserMailbox type, on passed in AzureADUser object
    Coordinates with verb-exo:get-ExoMailboxLicenses() to retrieve a static list of UserMailbox -supporting license names & sku's in our Tenant. 

    The get-EXOMailboxLicenses list is *not* interactive with AzureAD or EXO, 
    -- CORRECTION: the dependant get-AADlicensePlanList() includes an AAD call to pull the sku's: Connect-AAD -Credential:$Credential -verbose:$($verbose) -silent ;
    but that func needs working access, not the code w/in this.
    ...and it *will* have to be tuned for local Tenants, and maintained for currency over time. 

    It's a simple test, but it beats..
        ...the prior get-Msoluser |?{$_.islicensed} (which indicates:*some* license is assigned - could be a worthless 'FREEFLOW'!) 
        
        ... or testing |?{$_.LicenseReconciliationNeeded } 
        ( which used to indicate a mailbox *exists* but lacks a suitable mailbox-supporting license, 
        and continues to be mounted, *solely* due to being within 30days of onboarding to cloud.).  

    Not to mention get-AzureADuser's complete lack of any native evaluation on either front. [facepalm]
    Nor any similar native support in the gap from the ExchangeOnlineManagement module. 

    <rant>
        I *love* coding coverage for slipshod MS module providers that write to replace *force*-deprecated critical infra tools, 
        but can't be bothered to deliver equiv function, equiv parameters, or even similar outputs, 
        for long-standing higher-functioning tools, when they write the half-implemented *new* ones.

        And no, "Just make calls to GraphAPI!", is not a viable answer, for *working* admins, mandated to deliver working solutions on tight schedules. 
        If we wanted to be REST web devs, we wouldn't be running o365 services!
    </rant>

    .PARAMETER  User
    AzureADUser [Microsoft.Open.AzureAD.Model.User] object
    .PARAMETER TenOrg
    TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']
    .PARAMETER Credential
    Credential to be used for connection
    .OUTPUT
    System.Boolean
    .EXAMPLE
    PS> $isEXOLicensed = test-EXOIsLicensed -User $AADUser -verbose
    PS> if($isEXOLicensed){write-host 'Has EXO Usermailbox Type License'} else { write-warning 'NO EXO USERMAILBOX TYPE LICENSE!'} ; 
    Evaluate IsLicensed status on passed UPN object
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    #Requires -Version 3
    ##Requires -Modules AzureAD, verb-Text
    ##Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\sregex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    [CmdletBinding()]
    
     Param(
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,HelpMessage="Either Msoluser object or UserPrincipalName for user[-User upn@domain.com|`$msoluserobj ]")]
            [Microsoft.Open.AzureAD.Model.User]$User,
        [Parameter(Mandatory=$False,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
            [ValidateNotNullOrEmpty()]
            [ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(Mandatory=$False,HelpMessage="Credentials [-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential = $global:credo365TORSID,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent
    )
    BEGIN {
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        
        # recycling the inbound above into next call in the chain
        $pltRXO = [ordered]@{
            Credential = $Credential ; 
            verbose = $($VerbosePreference -eq "Continue")  ; 
            silent = $silent ; 
        } ;
        # default connectivity cmds - force silent false
        $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$true) ;
        if((gcm Reconnect-EXO).Parameters.keys -notcontains 'silent'){ $pltRxo.remove('Silent') } ; 

        $ExMbxLicenses = get-ExoMailboxLicenses -verbose:$($VerbosePreference -eq "Continue")  ;
        # pull the full Tenant list, for performing sku-> name conversions
        #$lplist =  get-AADlicensePlanList -verbose -IndexOnName ;

        $pltGLPList=[ordered]@{ 
            TenOrg= $TenOrg;
            IndexOnName=$false ;
            Credential = $pltRXO.Credential ; 
            verbose = $pltRXO.verbose  ; 
            silent = $false ; 
        } ; 
        $smsg = "get-AADlicensePlanList w`n$(($pltGLPList|out-string).trim())" ; 
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

        # this *does* require working AAD access logon. 
        $skus  = get-AADlicensePlanList @pltGLPList ;

        # check if using Pipeline input or explicit params:
        if ($PSCmdlet.MyInvocation.ExpectingInput) {
            write-verbose "Data received from pipeline input: '$($InputObject)'" ;
        } else {
            # doesn't actually return an obj in the echo
            write-verbose "Data received from parameter input:" # '$($InputObject)'" ;
        } ;
    } 
    PROCESS {
        if($ExMbxLicenses){
            $IsExoLicensed = $false ;
            foreach($pLic in $User.AssignedLicenses.skuid){
                $smsg = "(resolving $($plic) for EXO support)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                if($tsku = $skus[$pLic]){
                    if($xlic = $ExMbxLicenses[$tsku.SkuPartNumber]){
                        $IsExoLicensed = $true ;
                        $smsg = "$($User.userprincipalname) HAS EXO UserMailbox-supporting License:$($xlic.SKU)|$($xlic.Label)|$($tsku.skuid)" ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        break ; 
                    } ;
                } else { 

                } ; 
            } ;
        } else { 
            $smsg = "Unable to resolve get-ExoMailboxLicenses!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            throw $smsg ;
            Break ; 
        } ; 

    }  # PROC-E
    END{
        $IsExoLicensed | write-output ; 
    } ;
}

#*------^ test-EXOIsLicensed.ps1 ^------


#*------v test-ExoPSession.ps1 v------
Function test-ExoPSession {
  <#
    .SYNOPSIS
    test-ExoPSession - Does a *simple* - NO-ORG REVIEW - validation of functional PSSession with: ConfigurationName:'Microsoft.Exchange' -AND Name match  '^(Exchange2010|Session\sfor\simplicit\sremoting\smodule\sat\s.*)' -AND State:'Opened' -AND Availability:'Available' -AND can gcm -name 'Add-ADPermission'
    .NOTES
    Author: Todd Kadrie
    Website:	http://toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    Version     : 1.0.0
    CreatedDate : 2021-04-15
    FileName    : test-ExoPSession()
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka
    Tags        : Powershell,Exchange,Exchange-2013,Exchange-2016
    REVISIONS   :
    * 11:40 AM 5/14/2021 added -ea 0 to the gv tests (suppresses not-found error when called without logging config)
    * 10:38 AM 5/3/2021 init vers
    .DESCRIPTION
    test-ExoPSession - Does a *simple* - NO-ORG REVIEW - validation of functional EXO PSSession with: ConfigurationName:'Microsoft.Exchange' -AND Name match (ExchangeOnlineInternalSession| "^(Session|WinRM)\d*) -AND State:'Opened' -AND Availability:'Available' -AND can gcm -name 'Add-*ATPEvaluation'.
    This does *NO* validation that any specific EXOnPrem org is attached! It just validates that an existing PSSession *exists* that *generically* matches a Remote Exchange Mgmt Shell connection in a usable state. Use case is scripts/functions that *assume* you've already pre-established a suitable connection, and just need to pre-test that *any* PSS is already open, before attempting commands. 
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    System.Management.Automation.Runspaces.PSSession. Returns the functional PSSession object(s)
    .EXAMPLE
    PS> if(test-ExoPSession){'OK'} else { 'NOGO!'}  ;
    .LINK
    https://github.com/tostka/verb-Exo/
    #>
    [CmdletBinding()]
    Param()  ;
    BEGIN{
        $verbose = ($VerbosePreference -eq "Continue") ;
        if(!$rgxExoPsHostName){$rgxExoPsHostName="^(ps\.outlook\.com|outlook\.office365\.com)$" } ;
        $testCommand = 'Add-*ATPEvaluation' ; 
        $propsREMS = 'Id','Name','ComputerName','ComputerType','State','ConfigurationName','Availability' ; 
    } ;  # BEG-E
    PROCESS{
        $error.clear() ;
        TRY {
            $exov2Good = Get-PSSession | where-object {($_.ConfigurationName -like "Microsoft.Exchange") -AND (
            $_.Name -like "ExchangeOnlineInternalSession*") -AND ($_.ComputerName -match $rgxExoPsHostName) -AND ($_.State -like "*Opened*") -AND (
            $_.Availability -eq 'Available')} ; 
            $exov1Good = (Get-PSSession | where-object {$_.ConfigurationName -like "Microsoft.Exchange" -AND $_.Name -match "^(Session|WinRM)\d*" -AND ($_.ComputerName -match $rgxExoPsHostName) -AND (
                ($_.State -eq 'Opened') -AND ($_.Availability -eq 'Available')) }) ;
            if( $exov2Good -OR $exov1Good ){
                $REMSexo=@() ; 
                $REMSexo = $exov2Good ; 
                $REMSexo += $exov1Good ; 
                $smsg = "valid EXO EMS PSSession found:`n$(($REMSexo|ft -a $propsREMS |out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-VERBOSE "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                # test agnostic of prefix variant
                if($tmod = (get-command $testCommand ).source){
                    $smsg = "(confirmed PSSession open/available, with $($testCommand) available)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $REMSexo | write-output ; ;
                } else { 
                    throw "NO FUNCTIONAL PSSESSION FOUND!" ; 
                } ; 
            } else {
                throw "No existing open/available EXO Remote Exchange Management Shell found!"
            } ;
        } CATCH {
            $ErrTrapd = $_ ;
            write-warning "$(get-date -format 'HH:mm:ss'): Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            #-=-record a STATUSERROR=-=-=-=-=-=-=
            $statusdelta = ";ERROR"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(gv passstatus -scope Script -ea 0 ){$script:PassStatus += $statusdelta } ;
            if(gv -Name PassStatus_$($tenorg) -scope Script  -ea 0 ){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ;
            #-=-=-=-=-=-=-=-=
        } ;
        
    } ;  # PROC-E
    END {}
}

#*------^ test-ExoPSession.ps1 ^------


#*------v test-EXOToken.ps1 v------
function test-EXOToken {
    <#
    .SYNOPSIS
    test-EXOToken - Retrieve and summarize EXOv2 OAuth Active Token (leverages ExchangeOnlineManagement 'Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll', OAuth isn't used for EXO legacy basic-auth connections)
    .NOTES
    Version     : 1.0.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-08-08
    FileName    : test-EXOToken
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-aad
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    REVISIONS
    * 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
    * 2:02 PM 4/17/2023 rev: $MinNoWinRMVersion from 2.0.6 => 3.0.0.
    * 11:02 AM 4/4/2023 reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not
    * 3:34 PM 3/29/2023 3:14 pm 3/29/2023: REN'D $modname => $EOMModName
    * 10:12 AM 11/28/2022 add: test of get-command -name Test-ActiveToken) before using it (only avail in EOM v205 and less)
    * 3:59 PM 8/2/2022 got through dbugging EOM v205 SID interactive pass, working ; added NoWinRM test and -MinNoWinRMVersion, to bypass attempts with this, post EOM v205 (as v206 completely drops the dependant test|clear-ActiveToken())
    # 10:25 AM 8/2/2022 NOPE! get-msaltoken *authenticates* a fresh connection, like Connect-EOM, 
    - _if_ you spec the PS EXO client guid, as the 
     - so it can sort of 'act' like a token validator, but as it fully authenticates if there's no token, it's *not equive to test-ActiveToken* 
     from ExchangeOnlineManagement v205. and *it completely lacks -Prefix support*! Can't use this for hybrid prefix-tagged coexist with onprem Exch ps sessions.
     fundemental break there. 
    - So I coded out any use of this from connect-exo2/reconnect-exo2, for NoWinRM EOM v206p6+ use.
    * 3:30 PM 7/25/2022 tests against CBA & SID interactive creds on EOM v205, need to debug now against EOM v206p6, to accomodate PSSession-less connect & test code.
    * 8:30 AM 7/11/2022 rewrite for a post-PSS basicauth, EOM v206p6 world: can't use EOM:get-activetoken; add $Credential (needed for msal.ps:get-msaltoken()
    * 4:08 PM 3/29/2022 updated, got test-Activetoken call into gallery mod working again (token time is pulled off of the active setsion and looks like it id's which token /sesion you're closing to remove-Activetoken etc). 
    * 3:41 PM 3/28/2022 update for v2.05, supporting .netcore & .netframework subdirs in the ExchangeOnlineManagement module, failing on trailing test-activetoken code - wants -TokenExpiryTime now.
    * 11:40 AM 5/14/2021 added -ea 0 to the gv tests (suppresses not-found error when called without logging config)
    # 8:34 AM 3/31/2021 added verbose suppress to all import-mods
    * 12:21 PM 8/11/2020 added dependancy mod try/tach, and a catch on the failure error returned by the underlying test-ActiveToken cmd
    * 11:58 AM 8/9/2020 init
    .DESCRIPTION
    test-EXOToken - Retrieve and summarize EXOv2 OAuth Active Token (leverages ExchangeOnlineManagement 'Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll', OAuth isn't used for EXO legacy basic-auth connections)
    Trying to find a way to verify status of token, wo any interactive EXO traffic. Lifted concept from EXOM UpdateImplicitRemotingHandler().
    .PARAMETER Credential
    Credential to be used for connection
     .PARAMETER MinNoWinRMVersion
    MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']
    Test-ActiveToken doesn't appear to normally be exposed anywhere but with explicit load of the .dll
    .OUTPUT
    System.Boolean
    .EXAMPLE
    $hasActiveToken = test-EXOToken 
    $psss=Get-PSSession | where-object {$_.ConfigurationName -like "Microsoft.Exchange" -AND $_.Name -like "ExchangeOnlineInternalSession*" } ;  
    $sessionIsOpened = $psss.Runspace.RunspaceStateInfo.State -eq 'Opened'
    if (($hasActiveToken -eq $false) -or ($sessionIsOpened -ne $true)){
        #If there is no active user token or opened session then ensure that we remove the old session
        $shouldRemoveCurrentSession = $true;
    } ; 
    Retrieve and evaluate status of EXO user token against PSSessoin status for EXOv2
    .LINK
    https://github.com/tostka/verb-aad
    #>
    #Requires -Modules MSAL.PS,ExchangeOnlineManagement
    [CmdletBinding()] 
    Param(
        [Parameter(Mandatory=$True,HelpMessage="Credentials [-Credentials [credential object]]")]
        [System.Management.Automation.PSCredential]$Credential = $global:credo365TORSID,
        [Parameter(HelpMessage = "MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']")]
        [version] $MinNoWinRMVersion = '3.0.0'
    ) ;
    BEGIN {
        $verbose = ($VerbosePreference -eq "Continue") ;
        if(-not (gv rgxCertThumbprint -ea 0)){$rgxCertThumbprint = '[0-9a-fA-F]{40}' ; } ;

    } ;
    PROCESS {
        $hasActiveToken = $false ; 
        # Save time and pretest for *any* EXOv2 PSSession, before bothering to test (no session - even closed/broken => no OAuth token)
        # w EOM v206p5, there's no longer even a PSS to detect at all, so this loses function as well.
        # 8:52 AM 7/11/2022 this ^ is equiv to EOM code: $existingPSSession = Get-PSSession | Where-Object {$_.ConfigurationName -like "Microsoft.Exchange" -and $_.Name -like "ExchangeOnlineInternalSession*"}
        
        # * 11:02 AM 4/4/2023 reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not
        #region EOMREV ; #*------v EOMREV Check v------
        $EOMmodname = 'ExchangeOnlineManagement' ;
        $pltIMod = @{Name = $EOMmodname ; ErrorAction = 'Stop' ; verbose=$false} ;
        if($xmod = Get-Module $EOMmodname -ErrorAction Stop| sort version | select -last 1 ){ } else {
            $smsg = "Import-Module w`n$(($pltIMod|out-string).trim())" ;
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            Try {
                Import-Module @pltIMod | out-null ;
                $xmod = Get-Module $EOMmodname -ErrorAction Stop | sort version | select -last 1 ;
            } Catch {
                $ErrTrapd=$Error[0] ;
                $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $smsg = $ErrTrapd.Exception.Message ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Break ;
            } ;
        } ; # IsImported
        if([version]$xmod.version -ge $MinNoWinRMVersion){$MinNoWinRMVersion = $xmod.version.tostring() ;}
        [boolean]$UseConnEXO = [boolean]([version]$xmod.version -ge $MinNoWinRMVersion) ; 
        #endregion EOMREV ; #*------^ END EOMREV Check  ^------

        if($UseConnEXO){
            $smsg = "$($EOMmodname) v$($MinNoWinRMVersion)+ detected: No dependancy test-ActiveToken() available in later EOM builds" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

        } elseif ($exov2 = Get-PSSession | where-object {$_.ConfigurationName -like "Microsoft.Exchange" -AND $_.Name -like "ExchangeOnlineInternalSession*"}){

            $error.clear() ;
            TRY {
                #=load function module (subcomponent of dep module, pathed from same dir)
                #$tmodpath = join-path -path (split-path (get-module $EOMmodname -list).path) -ChildPath 'Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll' ;
                $EOMgmtModulePath = split-path (get-module $EOMmodname -list| sort version | select -last 1 ).Path ; 
                if($IsCoreCLR){
	                $EOMgmtModulePath = resolve-path -Path $EOMgmtModulePath\netcore ;
	                $smsg = "(.netcore path in use:" ; 
                } else {
	                $EOMgmtModulePath = resolve-path -Path $EOMgmtModulePath\netFramework
	                $smsg = "(.netnetFramework path in use:" ;
                } ;
                $smsg += "$($EOMgmtModulePath))" ;
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $tmodpath = join-path -path $EOMgmtModulePath -ChildPath 'Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll' ;

                if(test-path $tmodpath){ import-module -name $tmodpath -Cmdlet Test-ActiveToken -verbose:$false }
                else { throw "Unable to locate:Microsoft.Exchange.Management.ExoPowershellGalleryModule.dll" } ;  
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #-=-record a STATUSWARN=-=-=-=-=-=-=
                $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                #-=-=-=-=-=-=-=-=
                $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
            } ; 
        
            # targeted load example: # Import the module once more to ensure that Test-ActiveToken is present
            # Import-Module $global:_EXO_ModulePath -Cmdlet Test-ActiveToken;
            # ipmo $EOMgmtModulePath -Cmdlet Test-ActiveToken;
            if(get-command -name Test-ActiveToken){
                $error.clear() ;
                TRY {
                    #$hasActiveToken = Test-ActiveToken ; 
                    # updated from EOM v2.0.5
                    # grab the target session on it's settings:
                    $existingPSSession = Get-PSSession | Where-Object {$_.ConfigurationName -like "Microsoft.Exchange" -and $_.Name -like "ExchangeOnlineInternalSession*"}
                    if ($existingPSSession.count -gt 0) {
                        for ($index = 0; $index -lt $existingPSSession.count; $index++){
                            $session = $existingPSSession[$index]
                            $hasActiveToken = Test-ActiveToken -TokenExpiryTime $session.TokenExpiryTime ; 
                        } ; 
                    } ; 
                } CATCH [System.Management.Automation.RuntimeException] {
                    # reflects: test-activetoken : Object reference not set to an instance of an object.
                    write-verbose "Token not present"
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #-=-record a STATUSWARN=-=-=-=-=-=-=
                    $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                    if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                    if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                    #-=-=-=-=-=-=-=-=
                    $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                } ; 
            } else { throw "missing:gcm -name Test-ActiveToken" } 

            
        } else {
            $smsg = "Neither NoWinRM (EOM v206+) or existing EXOv2 (v205) PSSession found to confirm!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;  

} # E-PROC
    
    END{ $hasActiveToken | write-output } ;
}

#*------^ test-EXOToken.ps1 ^------


#*------v test-EXOv2Connection.ps1 v------
function test-EXOv2Connection {
    <#
    .SYNOPSIS
    test-EXOv2Connection.ps1 - Validate EXO connection, and that the proper Tenant is connected (as per provided Credential)
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2022-06-24
    FileName    : test-EXOv2Connection.ps1
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-EXO
    Tags        : Powershell
    REVISIONS
    * 1:55 PM 3/1/2024 added code to repop empty $TenOrg, prior to AcceptedDom caching (came through empty in testing, when no preexisting conn)
    * 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
    * 3:26 PM 5/30/2023 updated CBH, demos ; # reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not
    * 11:20 AM 4/25/2023 added -CertTag param (passed by connect-exo; used for validating credential alignment w Tenant)
    * 10:28 AM 4/18/2023 #372: added -ea 0 to gv calls (not found error suppress)
    * 2:02 PM 4/17/2023 rev: $MinNoWinRMVersion from 2.0.6 => 3.0.0.
    * 3:58 PM 4/4/2023 reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not; 
    fixed flipped $IsNoWinRM ; supports EMOv2 v EMOv3 pss/no-pss connections, adds support for get-connectioninformation()
    * 3:14 pm 3/29/2023: REN'D $modname => $EOMModName
    * 3:54 PM 11/29/2022:  force the $MinNoWinRMVersion value to the currnet highest loaded:; 
    * 3:59 PM 8/2/2022 got through dbugging EOM v205 SID interactive pass, working ; fully works from mybox w v206p6, cEOM connection, with functional prefix. need to code in divert on cxo2 etc to avoid redundant tests and just do them here.
    * 3:30 PM 7/25/2022 fixed missing else for if #152; works in tests against CBA & SID interactive creds on EOM v205, need to debug now against EOM v206p6, to accomodate PSSession-less connect & test code.
    * 10:18 AM 6/24/2022 init ; ren test-EXOConnection -> test-EXOv2Connection, as this only validates EXOversion2 connections, not basic-auth-based EXOv1
    .DESCRIPTION
    test-EXOv2Connection.ps1 - Validate EXO connection, and that the proper Tenant is connected (as per provided Credential)
    .PARAMETER Credential
    Credential to be used for connection
    .PARAMETER CertTag
    Cert FriendlyName Suffix to be used for validating credential alignment(Optional but required for CBA calls)[-CertTag `$certtag]
    .PARAMETER MinNoWinRMVersion
    MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']
    .OUTPUT
    System.Boolean
    .EXAMPLE
    PS> $oRet = test-EXOv2Connection -Credential $cred -verbose ; 
    PS> if($oRet.Valid){
    PS>     $pssEXOv2 = $oRet.PsSession ; 
    PS>     write-host 'Validated EXOv2 Connected to Tenant aligned with specified Credential'
    PS> } else { 
    PS>     write-warning 'NO EXO USERMAILBOX TYPE LICENSE!'
    PS> } ; 
    Evaluate EXOv2 connection status & Tenant:Credential alignment, with verbose output
    .EXAMPLE
    PS> $TenOrg = get-TenantTag -Credential $Credential ;
    PS> if($Credential){
    PS>     $uRoleReturn = resolve-UserNameToUserRole -Credential $Credential
    PS> } elseif($UserPrincipalName){
    PS>     $uRoleReturn = resolve-UserNameToUserRole -UserName $UserPrincipalName
    PS> } ; 
    PS> if($uRoleReturn.TenOrg){
    PS>     $CertTag = $uRoleReturn.TenOrg
    PS> } ; 
    PS> if($CertTag -ne $null){
    PS>     $smsg = "(specifying detected `$CertTag:$($CertTag))" ;
    PS>     if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
    PS>     else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
    PS>     $oRet = test-EXOv2Connection -Credential $credential -CertTag $CertTag -verbose:$($verbose) ;
    PS> } else {
    PS>     $oRet = test-EXOv2Connection -Credential $credential -verbose:$($verbose) ;
    PS> } ;
    PS> if($oRet.Valid){
    PS>     $pssEXOv2 = $oRet.PsSession ;
    PS>     $IsNoWinRM = $oRet.IsNoWinRM ;
    PS>     $smsg = "(Validated EXOv2 Connected to Tenant aligned with specified Credential)" ;
    PS>     if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
    PS>     else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
    PS> } else {
    PS>     $smsg = "NO VALID EXOV2/3 PSSESSION FOUND! (DISCONNECTING...)"
    PS>     if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
    PS>     else{ write-host -ForegroundColor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    PS>     # capture outlier: shows a session wo the test cmdlet, force reset
    PS>     DisConnect-EXO ;
    PS>     $bExistingEXOGood = $false ;
    PS> } ;    
    Fancier demo using a variety of verb-Auth & verb-xo cmdlets
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    #Requires -Version 3
    ##Requires -Modules AzureAD, verb-Text
    ##Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\sregex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    [CmdletBinding()]
     Param(
        [Parameter(Mandatory=$True,HelpMessage="Credentials [-Credentials [credential object]]")]
        [System.Management.Automation.PSCredential]$Credential = $global:credo365TORSID,
        [Parameter(HelpMessage = "Cert FriendlyName Suffix to be used for validating credential alignment(Optional but required for CBA calls)[-CertTag `$certtag]")]
        [string]$CertTag,
        [Parameter(HelpMessage = "MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']")]
        [version] $MinNoWinRMVersion = '3.0.0'
    )
    BEGIN {
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        if(-not $rgxCertFNameSuffix){$rgxCertFNameSuffix = '-([A-Z]{3})$' } ; 
        #*------v PSS & GMO VARIS v------
        # get-pssession session varis
        # select key differentiating properties:
        $pssprops = 'Id','ComputerName','ComputerType','State','ConfigurationName','Availability', 
            'Description','Guid','Name','Path','PrivateData','RootModuleModule', 
            @{name='runspace.ConnectionInfo.ConnectionUri';Expression={$_.runspace.ConnectionInfo.ConnectionUri} },  
            @{name='runspace.ConnectionInfo.ComputerName';Expression={$_.runspace.ConnectionInfo.ComputerName} },  
            @{name='runspace.ConnectionInfo.Port';Expression={$_.runspace.ConnectionInfo.Port} },  
            @{name='runspace.ConnectionInfo.AppName';Expression={$_.runspace.ConnectionInfo.AppName} },  
            @{name='runspace.ConnectionInfo.Credentialusername';Expression={$_.runspace.ConnectionInfo.Credential.username} },  
            @{name='runspace.ConnectionInfo.AuthenticationMechanism';Expression={$_.runspace.ConnectionInfo.AuthenticationMechanism } },  
            @{name='runspace.ExpiresOn';Expression={$_.runspace.ExpiresOn} } ; 
        $EXOv1ConfigurationName = $EXOv2ConfigurationName = $EXoPConfigurationName = "Microsoft.Exchange" ;

        if(-not $EXOv1ConfigurationName){$EXOv1ConfigurationName = "Microsoft.Exchange" };
        if(-not $EXOv2ConfigurationName){$EXOv2ConfigurationName = "Microsoft.Exchange" };
        if(-not $EXoPConfigurationName){$EXoPConfigurationName = "Microsoft.Exchange" };

        if(-not $EXOv1ComputerName){$EXOv1ComputerName = 'ps.outlook.com' };
        if(-not $EXOv1runspaceConnectionInfoAppName){$EXOv1runspaceConnectionInfoAppName = '/PowerShell-LiveID'  };
        if(-not $EXOv1runspaceConnectionInfoPort){$EXOv1runspaceConnectionInfoPort = '443' };

        if(-not $EXOv2ComputerName){$EXOv2ComputerName = 'outlook.office365.com' ;}
        if(-not $EXOv2Name){$EXOv2Name = "ExchangeOnlineInternalSession*" ; }
        if(-not $rgxEXoPrunspaceConnectionInfoAppName){$rgxEXoPrunspaceConnectionInfoAppName = '^/(exadmin|powershell)$'}; 
        if(-not $EXoPrunspaceConnectionInfoPort){$EXoPrunspaceConnectionInfoPort = '80' } ; 
        # gmo varis
        if(-not $rgxEXOv1gmoDescription){$rgxEXOv1gmoDescription = "^Implicit\sremoting\sfor\shttps://ps\.outlook\.com/PowerShell" }; 
        if(-not $EXOv1gmoprivatedataImplicitRemoting){$EXOv1gmoprivatedataImplicitRemoting = $true };
        if(-not $rgxEXOv2gmoDescription){$rgxEXOv2gmoDescription = "^Implicit\sremoting\sfor\shttps://outlook\.office365\.com/PowerShell" }; 
        if(-not $EXOv2gmoprivatedataImplicitRemoting){$EXOv2gmoprivatedataImplicitRemoting = $true } ;
        if(-not $rgxExoPsessionstatemoduleDescription){$rgxExoPsessionstatemoduleDescription = '/(exadmin|powershell)$' };
        if(-not $PSSStateOK){$PSSStateOK = 'Opened' };
        if(-not $PSSAvailabilityOK){$PSSAvailabilityOK = 'Available' };
        if(-not $EXOv1GmoFilter){$EXOv1GmoFilter = 'tmp_*' } ; 
        if(-not $EXOv2GmoNoWinRMFilter){$EXOv2GmoNoWinRMFilter = 'tmpEXO_*' };
        $EOMmodname = 'ExchangeOnlineManagement' ;
        # reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not
        #region EOMREV ; #*------v EOMREV Check v------
        #$EOMmodname = 'ExchangeOnlineManagement' ;
        $pltIMod = @{Name = $EOMmodname ; ErrorAction = 'Stop' ; verbose=$false} ;
        if($xmod = Get-Module $EOMmodname -ErrorAction Stop| sort version | select -last 1 ){ } else {
            $smsg = "Import-Module w`n$(($pltIMod|out-string).trim())" ;
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            Try {
                Import-Module @pltIMod | out-null ;
                $xmod = Get-Module $EOMmodname -ErrorAction Stop | sort version | select -last 1 ;
            } Catch {
                $ErrTrapd=$Error[0] ;
                $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $smsg = $ErrTrapd.Exception.Message ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Break ;
            } ;
        } ; # IsImported
        if([version]$xmod.version -ge $MinNoWinRMVersion){
            $MinNoWinRMVersion = $xmod.version.tostring() ;
            $IsNoWinRM = $true ; 
        }
        [boolean]$UseConnEXO = [boolean]([version]$xmod.version -ge $MinNoWinRMVersion) ; 
        #endregion EOMREV ; #*------^ END EOMREV Check  ^------

    } ;  # if-E BEGIN    
    PROCESS {
        $oReturn = [ordered]@{
            PSSession = $null ; 
            IsNoWinRM = $false ; 
            Valid = $false ; 
        } ; 
        $isEXOValid = $false ;
        # corrected $EXoPConfigurationName -> $EXOv2ConfigurationName; same value, but vari name should indicate purpose, as well as contents
        if($pssEXOv2 = Get-PSSession | 
                where-object {$_.ConfigurationName -like $EXOv2ConfigurationName -AND (
                    $_.Name -like $EXOv2Name) -AND (
                    $_.ComputerName -eq $EXOv2ComputerName) } ){
                    <# rem'd state/avail tests, run separately below: -AND (
                    $_.State -eq $PSSStateOK)  -AND (
                    $_.Availability -eq $PSSAvailabilityOK)
                    #>
            $smsg = "`n`nEXOv2 PSSessions:`n$(($pssEXOv2 | fl $pssprops|out-string).trim())" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

            if($pssEXOv2 | ?{ ($_.State -eq $PSSStateOK)  -AND (
                    $_.Availability -eq $PSSAvailabilityOK)}){

                # verify the exov2 cmdlets actually imported as a tmp_ module w specifid prefix & 1st cmdlet
                # below won't work with updated token support/MFA & loss of test|clear-ActiveToken from EOM (breaking change)
                # but it's needed when using EOM205, which still falls to basicauth! (readded down below)
                # revise for exov2 -cred support (where get-msaltoken gets used)
                # test-EXOToken & it's dependancy EOM:test-ActiveToken, *doesn't exist* after EOM v205!, if out the block
                if(-not $IsNoWinRM){
                    # Credential
                    $plttXT=[ordered]@{
                        Credential = $Credential ;
                        verbose = $($VerbosePreference -eq "Continue") ;
                    } ;
                    $smsg = "test-EXOToken w`n$(($plttXT|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ; 
                if ( (get-module -name $EXOv1GmoFilter | ForEach-Object {
                     Get-Command -module $_.name -name 'Add-xoAvailabilityAddressSpace' -ea 0 }) -AND (
                        test-EXOToken @plttXT)) {
                    $smsg = "(EXOv1Gmo Basic-Auth PSSession module detected)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $bExistingEXOGood = $true ;
                    # need as well, to get through if/then ahead of credential/tenant align check
                    $isEXOValid = $true ; 
                }elseif ( (get-module -name $EXOv2GmoNoWinRMFilter | ForEach-Object {
                    Get-Command -module $_.name -name 'Add-xoAvailabilityAddressSpace' -ea 0 }) -AND (
                        test-EXOToken @plttXT)) {
                    $smsg = "(EXOv2GmoNoWinRM module detected)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $bExistingEXOGood = $true ;
                    # need as well, to get through if/then ahead of credential/tenant align check
                    $isEXOValid = $true ; 
                } else { $bExistingEXOGood = $false ; }
                
                
            } else{
                # pss but disconnected state
                rxo2 ; 
            } ; 
            
        } elseif($IsNoWinRM -AND ((get-module $EXOv2GmoNoWinRMFilter) -AND (get-module $EOMmodname))){
            # no PSS and IsNoWinRM == v206+ PSS-less connection
            # verify the exov2 cmdlets actually imported as a tmp_ module w specifid prefix & 1st cmdlet

            # test-EXOToken() won't work with PSSession-less - it obtains the critical TokenExpireTime from the open PSSession
            # need to recode for these using get-aadtoken

            # 12:22 PM 8/1/2022 issue with get-msaltoken: it will auth EXO client app (by guid), but it doesn't support the key -prefix param, to make them verb-XOnoun; so you can't use it with hybrid onprem connections.
            # => looks like I'll have to either skip it, or test for cmdlets loaded, to verify. get-msaltoken actually runs an auth session, doesn't just validate one's present. 
            <# [PowerShell Gallery | MSAL.PS.psd1 4.1.0.2 - www.powershellgallery.com/](https://www.powershellgallery.com/packages/MSAL.PS/4.1.0.2/Content/MSAL.PS.psd1)
             nope, it's referring to 'virtual network address prefix'f
            #>
            # EOM v3 adds Get-ConnectionInformation, which has .tokenStatus -eq 'Active'

            if($xmod | Where-Object {$_.version -like "3.*"} ){
                $smsg = "EOM v3+ connection detected" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                if ((Get-ConnectionInformation).tokenStatus -eq 'Active') {
                    #write-host 'Connecting to Exchange Online' -ForegroundColor Cyan
                    #Connect-ExchangeOnline -UserPrincipalName $adminUPN
                    $bExistingEXOGood = $isEXOValid = $true ;
                }
            } else {  
                $smsg = "EOM v205p6+ connection detected" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                # it seamlessly reauths, wo prompts, so just validate a core cmdlet is loaded, plust the above
                if([boolean](get-command -name Get-xoOrganizationConfig)){
                    $smsg = "(`IsNoWinRM:`$true`nget-module:$($EXOv2GmoNoWinRMFilter)`nget-module:$($EOMmodname)`ngcm:Get-xoOrganizationConfig`n=>Appears Valid)" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

                    $bExistingEXOGood = $isEXOValid = $true ;
                    #$IsNoWinRM = $true ; # already tested above
                } else { 
                    $bExistingEXOGood = $isEXOValid = $false ;
                } ; 

            } ;
        } else { 
            $smsg = "Unable to detect EXOv2 or EXOv3 PSSession!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-host -ForegroundColor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            #throw $smsg ;
            #Break ; 
            $bExistingEXOGood = $isEXOValid = $false ; 
        } ; 

        if($bExistingEXOGood -ANd $isEXOValid){
            # implement caching of accepteddoms into the XXXMeta, in the session (cut back on queries to EXO on acceptedom)
            if( get-command Get-xoAcceptedDomain) {
                    #$TenOrg = get-TenantTag -Credential $Credential ;
                    # 1:10 PM 3/1/2024 Tenorg coming through unpopulated (after pulling legacy code), conditionally re-use the above rem:
                    if( (-not $TenOrg) -AND $Credential){ $TenOrg = get-TenantTag -Credential $Credential } ; 
                if(-not (Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_AcceptedDomains){
                    set-Variable  -name "$($TenOrg)Meta" -value ( (Get-Variable  -name "$($TenOrg)Meta" -ea 0).value += @{'o365_AcceptedDomains' = (Get-xoAcceptedDomain).domainname} )
                } ;
            } ;
            
            $smsg = "(validating Tenant:Credential alignment)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            
            if($credential.username -match $rgxCertThumbprint -AND $certTag -eq $null){
                $smsg = "CBA Certificate Thumprint cred uname detected, but -CertTag was *not* pass thru in call!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                break ; 
            } 
            if( ($credential.username -match $rgxCertThumbprint) -AND ((Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_Prefix -eq $certTag )){
                # 9:59 AM 6/24/2022 need a case for CBA cert (thumbprint username)
                # compare cert fname suffix to $xxxMeta.o365_Prefix
                # validate that the connected EXO is to the CBA Cert tenant
                $smsg = "(EXO Authenticated & Functional CBA cert:$($certTag),($($certUname)))" ;
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                $bExistingEXOGood = $isEXOValid = $true ;
            }elseif((Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_AcceptedDomains.contains($Credential.username.split('@')[1].tostring())){
                # validate that the connected EXO is to the $Credential tenant
                $smsg = "(EXO Authenticated & Functional:$($Credential.username.split('@')[1].tostring())),($($Credential.username))" ;
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $bExistingEXOGood = $isEXOValid = $true ;
            # issue: found fresh bug in cxo: svcacct UPN suffix @tenantname.onmicrosoft.com, but testing against AccepteDomain, it's not in there (tho @DOMAIN.mail.onmicrosoft.comis)
            }elseif((Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_TenantDomain -eq ($Credential.username.split('@')[1].tostring())){
                $smsg = "(EXO Authenticated & Functional(TenDom):$($Credential.username.split('@')[1].tostring()))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $bExistingEXOGood = $isEXOValid = $true ;
            } else {
                $smsg = "(Credential mismatch:disconnecting from existing EXO:$($eEXO.Identity) tenant)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                Disconnect-exo ;
                $bExistingEXOGood = $isEXOValid = $false ;
            } ;

            if($bExistingEXOGood -AND $isEXOValid){
                $oReturn.PSSession = $pssEXOv2 ; 
                if( ($IsNoWinRM -eq $true) -AND -not $pssEXOv2){
                    $smsg = "IsNoWinRM & no detected EXO PsSession:" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    $oReturn.IsNoWinRM = $IsNoWinRM
                }
                $oReturn.Valid = $isEXOValid ; 
            } else {
                $smsg = "(invalid session `$bExistingEXOGood:$($bExistingEXOGood) -OR `$isEXOValid:$($isEXOValid))" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                Disconnect-exo ;
            } ;  ; 
        } else { 
            $oReturn.PSSession = $pssEXOv2 ; 
            $oReturn.Valid = $isEXOValid ; 
        } ; 

    }  # PROC-E
    END{
        <# $oReturn = [ordered]@{
            PSSession = $null ; 
            Valid = $false ; 
        } ; 
        #>
        $smsg = "Returning `$oReturn:`n$(($oReturn|out-string).trim())" ; 
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        New-Object PSObject -Property $oReturn | write-output ; 
    } ;
}

#*------^ test-EXOv2Connection.ps1 ^------


#*------v test-xoMailbox.ps1 v------
Function test-xoMailbox {
    <#
    .SYNOPSIS
    test-xoMailbox.ps1 - Run quick mailbox function validation and metrics gathering, to streamline, 'Is it working?' questions. 
    .NOTES
    Version     : 10.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-04-21
    FileName    : test-xoMailbox.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell,ExchangeOnline,Exchange,Resource,MessageTrace
    REVISIONS
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 2:40 PM 12/10/2021 more cleanup 
    * 8:41 AM 8/27/2021 cleanup comments
    * 1:51 PM 5/19/2021 expanded $pltGHOpCred= to include 'ESVC','SID'; verbose=$($verbose)} ;
    # 12:27 PM 5/11/2021 updated to cover Room|Shared|Equipment mbx types, along with UserMailbox
    # 3:47 PM 5/6/2021 recoded start-log switching, was writing logs into AllUsers profile dir ; swapped out 'Fail' msgtrace expansion, and have it do all non-Delivery statuses, up to the $MsgTraceNonDeliverDetailsLimit = 10; tested, appears functional
    # 3:15 PM 5/4/2021 added trailing |?{$_.length} bug workaround for get-gcfastxo.ps1
    * 4:20 PM 4/29/2021 debugged, looks functional - could benefit from moving the msgtrk summary down into the output block, but [shrug]
    * 7:56 AM 4/28/2021 init
    .DESCRIPTION
    test-xoMailbox.ps1 - Run quick mailbox function validation and metrics gathering, to streamline, 'Is it working?' questions. 
    .PARAMETER Mailboxes
    Array of Mailbox email addresses [-Mailboxes mbx1@domain.com]
    .PARAMETER Ticket
    Ticket # [-Ticket nnnnn]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    .EXAMPLE
    test-xoMailbox.ps1 -TenOrg TOR -Mailboxes 'Fname.LName@domain.com','FName2.Lname2@domain.com' -Ticket 610706 -verbose ;
    .EXAMPLE
    .\test-xoMailbox.ps1
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    ##Requires -Modules ActiveDirectory,verb-Auth,verb-IO,verb-Mods,verb-Text,verb-Network,verb-AAD,verb-ADMS,verb-Ex2010,verb-logging
    # 2:49 PM 3/8/2022 pull verb-ex2010 ref - I think it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    #Requires -Modules ActiveDirectory,verb-Auth,verb-IO,verb-Mods,verb-Text,verb-Network,verb-AAD,verb-ADMS,verb-logging
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
        [ValidateNotNullOrEmpty()]
        $TenOrg = 'TOR',
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Array of EXO Mailbox identifiers to be processed [-mailboxes 'xxx','yyy']")]
        [ValidateNotNullOrEmpty()]$Mailboxes,
        [Parameter(Mandatory = $True, HelpMessage = "Ticket # [-Ticket nnnnn]")]
        [array]$Tickets,
        [Parameter(Position=0,Mandatory=$False,HelpMessage="Specific ResourceDelegate address to be confirmed for detailed delivery [emailaddr]")]
        [ValidateNotNullOrEmpty()][string]$TargetDelegate,
        [Parameter(Mandatory=$false,HelpMessage="Days back to search (defaults to 10)[-Days 10]")]
        [int]$Days=10,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2
    ) ;
    BEGIN {
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        #*======v SCRIPT/DOMAIN/MACHINE/INITIALIZATION-DECLARE-BOILERPLATE v======
        # SCRIPT-CONFIG MATERIAL TO SET THE UNDERLYING $DBGPREF:
        if ($ShowDebug) { $DebugPreference = "Continue" ; write-debug "(`$showDebug:$showDebug ;`$DebugPreference:$DebugPreference)" ; };
        if ($Whatif) { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):`$Whatif is TRUE (`$whatif:$($whatif))" ; };
        # If using WMI calls, push any cred into WMI:
        #if ($Credential -ne $Null) {$WmiParameters.Credential = $Credential }  ;

        <# scriptname with extension
        $ScriptDir = (Split-Path -parent $MyInvocation.MyCommand.Definition) + "\" ;
        $ScriptBaseName = (Split-Path -Leaf ((& { $myInvocation }).ScriptName))  ;
        $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
        #>
        # 11:24 AM 6/21/2019 UPDATED HYBRID VERS
        if($showDebug){
            write-host -foregroundcolor green "`SHOWDEBUG: `$PSScriptRoot:$($PSScriptRoot)`n`$PSCommandPath:$($PSCommandPath)" ;
        } ;
        if ($psISE){
                $ScriptDir = Split-Path -Path $psISE.CurrentFile.FullPath ;
                $ScriptBaseName = split-path -leaf $psise.currentfile.fullpath ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($psise.currentfile.fullpath) ;
                        $PSScriptRoot = $ScriptDir ;
                if($PSScriptRoot -ne $ScriptDir){ write-warning "UNABLE TO UPDATE BLANK `$PSScriptRoot TO CURRENT `$ScriptDir!"} ;
                $PSCommandPath = $psise.currentfile.fullpath ;
                if($PSCommandPath -ne $psise.currentfile.fullpath){ write-warning "UNABLE TO UPDATE BLANK `$PSCommandPath TO CURRENT `$psise.currentfile.fullpath!"} ;
        } else {
            if($host.version.major -lt 3){
                $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                $PSCommandPath = $myInvocation.ScriptName ;
                $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
            } elseif($PSScriptRoot) {
                $ScriptDir = $PSScriptRoot ;
                if($PSCommandPath){
                    $ScriptBaseName = split-path -leaf $PSCommandPath ;
                    $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($PSCommandPath) ;
                } else {
                    $PSCommandPath = $myInvocation.ScriptName ;
                    $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                    $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
                } ;
            } else {
                if($MyInvocation.MyCommand.Path) {
                    $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                    $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                    $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
                } else {
                    throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" ;
                } ;
            } ;
        } ;
        if($showDebug){
            write-host -foregroundcolor green "`SHOWDEBUG: `$ScriptDir:$($ScriptDir)`n`$ScriptBaseName:$($ScriptBaseName)`n`$ScriptNameNoExt:$($ScriptNameNoExt)`n`$PSScriptRoot:$($PSScriptRoot)`n`$PSCommandPath:$($PSCommandPath)" ;
        } ;
    
        $ComputerName = $env:COMPUTERNAME ;
        $sQot = [char]34 ; $sQotS = [char]39 ;
        $NoProf = [bool]([Environment]::GetCommandLineArgs() -like '-noprofile'); # if($NoProf){# do this};
        #$ProgInterval= 500 ; # write-progress wait interval in ms
        # 12:23 PM 2/20/2015 add gui vb prompt support
        #[System.Reflection.Assembly]::LoadWithPartialName('Microsoft.VisualBasic') | Out-Null ;
        # 11:00 AM 3/19/2015 should use Windows.Forms where possible, more stable

        switch -regex ($env:COMPUTERNAME) {
            ($rgxMyBox) { $LocalInclDir = "c:\usr\work\exch\scripts" ; }
            ($rgxProdEx2010Servers) { $LocalInclDir = "c:\scripts" ; }
            ($rgxLabEx2010Servers) { $LocalInclDir = "c:\scripts" ; }
            #($rgxProdL13Servers) { $LocalInclDir = "c:\scripts" ; }
            # ($rgxLabL13Servers) { $LocalInclDir = "c:\scripts" ; }
            ($rgxAdminJumpBoxes) { $LocalInclDir = (split-path $profile) ; }
        } ;

        $Retries = 4 ;
        $RetrySleep = 5 ;
        $DawdleWait = 30 ; # wait time (secs) between dawdle checks
        $DirSyncInterval = 30 ; # AADConnect dirsync interval 

        # email trigger vari, it will be semi-delimd list of mail-triggering events
        $PassStatus = $null ;


        $bMaintainEquipementLists = $false ; 
        $MsgTraceNonDeliverDetailsLimit = 10 ; # number of non status:Delivered messages to check/dump
    
        $ModMsgWindowMins = 5 ;
        if(!$Retries){$Retries = 4 } ;
        if(!$RetrySleep){$RetrySleep = 5} ;

         #$rgxOnMSAddr='.*.mail\.onmicrosoft\.com' ;
        # cover either mail. or not
        $rgxOnMSAddr = '.*@\w*((\.mail)*)\.onmicrosoft.com'
        $rgxExoSysFolders = '.*\\(Recipient\sCache|PersonMetadata|Audits|Calendar\sLogging|Purges)$'
            #'.*\\(Recipient\sCache|PersonMetadata|Audits|Calendar\sLogging|Purges|GAL\sContacts|Yammer\sRoot|Recoverable\sItems|Deletions|Versions)'
        #$rgxExcl = '.*\\(Recipient\sCache|PersonMetadata|Audits|Calendar\sLogging|Purges)$' ;

        $rgxSID = "^S-\d-\d+-(\d+-){1,14}\d+$" ;
        $rgxEntLicGrps = $TORMeta.rgxLicGrpDN ; 

        $propsXmbx = 'UserPrincipalName','Alias','ExchangeGuid','Database','ExternalDirectoryObjectId','RemoteRecipientType'
        $propsOPmbx = 'UserPrincipalName','SamAccountName','RecipientType','RecipientTypeDetails' ; 
        $propsRmbx = 'UserPrincipalName','ExchangeGuid','RemoteRoutingAddress','RemoteRecipientType' ;
        #$propNames = "SamAccountName","UserPrincipalName","name","mailNickname","msExchHomeServerName","mail","msRTCSIP-UserEnabled","msRTCSIP-PrimaryUserAddress","msRTCSIP-Line","DistinguishedName","Description","info","Enabled","LastLogonDate","userAccountControl","manager","whenChanged","whenCreated","msExchRecipientDisplayType","msExchRecipientTypeDetails","City","Company","Country","countryCode","Office","Department","Division","EmailAddress","employeeType","State","StreetAddress","surname","givenname","telephoneNumber" ;
        #$propNames = "SamAccountName","UserPrincipalName","name","mailNickname","msExchHomeServerName","mail","msRTCSIP-UserEnabled","msRTCSIP-PrimaryUserAddress","msRTCSIP-Line","DistinguishedName","Description","info","Enabled","LastLogonDate","userAccountControl","manager","whenChanged","whenCreated","msExchRecipientDisplayType","msExchRecipientTypeDetails","City","Company","Country","countryCode","Office","Department","Division","EmailAddress","employeeType","State","StreetAddress","surname","givenname","telephoneNumber" ;
        #$adprops = "samaccountname", "msExchRemoteRecipientType", "msExchRecipientDisplayType", "msExchRecipientTypeDetails", "userprincipalname" ;
        $adprops = "samaccountname","UserPrincipalName","memberof","msExchMailboxGuid","msexchrecipientdisplaytype","msExchRecipientTypeDetails","msExchRemoteRecipientType"
        $propsmbxfldrs = @{Name='Folder'; Expression={$_.Identity.tostring()}},@{Name='Items'; Expression={$_.ItemsInFolder}}, @{n='SizeMB'; e={($_.FolderSize.tostring().split('(')[1].split(' ')[0].replace(',','')/1MB).ToString('0.000')}}, @{Name='OldestItem'; Expression={get-date $_.OldestItemReceivedDate -f 'yyyy/MM/dd'}},@{Name='NewestItem'; Expression={get-date $_.NewestItemReceivedDate -f 'yyyy/MM/dd'}} ;
        $propsMsgTrc = @{N='ReceivedLocal';E={$_.Received.ToLocalTime()}},'SenderAddress','RecipientAddress','Subject','Status','ToIP','FromIP','Size','MessageId','MessageTraceId','Index' ; 
        $propsMsgTrcDtl = 'Date','Event','Action','Detail','Data' ;  
        $msgprops = 'Received','SenderAddress','RecipientAddress','Subject','Status' # ,'MessageId','MessageTraceId' ;
        $mtdprops = 'Date','Event','Detail','data' ;
    
        #*======v HELPER FUNCTIONS v======

        #-------v Function _cleanup v-------
        function _cleanup {
            # clear all objects and exit
            # Clear-item doesn't seem to work as a variable release

            # 12:58 PM 7/23/2019 spliced in chunks from same in maintain-restrictedothracctsmbxs.ps1
            # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
            # 8:45 AM 10/13/2015 reset $DebugPreference to default SilentlyContinue, if on
            # # 8:46 AM 3/11/2015 at some time from then to 1:06 PM 3/26/2015 added ISE Transcript
            # 8:39 AM 12/10/2014 shifted to stop-transcriptLog function
            # 7:43 AM 1/24/2014 always stop the running transcript before exiting

            write-verbose "_cleanup" ; 
            <# transcript/log are handled in the mbx loop
            #stop-transcript
            # 11:16 AM 1/14/2015 aha! does this return a value!??
            if ($host.Name -eq "Windows PowerShell ISE Host") {
                # 8:46 AM 3/11/2015 shift the logfilename gen out here, so that we can arch it
                #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -uformat "%Y%m%d-%H%M" ) + "-ISEtrans.log")) ;
                # 2:16 PM 4/27/2015 shift to static timestamp $timeStampNow
                #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + $timeStampNow + "-ISEtrans.log")) ;
                # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
                $Logname = (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -format 'yyyyMMdd-HHmmtt') + "-ISEtrans.log")) ;
                write-host "`$Logname: $Logname";
                Start-iseTranscript -logname $Logname ;
                #Archive-Log $Logname ;
                # 1:23 PM 4/23/2015 standardize processing file so that we can send a link to open the transcript for review
                $transcript = $Logname
            } else {
                write-verbose "$(get-timestamp):Stop Transcript" ;
                Stop-TranscriptLog ;
                #write-verbose "$(get-timestamp):Archive Transcript" ;
                #Archive-Log $transcript ;
            } # if-E
            
            # also echo the log:
            if ($logging) { 
                # Write-Log -LogContent $smsg -Path $logfile
                $smsg = "`$logging:`$true:written to:`n$($logfile)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
            #>

            # need to email transcript before archiving it
            
            #$smtpSubj= "Proc Rpt:$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"   ;

            #Load as an attachment into the body text:
            #$body = (Get-Content "path-to-file\file.html" ) | converto-html ;
            #$SmtpBody += ("Pass Completed "+ [System.DateTime]::Now + "`nResults Attached: " +$transcript) ;
            # 4:07 PM 10/11/2018 giant transcript, no send
            #$SmtpBody += "Pass Completed $([System.DateTime]::Now)`nResults Attached:($transcript)" ;
            $SmtpBody += "Pass Completed $([System.DateTime]::Now)`nTranscript:($transcript)" ;
            # 12:55 PM 2/13/2019 append the $PassStatus in for reference
            if($PassStatus ){
                $SmtpBody += "`n`$PassStatus triggers:: $($PassStatus)`n" ;
            } ;
            $SmtpBody += "`n$('-'*50)" ;
            #$SmtpBody += (gc $outtransfile | ConvertTo-Html) ;
            # name $attachment for the actual $SmtpAttachment expected by Send-EmailNotif
            #$SmtpAttachment=$transcript ;
            # 1:33 PM 4/28/2017 test for ERROR|CHANGE - actually non-blank, only gets appended to with one or the other
            if($PassStatus ){
                Send-EmailNotif ;
            } else {
                write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):No Email Report: `$Passstatus is `$null ; " ;
            } ;

            
            #$smsg= "#*======^ END PASS:$($ScriptBaseName) ^======" ;
            #this is now a function, use: ${CmdletName}
            $smsg= "#*======^ END PASS:$(${CmdletName}) ^======" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn

            Break
        } #*------^ END Function _cleanup ^------


        #*======^ END HELPER FUNCTIONS ^======

        #*======v SUB MAIN v======

        # email trigger vari, it will be semi-delimd list of mail-triggering events
        $script:PassStatus = $null ;
        $Alltranscripts = @() ;

        # defer transcript until mbx loop
    
        #-=-=configure EXO EMS aliases to cover useEXOv2 requirements-=-=-=-=-=-=
        # have to preconnect, as it gcm's the targets
        if ($script:useEXOv2) { reconnect-eXO2 }
        else { reconnect-EXO } ;
        # in this case, we need an alias for EXO, and non-alias for EXOP
        [array]$cmdletMaps = 'ps1GetxRcp;get-exorecipient;','ps1GetxMbx;get-exomailbox;','ps1SetxMbx;Set-exoMailbox;','ps1GetxUser;get-exoUser;',
            'ps1SetxCalProc;set-exoCalendarprocessing;','ps1GetxCalProc;get-exoCalendarprocessing;','ps1GetxMbxFldrPerm;get-exoMailboxfolderpermission;',
            'ps1GetxAccDom;Get-exoAcceptedDomain;','ps1GetXRetPol;Get-exoRetentionPolicy','ps1GetxDistGrp;get-exoDistributionGroup;',
            'ps1GetxDistGrpMbr;get-exoDistributionGroupmember;','ps1GetxMsgTrc;get-exoMessageTrace;','ps1GetxMsgTrcDtl;get-exoMessageTraceDetail;',
            'ps1GetxMbxFldrStats;get-exoMailboxfolderStatistics','ps1GetxMContact;Get-exomailcontact;','ps1SetxMContact;Set-exomailcontact;',
            'ps1NewxMContact;New-exomailcontact;' ,'ps1TestxMapi;Test-exoMAPIConnectivity' ;
        foreach($cmdletMap in $cmdletMaps){
            if($script:useEXOv2){
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1].replace('-exo','-xo') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
            } else {
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;                
                write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
            } ;
        } ;
    
        # shifting from ps1 to a function: need updates self-name:
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;

        #$sBnr="#*======v START PASS:$($ScriptBaseName) v======" ; 
        $sBnr="#*======v START PASS:$(${CmdletName}) v======" ; 
        $smsg= $sBnr ;   
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;


        # steer all onprem code on $XXXMeta.ExOPAccessFromToro & Ex10Server values
        $UseOP=$false ; 
        if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
            $UseOP = $true ; 
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ; 
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } else { 
            $UseOP = $false ; 
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ; 
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; 

        $useEXO = $true ; # non-dyn setting, drives variant EXO reconnect & query code
        if($useEXO){
            #*------v GENERIC EXO CREDS & SVC CONN BP v------
            # o365/EXO creds
            <### Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile* 
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
            Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
            Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
            Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            ###>
            $o365Cred=$null ;
            
            if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -UserRole 'CSVC','SID' -verbose:$($verbose))){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
                $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                Break ;
            } ;
            <### CALLS ARE IN FORM: (cred$($tenorg))
            $pltRXO = @{Credential = $Credential ; verbose = $($verbose) ; }
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                verbose = $($verbose) ; } ; 
            if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
            else { reconnect-EXO @pltRXO } ;
            # or with Tenant-specific cred($Tenorg) lookup
            #$pltRXO creds & .username can also be used for AzureAD connections 
            Connect-AAD @pltRXO ; 
            ###>
            # configure splat for connections: (see above useage)
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                verbose = $($verbose) ; } ; 
            #*------^ END GENERIC EXO CREDS & SVC CONN BP ^------
        } # if-E $useEXO

        if($UseOP){
            #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
            # do the OP creds too
            $OPCred=$null ;
            # default to the onprem svc acct
            $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC','SID'; verbose=$($verbose)} ;
            if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                Break ;
            } ;
            $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;  
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            <# CALLS ARE IN FORM: (cred$($tenorg))
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                verbose = $($verbose) ; }
            ReConnect-Ex2010XO @pltRX10 ; # cross-prem conns
            Reconnect-Ex2010 @pltRX10 ; # local org conns
            #$pltRx10 creds & .username can also be used for local ADMS connections
            #>
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                verbose = $($verbose) ; } ;     
            # TEST
        
            # defer cx10/rx10, until just before get-recipients qry
            #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
            # connect to ExOP X10
            if($pltRX10){
                #ReConnect-Ex2010XO @pltRX10 ;
                ReConnect-Ex2010 @pltRX10 ;
            } else { Reconnect-Ex2010 ; } ; 
        } ;  # if-E $useEXOP

        <# already confirmed in modloads
        # load ADMS
        $reqMods += "load-ADMS".split(";") ;
        if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
        #>
        write-host -foregroundcolor gray  "(loading ADMS...)" ;
        #write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):MSG" ; 

        load-ADMS ;

        if($UseOP){
            # resolve $domaincontroller dynamic, cross-org
            # setup ADMS PSDrives per tenant 
            if(!$global:ADPsDriveNames){
                $smsg = "(connecting X-Org AD PSDrives)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $global:ADPsDriveNames = mount-ADForestDrives -verbose:$($verbose) ;
            } ; 
            if(($global:ADPsDriveNames|measure).count){
                $useEXOforGroups = $false ; 
                $smsg = "Confirming ADMS PSDrives:`n$(($global:ADPsDriveNames.Name|%{get-psdrive -Name $_ -PSProvider ActiveDirectory} | ft -auto Name,Root,Provider|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                # returned object
                #         $ADPsDriveNames
                #         UserName                Status Name        
                #         --------                ------ ----        
                #         DOM\Samacctname   True  [forestname wo punc] 
                #         DOM\Samacctname   True  [forestname wo punc]
                #         DOM\Samacctname   True  [forestname wo punc]
        
            } else { 
                #-=-record a STATUS=-=-=-=-=-=-=
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                #-=-=-=-=-=-=-=-=
                $smsg = "Unable to detect POPULATED `$global:ADPsDriveNames!`n(should have multiple values, resolved to $()"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                Break ;
            } ; 
        } ; 
        #if (!$domaincontroller) { $domaincontroller = get-gcfast } ;
        #if(!$domaincontroller){ if(test-path function:get-gcfast){$domaincontroller=get-gcfast} else { throw "no get-gcfast()!" } ;} else {"(existing `$domaincontroller:$($domaincontroller))"} ;
        # use new get-GCFastXO cross-org dc finde
        # default to Op_ExADRoot forest from $TenOrg Meta
        $domaincontroller = get-GCFastXO -TenOrg $TenOrg -subdomain ((gv -name "$($TenOrg)Meta").value['OP_ExADRoot']) -verbose:$($verbose) |?{$_.length};


        <# MSOL CONNECTION
        $reqMods += "connect-msol".split(";") ;
        if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
        write-host -foregroundcolor gray  "(loading AAD...)" ;
        #connect-msol ;
        connect-msol @pltRXO ; 
        #>

        # AZUREAD CONNECTION
        $reqMods += "Connect-AAD".split(";") ;
        if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
        write-host -foregroundcolor gray  "(loading AAD...)" ;
        #connect-msol ;
        Connect-AAD @pltRXO ; 
        #


        #
        # EXO connection
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            verbose = $($verbose) ; } ; 
        if($VerbosePreference = "Continue"){
            $VerbosePrefPrior = $VerbosePreference ;
            $VerbosePreference = "SilentlyContinue" ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ; 
        disconnect-exo ;
        if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
        else { reconnect-EXO @pltRXO } ;
        # reenable VerbosePreference:Continue, if set, during mod loads 
        if($VerbosePrefPrior -eq "Continue"){
            $VerbosePreference = $VerbosePrefPrior ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        #

        
        # 3:00 PM 9/12/2018 shift this to 1x in the script ; - this would need to be customized per tenant, not used (would normally be for forcing UPNs, but CMW uses brand UPN doms)
        

        # Clear error variable
        $Error.Clear() ;
        

    } ;  # BEGIN-E
    PROCESS {
        $rMailboxes = @() ;
        $Error.Clear() ;
        $SearchesRun = 0 ;
        $smsg = "Net:$(($Mailboxes|measure).count) mailboxes" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $ttl = ($Mailboxes | measure).count ;
        $Procd = 0 ;

        # 9:20 AM 2/25/2019 Tickets will be an array of nnn's to match the mbxs, so use $Procd-1 as the index for tick# in the array
        if((($Mailboxes|measure).count -gt 1) -AND (($Tickets|measure).count -eq 1)){
            # Mult mbxs with single Ticket, expand ticket count to match # of mbxes
            foreach($mbx in $Mailboxes){
                $Tickets+=$Tickets[0] ; 
            } ; 
        } ; 
        foreach($Mailbox in $Mailboxes){
            $Procd++ ;
        
            if ($Ticket = $Tickets[($Procd - 1)]) {
                $sBnr = "#*======v `$Ticket:$($ticket):`$Mailbox:($($Procd)/$($ttl)):$($Mailbox) v======" ;
                $ofileroot = ".\logs\$($ticket)-" ;
                $lTag = "$($ticket)-$($Mailbox)-" ; 
            }else {
                $sBnr = "#*======v `$Ticket:(not spec'd):`$Mailbox:($($Procd)/$($ttl)):$($Mailbox) v======" ;
                $ofileroot = ".\logs\" ;
                $lTag = "$($Mailbox)-" ; 
            } ;

            # detect profile installs (installed mod or script), and redir to stock location
            $dPref = 'd','c' ; foreach($budrv in $dpref){ if(test-path -path "$($budrv):\scripts" -ea 0 ){ break ;  } ;  } ;
            [regex]$rgxScriptsModsAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)" ;
            [regex]$rgxScriptsModsCurrUserScope="^$([regex]::escape([environment]::getfolderpath('Mydocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)" ;
            # -Tag "($TenOrg)-LASTPASS" 
            $pltSLog = [ordered]@{ NoTimeStamp=$false ; Tag=$lTag  ; showdebug=$($showdebug) ;whatif=$($whatif) ;} ;
            if($PSCommandPath){
                if(($PSCommandPath -match $rgxScriptsModsAllUsersScope) -OR ($PSCommandPath -match $rgxScriptsModsCurrUserScope) ){
                    # AllUsers or CU installed script, divert into [$budrv]:\scripts (don't write logs into allusers context folder)
                    if($PSCommandPath -match '\.ps(d|m)1$'){
                        # module function: use the ${CmdletName} for childpath
                        $pltSLog.Path= (join-path -Path "$($budrv):\scripts" -ChildPath "$(${CmdletName}).ps1" )  ;
                    } else { 
                        $pltSLog.Path=(join-path -Path "$($budrv):\scripts" -ChildPath (split-path $PSCommandPath -leaf)) ;
                    } ; 
                }else {
                    $pltSLog.Path=$PSCommandPath ;
                } ;
            } else {
                if( ($MyInvocation.MyCommand.Definition -match $rgxScriptsModsAllUsersScope) -OR ($MyInvocation.MyCommand.Definition -match $rgxScriptsModsCurrUserScope) ){
                    $pltSLog.Path=(join-path -Path "$($budrv):\scripts" -ChildPath (split-path $PSCommandPath -leaf)) ;
                } else {
                    $pltSLog.Path=$MyInvocation.MyCommand.Definition ;
                } ;
            } ;
            $smsg = "start-Log w`n$(($pltSLog|out-string).trim())" ;
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            $logspec = start-Log @pltSLog ;

            if($logspec){
                $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                $logging=$logspec.logging ;
                $logfile=$logspec.logfile ;
                $transcript=$logspec.transcript ;
                #Configure default logging from parent script name
                # logfile                        C:\usr\work\o365\scripts\logs\move-MailboxToXo-(TOR)-LASTPASS-LOG-BATCH-WHATIF-log.txt
                # transcript                     C:\usr\work\o365\scripts\logs\move-MailboxToXo-(TOR)-LASTPASS-Transcript-BATCH-WHATIF-trans-log.txt
                #$logfile = $logfile.replace('-LASTPASS','').replace('BATCH',(Remove-InvalidFileNameChars -name $BatchName )) ;
                $logfile = $logfile.replace('-LASTPASS','').replace('BATCH','') ;
                #$transcript = $transcript.replace('-LASTPASS','').replace('BATCH',(Remove-InvalidFileNameChars -name $BatchName )) ;
                $transcript = $transcript.replace('-LASTPASS','').replace('BATCH','') ;
                if(Test-TranscriptionSupported){start-transcript -Path $transcript }
                else { write-warning "$($host.name) v$($host.version.major) does *not* support Transcription!" } ;
            } else {throw "Unable to configure logging!" } ;
    
            $smsg = "$($sBnr)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            $sBnr="#*======v MAILBOX:$($Mailbox) v======" ;
            $smsg = "$((get-date).ToString('HH:mm:ss')):$($sBnr)" ;
            $pltXcsv = [ordered]@{Path=$null; NoTypeInformation=$true ; } ;
            $error.clear() ;

            $rcp = $null ; $exorcp = $null ;
            $exombx = $null ; $opombx = $null ;  $rmbx = $null ;
            $targetUPN = $NULL ;
            $adu = $null ; $msolu = $null ;
            $bMissingMbx = $false ;
            $exolicdetails = $null ;
            $obj = $null ;
            $grantgroup = $null ;
            $tuser = $null ;
            $UPN = $null ;
            $MailboxFoldersExo = $null ;

            $Exit = 0 ;

            if($pltRXO){
                if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
                else { reconnect-EXO @pltRXO } ;
            } else {reconnect-exo ;} ; 
            #Reconnect-Ex2010 ;
            if($pltRX10){
                #ReConnect-Ex2010XO @pltRX10 ;
                ReConnect-Ex2010 @pltRX10 ;
            } else { Reconnect-Ex2010 ; } ; 

            $Exit = 0 ; $error.clear() ;
            Do {
                Try {
                    $rcp = get-recipient -id $Mailbox -domaincontroller $domaincontroller -ea stop ;
                
                    $smsg= "(successful get-recipient -id $($Mailbox))" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else { write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $Exit = $Retries ;
                }
                Catch {
                    $errTrpd=$_ ; 
                    if( $errtrpd -match "\scouldn't\sbe\sfound\son\s" ){
                        $smsg = "(no EXOP recicpient found)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $Exit = $Retries ;
                    } else { 
                        $smsg=": Error Details: $($errTrpd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        Start-Sleep -Seconds $RetrySleep ;
                        if($pltRX10){
                            #ReConnect-Ex2010XO @pltRX10 ;
                            ReConnect-Ex2010 @pltRX10 ;
                        } else { ReConnect-Ex2010  } ; 
                        $Exit ++ ;
                        Write-Verbose "Failed to exec cmd because: $($Error[0])" ;
                        Write-Verbose "Try #: $Exit" ;                    
                    } ; 
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;
            } Until ($Exit -eq $Retries) ;

            $Exit = 0 ; $error.clear() ;
            Do {
                Try {
                    $pltgxrcp=[ordered]@{identity=$Mailbox ; erroraction='stop'; } ; 

                    $smsg= "$((get-alias ps1GetxRcp).definition) w`n$(($pltgxrcp|out-string).trim())" ; 
                    if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

                    $exorcp = ps1GetxRcp @pltgxrcp ;
                
                    $smsg= "(successful get-exorecipient -id $($Mailbox))" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                
                    $Exit = $Retries ;
                }
                Catch {
                    # get fails go here with: The operation couldn't be performed because object 'ACCOUNT@DOMAIN.com' couldn't be found on 'CY4PR04A008DC10.NAMPR04A008.PROD.OUTLOOK.COM'.
                    $errTrpd=$_ ; 
                    if( $errtrpd -match "\scouldn't\sbe\sfound\son\s" ){
                        $smsg = "(no EXO recipient found)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $Exit = $Retries ;
                    } else { 
                        $smsg=": Error Details: $($errTrpd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        Start-Sleep -Seconds $RetrySleep ;
                        if($pltRXO){
                            if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
                            else { reconnect-EXO @pltRXO } ;
                        } else {reconnect-exo ;} ; 
                        $Exit ++ ;
                        Write-Verbose "Failed to exec cmd because: $($Error[0])" ;
                        Write-Verbose "Try #: $Exit" ;                    
                    } ; 
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;
            } Until ($Exit -eq $Retries) ;


            $Exit = 0 ; $error.clear() ;
            Do {
                Try {
                    $pltgxmbx=[ordered]@{identity=$Mailbox ; erroraction='stop'; } ; 
                    $smsg= "$((get-alias ps1GetxMbx).definition) w`n$(($pltgxmbx|out-string).trim())" ; 
                    if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

                
                    $exombx = ps1GetxMbx @pltgxmbx ; 

                    $smsg= "(successful get-exomailbox -id $($Mailbox))" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;


                    if ($exombx) {
                        $pltGetxMbxFldrStats=[ordered]@{Identity=$exombx.identity ;IncludeOldestAndNewestItems=$true; erroraction='stop'; } ; 
                        #$smsg= "(collecting get-exomailboxfolderstatistics...)" ;
                        $smsg= "$((get-alias ps1GetxMbxFldrStats).definition) w`n$(($pltGetxMbxFldrStats|out-string).trim())" ; 
                        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        $exofldrs = ps1GetxMbxFldrStats @pltGetxMbxFldrStats | 
                            ?{($_.ItemsInFolder -gt 0 ) -AND ($_.identity -notmatch $rgxExoSysFolders)} ;
                        #$fldrs = get-exomailboxfolderstatistics -id ID -IncludeOldestAndNewestItems ;
                        #$fldrs = $fldrs |?{($_.ItemsInFolder -gt 0 ) -AND ($_.identity -notmatch $rgxExoSysFolders)} ;
                        #$fldrs | ft -auto $propsmbxfldrs ;

                        # do a 7day msgtrc
                        #-=-=-=-=-=-=-=-=
                        $isplt=@{    
                            ticket=$ticket ;
                            uid=$Mailbox;
                            days=$Days ;
                            StartDate='' ;
                            EndDate='' ;
                            Sender="" ;
                            Recipients=$exombx.PrimarySmtpAddress ;
                            MessageSubject="" ;
                            Status='' ;
                            MessageTraceId='' ;
                            MessageId='' ;
                        }  ;
                        $msgtrk=@{ PageSize=1000 ; Page=$null ; StartDate=$null ; EndDate=$null ; } ;

                        if($isplt.days){  
                            $msgtrk.StartDate=(get-date ([datetime]::Now)).adddays(-1*$isplt.days);
                            $msgtrk.EndDate=(get-date) ;
                        } ;
                        if($isplt.StartDate -and !($isplt.days)){$msgtrk.StartDate=$(get-date $isplt.StartDate)} ;
                        if($isplt.EndDate -and !($isplt.days)){$msgtrkEndDate=$(get-date $isplt.EndDate)} 
                        elseif($isplt.StartDate -and !($isplt.EndDate)){
                            $smsg = '(StartDate w *NO* Enddate, asserting currenttime)' ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $msgtrkEndDate=(get-date) ;
                        } ;

                        TRY{$tendoms=Get-AzureADDomain }CATCH{
                            #write-warning "NOT AAD CONNECTED!" ;BREAK ;
                            $smsg = "Not AAD connected, reconnect..." ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Connect-AAD @pltRXO ; 
                        } ;

                        $Ten = ($tendoms |?{$_.name -like '*.mail.onmicrosoft.com'}).name.split('.')[0] ;
                        $ofile ="$($isplt.ticket)-$($Ten)-$($isplt.uid)-EXOMsgTrk" ;
                        if($isplt.Sender){
                            if($isplt.Sender -match '\*'){
                                $smsg = "(wild-card Sender detected)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                $msgtrk.add("SenderAddress",$isplt.Sender) ;
                            } else {
                                $msgtrk.add("SenderAddress",$isplt.Sender) ;
                            } ;
                            $ofile+=",From-$($isplt.Sender.replace("*","ANY"))" ;
                        } ;
                        if($isplt.Recipients){
                            if($isplt.Recipients -match '\*'){
                                $smsg = "(wild-card Recipient detected)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                $msgtrk.add("RecipientAddress",$isplt.Recipients) ;
                            } else {
                                $msgtrk.add("RecipientAddress",$isplt.Recipients) ;
                            } ;
                            $ofile+=",To-$($isplt.Recipients.replace("*","ANY"))" ;
                        } ;

                        if($isplt.MessageId){
                            $msgtrk.add("MessageId",$isplt.MessageId) ;
                            $ofile+=",MsgId-$($isplt.MessageId.replace('<','').replace('>',''))" ;
                        } ;
                        if($isplt.MessageTraceId){
                            $msgtrk.add("MessageTraceId",$isplt.MessageTraceId) ;
                            $ofile+=",MsgId-$($isplt.MessageTraceId.replace('<','').replace('>',''))" ;
                        } ;
                        if($isplt.MessageSubject){
                            $ofile+=",Subj-$($isplt.MessageSubject.substring(0,[System.Math]::Min(10,$isplt.MessageSubject.Length)))..." ;
                        } ;
                        if($isplt.Status){
                            $msgtrk.add("Status",$isplt.Status)  ;
                            $ofile+=",Status-$($isplt.Status)" ;
                        } ;
                        if($isplt.days){$ofile+= "-$($isplt.days)d-" } ;
                        if($isplt.StartDate){$ofile+= "-$(get-date $isplt.StartDate -format 'yyyyMMdd-HHmmtt')-" } ;
                        if($isplt.EndDate){$ofile+= "$(get-date $isplt.EndDate -format 'yyyyMMdd-HHmmtt')" } ;

                        $smsg = "Running MsgTrk:$($Ten)" ;
                        $smsg += "`n$(($msgtrk|out-string).trim()|out-default)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        $Page = 1  ;
                        $Msgs=$null ;
                        do {
                            $smsg = "Collecting - Page $($Page)..."  ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            $msgtrk.Page=$Page ;
                            $PageMsgs = ps1GetxMsgTrc @msgtrk |  ?{$_.SenderAddress -notlike '*micro*' -or $_.SenderAddress -notlike '*root*' }  ;
                            $Page++  ;
                            $Msgs += @($PageMsgs)  ;
                        } until ($PageMsgs -eq $null) ;
                        $Msgs=$Msgs| Sort Received ;
                    
                        $smsg = "==Msgs Returned:$(($Msgs|measure).count)`nRaw matches:$(($Msgs|measure).Count)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        if($isplt.MessageSubject){
                            $smsg = "Post-Filtering on Subject:$($isplt.MessageSubject)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            $Msgs = $Msgs | ?{$_.Subject -like $isplt.MessageSubject} ;
                            $ofile+="-Subj-$($isplt.MessageSubject.replace("*"," ").replace("\"," "))" ;
                            $smsg = "Post Subj filter matches:$(($Msgs|measure).Count)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        } ;
                        $ofile+= "-run$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
                        #$ofile=[RegEx]::Replace($ofile, "[{0}]" -f ([RegEx]::Escape(-join [System.IO.Path]::GetInvalidFileNameChars())), '') ;
                        $ofile = Remove-InvalidFileNameChars -name $ofile ; 
                        $ofile=".\logs\$($ofile)" ;
                     
                        if($Msgs){
                            $Msgs | select  | export-csv -notype -path $ofile  ;
                            "Status Distrib:" ;
                            $smsg = "`n#*------v MOST RECENT MATCH v------" ;
                            $smsg += "`n$(($msgs[-1]| format-list ReceivedLocal,StatusSenderAddress,RecipientAddress,Subject|out-string).trim())";
                            $smsg += "`n#*------^ MOST RECENT MATCH ^------" ;
                            $smsg += "`n#*------v Status DISTRIB v------" ;
                            $smsg += "`n$(($Msgs | select -expand Status | group | sort count,count -desc | select count,name |out-string).trim())";
                            $smsg += "`n#*------^ Status DISTRIB ^------" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            <# Count Name                      Group
                            ----- ----                      -----
                              448 Delivered                 {@{PSComputerName=ps.outlook.com; RunspaceId=25f3aa28-9437-4e30-aa8f-8d83d2d2fc5a; PSShowComputerName=False; Organization=DOMAIN.onmicrosoft.com; MessageId=<BN8PR12MB33158F1D07B3862078D758E6EB499@BN8PR12MB3315.namprd12.prod.o...
                                1 Failed                    {@{PSComputerName=ps.outlook.com; RunspaceId=25f3aa28-9437-4e30-aa8f-8d83d2d2fc5a; PSShowComputerName=False; Organization=DOMAIN.onmicrosoft.com; MessageId=<5bc2055fed4d43d3827cf7f61d37a4c9@CH2PR04MB7062.namprd04.prod.outlook...
                                1 Quarantined               {@{PSComputerName=ps.outlook.com; RunspaceId=25f3aa28-9437-4e30-aa8f-8d83d2d2fc5a; PSShowComputerName=False; Organization=DOMAIN.onmicrosoft.com; MessageId=<threatsim-5f0bc0101d-c200b2590d@app.emaildistro.com>; Received=4/28/...
                                1 FilteredAsSpam            {@{PSComputerName=ps.outlook.com; RunspaceId=25f3aa28-9437-4e30-aa8f-8d83d2d2fc5a; PSShowComputerName=False; Organization=DOMAIN.onmicrosoft.com; MessageId=<SA0PR01MB61858E3C6111672E081373C1E45F9@SA0PR01MB6185.prod.exchangela...
                            #>
                            $nonDelivStats = $msgs | ?{$_.status -ne 'Delivered'} | group status | select-object -expand name ; 
                            
                            foreach ($status in $nonDelivStats){
                                $smsg = "Enumerating Status:$($status) messages" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                if($StatMsgs  = $msgs|?{$_.status -eq $status}){
                                    if(($StatMsgs |measure).count -gt 10){
                                        $smsg = "(over $($MsgTraceNonDeliverDetailsLimit) $($status) msgs: processing a sample of last $($MsgTraceNonDeliverDetailsLimit)...)" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        $StatMsgs = $StatMsgs | select-object -Last $MsgTraceNonDeliverDetailsLimit ;
                                    } ; 
                                    $statTtl = ($StatMsgs |measure).count ; $fProcd=0 ; 
                                    $smsg = "$($statTtl) Status:'$($status)' messages returned. Expanding detailed processing..." ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        foreach($fmsg in $StatMsgs ){
                                            $fProcd++ ; 
                                            $sBnrS="`n#*------v PROCESSING $($status)#$($fProcd)/$($statTtl): v------" ; 
                                            $smsg= "$($sBnrS)" ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                                            $pltGetxMsgTrcDtl = [ordered]@{MessageTraceId=$fmsg.MessageTraceId ;RecipientAddress=$fmsg.RecipientAddress} ; 
                                            $smsg= "$((get-alias ps1GetxMsgTrcDtl).definition) w`n$(($pltGetxMsgTrcDtl|out-string).trim())" ; 
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                
                                            # this is nested in a try already
                                            $MsgTrkDtl = ps1GetxMsgTrcDtl @pltGetxMsgTrcDtl ; 

                                            if($MsgTrkDtl){
                                                $smsg = "`n-----`n$(( $MsgTrkDtl | fl $propsMsgTrcDtl|out-string).trim())`n-----`n" ; 
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                            } else { 
                                                $smsg = "(no matching MessageTraceDetail was returned by MS for MsgTrcID:$($pltGetxMsgTrcDtl.MessageTraceId), aged out of availability already)" ; 
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                                $smsg = "$($status)#$($fProcd)/$($statTtl):DETAILS`n----`n$(($fmsg|fl | out-string).trim())`n----`n" ; 
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                            } ; 

                                            $smsg= "$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        } ; 
                                
                                }
                            } ; #nonDelivStats
                            if(test-path -path $ofile){
                                $smsg = "(log file confirmed)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                Resolve-Path -Path $ofile | select -expand Path | out-clipboard ;
                                $smsg = "$($Msgs.count) matches output to:`n'$($ofile)'`n(copied to CB)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            } else { 
                                $smsg = "MISSING LOG FILE!"  ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } ;
                        } else {
                            $smsg = "NO MATCHES FOUND from::`n$(($msgtrk|out-string).trim()|out-default)`n(with any relevant ConnectorId postfilter)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ;

                        #-=-=-=-=-=-=-=-=


                    } else {
                        $smsg = "(no EXO mailbox found, skipping $((get-alias ps1GetxMbxFldrStats).definition) )" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $Retries ;
                }
                Catch {
                    # get fails go here with: The operation couldn't be performed because object 'ACCOUNT@DOMAIN.com' couldn't be found on 'CY4PR04A008DC10.NAMPR04A008.PROD.OUTLOOK.COM'.
                    $errTrpd=$_ ; 
                    if( $errtrpd -match "\scouldn't\sbe\sfound\son\s" ){
                        $smsg = "(no EXO mailbox found)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $Exit = $Retries ;
                    } else { 
                        $smsg=": Error Details: $($errTrpd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        Start-Sleep -Seconds $RetrySleep ;
                        if($pltRXO){
                            if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
                            else { reconnect-EXO @pltRXO } ;
                        } else {reconnect-exo ;} ; 
                        $Exit ++ ;
                        Write-Verbose "Failed to exec cmd because: $($Error[0])" ;
                        Write-Verbose "Try #: $Exit" ;                    
                    } ; 
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;
            } Until ($Exit -eq $Retries) ;

            $Exit = 0 ; $error.clear() ;
            Do {
                Try {
                    $pltgRmbx=@{identity=$Mailbox ; domaincontroller=$domaincontroller ; erroraction='stop'; } ; 
                    $smsg= "get-RemoteMailbox w`n$(($pltgRmbx|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    $rmbx = get-remotemailbox @pltgRmbx ;

                    if($rmbx){
                        $smsg= "(successful get-remotemailbox  -id $($Mailbox))" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $Retries ;
                }
                Catch {
                    # get fails go here with: The operation couldn't be performed because object 'blahblah' couldn't be found on DC.domain.ccc
                    $errTrpd=$_ ; 
                    if( $errtrpd -match "\scouldn't\sbe\sfound\son\s" ){
                        $smsg = "(no EXOP remotemailbox found)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else { write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $Exit = $Retries ;
                    } else { 
                        $smsg=": Error Details: $($errTrpd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        Start-Sleep -Seconds $RetrySleep ;
                        if($pltRX10){
                            #ReConnect-Ex2010XO @pltRX10 ;
                            ReConnect-Ex2010 @pltRX10 ;
                        } else { ReConnect-Ex2010  } ; 
                        $Exit ++ ;
                        Write-Verbose "Failed to exec cmd because: $($Error[0])" ;
                        Write-Verbose "Try #: $Exit" ;                    
                    } ; 
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;
            } Until ($Exit -eq $Retries) ;


            if ($exombx ) {
                $targetUPN = $exombx.userprincipalname ;
            }
            elseif ($rmbx) {
                $targetUPN = $rmbx.userprincipalname ;
            }
            else {
                throw "Unable to locate either an EXO mailbox or an on-prem RemoteMailbox. ABORTING!"
                Break ;
            } ;


            $Exit = 0 ; $error.clear() ;
            Do {
                Try {
                    $pltgMbx=[ordered]@{identity=$targetUPN ;domaincontroller=$domaincontroller ;erroraction='SilentlyContinue';  };
                    $smsg = "get-mailbox w`n$(($pltgMbx|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    $opmbx = get-mailbox @pltgMbx ; 
                    if($opmbx){
                        $smsg= "(successful get-mailbox -id $($targetUPN))" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $Retries ;

                }
                Catch {
                    # get fails go here with: The operation couldn't be performed because object 'blahblah' couldn't be found on dc.domain...
                    $errTrpd=$_ ; 
                    if( $errtrpd -match "\scouldn't\sbe\sfound\son\s" ){
                        $smsg = "(no EXOP mailbox found)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else { write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $Exit = $Retries ;
                    } else { 
                        $smsg=": Error Details: $($errTrpd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        Start-Sleep -Seconds $RetrySleep ;
                        if($pltRX10){
                            #ReConnect-Ex2010XO @pltRX10 ;
                            ReConnect-Ex2010 @pltRX10 ;
                        } else { ReConnect-Ex2010  } ; 
                        $Exit ++ ;
                        Write-Verbose "Failed to exec cmd because: $($Error[0])" ;
                        Write-Verbose "Try #: $Exit" ;                    
                    } ; 
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;
            } Until ($Exit -eq $Retries) ;


            $Exit = 0 ; $error.clear() ;
            Do {
                Try {
                    connect-msol @pltRXO ;
                    $pltgMSOLU = [ordered]@{userprincipalname=$targetUPN  ;erroraction='SilentlyContinue';} ; 
                    $smsg = "get-msoluser w`n$(($pltgMSOLU|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    $msolu = get-msoluser @pltgMSOLU ;
                    if($msolu){
                        $smsg= "(successful get-msoluser -userprincipalname $($targetUPN))" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $Retries ;
                }
                Catch {
                    # get fails go here with: get-msoluser : User Not Found.  User: blah@DOMAIN.com.
                    $errTrpd=$_ ; 
                    if( $errtrpd -match "User\sNot\sFound" ){
                        $smsg = "(no EXOP mailbox found)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $Exit = $Retries ;
                    } else { 
                        $smsg=": Error Details: $($errTrpd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        Start-Sleep -Seconds $RetrySleep ;
                        if($pltRXO){
                            if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
                            else { reconnect-EXO @pltRXO } ;
                        } else {reconnect-exo ;} ; 
                        $Exit ++ ;
                        Write-Verbose "Failed to exec cmd because: $($Error[0])" ;
                        Write-Verbose "Try #: $Exit" ;                    
                    } ; 
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;
            } Until ($Exit -eq $Retries) ;

            if ($msolu) {
                connect-msol @pltRXO;
               # to find group, check user's membership
                # do the full lookup first

                if ($msolu.IsLicensed -AND !($msolu.LicenseReconciliationNeeded)) {
                    $smsg = "USER HAS *NO* LICENSING ISSUES:" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                }
                else {
                    $smsg = "USER *HAS* LICENSING ISSUES:" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else { write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;

                $smsg = "Get-MsolUser:`n$(($msolu | select userprin*,*Error*,*status*,softdel*,lic*,islic*|out-string).trim())`n" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                if ($null -eq $msolu.SoftDeleteTimestamp) {
                    $smsg = "$($msol.userprincipalname) has a BLANK SoftDeleteTimestamp`n=>If mailbox missing it would indicate the user wasn't properly de-licensed (or would have fallen into dumpster at >30d).`n That scenario would reflect a replic break (AAD sync loss wo proper update)`n" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;

                if ($EXOLicDetails = get-MsolUserLicenseDetails -UPNs $targetUPN -showdebug:$($showdebug) ) {
                    $smsg = "Returned License Details`n$(($EXOLicDetails|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
                }
                else {
                    $smsg = "UNABLE TO RETURN License Details FOR `n$(($targetUPN|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } ; #Error|Warn
                };

                # 2:12 PM 1/27/2020 rough in Pull-AADSignInReports.ps1 syntax
                $AADSigninSyntax=@"

---------------------------------------------------------------------------------
If you would like to retrieve user AAD Sign On Reports, use the following command:

A. Query the events into json outputs:

.\Pull-AADSignInReports.ps1 -UPNs "$($targetUPN)" -ticket "$($Ticket)" -StartDate (Get-Date).AddDays(-30) -showdebug ;

B. Process & Profile the output .json file from the above:
.\profile-AAD-Signons.ps1 -Files PATH-TO-FILE.json ;

---------------------------------------------------------------------------------

"@ ;

            }
            else {
                $smsg = "$($targetUPN):NO MATCHING MSOLUSER RETURNED!" ; ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;

        
            $Exit = 0 ; $error.clear() ;
            Do {
                Try {
                    $aduFilter = { UserPrincipalName -eq $targetUPN }  ;
                    $pltgADU=[ordered]@{filter=$aduFilter;Properties=$adprops ;server=$domaincontroller  ;erroraction='SilentlyContinue'; } ; 
                    $smsg = "get-aduser w`n$(($pltgADU|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    #$adu = get-aduser -filter { UserPrincipalName -eq $targetUPN } -Properties $adprops -server $domaincontroller -ea 0  ; 
                    $adu = get-aduser @pltgADU  ; 
                    if($adu){
                        $smsg= "(successful get-aduser -filter { UserPrincipalName -eq $($targetUPN) }" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $Retries ;
                }
                Catch {
                    $errTrpd=$_ ;
                    $smsg = "Failed processing $($errTrpd.Exception.ItemName). `nError Message: $($errTrpd.Exception.Message)`nError Details: $($errTrpd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } #Error|Warn|Debug
                    else { write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Start-Sleep -Seconds $RetrySleep ;
                    $Exit ++ ;
                    $smsg = "Failed to exec cmd because: $($Error[0])`nTry #: $($Exit)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } #Error|Warn|Debug
                    else { write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;
            } Until ($Exit -eq $Retries) ;

            # DETERMINE LIC GRANT GROUP
            if ($GrantGroupDN = $adu | select -expand memberof | ? { $_ -match $rgxEntLicGrps } ) {
                Try {
                    # 8:47 AM 3/1/2019 #626:expand the name, (was coming out a hash)
                    $GrantGroup = get-adgroup -id $grantgroupDN | select -expand name ;
                }
                catch {
                    $grantgroup = "(NOT RESOLVABLE)"
                } ;
            }
            else {
                $grantgroup = "(NOT RESOLVABLE)"
            } ;

            # TRIAGE RESULTS
            if ($exombx -AND $opmbx) {
                # SPLIT BRAIN
                $smsg = "USER HAS SPLIT-BRAIN MAILBOX (MBX IN EXO & EXOP)!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else { write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            }elseif (($rcp.RecipientTypeDetails -eq 'RemoteUserMailbox') -AND ($exorcp.RecipientTypeDetails -eq 'MailUser') ) {
                # NO BRAIN
                $smsg = "USER HAS NO-BRAIN MAILBOX (*NO* MBX IN *EITHER* EXO & EXOP)!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else { write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

             }
            elseif ( ($rcp.RecipientTypeDetails -match '(User|Shared|Room|Equipment)Mailbox') -AND ($exorcp.RecipientTypeDetails -eq 'MailUser') ) {
                # ON PREM MAILBOX
                #$mapiTest = Test-MAPIConnectivity -id $Mailbox ;
                $pltTMapi=[ordered]@{identity=$Mailbox;domaincontroller=$domaincontroller  ;erroraction='SilentlyContinue'; } ; 
                $smsg = "Test-MAPIConnectivity w`n$(($pltTMapi|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                Try {
                    $mapiTest = Test-MAPIConnectivity @pltTMapi  ; 
                    if ($mapiTest.Result -eq 'Success') {
                        $smsg= "(successful Outlook Mbx MAPI validate: Test-MAPIConnectivity -id $($Mailbox) }" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $Retries ;
                } Catch {
                    $errTrpd=$_ ;
                    $smsg = "Failed processing $($errTrpd.Exception.ItemName). `nError Message: $($errTrpd.Exception.Message)`nError Details: $($errTrpd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } #Error|Warn|Debug
                    else { write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Start-Sleep -Seconds $RetrySleep ;
                    $Exit ++ ;
                    $smsg = "Failed to exec cmd because: $($Error[0])`nTry #: $($Exit)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } #Error|Warn|Debug
                    else { write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;


                $FixText = @"
========================================
Problem User:`t "$($adu.UserPrincipalName)"
Has an *ONPREM* mailbox:Type:$($exombx.recipienttypedetails) hosted in $($opmbx.database)
"@ ;
                if ($mapiTest.Result -eq 'Success') {
                    $FixText2 = @"
*with *NO* detected issues*
Mailbox Outlook connectivity tested and validated functional...
"@ ;
                } else {
                    $FixText2 = @"
*FAILED Test-MAPIConnectivity*
Mailbox Outlook connectivity test failed to connect!...
"@ ;
                }

                $FixText3 = @"

$(($mapiTest|out-string).trim())

The user's o365 LICENSESKUs:                     "$($exolicdetails.LicAccountSkuID)"
With DisplayNames:                               "$($exolicdetails.LicenseFriendlyName)"
The user's o365 Licensing group appears to be:  "$($grantgroup)"

OnPrem RecipientTypeDetails:`t "$($rcp.RecipientTypeDetails)"
OnPrem WhenCreated:`t "$($rcp.WhenCreated)"
EXO RecipientTypeDetails:`t "$($exorcp.RecipientTypeDetails)"
EXO WhenMailboxCreated:`t "$($exombx.WhenMailboxCreated)"
"@

                $smsg = "$($FixText)`n$($FixText2)`n$($FixText3)"  ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                #output the AAD Signon Profile info: $AADSigninSyntax
                $smsg = "$($AADSigninSyntax)"  ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            }elseif ( ($rcp.RecipientTypeDetails -match 'Remote(User|Shared|Room|Equipment)Mailbox' ) -AND ($exorcp.RecipientTypeDetails -match '(User|Shared|Room|Equipment)Mailbox') ) {
                # EXO MAILBOX
                $pltTxmc=@{identity=$Mailbox ;erroraction='SilentlyContinue'; } ;
                Try {
                    $mapiTest = ps1TestXMapi @pltTxmc ; 
                    if ($mapiTest.Result -eq 'Success') {
                        $smsg= "(successful Outlook Mbx MAPI validate: Test-MAPIConnectivity -id $($Mailbox) }" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $Retries ;
                } Catch {
                    $errTrpd=$_ ;
                    $smsg = "Failed processing $($errTrpd.Exception.ItemName). `nError Message: $($errTrpd.Exception.Message)`nError Details: $($errTrpd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } #Error|Warn|Debug
                    else { write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Start-Sleep -Seconds $RetrySleep ;
                    $Exit ++ ;
                    $smsg = "Failed to exec cmd because: $($Error[0])`nTry #: $($Exit)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } #Error|Warn|Debug
                    else { write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;
                $FixText = @"
========================================
User:`t "$($adu.UserPrincipalName)"
Has an *EXO* mailbox:Type:$($exombx.recipienttypedetails) in db:$($exombx.database)
"@ ;
                if ($mapiTest.Result -eq 'Success') {
                $FixText2 = @"
*with *NO* detected issues*
Mailbox Outlook connectivity tested and validated functional...
"@ ;
                } else {
                    $FixText2 = @"
*FAILED Test-exoMAPIConnectivity*
Mailbox Outlook connectivity test failed to connect!...
"@ ;
                } ; 

                $FixText3 = @"

$(($mapiTest|out-string).trim())

The user's o365 LICENSESKUs:                     "$($exolicdetails.LicAccountSkuID)"
With DisplayNames:                               "$($exolicdetails.LicenseFriendlyName)"
The user's o365 Licensing group appears to be:  "$($grantgroup)"
$(if($rcp.recipienttypedetails -ne 'RemoteUserMailbox'){
    '(non-usermailbox, *non*-licensed is typical status)'
})

OnPrem RecipientTypeDetails:`t "$($rcp.RecipientTypeDetails)"
OnPrem WhenCreated:`t "$($rcp.WhenCreated)"
EXO RecipientTypeDetails:`t "$($exorcp.RecipientTypeDetails)"
EXO WhenMailboxCreated:`t "$($exombx.WhenMailboxCreated)"

Mailbox content:
$(($exofldrs | ft -auto $propsmbxfldrs|out-string).trim())

"@


                $smsg = "$($FixText)`n$($FixText2)`n$($FixText3)"  ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                #output the AAD Signon Profile info: $AADSigninSyntax
                $smsg = "$($AADSigninSyntax)"  ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            } else {
                # UNRECOGNIZED RECIPIENTTYPE COMBO
                # ($rcp.RecipientTypeDetails -eq 'RemoteUserMailbox'), ($exorcp.RecipientTypeDetails -eq 'UserMailbox')
                $smsg= "UNRECOGNIZED RECIPIENTTYPE COMBO:`nOPREM:RecipientTypeDetails:$($rcp.RecipientTypeDetails)`nEXO:RecipientTypeDetails:$($exorcp.RecipientTypeDetails)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            } ; 

            
            if($host.Name -eq "Windows PowerShell ISE Host" -and $host.version.major -lt 5){
                # 11:51 AM 9/22/2020 isev5 supports transcript, anything prior has to fake it
                # 8:46 AM 3/11/2015 shift the logfilename gen out here, so that we can arch it
                #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -uformat "%Y%m%d-%H%M" ) + "-ISEtrans.log")) ;
                # 2:16 PM 4/27/2015 shift to static timestamp $timeStampNow
                #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + $timeStampNow + "-ISEtrans.log")) ;
                # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
                #$Logname=(join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -format 'yyyyMMdd-HHmmtt') + "-ISEtrans.log")) ;
                # maintain-ExoUsrMbxFreeBusyDetails-TOR-ForceAll-Transcript-BATCH-EXEC-20200921-1539PM-trans-log.txt
                $Logname=$transcript.replace('-trans-log.txt','-ISEtrans-log.txt') ;
                write-host "`$Logname: $Logname";
                Start-iseTranscript -logname $Logname  -Verbose:($VerbosePreference -eq 'Continue') ;
                #Archive-Log $Logname ;
                # 1:23 PM 4/23/2015 standardize processing file so that we can send a link to open the transcript for review
                $transcript = $Logname ;
                if($host.version.Major -ge 5){ stop-transcript  -Verbose:($VerbosePreference -eq 'Continue')} # ISE in psV5 actually supports transcription. If you don't stop it, it just keeps rolling
            } else {
                write-verbose "$((get-date).ToString('HH:mm:ss')):Stop Transcript" ;
                Stop-TranscriptLog -Transcript $transcript -verbose:$($VerbosePreference -eq "Continue") ;
            } # if-E
            
            # also trailing echo the log:
            $smsg = "`$logging:`$true:written to:`n$($logfile)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $smsg = "$((get-date).ToString('HH:mm:ss')):$($sBnr.replace('=v','=^').replace('v=','^='))" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            
            $logging = $false ;  # reset logging for next pass

        } ; # loop-E $mailboxes
    } ;  # PROC-E
    END {
        # =========== wrap up Tenant connections
        # suppress VerbosePreference:Continue, if set, during mod loads (VERY NOISEY)
        if($VerbosePreference = "Continue"){
            $VerbosePrefPrior = $VerbosePreference ;
            $VerbosePreference = "SilentlyContinue" ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        if($script:useEXOv2){
            disconnect-exo2 -verbose:$($verbose) ;
        } else {
            disconnect-exo -verbose:$($verbose) ;
        } ;
        # aad mod *does* support disconnect (msol doesen't!)
        #Disconnect-AzureAD -verbose:$($verbose) ;
        # reenable VerbosePreference:Continue, if set, during mod loads
        if($VerbosePrefPrior -eq "Continue"){
            $VerbosePreference = $VerbosePrefPrior ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;

        $pltCleanup=@{
            LogPath=$tmpcopy
            summarizeStatus=$false ;
            NoTranscriptStop=$true ;
            showDebug=$($showDebug) ;
            whatif=$($whatif) ;
            Verbose = ($VerbosePreference -eq 'Continue') ;
        } ;
        $smsg = "_cleanup():w`n$(($pltCleanup|out-string).trim())" ;
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        #_cleanup -LogPath $tmpcopy ;
        _cleanup @pltCleanup ;
        # prod is still showing a running unstopped transcript, kill it again
        $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;

        $smsg = "$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        # clear the script aliases
        write-verbose "clearing ps1* aliases in Script scope" ; 
        get-alias -scope Script |Where-Object{$_.name -match '^ps1.*'} | ForEach-Object{Remove-Alias -alias $_.name} ;

        write-verbose "(explicit EXIT...)" ;
        Break ;

    } ;  # END-E
}

#*------^ test-xoMailbox.ps1 ^------


#*======^ END FUNCTIONS ^======

Export-ModuleMember -Function add-EXOLicense,check-EXOLegalHold,Connect-ExchangeOnlineTargetedPurge,Test-Uri,Connect-EXO,Test-Uri,Connect-EXOPSSession,connect-EXOv2RAW,Connect-IPPSSessionTargetedPurge,convert-ADUserRecipientTypeRemoteSharedMailbox,convert-ADUserRecipientTypeRemoteUserMailbox,convert-exoMailboxTypeSharedMailbox,convert-exoMailboxTypeUserMailbox,convert-HistoricalSearchCSV,copy-XPermissionGroupToCloudOnly,cxoCMW,cxoTOL,cxoTOR,cxoVEN,Disconnect-EXO,get-ADUsersWithSoftDeletedxoMailboxes,get-ExoMailboxLicenses,get-EXOMsgTraceDetailed,get-MailboxFolderStats,get-MsgTrace,Get-OrgNameFromUPN,get-xoHistSearch,_cleanup,get-XOMailboxFolderList,Get-xoMailboxFolderPermissionsRecursive,get-XOMailboxFolderPermissionsSummary,import-XoW_func,Invoke-ExoOnlineConnection,invoke-XOWrapper,_Redo-Connection,move-MailboxToXo,check-ReqMods,new-DgTor,_cleanup,new-xoDGFromProperty,Print-Details,Reconnect-EXO,Reconnect-EXO2old,RemoveExistingEXOPSSession,RemoveExistingPSSessionTargeted,Remove-EXOBrokenClosed,remove-EXOLicense,Reset-xoMailboxFolderPermissionsRecursive,resolve-Name,resolve-user,Resolve-xoRcps,rxocmw,rxoTOL,rxoTOR,rxoVEN,test-EXOv2Connection,test-EXOIsLicensed,test-ExoPSession,test-EXOToken,test-EXOv2Connection,test-xoMailbox,_cleanup -Alias *



