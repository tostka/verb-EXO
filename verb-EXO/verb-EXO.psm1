# verb-EXO.psm1


  <#
  .SYNOPSIS
  verb-EXO - Powershell Exchange Online generic functions module
  .NOTES
  Version     : 11.0.1.0
  Author      : Todd Kadrie
  Website     :	https://www.toddomation.com
  Twitter     :	@tostka
  CreatedDate : 3/3/2020
  FileName    : verb-EXO.psm1
  License     : MIT
  Copyright   : (c) 3/3/2020 Todd Kadrie
  Github      : https://github.com/tostka
  REVISIONS
  * 4:38 PM 3/16/2020 public cleanup
  * 8:45 AM 3/3/2020 1.0.0.0 public cleanup
  * 9:52 PM 1/16/2020 cleanup
  * 11:36 AM 12/30/2019 ran vsc alias-expan
  * 10:55 AM 12/6/2019 Connect-EXO:added suffix to TitleBar tag for non-TOR tenants, also config'd a central tab vari
  * 5:14 PM 11/27/2019 repl $MFA code with get-TenantMFARequirement
  * 1:07 PM 11/25/2019 added 3-letter alias variants for connect & reconnect
  # 9:57 AM 11/20/2019 added Credential param to reconnect, with passthru.
  # 1:26 PM 11/19/2019 added MFA detection fr infastrings .ps1 globals
  * 10:10 AM 6/20/2019 added local $rgxExoPsHostName, swapped dxo to use the vari, added showdebug to rxo & cxo, added $pltPSS wplat dump to the import-pssession cmd block
  * 1:02 PM 11/7/2018 added Disconnect-PssBroken
  * 2:55 PM 10/11/2018 connect-exo: added pre sleep skip on tryno 1
  # 9:24 PM 7/16/2018 broad cleanup & tightening
  # 9:04 PM 7/11/2018 synced to tsksid-incl-ServerApp.ps1
  .DESCRIPTION
  verb-EXO - Powershell Exchange Online generic functions module
  .LINK
  https://github.com/tostka/verb-EXO
  #>


    $script:ModuleRoot = $PSScriptRoot ;
    $script:ModuleVersion = (Import-PowerShellDataFile -Path (get-childitem $script:moduleroot\*.psd1).fullname).moduleversion ;
    $runningInVsCode = $env:TERM_PROGRAM -eq 'vscode' ;

#*======v FUNCTIONS v======




#*------v add-EXOLicense.ps1 v------
function add-EXOLicense {
    <#
    .SYNOPSIS
    add-EXOLicense.ps1 - Add a temporary o365 license to specified MGUser account. Returns updated MGUser object to pipeline.
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-07-13
    FileName    : add-EXOLicense.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell, ExchangeOnline, MG, License
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 1:30 PM 1/7/2026 WIP unupdated port from AADLicense -> MGULicense
    * 1:21 PM 6/18/2024: finally got through full tree of add-EXOLicense, and deps cred fixes in add-AADUserLicense_func.ps1; set-AADUserUsageLocation_func.ps1; get-AADlicensePlanList_func.ps1; 
    * 9:48 AM 6/17/2024 fixed credential code, spliced over code to resolve creds, and assign to $Credential
    * 3:14 PM 5/30/2023 updated CBH; udpt CBH; consold 222+223 into 1 line; add pswl compliance; expanded demos ; rem'd unused
    * 3:52 PM 5/23/2023 implemented @rxo @rxoc split, (silence all connectivity, non-silent feedback of functions); flipped all r|cxo to @pltrxoC, and left all function calls as @pltrxo; generic'd the meta vari name ; general cleanup rem'd; added expanded licname to echo ; 
    * 4:11 PM 5/22/2023 flipped all lic status testing to use of test-exoislicensed ; logic fixes
    * 9:49 AM 5/19/2023 trimmed rem's; ++ adv func/pipeline supp ; shifted usr reso into thge process loop ; rem'd unused $TenantShortName; wrapped plts ; 
        rem'd END transcript stop - these are util functions: connectivity; transcription & control of logging should occur in the calling script/func, not the stripped down leaf function.
    * 3:37 PM 5/17/2023 added pltRXO support; replaced hard-coded LicenseSkuIds w dyn LicenseSkuKeys pulled from global Meta. Updated UserRole validator to modern; 
        added AADUser detect, deprected MSolUser; stripped out all logging & fancy connectivity, the pltRXO support provides enough to chain through existing creds ; 
        removed dangling xow support
    * 4:01 PM 4/19/2023 roughed in, untested EOM310 updates: pasted in generic services block, sub'd -exo -> -xo. No further testing.
    * 2:54 PM 12/21/2022 tested through non-debug of shared, no-add lic mbx ;  more recent retooling for EXOv2/MFA support/Loss of MSONLINE/MSOL module support/cmdlets around AADU status and licensure.
    * 2:29 PM 8/12/2022 sync'd back to last _func.ps1 chgs as well ; fixed inacc warning, when lic's all burned (was echo'ing failure to update usageloc, not lic fail).
    * 5:17 PM 3/23/2022 more retooling to remove msonline module dependance, and shift to AzureAD (crappy implementation GraphAPI) module
    * 1:50 PM 3/23/2022 hunting the VerbosePreference toggle midway through, found 2 more verbose tests lacking leading verbose = $($VerbosePreference -eq "Continue"); prefixed examples with PS>
    * 5:00 PM 3/22/2022 extensive rewrite: Sec mandate to disable all basic auth == complete loss of the long-standing MS MSOnline powershell module:
        net effect: have to reimplement & rewraite all verb-MsolNoun cmdlet calls into
        the new AzureAD module's equivelents (which fail to match msol cmdlets names,
        parameters, or even the data returned, and property names)
        - had to write 3 new functions, ground up, to reimplement loss of the 1-liner Set-MsolUserLicense cmdlet functions:
        - wrote verb-aad: add-AADUserLicense()
        - wrote verb-aad: remove-AADUserLicense()
        - wrote verb-aad: set-AADUserUsageLocation()
        - wrote verb-aad: get-AADlicensePlanList, to workaround loss of useful sku reporting from the prior equiv msol sku cmdlet (new output is unformatted json [facepalm])
        - rewrote most of the license testing & handling code in this verb-exo:Add-EXOLicense() (roughly 11:20am 3/21/2022 to 5:03 PM 3/22/2022, and I still have a verbose state bug to workout on this script).
    * 11:51 AM 3/2 1/2022 update: because *any* licenes, including worthless FLOWFREE, toggles IsLicensed:$true, logic below fails to detect the lack of an EXO lic.
    Have to splice over from get-mailboxuserStatus, that evaluates existing aaduser/msolu licenses against the ones that actually support a UserMailbox type.
    * 12:57 PM 1/31/2022 addded -ea 0 to gv PassStatus_$($tenorg) (spurious error suppress)
    * 2:14 PM 1/18/2022 updated Example 1 to include echo of the returned msolu.licenses value.
    * 12:08 PM 1/11/2022 ren add-EXOLicenseTemp -> add-EXOLicense ; add
    $XXXMETA.o365LicSkuExStd == EXCHANGESTANDARD (Office 365 Exchange Online Only
    ,commonly used for App Access) & stick in front of $LicenseSkuIds,
    $XXXMETA.o365LicSkuExStd; added examples with explicit cmdlines for the adds;
    spliced over UsageLocation test/assert code from add-o365license.
    * 1:34 PM 1/5/2022 init
    .DESCRIPTION
    add-EXOLicense.ps1 - Add a temporary o365 license from specified MGUser account. Returns updated MGUser object to pipeline.
    .PARAMETER Ticket
    Ticket Number [-Ticket '999999']
    .PARAMETER TenOrg
    TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']
    .PARAMETER  users
    Array of UserPrincipalNames (or MGUser objects) to have a temporary Exchange License applied
    .PARAMETER LicenseSkuKeys
    Array, in preference order, of XXXMeta global value LicenseSkuKey names (resolves SKUId from TenOrg global Meta vari ; first working lic assignment, will be applied)[-LicenseSkuIds 'o365LicSkuExStd','o365LicSkuF1']
    .PARAMETER QueryLicenseSkus
    Switch to perform dynamic lookup of LicenseSKUIDs against Get-MGSubscribedSku EXCHANGE_* serviceplanname filtering
    .PARAMETER LicenseSkuIds
    Optional Array, in preference order, of LicenseSkuID (e.g. TenantName:SPE_F1) to be added, runs list until first sucess (default process is to dynamically resolve id's from Meta LicenseSkuKeys specifications)[-LicenseSkuIds @(`$XXXMETA.o365LicSkuExStd,`$XXXMETA.o365LicSkuF1)]
    .PARAMETER Force
    switch to override normal 'skipped' license application to existing Mailbox (needed for licensed-Shared, or upgraded existing lic).
    .PARAMETER UserRole
    Credential User Role spec (SID|CSID|UID|B2BI|CSVC)[-UserRole SID]
    .PARAMETER Credential
    Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]
    .PARAMETER silent
    Switch to specify suppression of all but warn/error echos.(unimplemented, here for cross-compat)
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER outObject
    switch to return a system.object summary to the pipeline[-outObject]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Microsoft.Online.Administration.User
    Returns updated MGUser object to pipeline
    .EXAMPLE
    PS> add-EXOLicense -users 'Test@domain.com','Test2@domain.com' -Ticket 999999 -Credential $pltrxo.Credential ; 
    Process an array of users, with default 'hunting' -LicenseSkuIds array.
    .EXAMPLE
    PS> $whatif = $false ;
    PS> $target = '999998,TestSharedMbxConversion@toro.com' ;
    PS> pushd;
    PS> $prpADU1 = 'UserPrincipalName','DisplayName',@{Name='IsLicensed'; Expression={[boolean]($_.AssignedLicenses.count -gt 0) }}  ;
    PS> $prpADU2 = @{Name='Licenses';Expression={($_ | Get-MGUserLicenseDetail).SkuPartNumber -join ','}} ;
    PS> if($target.contains(',')){
    PS>     $ticket,$trcp = $target.split(',') ;
    PS>     $pltAxLic = [ordered]@{
    PS>         users = $trcp ;
    PS>         ticket = $ticket ;
    PS>         whatif = $($whatif) ;
    PS>         Verbose = $false ;
    PS>         Credential  =  $credO365TORSIDCBA ;
    PS>         silent = $false ;
    PS>     } ;
    PS>     $smsg = "add-EXOLicense w`n$(($pltAxLic|out-string).trim())" ;
    PS>     if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    PS>     $updatedMGu = add-EXOLicense @pltAxLic ;
    PS>     write-verbose "re -refresh MGU" ;
    PS>     $updatedMGu  = get-MGUser -obj $updatedMGu.UserPrincipalName ;
    PS>     $smsg = "UpdatedMGu: w`n$(($updatedMGu| ft -auto $prpADU1 |out-string).trim())" ;
    PS>     $smsg += "`n:$(($updatedMGu| fl $prpADU2 |out-string).trim())" ;
    PS>     write-host -foregroundcolor green $smsg ;
    PS> } else { write-warning "`$target does *not* contain comma delimited ticket,UPN string!"} ;    
    Fancier variant of above, with more post-confirm reporting
    .EXAMPLE 
    add-EXOLicense -users Test@domain.com -Ticket 999999 -verbose -QueryLicenseSkus -whatIf;
    Demo dynamic QueryLicenseSkus in use 
    .EXAMPLE
    PS> add-EXOLicense -users 'Test@domain.com' -LicenseSkuIds $XXXMETA.o365LicSkuExStd -ticket TICKETNUMBER;
    add an explicitly specified lic to a user (in this case, using the LicenseSku for EXCHANGESTANDARD, as stored in a global variable)
    .EXAMPLE
    PS> add-EXOLicense -users 'Test@domain.com' -LicenseSkuIds $XXXMETA.o365LicSkuF1 -ticket TICKETNUMBER;
    add an explicitly specified lic to a user (in this case, using the LicenseSku for SPE_F1 - web-only o365 - lic as stored in a global variable)
    .EXAMPLE
    PS> add-EXOLicense -users 'Test@domain.com' -LicenseSkuIds $XXXMETA.o365LicSkuE3 -ticket TICKETNUMBER ;
    add an explicitly specified lic to a user (in this case, using the LicenseSku for ENTERPRISEPACK - E3 o365 - lic as stored in a global variable)
    .EXAMPLE
    PS> add-EXOLicense -users 'Test@domain.com' -LicenseSkuIds 'TENANTNAME:EXCHANGESTANDARD' -ticket TICKETNUMBER ;
    add an explicitly specified lic to a user by specifying the Tenant-specific LicenseSkuID directly
    .EXAMPLE
    PS> add-EXOLicense -users 'Test@domain.com' -LicenseSkuIds @('TENANTNAME:EXCHANGESTANDARD',$XXXMETA.o365LicSkuF1) -ticket TICKETNUMBER ;
    Explicitly specify a preference order array of Tenant-specific LicenseSkuIDs (one string, another pulleed from Meta global vari; attempted in order until first success)
    .EXAMPLE
    PS> add-o365License -users $MGuser.UserprincipalName -ticket TICKETNUMBER ;
    add-o365License compatibility option
    .LINK
    https://github.com/tostka/verb-exo
    #>
    # migr to verb-exo, pull the dupe spec...
    # # Requires -Modules MG, MSOnline, ExchangeOnlineManagement, verb-MG, verb-Auth, verb-IO, verb-logging, verb-Mods, verb-Text
    #Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\s\regex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    #[Alias('add-o365License')]
    PARAM(
        [Parameter(Position=0,Mandatory=$False,ValueFromPipeline=$true,HelpMessage="Array of UserPrincipalNames (or MGUser objects) to have a temporary Exchange License applied")]
            #[ValidateNotNullOrEmpty()]
            #[Alias('ALIAS1', 'ALIAS2')]
            #[ValidatePattern("^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$")]
            [array]$users,
        [Parameter(Mandatory=$True,HelpMessage="Ticket Number [-Ticket '999999']")]
            [string]$Ticket,
        [Parameter(,HelpMessage="Array, in preference order, of XXXMeta global value LicenseSkuKey names (resolves SKUId from TenOrg global Meta vari ; first working lic assignment, will be applied)[-LicenseSkuIds 'o365LicSkuExStd','o365LicSkuF1']")]
            [ValidateNotNullOrEmpty()]
            [array]$LicenseSkuKeys=@('o365LicSkuExStd','o365LicSkuF1','o365LicSkuE3'),
        [Parameter(HelpMessage="Switch to perform dynamic lookup of LicenseSKUIDs against Get-MGSubscribedSku EXCHANGE_* serviceplanname filtering[-QueryLicenseSkus]")]
            [switch] $QueryLicenseSkus,   
        [Parameter(,HelpMessage="Optional Array, in preference order, of LicenseSkuID (e.g. TenantName:SPE_F1) to be added, runs list until first sucess (default process is to dynamically resolve id's from Meta LicenseSkuKeys specifications)[-LicenseSkuIds @(`$XXXMETA.o365LicSkuExStd,`$XXXMETA.o365LicSkuF1)]")]
            #[ValidateNotNullOrEmpty()]
            [array]$LicenseSkuIds = @(), 
        [Parameter(HelpMessage="switch to override normal 'skipped' license application to existing Mailbox (needed for licensed-Shared, or upgraded existing lic).[-Force]")]
            [switch] $Force,
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
            [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
            [switch] $useEXOv2=$true,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ;
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ;
                return $true ;
            })]
            [string[]]$UserRole = @('ESvcCBA','CSvcCBA','SIDCBA','SID'),
            #@('SID','CSVC'),
            # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent,
        [Parameter(HelpMessage="switch to show extended debugging output [-showdebug]")]
            # included solely for backward compatibility with add-o365License()
            [switch] $showDebug,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
            [switch] $whatIf
    ) ;
    BEGIN{
        #region CONSTANTS-AND-ENVIRO #*======v CONSTANTS-AND-ENVIRO v======
        # function self-name (equiv to script's: $MyInvocation.MyCommand.Path) ;
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        # Get parameters this function was invoked with
        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
        $smsg = "(ParameterSetName $($PSCmdlet.ParameterSetName) is in effect)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        $rgxLicAgentExclude = '^MICROSOFT_AGENT_' ;
        if(-not $rgxEmailAddr){ $rgxEmailAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$"}

        <#
        # recycling the inbound above into next call in the chain
        # downstream commands
        $pltRXO = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
        } ;
        #>
        # 9:26 AM 6/17/2024 this needs cred resolution splice over latest get-exomailboxlicenses
        $o365Cred = $null ;
        if($Credential){
            $smsg = "`Credential:Explicit credentials specified, deferring to use..." ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                # get-TenantCredentials() return format: (emulating)
                $o365Cred = [ordered]@{
                Cred=$Credential ;
                credType=$null ;
            } ;
            $uRoleReturn = resolve-UserNameToUserRole -UserName $Credential.username -verbose:$($VerbosePreference -eq "Continue") ; # Username
            #$uRoleReturn = resolve-UserNameToUserRole -Credential $Credential -verbose = $($VerbosePreference -eq "Continue") ;   # full Credential support
            if($uRoleReturn.UserRole){
                $o365Cred.credType = $uRoleReturn.UserRole ;
            } else {
                $smsg = "Unable to resolve `$credential.username ($($credential.username))"
                $smsg += "`nto a usable 'UserRole' spec!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ;
                Break ;
            } ;
        } else {
            $pltGTCred=@{TenOrg=$TenOrg ; UserRole=$null; verbose=$($verbose)} ;
            if($UserRole){
                $smsg = "(`$UserRole specified:$($UserRole -join ','))" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $pltGTCred.UserRole = $UserRole;
            } else {
                $smsg = "(No `$UserRole found, defaulting to:'CSVC','SID' " ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                $pltGTCred.UserRole = 'CSVC','SID' ;
            } ;
            $smsg = "get-TenantCredentials w`n$(($pltGTCred|out-string).trim())" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            $o365Cred = get-TenantCredentials @pltGTCred
        } ;
        if($o365Cred.credType -AND $o365Cred.Cred -AND $o365Cred.Cred.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
            $smsg = "(validated `$o365Cred contains .credType:$($o365Cred.credType) & `$o365Cred.Cred.username:$($o365Cred.Cred.username)" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            # 9:58 AM 6/13/2024 populate $credential with return, if not populated (may be required for follow-on calls that pass common $Credentials through)
            if((gv Credential) -AND $Credential -eq $null){
                $credential = $o365Cred.Cred ;
            }elseif($credential.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                $smsg = "(`$Credential is properly populated; explicit -Credential was in initial call)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else {
                $smsg = "`$Credential is `$NULL, AND $o365Cred.Cred is unusable to populate!" ;
                $smsg = "downstream commands will *not* properly pass through usable credentials!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ;
                break ;
            } ;
        } else {
            $smsg = "UNABLE TO RESOLVE FUNCTIONAL CredType/UserRole from specified explicit -Credential:$($Credential.username)!" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            break ;
        } ; 

        # downstream commands
        $pltRXO = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
        } ;
        if((get-command Reconnect-EXO).Parameters.keys -contains 'silent'){
            $pltRxo.add('Silent',$silent) ;
        } ;
        # default connectivity cmds - force silent false
        $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$true) ; 
        if((get-command Reconnect-EXO).Parameters.keys -notcontains 'silent'){
            $pltRxo.remove('Silent') ;
        } ; 

        # 2:36 PM 1/7/2026 splice in MG code
        #region cMG_SCAFFOLD ; #*------v cMG_SCAFFOLD v------
        if(-not (get-command  test-mgconnection)){
            if(-not (get-module -list Microsoft.Graph -ea 0)){
                $smsg = "MISSING Microsoft.Graph!" ; 
                $smsg += "`nUse: install-module Microsoft.Graph -scope CurrentUser" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            } ;             
        } ;
        $MGCntxt = test-mgconnection -Verbose:($VerbosePreference -eq 'Continue') ;
        $o365Cred = $null ;
        if($Credential -AND $MGCntxt.isConnected){
            $smsg = "Explicit -Credential:$($Credential.username) -AND `$MGCntxt.isConnected: running pre:Disconnect-MgGraph" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # Dmg returns a get-mgcontext into pipe, if you don't cap it corrupts the pipe on your current flow
            $dOut = Disconnect-MgGraph -Verbose:($VerbosePreference -eq 'Continue')
            $MGCntxt = test-mgconnection -Verbose:($VerbosePreference -eq 'Continue') ;
        };
        if($Credential){
            $smsg = "`Credential:Explicit credentials specified, deferring to use..." ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            write-verbose "get-TenantCredentials() return format: (emulating)" ; 
            $o365Cred = [ordered]@{
                Cred=$Credential ;
                credType=$null ;
            } ;
            $uRoleReturn = resolve-UserNameToUserRole -UserName $Credential.username -verbose:$($VerbosePreference -eq "Continue") ; # Username
            write-verbose "w full cred opt: $uRoleReturn = resolve-UserNameToUserRole -Credential $Credential -verbose = $($VerbosePreference -eq 'Continue')"  ; 
            if($uRoleReturn.UserRole){
                $o365Cred.credType = $uRoleReturn.UserRole ;
            } else {
                $smsg = "Unable to resolve `$credential.username ($($credential.username))"
                $smsg += "`nto a usable 'UserRole' spec!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ;
                Break ;
            } ;
        } else {
            if($MGCntxt.isConnected){
                if($MgCntxt.isUser){
                    $TenantTag = $TenOrg = get-TenantTag -Credential $MgCntxt.Account ;
                    $uRoleReturn = resolve-UserNameToUserRole -UserName $MgCntxt.CertificateThumbprint -verbose:$($VerbosePreference -eq "Continue") ;
                    $credential = get-TenantCredentials -TenOrg $TenOrg -UserRole $uRoleReturn.UserRole -verbose:$($VerbosePreference -eq "Continue") ;
                } elseif($MgCntxt.isCBA -AND $MgCntxt.AppName -match 'CBACert-(\w{3})'){
                        #$MgCntxt.AppName.split('-')[-1]
                        $TenantTag = $TenOrg = $matches[1]
                        # also need credential
                        $uRoleReturn = resolve-UserNameToUserRole -UserName $MgCntxt.CertificateThumbprint -verbose:$($VerbosePreference -eq "Continue") ;
                        write-verbose "ret'd obj:$uRoleReturn = [ordered]@{     UserRole = $null ;     Service = $null ;     TenOrg = $null ; } " ;  
                        $credRet = get-TenantCredentials -TenOrg $TenOrg -UserRole $uRoleReturn.UserRole -verbose:$($VerbosePreference -eq "Continue")
                        $credential = $credRet.Cred ;
                }else{
                    $smsg = "UNABLE TO RESOLVE mgContext to a working TenOrg!" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                }
            } ; 
            $pltGTCred=@{TenOrg=$TenOrg ; UserRole=$null; verbose=$($verbose)} ;
            if($UserRole){
                $smsg = "(`$UserRole specified:$($UserRole -join ','))" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $pltGTCred.UserRole = $UserRole;
            } else {
                $smsg = "(No `$UserRole found, defaulting to:'CSVC','SID' " ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $pltGTCred.UserRole = 'CSVC','SID' ;
            } ;
            $smsg = "get-TenantCredentials w`n$(($pltGTCred|out-string).trim())" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            $o365Cred = get-TenantCredentials @pltGTCred
        } ;
        if($o365Cred.credType -AND $o365Cred.Cred -AND $o365Cred.Cred.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
            $smsg = "(validated `$o365Cred contains .credType:$($o365Cred.credType) & `$o365Cred.Cred.username:$($o365Cred.Cred.username)" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            write-verbose "populate $credential with return, if not populated (may be required for follow-on calls that pass common $Credentials through)" ; 
            if((gv Credential) -AND $Credential -eq $null){
                $credential = $o365Cred.Cred ;
            }elseif($credential.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                $smsg = "(`$Credential is properly populated; explicit -Credential was in initial call)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else {
                $smsg = "`$Credential is `$NULL, AND $o365Cred.Cred is unusable to populate!" ;
                $smsg = "downstream commands will *not* properly pass through usable credentials!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ;
                break ;
            } ;
        } else {
            $smsg = "UNABLE TO RESOLVE FUNCTIONAL CredType/UserRole from specified explicit -Credential:$($Credential.username)!" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            break ;
        } ;         
        $pltCMG = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
        } ;
        if((get-command Connect-MG).Parameters.keys -contains 'silent'){
            $pltCMG.add('Silent',$silent) ;
        } ;
        #endregion cMG_SCAFFOLD ; #*------^ END cMG_SCAFFOLD ^------

        #[array]$LicenseSkuIds = @() ; # moved to param , to permit direct lic spec when using indep of formal scripts
        # 9:24 AM 1/13/2026: make remove-exolicense dyn:
        if(gcm get-ExoMailboxLicenses -ea 0){
            IF($ExMbxLicenses = get-ExoMailboxLicenses){
                TRY{
                    $TenantShortName = ((Get-MgOrganization -EA STOP).verifieddomains |?{$_.isdefault}).name.split('.')[0] ;
                    $ExGrantingLicenseSkuIds = @() ;
                    # exclude any variant of: MICROSOFT_AGENT_365_TIER_3
                    #$rgxLicAgentExclude = '^MICROSOFT_AGENT_' ; (UP IN CONSTANTS)
                    $ExMbxLicenses.GetEnumerator() |
                        ?{$_.name -notmatch $rgxLicAgentExclude} | foreach-object{
                          $ExGrantingLicenseSkuIds += "$($TenantShortName):$($_.name)" ;
                    } ;
                    $smsg = "Resolved `$ExGrantingLicenseSkuIds:`n$(($ExGrantingLicenseSkuIds|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    if($ExGrantingLicenseSkuIds){
                        $LicenseSkuIds = $ExGrantingLicenseSkuIds ;
                    };
                } CATCH {$ErrTrapd=$Error[0] ;
                    write-host -foregroundcolor gray "TargetCatch:} CATCH [$($ErrTrapd.Exception.GetType().FullName)] {"  ;
                    $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    BREAK ;
                } ;
            }ELSE{
                $smsg = "UNABLE TO:VXO\get-ExoMailboxLicenses()!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                BREAK
            }
        }elseif(-not $LicenseSkuIds){
            $smsg = "Missing vxo\get-ExoMailboxLicenses(): Retrieve & build LicenseSkuIDS from global Meta vari" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            $LicenseSkuKeys | foreach-object { $LicenseSkuIds += @((get-variable -name "$($tenorg)META").value[$_]) } ;
        } else {
            $smsg = "Explicit -LicenseSkuIds specified, using those licenses (in preference order)" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            $LicenseSkuKeys = $LicenseSkuIds
        } ;

        $smsg = $sBnr="`n#*======v $(${CmdletName}) : v======" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        $admin = "$env:username" ;

        # check if using Pipeline input or explicit params:
        if ($PSCmdlet.MyInvocation.ExpectingInput) {
            $smsg = "Data received from pipeline input: '$($InputObject)'" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } else {
            # doesn't actually return an obj in the echo
            #$smsg = "Data received from parameter input: '$($InputObject)'" ;
            #if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            #else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ;

    } ;  # BEGIN-E
    PROCESS{
        
        $ttl = ($users|measure).count ; $Procd=0 ;
        [array]$Rpt =@() ;
        
        foreach ($usr in $users){

            switch($usr.GetType().FullName){
                'Microsoft.Online.Administration.User' {
                    #$smsg = "(-user:MsolU detected:$($usr.userprincipalname), extracting the UPN...)" ;
                    $smsg = "MSOLUSER OBJECT IS NO LONGER SUPPORTED BY THIS FUNCTION! (flipping to resolvable UPN)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $usr = $usr.userprincipalname ;
                } ;
                'Microsoft.Open.AzureAD.Model.User' {
                    #$smsg = "(-user:AzureADU detected)" ;
                    $smsg = "AzureADU OBJECT IS NO LONGER SUPPORTED BY THIS FUNCTION! (flipping to resolvable UPN)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $usr = $usr.userprincipalname ;
                } ;
                # add missing MGGraphuser
                'Microsoft.Graph.PowerShell.Models.MicrosoftGraphUser' {
                    $smsg = "(-user:MGUser detected)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $usr = $usr.userprincipalname ;
                } ;
                'System.String'{
                    $smsg = "(-user:string detected)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    if($usr -match $rgxEmailAddress){

                        $smsg = "(-user:EmailAddress/UPN detected:$($usr))" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $usr = $usr ;
                    } else {
                        $smsg = "-Users: Unable to recognize either an MG user object, an MGUser object or a UPN string, from the specified input:`n$($usr)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        break ; 
                    } ; 
                }
                default{
                    $smsg = "Unrecognized format for -User:$($usr)!. Please specify either a user UPN, or pass a full MGUser object." ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Break ;
                }
            }
            
            $tUPN=$usr ;
            #$LicenseSkuIds=$XXXMETA.o365LicSkuF1; # dyn from global XXXmeta
            $error.clear() ;
            TRY {

                $Exit = 0 ;
                Do {
                    Try {
                        #connect-aad @pltRXOC ; 
                        $MGUser=$null ;
                        #$TenantShortName = ((Get-AzureADTenantDetail).verifieddomains |?{$_._default}).name.split('.')[0] ;
                        $pltGMGU=[ordered]@{ 
                            UserID = $tUPN ; # AAD -> MGU -objectID -> userid
                            ErrorAction = 'STOP' ;
                            verbose = $($VerbosePreference -eq "Continue") ;
                        } ;
                        $MGUser = Get-MGUser @pltGMGU ;
                        $Exit = $Retries ;
                    } CATCH {
                        Start-Sleep -Seconds $RetrySleep ;
                        $Exit ++ ;
                        $smsg = "Failed to exec cmd because: $($Error[0])" ;
                        $smsg += "`nTry #: $Exit" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        If ($Exit -eq $Retries) {
                            $smsg =  "Unable to exec cmd!" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ;
                        Continue ;
                    }  ;
                } Until ($Exit -eq $Retries) ;

                # confirm/set UsageLoc (reqd for updates)
                if (-not $MGUser.UsageLocation) {
                    $smsg = "MGUser: MISSING USAGELOCATION, FORCING" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $spltSMGUUL = [ordered]@{
                        Users = $MGUser.UserPrincipalName ;
                        UsageLocation = "US" ;
                        whatif = $($whatif) ;
                        Credential = $pltRXO.Credential ;
                        verbose = $pltRXO.verbose  ;
                        silent = $false ;
                    } ;
                    $smsg = "set-MGUserUsageLocationw`n$(($spltSMGUUL|out-string).trim())" ;
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                    $bRet = set-MGUserUsageLocation @spltSMGUUL ;
                    if($bRet.Success){
                        $smsg = "set-MGUserUsageLocation updated UsageLocation:$($bRet.MGuser.UsageLocation)" ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        # update the local MGUser to reflect the updated MGU returned
                        $MGUser = $bRet.MGuser ;
                        #$Report.FixedUsageLocation = $true ;
                    } else {
                        if($whatif){
                            $smsg = "-whatif: skipping" ; 
                        } else {                         
                            $smsg = "set-MGUserUsageLocation: FAILED TO UPDATE USAGELOCATION!" ;
                        } ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #$Report.FixedUsageLocation = $false ;
                        if(-not $whatif){
                            BREAK;
                        }
                    } ;
                } ;
                #

                # if lic'd and has a mailbox, shouldn't need a new license
                # w shift from msol -> aad, $aadU doesn 't even *have* an islicensed property! Have to interpolate:
                # nope!: IsLicensed:true, even if nothing but FLOWFREE is set. Worthless, for determining why there's no mailbox.
                # have to splice over the full exolic-testing code from verb-ex2010:get-mailboxUserStatus():

                # 8:44 AM 12/21/2022 no, use the verb-EXO:test-EXOIsLicensed(): test-EXOIsLicensed -User $AADUser -verbose
                $IsExoLicensed = test-EXOIsLicensed -User $MGUser -Credential:$pltRXO.Credential -verbose:$pltRXO.verbose -silent:$pltRXO.silent ;
                $pltGLPList=[ordered]@{ 
                    TenOrg= $TenOrg;
                    verbose=$($VerbosePreference -eq "Continue") ;
                    credential= $pltRXO.credential ;
                    silent = $false ; 
                } ;
                $smsg = "$($tenorg):get-MGlicensePlanList wn$(($pltGLPList|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $skus = $null ;
                $skus = get-MGlicensePlanList @pltGLPList ;

                $ombx = get-xomailbox -id $MGUser.UserPrincipalName -ea continue  ;
                $ombx = $ombx | ?{$_ -is [System.Management.Automation.PSObject]} # filtering any aberrant obj returned (legacy of prior problematic xow reliance to work around hybrid stepable pipeline bug)
                $MGLicDetails = get-MGUserLicenseDetailTDO -UPNs $MGUser.userprincipalname -Credential:$pltRXO.Credential -verbose:$pltRXO.verbose -silent:$pltRXO.silent ; 
                $smsg = "`nExisting Mbx:`n$(($ombx | ft -a 'RecipientType','RecipientTypeDetails'|out-string).trim())" ;
                if($MGLicDetails){
                    $smsg += "`n`$MGLicDetails`n$(($MGLicDetails|out-string).trim())" ;
                } else { 
                    $smsg += "`n`$MGLicDetails:(empty return)" ;
                } ; 
                if($ombx.RecipientTypeDetails -eq 'SharedMailbox'){
                    $smsg += "`nSharedMailbox does not *require* a license" ;
                } ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                #if( -not($Force) -AND $ombx){
                <#if( -not($Force) -AND ($ombx.RecipientTypeDetails -eq 'SharedMailbox') ){
                    $smsg += "`n -- SKIPPING EXO-RELATED LICENSE ADD! --" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                } else
                #>
                if( (-not $IsExoLicensed) -OR ($Force) ){
                    # not supported on aadu: defer to: verb-MG:test-MGUserIsLicensed(): $isLicensed = test-MGUserIsLicensed -user $AADUser -verbose
                    if($IsMGIsLicensed = test-MGUserIsLicensed -user $MGUser -Verbose:($VerbosePreference -eq 'Continue')){
                        # has a bozo lic that doesn't support a mailbox
                        $smsg = "MGUser:$($tUPN):  isLicensed (has some form of license added), but has *NO* EXO UserMailbox-supporting license!" ;
                        $smsg += "`n(or is being -Force upgraded to an elevated license)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $smsg="confirmed $($MGUser.UserPrincipalName):is unlicensed/underlicensed" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    # 9:55 AM 11/15/2019 per BB: apply a license, and notify lic staff to record
                    
                    # Set-MGUserLicense  vers
                    $pltALic=[ordered]@{
                        UserPrincipalName=$MGUser.userprincipalname ;
                         AssignedLicenses=$null ;
                    } ;

                    foreach($LicenseSkuId in $LicenseSkuIds){
                        if( $LicenseSkuId.contains(':') ){
                            $LicenseSkuId = $LicenseSkuId.split(':')[1] ;
                            # need the skuid, not the name, could pull another licplan list indexedonName, but can also post-filter the hashtable, and get it.
                            $LicenseSkuId = ($skus.values | ?{$_.SkuPartNumber -eq $LicenseSkuId}).skuid ;
                        } ;
                        #$smsg = "(attempting license:$($LicenseSkuId)...)" ;
                        $smsg = "(attempting license:$(($skus.values | ?{$_.Skuid -eq $LicenseSkuId}).SkuPartNumber):$($LicenseSkuId)...)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        $pltAMGUL=[ordered]@{
                            Users=$MGUser.UserPrincipalName ;
                            skuid=$LicenseSkuId ;
                            Credential = $pltRXO.Credential ; 
                            verbose = $pltRXO.verbose  ; 
                            silent = $false ; 
                            erroraction = 'STOP' ;
                            whatif = $($whatif) ;
                        } ;
                        $smsg = "add-MGUserLicense w`n$(($pltAMGUL|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        $bRet = add-MGUserLicense @pltAMGUL ;
                        if($bRet.Success){
                            $smsg = "add-MGUserLicense added  Licenses:$($bRet.AddedLicense)" ;
                            # $MGUser.AssignedLicenses.skuid
                            $smsg += "`n$(($MGUser.AssignedLicenses.skuid|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            $smsg = "Detailed Return:`n$(($bRet|out-string).trim())" ;
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            BREAK ; # abort further loops if one successfully applied
                        } elseif($whatif){
                            $smsg = "(whatif pass, exec skipped), " ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } elseif( -not [boolean]($bRet.AddedLicenses)){
                            # failed add
                            $smsg = "Failed Lic Add:$($LicenseSkuId) (exhausted units?, moving on to next if avail...)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Continue ;
                        } else {
                            $smsg = "add-MGUserLicense : UNAVAIL LIC UNIT, OR FAILED TO UPDATE USAGELOCATION!" ;
                            $smsg += "`n$(($bRet|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #$Report.FixedUsageLocation = $false ;
                            if(-not $whatif){
                                BREAK;
                            }
                        } ;

                    } ;  # loop-E $LicenseSkuIds

                };  # if-E $ombx
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                $smsg += "`n$($ErrTrapd.Exception.Message)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                BREAK ;
            } ; 
            if(!$whatif){
                $smsg = "dawdling until License reinflates mbx..." ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $1F=$false ;
                Do {
                    if($1F){Sleep -s 30} ;
                    write-host "." -NoNewLine ;
                    $1F=$true ;
                } Until ($ombx = get-xomailbox -id $MGUser.userprincipalname -EA 0) ; # capture return (prevent from dropping into pipe)
                # get-xomailbox returns: System.Management.Automation.PSObject; not a real Mailbox object class
                $ombx = $ombx | ?{$_ -is [System.Management.Automation.PSObject]} ; # looks like an attempt to filter just the mailbox out of the pipeline return
                $smsg = "xo Mailbox confirmed!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;

            # return $MGUser to pipeline if populated
            $smsg = "refresh updated MGUser:" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

            $pltGMGU.UserId = $MGUser.UserPrincipalName ;
            TRY {
                $MGUser = Get-MGUser @pltGMGU ;
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                $smsg += "`n$($ErrTrapd.Exception.Message)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                BREAK ;
            } ; 

            $smsg = "Return updated MGUser to pipeline" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            $MGUser | write-output ;

            $smsg =  $sBnr.replace('=v','=^').replace('v=','^=') ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; # ($usr in $users)

    } # PROC-E
    END{

    } ;
 }

#*------^ add-EXOLicense.ps1 ^------


#*------v check-EXOLegalHold.ps1 v------
Function check-EXOLegalHold {
    <#
    .SYNOPSIS
    check-EXOLegalHold - check passed in EXO mailbox object for Legal Hold status
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 12:36 PM 11/6/2020
    FileName    :
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,Legal
    REVISIONS   :
    * 2:40 PM 12/10/2021 more cleanup 
    * 11:23 AM 9/16/2021 string
    * 8:24 AM 8/27/2021 cleanedup 
    * 1:23 PM 5/14/2021 init version, roughed in, completely untested (was prev a largely unmodified dupe of disconnect-exo)
    .DESCRIPTION
    check-EXOLegalHold - check passed in EXO mailbox object for Legal Hold status
    
    # chk mbx-level holds
      Rxo ; 
      +[SIDS]::[PS]:C:\u\w\e\scripts$ get-exomailbox USERUPN | FL LitigationHoldEnabled,InPlaceHolds
      LitigationHoldEnabled : False
      InPlaceHolds          : {}
      # expand per arti
      +[SIDS]::[PS]:C:\u\w\e\scripts$ get-exomailbox USERUPN  | Select-Object -ExpandProperty InPlaceHolds
      # nothing

      # check for org hold
      +[SIDS]::[PS]:C:\u\w\e\scripts$ Get-exoOrganizationConfig | FL InPlaceHolds
      InPlaceHolds : {}
      # expand spec
      +[SIDS]::[PS]:C:\u\w\e\scripts$ Get-exoOrganizationConfig | select -expand InPlaceHolds
      # nothing
      # check compliancetaghold (per above)
      +[SIDS]::[PS]:C:\u\w\e\scripts$ get-exomailbox USERUPN  |FL ComplianceTagHoldApplied
      ComplianceTagHoldApplied : False

      No holds above.

      # eDiscovery holds – appears to require the GUID from one of the blank values above.(can't check)
      If had it, my run on the details would be:
      connect-ccms ; 
      $CaseHold = Get-ccCaseHoldPolicy <hold GUID without prefix> ; 
      Get-ccComplianceCase $CaseHold.CaseId | FL Name ; 
      $CaseHold | FL Name,ExchangeLocation ; 
      Get-exoMailboxSearch -InPlaceHoldIdentity <hold GUID> | FL Name,SourceMailboxes
      # check RetentionCompliancePolicy
      Get-ccRetentionCompliancePolicy <hold GUID without prefix or suffix> -DistributionDetail  | FL Name,*Location

      # check compliancetaghold in mbx:
      +[SIDS]::[PS]:C:\u\w\e\scripts$ get-exomailbox USERUPN  |FL ComplianceTagHoldApplied
      ComplianceTagHoldApplied : False

      Erm, did anyone *read* the following on holds in the above article?:
      This appears to be *routine* behavior per section…

        Managing mailboxes on delay hold  - https://docs.microsoft.com/en-us/microsoft-365/compliance/identify-a-hold-on-an-exchange-online-mailbox?view=o365-worldwide#managing-mailboxes-on-delay-hold
 
        After any type of hold is removed from a mailbox, a delay hold is applied. This means that the actual removal of the hold is delayed for 30 days to prevent data from being permanently deleted (purged) from the mailbox. This gives admins an opportunity to search for or recover mailbox items that will be purged after a hold is removed. A delay hold is placed on a mailbox the next time the Managed Folder Assistant processes the mailbox and detects that a hold was removed. Specifically, a delay hold is applied to a mailbox when the Managed Folder Assistant sets one of the following mailbox properties to True:
                · DelayHoldApplied: This property applies to email-related content (generated by people using Outlook and Outlook on the web) that's stored in a user's mailbox.
                · DelayReleaseHoldApplied: This property applies to cloud-based content (generated by non-Outlook apps such as Microsoft Teams, Microsoft Forms, and Microsoft Yammer) that's stored in a user's mailbox. Cloud data generated by a Microsoft app is typically stored in a hidden folder in a user's mailbox.
        When a delay hold is placed on the mailbox (when either of the previous properties is set to True), the mailbox is still considered to be on hold for an unlimited hold duration, as if the mailbox was on Litigation Hold. After 30 days, the delay hold expires, and Microsoft 365 will automatically attempt to remove the delay hold (by setting the DelayHoldApplied or DelayReleaseHoldApplied property to False) so that the hold is removed. After either of these properties are set to False, the corresponding items that are marked for removal are purged the next time the mailbox is processed by the Managed Folder Assistant.
        To view the values for the DelayHoldApplied and DelayReleaseHoldApplied properties for a mailbox, run the following command in Exchange Online PowerShell.

      # checking the above:
      +[SIDS]::[PS]:C:\u\w\e\scripts$ get-exomailbox USERUPN  | FL *HoldApplied*
      ComplianceTagHoldApplied : False
      DelayHoldApplied         : True
      DelayReleaseHoldApplied  : True
      
    .PARAMETER  ProxyEnabled
    Use Proxy-Aware SessionOption settings [-ProxyEnabled]
    .PARAMETER  CommandPrefix
    [verb]-PREFIX[command] PREFIX string for clearly marking cmdlets sourced in this connection [-CommandPrefix tag]
    .PARAMETER  Credential
    Credential to use for this connection [-credential 'SOMEACCT@DOMAIN.COM']
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    check-EXOLegalHold
    Connect using defaults, and leverage any pre-set $global:credo365TORSID variable
    .EXAMPLE
    check-EXOLegalHold -CommandPrefix exo -credential (Get-Credential -credential user@domain.com)  ;
    Connect an explicit credential, and use 'exolab' as the cmdlet prefix
    .EXAMPLE
    $cred = get-credential -credential $o365_Torolab_SIDUpn ;
    check-EXOLegalHold -credential $cred ;
    Pass in a prefab credential object (useful for auto-shifting to MFA - the function will autoresolve MFA reqs based on the cred domain)
    .LINK
    https://social.technet.microsoft.com/Forums/msonline/en-US/f3292898-9b8c-482a-86f0-3caccc0bd3e5/exchange-powershell-monitoring-remote-sessions?forum=onlineservicesexchange
    .LINK
    https://github.com/JeremyTBradshaw
    #>
    ##Requires -Modules ActiveDirectory,verb-Auth,verb-IO,verb-Mods,verb-Text,verb-Network,verb-AAD,verb-ADMS,verb-Ex2010,verb-logging

    [CmdletBinding()]
    PARAM(
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="EXO Mailbox identifier[-mailbox 'xxx']")]
        [ValidateNotNullOrEmpty()]$Mailbox,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2
    ) ;
    BEGIN {
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        # shifting from ps1 to a function: need updates self-name:
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        #-=-=configure EXO EMS aliases to cover useEXOv2 requirements-=-=-=-=-=-=
        # have to preconnect, as it gcm's the targets
        if ($script:useEXOv2) { reconnect-eXO2 }
        else { reconnect-EXO } ;
        # in this case, we need an alias for EXO, and non-alias for EXOP
        [array]$cmdletMaps = 'ps1GetxRcp;get-exorecipient;','ps1GetxMbx;get-exomailbox;','ps1SetxMbx;Set-exoMailbox;','ps1GetxUser;get-exoUser;',
            'ps1SetxCalProc;set-exoCalendarprocessing;','ps1GetxCalProc;get-exoCalendarprocessing;','ps1GetxMbxFldrPerm;get-exoMailboxfolderpermission;',
            'ps1GetxAccDom;Get-exoAcceptedDomain;','ps1GetxRetPol;Get-exoRetentionPolicy','ps1GetxDistGrp;get-exoDistributionGroup;',
            'ps1GetxDistGrpMbr;get-exoDistributionGroupmember;','ps1GetxMsgTrc;get-exoMessageTrace;','ps1GetxMsgTrcDtl;get-exoMessageTraceDetail;',
            'ps1GetxMbxFldrStats;get-exoMailboxfolderStatistics','ps1GetxMContact;Get-exomailcontact;','ps1SetxMContact;Set-exomailcontact;',
            'ps1NewxMContact;New-exomailcontact;' ,'ps1TestxMapi;Test-exoMAPIConnectivity','ps1GetxOrgCfg;Get-exoOrganizationConfig' ;
        foreach($cmdletMap in $cmdletMaps){
            if($script:useEXOv2){
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1].replace('-exo','-xo') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
            } else {
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;                
                write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
            } ;
        } ;
    
        # shifting from ps1 to a function: need updates self-name:
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;

        #$sBnr="#*======v START PASS:$($ScriptBaseName) v======" ; 
        $sBnr="#*======v START PASS:$(${CmdletName}) v======" ; 
        $smsg= $sBnr ;   
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        # Clear error variable
        $Error.Clear() ;
        

    } ;  # BEGIN-E
    PROCESS {
        $error.clear() ;
        TRY {
            $objReturn=[ordered]@{
                Held=$false ; 
                LitigationHoldEnabled=$null ; 
                InPlaceHolds =$null ; 
                ComplianceTagHoldApplied =$null ; 
                DelayHoldApplied =$null ; 
                DelayReleaseHoldApplied =$null ; 
                OrgInPlaceHolds =$null ; 
            } ; 
            $xmbx = ps1GetxMbx -id $Mailbox -ea STOP; 
            $xOrgCfgInPlaceHolds = ps1GetxOrgCfg -ea STOP | select -expand InPlaceHolds
            if($xmbx.LitigationHoldEnabled){
                $objReturn.Held=$true ;
                $objReturn.LitigationHoldEnabled = $xmbx.LitigationHoldEnabled;
            } ; 
            if($xmbx.ComplianceTagHoldApplied){
                $objReturn.Held=$true ;
                $objReturn.ComplianceTagHoldApplied = $xmbx.ComplianceTagHoldApplied;
            } ; 
            if($xmbx.DelayHoldApplied){
                $objReturn.Held=$true ;
                $objReturn.DelayHoldApplied = $xmbx.DelayHoldApplied;
            } ; 
            if($xmbx.DelayReleaseHoldApplied){
                $objReturn.Held=$true ;
                $objReturn.DelayReleaseHoldApplied = $xmbx.DelayReleaseHoldApplied;
            } ; 
            # checking orgs: Get-exoOrganizationConfig | FL InPlaceHolds
            # reportedly expanding InPlaceHolds will return a list of mbxs, but I can't find an example of the actual return, to try to test for it.
            if(xOrgCfgInPlaceHolds){
                $objReturn.Held=$true ;
                $objReturn.OrgInPlaceHolds = $xOrgCfgInPlaceHolds;
                $smsg = "$(${CmdletName}):detected $((get-alias ps1GetxOrgCfg).definition).OrgInPlaceHolds`nbut the function is not currently written to *expand and compare* the value contents`n(requires a code update to properly work with the sample returned)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 

        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ; 
    } ;  # PROC-E
    END {
        $objReturn | write-output ; 
    } ;  # END-E
}

#*------^ check-EXOLegalHold.ps1 ^------


#*------v Connect-EXO.ps1 v------
Function Connect-EXO {
    <#
    .SYNOPSIS
    Connect-EXO - Establish connection to Exchange Online (via EXO V2 graph-api module)
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-07-29
    FileName    :
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    REVISIONS   :
    *2:48 PM 5/22/2025 rolled reconnect-exo into an alias of this (found updating it, that I was copying most of cxo's logic over, no point wo local baseicauth creds being moved anymore); 
        dbgd working cxo, rxo, csc & rsc, looks functional. put through a build, anduse it with Invoke-SCMailboxFolderContentPurgeV2.ps1; 
        -credential should work (though modernAuth wouldn't permit); -userprincipalname works; userRole specs work; SC connections appear to work. Put everything through this, instead of running bespoke code
         made some changes for full -userprincipalname support (as Prvw/S&C doesn't support CBA for discovery-tied commands: have to use native upn connects)
    * 12:34 PM 10/29/2024 splicing back updates from Invoke-SCMailboxFolderContentPurge.ps1, incl abil to do prefixless (so have to pull the -prefix as a driver), checking Connect-IPPSSession it's still cited as "cmdlet in the Exchange Online PowerShell module to connect to Security & Compliance PowerShell using modern authentication ": SC is the ideal conn
    * 1:30 PM 9/5/2024 added  update-SecurityProtocolTDO() SB to begin
    * 3:11 PM 7/15/2024 needed to change CHKPREREQ to check for presence of prop, not that it had a value (which fails as $false); hadn't cleared $MetaProps = ...,'DOESNTEXIST' ; confirmed cxo working non-based
    * 1:43 PM 7/9/2024 passes hybrid xo/s&c, with variant prefixes (other than hard-req that prefix cc indicates an s&c conn).
    * 4:13 PM 7/8/2024 passes dbg xo; END block validation code using test-exoConnectionTDO()+resolve-AppIDToCBAFriendlyName() is now functional
    * 3:33 PM 7/3/2024 updated, rewrote tests & END block to rely on test-EXOConnectionTDO, and new resolve-AppIDToCBAFriendlyName(); Initial tests are working. 
    * 2:55 PM 6/27/2024 back to cc support: "# build in hybrid xo & Prvw support, switch on the prefix spec" -prefix cc triggers it.
        rem'd no-longer needed legacy EOM specs -ExchangeEnvironmentName,-UseMultithreading, -PageSize, $rgxEXoPrunspaceConnectionInfoAppName,$EXoPrunspaceConnectionInfoPort,$rgxExoPsHostName,$rgxEXOv1gmoDescription,$EXOv1gmoprivatedataImplicitRemoting,$rgxEXOv2gmoDescription,$EXOv2gmoprivatedataImplicitRemoting,$rgxExoPsessionstatemoduleDescription,$EXOv2StateOK,$EXOv2AvailabilityOK,$EXOv2RunStateBad,$EXOv1GmoFilter
        wip updated for functionalized verb-AAD:Update-AADAppRegistrationKeyCertificate(); need to debug the S&C conn, haven't revisited since initial hybrid coding attempt ; odd, it lost the cxo alias def (added back, did I lose a rev in the mix?) CBA certs expired, error in connect-ExchangeOnline doesn't cite the expiration, just crashes out. So added code to precheck local cert NotAfter, and premptively feed problem cert into Update-AADAppRegistrationKeyCertificate 
        (not debugged yet; need to reroll the certs & creds)
    * 4:28 PM 6/26/2024 interrum, functional 
    * 9:55 AM 6/21/2024 add: prereq checks, and $isBased support, to devert into most basic Get-ConnectionInformation , Connect-ExchangeOnline fall back support
    * 11:26 AM 4/12/2024 validated connect-exo -prefix xo -verbose ; 
    * 9:09 AM 4/2/2024 rem'd citations of $bPreExoPPss
    * 1:05 PM 4/1/2024 validates functional jb    
    * 1:48 PM 3/1/2024  with v340 support for proper/native S&C conn, I can finally remove the legacy EOM connection bits from this (*substantial* simplification):
        - removed raft of pre EOMv3xx code, basic auth is fully blocked now, independantly, test-EXOv2Connection() got some updates (TenOrg tweak, likewise removed code < EOM3xx support)
    * 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
    * 1:32 PM 5/30/2023 Updates to support either -Credential, or -UserRole + -TenOrg, to support fully portable downstream credentials: 
        - Add -UserRole & explicit -TenOrg params; working. 
        - Drive TenOrg defaulted $global:o365_TenOrgDefault, or on $env:userdomain
        - use the combo thru get-TenantCredential(), then set result to $Credential
        - if using Credential, the above are backed out via get-TenantTag() on the $credential 
        - CBA identifiers are resolve always via $uRoleReturn = resolve-UserNameToUserRole -Credential $Credential ;
    * 2:02 PM 5/25/2023 updated CBH example to reflect use of $pltRXOC std conn splat
    * 1:08 PM 5/23/2023 fixed typo (-eq vs =, dumping $false into pipe)     
    * 4:15 PM 5/22/2023 cleaned cbh ; removed some rem'd 
    * 10:06 AM 5/19/2023 add: code to run resolve-UserNameToUserRole  wi $Credential or $UserPrincipalName; sub'd out direct cert-parsing & value assignements with resolve-UserNameToUserRole outputs; 
    * 3:21 PM 4/25/2023 add CBA CBH demo ; added code to pass through calc'd $CertTag as test-EXOv2Connection() -CertTag (used for validating credential alignment w Tenant)
    * 10:59 AM 4/18/2023 step debugs ; 
    * 10:16 AM 4/18/2023 rem'd out unused $ConnectionUri;$AzureADAuthorizationEndpointUri;$PSSessionOption;$BypassMailboxAnchoring;$DelegatedOrganization;
    rem'd boolean dump into pipeline in END{}
    * 4:08 PM 4/17/2023 ported into connect-exo(), aliased cxo2,connect-exo2 in it.
    * 2:02 PM 4/17/2023 rev: $MinNoWinRMVersion from 2.0.6 => 3.0.0.
    * 2:40 PM 4/5/2023: force the Connect-ExchangeOnline banner hidden:$pltCEO.ShowBanner = $false ;
    * 11:02 AM 4/4/2023 reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not; added support for EMOv3 get-connectioninfo() etc, and differentiate EMOv2 from EMOv3 connections
    * 3:14 pm 3/29/2023: REN'D $modname => $EOMModName
    * 3:59 PM 8/2/2022 got through dbugging EOM v205 SID interactive pass, working ; added Conn-EOM missing -prefix spec; fully works from mybox w v206p6, cEOM connection, with functional prefix.
    * 4:07 PM 7/26/2022 found that MS code doesn't chk for multi vers's installed, when building .dll paths: wrote in code to take highest version.
    * 3:30 PM 7/25/2022 tests against CBA & SID interactive creds on EOM v205, need to debug now against EOM v206p6, to accomodate PSSession-less connect & test code.
    * 10:50 AM 6/27/2022 missing: $rgxCertThumbprint; validated works with userp interactive mfa
    * 3:27 PM 6/24/2022 dbgd through w x10 connected, looks like it properly disconnects and reconnects; shifted valid code into test-EXOv2Connection(); patched in CBA support
    * 11:27 AM 6/7/2022 cbh cleanup
    * 3:54 PM 4/1/2022 add missing $silent param (had support, but no param)
    * 4:10 PM 3/29/2022 finished getting test-EXOToken interaction and EOM module/.dll load code squared up. 
    3:58 PM 3/28/2022 add: DefaultParameterSetName='UPN', avoid: 'Parameter set cannot be resolved using the specified named parameters.'
    - updated module path code, to support new .netcore/.netframework subdir forking of the .dll storage in the EOm module. 
    - all of the write-* to incl wl support. 
    - trying to sort out use of the test-ActiveToken() - wants a new -TokenExpiryTime, in other code in the EOM .psm1 it's called as 
    $hasActiveToken = Test-ActiveToken -TokenExpiryTime $script:PSSession.TokenExpiryTime
    $sessionIsOpened = $script:PSSession.Runspace.RunspaceStateInfo.State -eq 'Opened'
    if (($hasActiveToken -eq $false) -or ($sessionIsOpened -ne $true))
    {
        #If there is no active user token or opened session then ensure that we remove the old session
        $shouldRemoveCurrentSession = $true;
    }
    * 1:24 PM 3/15/2022 moved $minvers to a param: -MinimumVersion
    * 2:40 PM 12/10/2021 more cleanup 
    # 11:23 AM 9/16/2021 string
    # 1:31 PM 7/21/2021 revised Add-PSTitleBar $sTitleBarTag with TenOrg spec (for prompt designators)
    * 11:53 AM 4/2/2021 updated with rlt & recstat support, updated catch blocks
    # 8:34 AM 3/31/2021 added verbose suppress to all import-mods
    * 11:36 AM 3/5/2021 updated colorcode, subed wv -verbose with just write-verbose, added cred.uname echo
    * 1:15 PM 3/1/2021 added org-level color-coded console
    * 8:55 AM 11/11/2020 added fake -Username block, to make -Credential, *also* auto-renew sessions! (above from: https://ingogegenwarth.wordpress.com/2018/02/02/exo-ps-mfa/)
    * 2:01 PM 11/10/2020 swap connect-exo2 to connect-exo2old (uses connect-ExchangeOnline), and ren this "Connect-EXO2A" to connect-exo2 ; fixed get-module tests (sub'd off the .dll from the modname)
    * 9:56 AM 11/10/2020 variant of cxo2, that has direct ported-in low-level code from the ExchangeOnlineManagement:connect-ExchangeOnlin(). debugs functional so far, haven't tested concurrent CCMS + EXO overlap & tokens yet. 
    * 8:30 AM 10/22/2020 ren'd $TentantTag -> $TenOrg, swapped looping meta resolve with 1-liner approach ; added AcceptedDom caching to the middle status test (suppress one more get-exoaccepteddomain call if possible)
    * 4:41 PM 10/8/2020 implemented AcceptedDomain caching, in connect-exo2 to match rxo2
    * 1:18 PM 8/11/2020 fixed typo in *broken *closed varis in use; updated ExoV1 conn filter, to specificly target v1 (old matched v1 & v2) ; trimmed entire rem'd MFA block ; added trailing test-EXOToken confirm
    * 12:57 PM 8/4/2020 sorted ExchangeOnlineMgmt mod issues (splatting wo using splat char), if MS hadn't completely rewritten the access, this rewrite wouldn't have been necessary in the 1st place. I'm not looking forward to the org wide rewrites to recode verb-exoNoun -> verb-xoNoun, to accomodate the breaking-change blocking -Prefix 'exo'. ; # 1:04 PM 8/4/2020 cute: now the above error's stopped occuring on the problem tenant. Can't do further testing of the workaround, unless/until it breaks again ; * 2:39 PM 8/4/2020 fixed -match "^(Session|WinRM)\d*" rgx (lacked ^, mismatched EXOv2 conns)
    * 12:20 PM 7/29/2020 rewrite/port from connect-EXO to replace import-pssession with new connect-ExchangeOnline cmdlet (supports MFA natively) - #127 # *** LEFT OFF HERE 5:01 PM 7/29/2020 *** not sure if it supports allowclobber, if it's actually wrapping pssession, it sure as shit does!
    * 11:21 AM 7/28/2020 added Credential -> AcceptedDomains Tenant validation, also testing existing conn, and skipping reconnect unless unhealthy or wrong tenant to match credential
    * 3:24 PM 7/24/2020 updated to support tenant-alignment & sub'd out showdebug for verbose
    * 7:13 AM 7/22/2020 replaced codeblock w get-TenantTag()
    * 5:12 PM 7/21/2020 added ven supp
    * 11:50 AM 5/27/2020 added alias:cxo win func
    * 8:38 AM 4/17/2020 added a new test of $global:EOLSession, to detect initial cred fail (pw chg, outofdate creds, locked out)
    * 8:45 AM 3/3/2020 public cleanup, refactored Connect-EXO2 for Meta's
    * 9:52 PM 1/16/2020 cleanup
    * 10:55 AM 12/6/2019 Connect-EXO2:added suffix to TitleBar tag for other tenants, also config'd a central tab vari
    * 9:17 AM 12/4/2019 CONSISTENTLY failing to load properly in lab, on lynms6200d - wont' get-module xxxx -listinstalled, even after load, so I rewrote an exemption diverting into the locally installed $env:userprofile\documents\WindowsPowerShell\Modules\exoMFAModule\ copy.
    * 5:14 PM 11/27/2019 repl $MFA code with get-TenantMFARequirement
    * 1:07 PM 11/25/2019 added tenant-specific alias variants for connect & reconnect
    # 1:26 PM 11/19/2019 added MFA detection fr infastrings .ps1 globals, lifted from Jeremy Bradshaw (https://github.com/JeremyTBradshaw)'s Connect-Exchange()
    # 10:35 AM 6/20/2019 added $pltiSess splat dump to the import-pssession cmd block; hard-typed the $Credential [System.Management.Automation.PSCredential]
    # 8:22 AM 11/20/2017 spliced in retry loop into reConnect-EXO2 as well, to avoid using any state testing in scripts, localize it 1x here.
    # 1:49 PM 11/2/2017 coded around non-profile gaps from not having get-admincred() - added the prompt code in to fake it
    # 12:26 PM 9/11/2017 debugged retry - catch doesn't fire properly on new-Pssession, have to test the $error state, to detect auth fails (assuming the bad pw error# is specific). $error test is currently targeting specific error returned on a bad password. Added retry, for when connection won't hold and fails breaks - need to watch out that bad pw doesn't lock out the acct!
    # 12:50 PM 6/2/2017 expanded pshelp, added Examples, cleaned up deadwood
    * # 12:10 PM 3/15/2017 Connect-EXO2 typo, disable prefix auto spec, unless actually blanked. switch ProxyEnabled to non-Mandatory.
    .DESCRIPTION
    Connect-EXO - Establish connection to Exchange Online (via EXO V2 graph-api module)
    .PARAMETER  Prefix
    [verb]-PREFIX[command] PREFIX string for clearly marking cmdlets sourced in this connection (defaults to xo, assert -Prefix:`$null to suppress any prefix use) [-Prefix tag]
    .PARAMETER Credential
    Credential to use for this connection [-credential [credential obj variable]
    .PARAMETER UserPrincipalName
    User Principal Name or email address of the user
    .PARAMETER connectPurview
    Switch to connect to Security & Compliance ('Purview') Powershell via Connect-IPPSSession[-connectPurview]
    .PARAMETER SCDefaultPrefix
    Default Prefix/ModulePrefix to be used for connections to Security & Compliance ('Purview') Powershell via Connect-IPPSSession[-SCDefaultPrefix 'sc']
    .PARAMETER UserRole
    Credential Optional User Role spec for credential discovery (wo -Credential)(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]
    .PARAMETER TenOrg
    Optional Tenant Tag (wo -Credential)[-TenOrg 'XYZ']
    .PARAMETER ExchangeEnvironmentName
    Exchange Environment name [-ExchangeEnvironmentName 'O365Default']
    .PARAMETER MinimumVersion
    MinimumVersion required for ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']
    .PARAMETER MinNoWinRMVersion
    MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']
    .PARAMETER UseMultithreading
    Switch to enable/disable Multi-threading in the EXO cmdlets
    .PARAMETER ShowProgress
    Flag to enable or disable showing the number of objects written
    .PARAMETER Pagesize
    Pagesize Param
    .PARAMETER silent
    Switch to suppress all non-error echos
    .PARAMETER showDebug
    Debugging Flag [-showDebug]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    PS>  Connect-EXO -cred $credO365TORSID ;
    Connect using defaults, and leverage any pre-set $global:credo365TORSID variable
    .EXAMPLE
    PS>  Connect-EXO -Prefix exolab -credential (Get-Credential -credential user@domain.com)  ;
    Connect an explicit credential, and use 'exolab' as the cmdlet prefix
    .EXAMPLE 
    connect-exo2 -credential $credO365xxxCBA -verbose ; 
    Connect using a CBA credential variable (prestocked from profile automation). Script opens and recycles the cred cert specs emulating the native CBA connection below, but pulling source info from a stored dpapi-encrypted .xml credential file.
    .EXAMPLE
    connect-exo -UserRole SIDCBA -TenOrg ABC -verbose  ; 
    Demo use of UserRole (specifying a CBA variant), AND TenOrg spec, to connect (autoresolves against preconfigured credentials in profile)
    .EXAMPLE
    PS>  $cred = get-credential -credential $o365_Torolab_SIDUpn ;
    PS>  Connect-EXO -credential $cred ;
    Pass in a prefab credential object (useful for auto-shifting to MFA - the function will autoresolve MFA reqs based on the cred domain)
    .EXAMPLE
    PS> $pltRXOC = [ordered]@{
    PS>     Credential = $Credential ;
    PS>     verbose = $($VerbosePreference -eq "Continue")  ;
    PS>     Silent = $silent ; 
    PS> } ;
    PS> if ($script:useEXOv2 -OR $useEXOv2) { Connect-EXO2 @pltRXOC }
    PS> else { Connect-EXO @pltRXOC } ;    
    Splatted example leveraging prefab $pltRXOC splat, derived from local variables & $VerbosePreference value.
    .EXAMPLE
    PS>  $pltCXOCThmb=[ordered]@{
    PS>  	CertificateThumbPrint = $credO365TORSIDCBA.UserName ;
    PS>  	AppID = $credO365TORSIDCBA.GetNetworkCredential().Password ;
    PS>  	Organization = 'TENANTNAME.onmicrosoft.com' ;
    PS>  	Prefix = 'xo' ;
    PS>  	ShowBanner = $false ;
    PS>  };
    PS>  write-host "Connect-ExchangeOnline w $(($pltCXOCThmb|out-string).trim())" ;
    PS>  Connect-ExchangeOnline @pltCXOCThmb ;
    Example of native connect-ExchangeOnline syntax leveraging a CBA certificate stored locally, with AppID and CertificateThumbPrint pulled from a local global-scope credential object (with AppID stored as password & Thumprint as username)
    .LINK
    #>
    [CmdletBinding(DefaultParameterSetName='UPN')]
    # add rxo aliases here, drop rxo as a separate function
    [Alias('cxo','cxo2','Connect-EXO2','Connect-Purview','Connect-SC','Reconnect-EXO','Reconnect-Purview','Reconnect-SC' )]
    PARAM(
        # try pulling all the ParameterSetName's - just need to get through it now. - no got through it with a defaultparametersetname (avoids 
        [Parameter(HelpMessage = "[verb]-PREFIX[command] PREFIX string for clearly marking cmdlets sourced in this connection (defaults to xo, assert -Prefix:`$null to suppress any prefix use) [-Prefix tag]")]
            [string]$Prefix = 'xo',
        [Parameter(ParameterSetName = 'Cred', HelpMessage = "Credential to use for this connection [-credential [credential obj variable]")]
            [System.Management.Automation.PSCredential]$Credential,
            # = $global:credo365TORSID, # defer to TenOrg & UserRole resolution
        [Parameter(ParameterSetName = 'UPN',HelpMessage = "User Principal Name or email address of the user[-UserPrincipalName logon@domain.com]")]
            [string]$UserPrincipalName,
        [Parameter(HelpMessage = "Switch to connect to Security & Compliance ('Purview') Powershell via Connect-IPPSSession[-connectPurview]")]
            [Alias('ConnectSC')]
            [switch]$connectPurview,
        [Parameter(HelpMessage = "Default Prefix/ModulePrefix to be used for connections to Security & Compliance ('Purview') Powershell via Connect-IPPSSession[-SCDefaultPrefix 'sc']")]
            [string] $SCDefaultPrefix = 'sc',
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ; 
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ; 
                return $true ; 
            })]
            [string[]]$UserRole = @('SIDCBA','SID','CSVC'),
            # Prvw: [string[]]$UserRole = @('SID'),
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
            [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        #[Parameter(HelpMessage = "Exchange Environment name [-ExchangeEnvironmentName 'O365Default']")]
            #[Microsoft.Exchange.Management.RestApiClient.ExchangeEnvironment]
            <# error: typedef missing, pre ipmo the mod. 
            Unable to find type [Microsoft.Exchange.Management.RestApiClient.ExchangeEnvironment].
            At D:\scripts\connect-exo2_func.ps1:132 char:9
            +         [Microsoft.Exchange.Management.RestApiClient.ExchangeEnvironm ...
            +         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                + CategoryInfo          : InvalidOperation: (Microsoft.Excha...angeEnvironment:TypeName) [], RuntimeException
                + FullyQualifiedErrorId : TypeNotFound
            #>
            #$ExchangeEnvironmentName = 'O365Default',
        [Parameter(HelpMessage = "MinimumVersion required for ExchangeOnlineManagement module (defaults to '2.0.5')[-MinimumVersion '2.0.6']")]
            [version] $MinimumVersion = '2.0.5',
        [Parameter(HelpMessage = "MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']")]
            [version] $MinNoWinRMVersion = '3.0.0',
        #[Parameter(HelpMessage = "Switch to enable/disable Multi-threading in the EXO cmdlets [-UseMultithreading]")]
        #    [switch]$UseMultithreading=$true,
        [Parameter(HelpMessage = "Switch to enable or disable showing the number of objects written (defaults `$true)[-ShowProgress]")]
            [switch]$ShowProgress=$true,
        #[Parameter(HelpMessage = "Pagesize Param[-PageSize 500]")]
        #    [uint32]$PageSize = 1000,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent,
        [Parameter(HelpMessage = "Debugging Flag [-showDebug]")]
            [switch] $showDebug
    ) ;
    BEGIN {
        # Debugger:proxy automatic variables that aren't directly accessible when debugging (must be assigned and read back from another vari) ; 
        $rPSCmdlet = $PSCmdlet ; 
        $rPSScriptRoot = $PSScriptRoot ; 
        $rPSCommandPath = $PSCommandPath ; 
        $rMyInvocation = $MyInvocation ; 
        $rPSBoundParameters = $PSBoundParameters ; 
        $verbose = ($VerbosePreference -eq "Continue") ;
        ${CmdletName} = $rPSCmdlet.MyInvocation.MyCommand.Name ;
        $PSParameters = New-Object -TypeName PSObject -Property $rPSBoundParameters ;
		$CurrentVersionTlsLabel = [Net.ServicePointManager]::SecurityProtocol ; # Tls, Tls11, Tls12 ('Tls' == TLS1.0)  ;
        write-verbose "PRE: `$CurrentVersionTlsLabel : $($CurrentVersionTlsLabel )" ;
        # psv6+ already covers, test via the SslProtocol parameter presense
        if ('SslProtocol' -notin (Get-Command Invoke-RestMethod).Parameters.Keys) {
            $currentMaxTlsValue = [Math]::Max([Net.ServicePointManager]::SecurityProtocol.value__,[Net.SecurityProtocolType]::Tls.value__) ;
            write-verbose "`$currentMaxTlsValue : $($currentMaxTlsValue )" ;
            $newerTlsTypeEnums = [enum]::GetValues('Net.SecurityProtocolType') | Where-Object { $_ -gt $currentMaxTlsValue }
            if($newerTlsTypeEnums){
                write-verbose "Appending upgraded/missing TLS `$enums:`n$(($newerTlsTypeEnums -join ','|out-string).trim())" ;
            } else {
                write-verbose "Current TLS `$enums are up to date with max rev available on this machine" ;
            };
            $newerTlsTypeEnums | ForEach-Object {
                [Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bor $_
            } ;
        } ;
        #region CHKPREREQ ; #*------v CHKPREREQ v------
        # critical dependancy Meta variables
        $MetaNames = 'TOR','CMW','TOL' # ,'NOSUCH' ; 
        # critical dependancy Meta variable properties
        $MetaProps = 'legacyDomain','o365_TenantDomain' #,'DOESNTEXIST' ; 
        $isBased = $true ; $gvMiss = @() ; $ppMiss = @() ; 
        foreach($met in $metanames){
            write-verbose "chk:`$$($met)Meta" ; 
            if(-not (gv -name "$($met)Meta" -ea 0)){
                $isBased = $false; $gvMiss += "$($met)Meta" ; 
            } ; 
            foreach($mp in $MetaProps){
                write-verbose "chk:`$$($met)Meta.$($mp)" ; 
                #if(-not (gv -name "$($met)Meta" -ea 0).value[$mp]){ # testing has a value, not is present as a spec!
                if(-not (gv -name "$($met)Meta" -ea 0).value.keys -contains $mp){
                    $isBased = $false; $ppMiss += "$($met)Meta.$($mp)" ; 
                } ; 
            } ; 
        } ; 
        if($gvmiss){write-warning "Missing Dependant Meta variables:`n$(($gvMiss |%{"`$$($_)" }) -join ',')" } ; 
        if($ppMiss){write-warning "Missing Dependant Meta vari properties:`n$(($ppMiss |%{"`$$($_)" }) -join ',')" } ; 
        if(-not $isBased){ write-warning  "missing critical dependancy profile config!" } ; 
        #endregion CHKPREREQ ; #*------^ END CHKPREREQ ^------

        if(-not (gv rgxCertThumbprint -ea 0)){$rgxCertThumbprint = '[0-9a-fA-F]{40}' ; } ;
        if(-not (gv rgxCertFNameSuffix -ea 0)){$rgxCertFNameSuffix = '-([A-Z]{3})$' ; } ; 

        #*------v PSS & GMO VARIS v------
        # move into a param
        #$MinNoWinRMVersion = '3.0.0' ; 
        # get-pssession session varis
        # select key differentiating properties:
        $pssprops = 'Id','ComputerName','ComputerType','State','ConfigurationName','Availability', 
            'Description','Guid','Name','Path','PrivateData','RootModuleModule', 
            @{name='runspace.ConnectionInfo.ConnectionUri';Expression={$_.runspace.ConnectionInfo.ConnectionUri} },  
            @{name='runspace.ConnectionInfo.ComputerName';Expression={$_.runspace.ConnectionInfo.ComputerName} },  
            @{name='runspace.ConnectionInfo.Port';Expression={$_.runspace.ConnectionInfo.Port} },  
            @{name='runspace.ConnectionInfo.AppName';Expression={$_.runspace.ConnectionInfo.AppName} },  
            @{name='runspace.ConnectionInfo.Credentialusername';Expression={$_.runspace.ConnectionInfo.Credential.username} },  
            @{name='runspace.ConnectionInfo.AuthenticationMechanism';Expression={$_.runspace.ConnectionInfo.AuthenticationMechanism } },  
            @{name='runspace.ExpiresOn';Expression={$_.runspace.ExpiresOn} } ; 
        $EOMmodname = 'ExchangeOnlineManagement' ;
        $EXOv1ConfigurationName = $EXOv2ConfigurationName = $EXoPConfigurationName = "Microsoft.Exchange" ;
        if(-not (gv EXOv1ComputerName -ea 0 )){$EXOv1ComputerName = 'ps.outlook.com' };
        if(-not (gv EXOv1runspaceConnectionInfoAppName -ea 0 )){$EXOv1runspaceConnectionInfoAppName = '/PowerShell-LiveID'  };
        if(-not (gv EXOv1runspaceConnectionInfoPort -ea 0 )){$EXOv1runspaceConnectionInfoPort = '443' };

        if(-not (gv EXOv2ComputerName -ea 0 )){$EXOv2ComputerName = 'outlook.office365.com' ;}
        if(-not (gv EXOv2Name -ea 0 )){$EXOv2Name = "ExchangeOnlineInternalSession*" ; }
        #if(-not (gv rgxEXoPrunspaceConnectionInfoAppName -ea 0 )){$rgxEXoPrunspaceConnectionInfoAppName = '^/(exadmin|powershell)$'}; 
        #if(-not (gv EXoPrunspaceConnectionInfoPort -ea 0 )){$EXoPrunspaceConnectionInfoPort = '80' } ; 
        # gmo varis
        #if(-not (gv rgxExoPsHostName -ea 0 )){ $rgxExoPsHostName = "^(ps\.outlook\.com|outlook\.office365\.com)$" } ;
        #if(-not (gv rgxEXOv1gmoDescription -ea 0 )){$rgxEXOv1gmoDescription = "^Implicit\sremoting\sfor\shttps://ps\.outlook\.com/PowerShell" }; 
        #if(-not (gv EXOv1gmoprivatedataImplicitRemoting -ea 0 )){$EXOv1gmoprivatedataImplicitRemoting = $true };
        #if(-not (gv rgxEXOv2gmoDescription -ea 0 )){$rgxEXOv2gmoDescription = "^Implicit\sremoting\sfor\shttps://outlook\.office365\.com/PowerShell" }; 
        #if(-not (gv EXOv2gmoprivatedataImplicitRemoting -ea 0 )){$EXOv2gmoprivatedataImplicitRemoting = $true } ;
        #if(-not (gv rgxExoPsessionstatemoduleDescription -ea 0 )){$rgxExoPsessionstatemoduleDescription = '/(exadmin|powershell)$' };
        #if(-not (gv EXOv2StateOK -ea 0 )){$EXOv2StateOK = 'Opened'} ; 
        #if(-not (gv EXOv2AvailabilityOK -ea 0 )){$EXOv2AvailabilityOK = 'Available'} ; 
        #if(-not (gv EXOv2RunStateBad -ea 0 )){ $EXOv2RunStateBad = 'Broken'} ;
        #if(-not (gv EXOv1GmoFilter -ea 0 )){$EXOv1GmoFilter = 'tmp_*' } ; 
        if(-not (gv EXOv2GmoNoWinRMFilter -ea 0 )){$EXOv2GmoNoWinRMFilter = 'tmpEXO_*' };
        # add get-connectioninformation.ConnectionURI targeting rgxs for Prvw vs EXO
        if(-not $rgxConnectionUriEXO){$rgxConnectionUriEXO = 'https://outlook\.office365\.com'} ; 
        if(-not $rgxConnectionUriPrvw){$rgxConnectionUriPrvw = 'https://ps\.compliance\.protection\.outlook\.com'} ; 
        $sTitleBarTag = @("EXO2") ;
        #*------^ END PSS & GMO VARIS ^------

        #*======v FUNCTIONS v======
        if(-not(get-command test-uri -ea 0)){
            #*------v Function Test-Uri v------
            function Test-Uri {
                [CmdletBinding()]
                [OutputType([bool])]
                Param(
                    # Uri to be validated
                    [Parameter(Mandatory=$true, ValueFromPipelineByPropertyName=$true, Position=0)]
                    [string]$UriString
                ) ; 
                [Uri]$uri = $UriString -as [Uri]
                $uri.AbsoluteUri -ne $null -and $uri.Scheme -eq 'https'
            } ; 
            #*------^ END Function Test-Uri ^------
        } ;
        #*======^ END FUNCTIONS ^======

        # 'Reconnect-EXO','Reconnect-Purview','Reconnect-SC'
        if($ConnectPurview -OR ($rMyInvocation.Line -match 'Connect-(Purview|SC)' )){
            if($rMyInvocation.Line -match 'Connect-(Purview|SC)' ){
                $smsg = "Connect-EXO() invoked using Connect-Purview Alias:" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            }
            if($ConnectPurview){
                $smsg = "Connect-EXO() invoked using -ConnectPurview" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            }
            $smsg = "Set:-ConnectPurview:`$true" ; 
            if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            $ConnectPurview = $true ; 
            if($null -eq $Prefix){
                $smsg = "-prefix:`$null detected, skipping default prefix assignement" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success    
            }elseif($Prefix -eq 'xo'){
                $smsg = "Set:-Prefix:`$($SCDefaultPrefix)" ; 
                if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                $Prefix = $SCDefaultPrefix
            }elseif(-not $Prefix){
                $smsg = "Set:-Prefix:`$($SCDefaultPrefix)" ; 
                if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            } ; 
        }
        if(-not $ConnectPurview -AND -not ($null -eq $Prefix)){
            # disable prefix spec, unless actually blanked (e.g. centrally spec'd in profile).
            if (-not $Prefix) {
                $Prefix = 'xo' ; # 4:31 PM 7/29/2020 MS has RESERVED use of the 'exo' prefix [facepalm]
                #$Prefix = 'sc' ; # Prvw variant
                $smsg = "(asserting default Prefix:$($Prefix)" ;
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } ;
            if (($Prefix) -and ($Prefix -eq 'EXO')) {
                throw "Prefix 'EXO' is a reserved Prefix, please use a different prefix."
            }
        } ; 
        <#
        if($Prefix -eq 'sc'){
            # build in hybrid xo & Prvw support, switch on the prefix spec
            $ConnectPurview = $true ; 
        }; 
        if($ConnectPurview){
            # respec userrole
            $UserRole = @('SID') ; 
            $sTitleBarTag = @("Prvw") ;
        } ; 
        #>

        if($ConnectPurview){
            # respec userrole
            $UserRole = @('SID') ; 
            $sTitleBarTag = @("Prvw") 
        } ; 

        <#
        $TenOrg = get-TenantTag -Credential $Credential ;
        if($Credential){
            $uRoleReturn = resolve-UserNameToUserRole -Credential $Credential
        } elseif($UserPrincipalName){
            $uRoleReturn = resolve-UserNameToUserRole -UserName $UserPrincipalName
        } ; 
        if($uRoleReturn.TenOrg){
            $CertTag = $uRoleReturn.TenOrg
        } ; 
        #>

        if(-not $isBased){
            # default to most basic rudimentary connection
            $connections = Get-ConnectionInformation -ErrorAction SilentlyContinue
            if($connections|?{$_.ConnectionUri -match $rgxConnectionUriEXO -AND $_.TokenStatus -ne 'Expired'  -AND $_.ModulePrefix -eq $Prefix}){
                $smsg = "EXO connected" ; 
                if($Prefix){
                    $smsg += " w Prefix:$($Prefix)" ; 
                }else{
                    $smsg += " w *no* Prefix" ; 
                } ; 
                $smsg += "/non-Expired Token" ;
                if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            }elseif($connections|?{$_.ConnectionUri -eq $rgxConnectionUriPrvw -AND $_.TokenStatus -ne 'Expired'  -AND $_.ModulePrefix -eq $Prefix}){
                $smsg = 'Purview S&C connected' ; 
                if($Prefix){
                    $smsg += " w Prefix:$($Prefix)" ; 
                }else{
                    $smsg += " w *no* Prefix" ; 
                } ; 
                $smsg += "/non-Expired Token" ;
                if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            #}elseIf (-not ($connections)) {
            } else {
                if($ConnectPurview){
                    write-host 'Purview S&C disconnected or Expired Token';
                    Import-Module $EOMmodname -ErrorAction stop ;
                    Connect-IPPSSession  -ErrorAction stop ;
                } else {
                    #Connect-ExchangeOnline -SkipLoadingCmdletHelp
                    #Connect-ExchangeOnline -SkipLoadingCmdletHelp -ShowBanner:$false ; 
                    write-host 'EXO disconnected or Expired Token';
                    Import-Module $EOMmodname -ErrorAction stop ;
                    Connect-ExchangeOnline -SkipLoadingCmdletHelp
                } ; 
            } ; 
        } else {

            # transplat fr rxo ---
            if(-not $Credential -AND -not $UserPrincipalName){
                if($UserRole){
                    $smsg = "Using specified -UserRole:$( $UserRole -join ',' )" ;
                    if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                } else { $UserRole = @('SID','CSVC') } ;
                if($TenOrg){
                    $smsg = "Using explicit -TenOrg:$($TenOrg)" ; 
                    if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                } else { 
                    switch -regex ($env:USERDOMAIN){
                        ([regex]('(' + (( @($TORMeta.legacyDomain,$CMWMeta.legacyDomain)  |foreach-object{[regex]::escape($_)}) -join '|') + ')')).tostring() {$TenOrg = $env:USERDOMAIN.substring(0,3).toupper() } ;
                        $TOLMeta.legacyDomain {$TenOrg = 'TOL' }
                        default {throw "UNRECOGNIZED `$env:USERDOMAIN!:$($env:USERDOMAIN)" ; exit ; } ;
                    } ;  
                    $smsg = "Imputed `$TenOrg from logged on USERDOMAIN:$($TenOrg)" ; 
                    if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                } ; 
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;             
            
                $sTitleBarTag += $TenOrg ;

                $o365Cred = $null ;
                $pltGTCred=@{TenOrg=$TenOrg ; UserRole= $UserRole; verbose=$($verbose)} ;
                $smsg = "get-TenantCredentials w`n$(($pltGTCred|out-string).trim())" ; 
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $o365Cred = get-TenantCredentials @pltGTCred ;

                if($o365Cred.credType -AND $o365Cred.Cred -AND $o365Cred.Cred.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                    $smsg = "(validated `$o365Cred contains .credType:$($o365Cred.credType) & `$o365Cred.Cred.username:$($o365Cred.Cred.username)" ; 
                    if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    $Credential = $o365Cred.Cred ;
                } else { 
                    $smsg = "UNABLE TO RESOLVE FUNCTIONAL CredType/UserRole from specified explicit -Credential:$($Credential.username)!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    break ; 
                } ; 
            }elseif($UserPrincipalName){
                # convert UPN to cred for get-tenanttag handling
                $UpnCredential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList ($UserPrincipalName,(convertto-securestring -string "passworddummy" -asplaintext -force)) ;
                $TenOrg = get-TenantTag -Credential $UpnCredential ;
            }elseif($Credential){
                $TenOrg = get-TenantTag -Credential $Credential ;
            }elseif(-not $Credential -AND -not $isBased){    
                $smsg = "Missing Profile config to drive connection automation, defaults" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            } else { 
                # test-exotoken only applies if $UseConnEXO  $false
                #$TenOrg = get-TenantTag -Credential $Credential ;
            } ;
            # build the cred etc once, for all below:

            $pltCXO=[ordered]@{
                #Credential = $Credential ;
                verbose = $($verbose) ; 
                erroraction = 'STOP' ;
            } ;
            if($Credential){
                $pltCXO.add('Credential',$Credential) ;
                $uRoleReturn = resolve-UserNameToUserRole -Credential $Credential ; 
            } elseif($UserPrincipalName){
                $pltCXO.add('UserPrincipalName',$UserPrincipalName) ;
                $uRoleReturn = resolve-UserNameToUserRole -Credential $UpnCredential ; 
            } else {
            
            } ; 
            if((gcm connect-EXO).Parameters.keys -contains 'silent'){
                $pltCXO.add('Silent',$silent) ;
            } ;

            if($credential.username -match $rgxCertThumbprint){
                $certTag = $uRoleReturn.TenOrg ; 
            } ; 
            # ---

            if($UserPrincipalName){
                $MFA = get-TenantMFARequirement -Credential $UpnCredential  ;
            }else{
                $MFA = get-TenantMFARequirement -Credential $Credential ;
            } ; 

            # 12:08 PM 8/2/2022 scrap the msal.net material: it's fundementally incompatible with EXO - sure you can pull and auth a token into the PS EXO clientid, but you can't spec a prefix on the returned cmdlets.
            # 4:45 PM 7/7/2022 workaround msal.ps bug: always ipmo it FIRST: "Get-msaltoken : The property 'Authority' cannot be found on this object. Verify that the property exists."

            # * 11:02 AM 4/4/2023 reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not
            #region EOMREV ; #*------v EOMREV Check v------
            # reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not
            $pltIMod = @{Name = $EOMmodname ; ErrorAction = 'Stop' ; verbose=$false} ;
            if($xmod = Get-Module $EOMmodname -ErrorAction Stop| sort version | select -last 1 ){ } else {
                $smsg = "Import-Module w`n$(($pltIMod|out-string).trim())" ;
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                Try {
                    Import-Module @pltIMod | out-null ;
                    $xmod = Get-Module $EOMmodname -ErrorAction Stop | sort version | select -last 1 ;
                } Catch {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $smsg = $ErrTrapd.Exception.Message ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Break ;
                } ;
            } ; # IsImported
            if([version]$xmod.version -ge $MinNoWinRMVersion){
                $MinNoWinRMVersion = $xmod.version.tostring() ;
                $IsNoWinRM = $true ; 
            }
            [boolean]$UseConnEXO = [boolean]([version]$xmod.version -ge $MinNoWinRMVersion) ; 
            #endregion EOMREV ; #*------^ END EOMREV Check  ^------

            if(-not $UseConnEXO){
                $smsg = "NON-connect-ExchangeOnline() version of ExchangeOnlineManagement installed, update to vers:$($MinNoWinRMVersion) or higher!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                throw $smsg ; 
                break ; 

                # dropping all support/legacy code for EOMv1 (PSSession native-only connections)
                # code below is used *solely* for EOM v205 connections (uses cached creds, integrates Connect-ExchangeOnline underlying commands)
                # EOM -lt 2.0.5preview6 .dll etc loads, from connect-exchangeonline: (should be installed with the above)
                # removed 12:23 PM 3/1/2024
        
            } else { 
                # $UseConnEXO => we're doing native connect-ExchangeOnline connectivity, no PSSession etc
                $smsg = "native connect-ExchangeOnline specified..." ; 
                if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 

        }  # if-E $isBased 

    } ; # BEG-E
    PROCESS {
        if($isBased){

            $bExistingEXOGood = $bExistingPrvwGood = $false ;
            $certUname = $null ; 

            # Keep track of error count at beginning.
            $errorCountAtStart = $global:Error.Count;
            $global:_EXO_TelemetryFilePath = $null;

            <# EXOv1: fully deprecated 12:24 PM 3/1/2024
            Get-PSSession | fl ConfigurationName,name,state,availability,computername
            -legacy remote-ps New-PSSession results in this PSS:
              ConfigurationName : Microsoft.Exchange
              Name              : WinRM2 (seems to increment)
              State             : Opened
              Availability      : Available
              ComputerName      : ps.outlook.com

            - legacy remote from jumpbox:
            ConfigurationName : Microsoft.Exchange
              Name              : Session6
              State             : Opened
              Availability      : Available
              ComputerName      : ps.outlook.com

            -while a connect-ExchangeOnline (non-MFA, haven't verified) connect results in this PSS:
              ConfigurationName : Microsoft.Exchange
              Name              : ExchangeOnlineInternalSession_4
              State             : Opened
              Availability      : Available
              ComputerName      : outlook.office365.com
        
            #EXOv2 MFA: 4/4/2022
            TokenProvider          : Microsoft.Exchange.Management.AdminApiProvider.Authentication.MSALTokenProvider
            ConnectionUri          : https://outlook.office365.com:443/PowerShell-LiveID?BasicAuthToOAuthConversion=true&HideBannerMessage=true&ConnectionId=c93cad7f-d8f5-4cce-8ac2-24de6c28518e&ClientProcessId=10808&ExoModuleVersion=2.0.5&OSVersion=
                                     Microsoft+Windows+NT+10.0.14393.0&email=s-email%40domain.com
            PSSessionOption        :
            TokenExpiryTime        : 3/29/2022 8:21:45 PM +00:00
            CurrentModuleName      : tmp_j2itmjec.1iw
            State                  : Opened
            IdleTimeout            : 900000
            OutputBufferingMode    : None
            DisconnectedOn         :
            ExpiresOn              :
            ComputerType           : RemoteMachine
            ComputerName           : outlook.office365.com
            ContainerId            :
            VMName                 :
            VMId                   :
            ConfigurationName      : Microsoft.Exchange
            InstanceId             : 7b793cd7-33de-451d-92a3-bdb3e154bd35
            Id                     : 1
            Name                   : ExchangeOnlineInternalSession_1
            Availability           : Available
            ApplicationPrivateData : {SupportedVersions, ImplicitRemoting, PSVersionTable}
            Runspace               : System.Management.Automation.RemoteRunspace

            -Prvw session via Connect-IPPSSession
            ConfigurationName : Microsoft.Exchange
            ComputerName      : nam02b.ps.compliance.protection.outlook.com
            Name              : ExchangeOnlineInternalSession_1
            State             : Opened
            Availability      : Available
            #>

            
            # clear any existing legacy EXO sessions:
            # legacy non-OAuth EXOv2 sessions (AKA EXOv1 basic-auth PSsession-based connections) distinguished on the Computername etc
            if ( $pssEXOv1 = Get-PSSession | 
                where-object {$_.ConfigurationName -like $EXOv1ConfigurationName -AND ($_.ComputerName -eq $EXOv1ComputerName) -AND (
                    $_.runspace.ConnectionInfo.AppName -eq $EXOv1runspaceConnectionInfoAppName) -AND (
                    $_.runspace.ConnectionInfo.Port -eq $EXOv1runspaceConnectionInfoPort) }  ) {
                # ignore state & Avail, close the conflicting legacy conn's
                if ($pssEXOv1.count -gt 0) {
                    $smsg = "(closing $($pssEXOv1.count) legacy EXOv1 sessions...)" ;
                    if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    for ($index = 0; $index -lt $pssEXOv1.count; $index++) {
                        $session = $pssEXOv1[$index] ;
                        Remove-PSSession -session $session ;
                        $smsg = "Removed the PSSession $($session.Name) connected to $($session.ComputerName)" ;
                        if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    } ;
                    $bExistingEXOGood = $false ;
                } ;
            } ;
            # use test-EXOConnectionTDO - cxo2 *only* drives compliant eXOv2 connections, not legacy basicAuth

            #$oRet = test-EXOConnectionTDO -Organization ((get-variable -name "$($TenOrg)Meta").Value.o365_TenantDomain) 
            #$oRet = test-EXOConnectionTDO -Organization ((get-variable -name "$($TenOrg)Meta").Value.o365_TenantDomain) 

            $pltTXO=[ordered]@{
                    erroraction = 'STOP' ;
            } ;
            if($Prefix){
                $pltTXO.add('Prefix',$Prefix) ; 
            } ; 
            if($ConnectPurview -AND ( (get-command test-EXOConnectionTDO).Parameters.Keys -contains 'ConnectPurview') ){
                $pltTXO.add('ConnectPurview',$ConnectPurview) ; 
            } ; 

            $smsg = "test-EXOConnectionTDO w`n$(($pltTXO|out-string).trim())" ; 
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

            $bExistingEXOGood = $bExistingPrvwGood = $false ;
            if($oRet = test-EXOConnectionTDO @pltTXO ){
                foreach($xSess in $oRet){
                    if($null -eq $xSess.Organization -AND $xSess.TenantID){
                        $Tenantdomain = convert-TenantIdToDomainName -TenantId $xSess.TenantID ;
                        $smsg = "(coercing blank Session Org, to resolved TenantID equivelent TenantDomain)" ; 
                        if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;  
                        $xSess.Organization = $Tenantdomain ; 

                    } ; 
                    if($xSess.isCBA){
                        $uRoleReturn = resolve-AppIDToCBAFriendlyName -AppID $xSess.AppId -verbose:$($VerbosePreference -eq "Continue")  ;
                        $certUname = $uRoleReturn.FriendlyName ;
                        $certTag = $uRoleReturn.TenOrg ;
                    } ;
                    if($xSess.isValid){
                        $smsg = "Connected to " ;
                        if($xSess.isXO){
                            $smsg += "XO EOM PS "

                            $bExistingEXOGood = $true ; 
                        }
                        elseif($xSess.isSC){
                            $smsg += "Sec & Compl PS " 
                            $bExistingPrvwGood = $true ;
                        }else{
                            $smsg += "DISCONNECTED!" ; 
                        } ; 
                        if($xSess.isCBA){
                            $smsg += "using CBA:" ;
                            $smsg += " $($certUname)" ;
                        } else{
                            $smsg += "using Account:" ;
                            $smsg += " $($xsess.UserPrincipalName)" ;
                            if($null -eq $xSess.Organization -AND $Tenantdomain){
                                $smsg += " ($($Tenantdomain.split('.')[0]))" ;
                            }elseif($xSess.Organization){
                                $smsg += " ($($xSess.Organization.split('.')[0]))" ;
                            } ; 
                        } ; 
                        if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success

                        
                    } else {
                        # 3:17 PM 10/29/2024 disconnect them if borked!
                        $pltDXOC=[ordered]@{
                            ConnectionId = $xSess.ConnectionId ; 
                            Confirm = $false ; 
                            erroraction = 'STOP' ;
                            whatif = $($whatif) ;
                        } ;
                        $smsg = "Clear broken Connection: Disconnect-ExchangeOnline w`n$(($pltDXOC|out-string).trim())" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        Disconnect-ExchangeOnline @pltDXOC ;

                        $smsg = "Connection Was not currently connected (TokenStatus:$($xSess.connection.TokenStatus))" ;
                        $smsg += "`nPreviously: "
                        if($xSess.isXO){
                            $smsg += "XO EOM PS " ; 
                            $bExistingEXOGood = $false ;
                        }
                        elseif($xSess.isSC){
                            $smsg += "Sec & Compl PS " 
                            $bExistingPrvwGood = $false ;
                        }else{
                            $smsg += "DISCONNECTED!" ;
                            $bExistingEXOGood = $bExistingPrvwGood = $false ;
                        } ;
                        if($xSess.isCBA){
                            $smsg += " using CBA:" ;
                            $smsg += " $($certUname)" ;
                        } else{
                            $smsg += "using Account:" ;
                            $smsg += " $($xsess.UserPrincipalName)" ;
                        } ;
                        if($null -eq $xSess.Organization -AND $Tenantdomain){
                            $smsg += " ($($Tenantdomain.split('.')[0]))" ;
                        }elseif($xSess.Organization){
                            $smsg += " ($($xSess.Organization.split('.')[0]))" ;
                        } else {
                            $smsg += " (neither Organization nor TenantID is populated)" ;
                        } ;
                        if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    } ;
                } ;   # loop-E
            } ; 
        
            #$bExistingPrvwGood
            #if ($bExistingEXOGood -eq $false) {
            # $UseConnEXO indicates it's a MinNoWinRMVersino, not necc xo-only conn; $ConnectPurview indicates it's a prefix cc/Prvw connection, solely
            if( ($ConnectPurview -AND ($bExistingPrvwGood -eq $false)) -OR (-not($ConnectPurview) -AND $bExistingEXOGood -eq $false) ){
                # open a new EXOv2 session
                if(-not $UseConnEXO){
                
                    # removed all legacy code: 12:25 PM 3/1/2024

                } else { 
                    # $UseConnEXO 
                    <#
                ==4:21 PM 6/30/2022: v2.0.6p6 examples
                -------------------------- Example 1 --------------------------
                    Connect-ExchangeOnline -UserPrincipalName chris@contoso.com
                    This example connects to Exchange Online PowerShell using modern authentication, with or without multi-factor authentication (MFA). We
                    aren't using the UseRPSSession parameter, so the connection uses REST and doesn't require Basic authentication to be enabled in WinROM
                    on the local computer. But, only the subset of frequently used REST API parameters are available.
                    -------------------------- Example 2 --------------------------
                    Connect-ExchangeOnline -UserPrincipalName chris@contoso.com -UseRPSSession
                    This example connects to Exchange Online PowerShell using modern authentication, with or without MFA. We're using the UseRPSSession
                    parameter, so the connection requires Basic authentication to be enabled in WinRM on the local computer. But, all Exchange Online
                    PowerShell cmdlets are available using traditional remote PowerShell access.
                    -------------------------- Example 3 --------------------------
                    Connect-ExchangeOnline -AppId <%App_id%> -CertificateFilePath "C:\users\navin\Documents\TestCert.pfx" -Organization
                    "contoso.onmicrosoft.com"
                    This example connects to Exchange Online PowerShell in an unattended scripting scenario using the public key of a certificate.
                    -------------------------- Example 4 --------------------------
                    Connect-ExchangeOnline -AppId <%App_id%> -CertificateThumbprint <%Thumbprint string of certificate%> -Organization
                    "contoso.onmicrosoft.com"
                    This example connects to Exchange Online PowerShell in an unattended scripting scenario using a certificate thumbprint.
                    -------------------------- Example 5 --------------------------
                    Connect-ExchangeOnline -AppId <%App_id%> -Certificate <%X509Certificate2 object%> -Organization "contoso.onmicrosoft.com"
                    This example connects to Exchange Online PowerShell in an unattended scripting scenario using a certificate file. This method is best
                    suited for scenarios where the certificate is stored in remote machines and fetched at runtime. For example, the certificate is stored
                    in the Azure Key Vault.
                    -------------------------- Example 6 --------------------------
                    Connect-ExchangeOnline -Device
                    In PowerShell 7.0.3 or later using the EXO V2 module version 2.0.4 or later, this example connects to Exchange Online PowerShell in
                    interactive scripting scenarios on computers that don't have web browsers.
                    The command returns a URL and unique code that's tied to the session. You need to open the URL in a browser on any computer, and then
                    enter the unique code. After you complete the login in the web browser, the session in the Powershell 7 window is authenticated via
                    the regular Azure AD authentication flow, and the Exchange Online cmdlets are imported after few seconds.
                    -------------------------- Example 7 --------------------------
                    Connect-ExchangeOnline -InlineCredential
                    In PowerShell 7.0.3 or later using the EXO V2 module version 2.0.4 or later, this example connects to Exchange Online PowerShell in
                    interactive scripting scenarios by passing credentials directly in the PowerShell window.
                #>
                    <# Prvw connect
                    ==2:04 PM 4/1/2024: v3.4.0 examples
                    -------------------------- Example 1 --------------------------
                    Connect-IPPSSession -UserPrincipalName michelle@contoso.onmicrosoft.com
                    This example connects to Security & Compliance PowerShell using the specified account and modern authentication, with or without MFA. In v3.2.0 or later of the module, we're connecting in REST API mode, so Basic authentication in WinRM isn't required on the
                    local computer.
                    -------------------------- Example 2 --------------------------
                    Connect-IPPSSession -UserPrincipalName michelle@contoso.onmicrosoft.com -UseRPSSession
                    This example connects to Security & Compliance PowerShell using the specified account and modern authentication, with or without MFA. In v3.2.0 or later of the module, we're connecting in remote PowerShell mode, so Basic authentication in WinRM is required
                    on the local computer.
                    -------------------------- Example 3 --------------------------
                    Connect-IPPSSession -AppId <%App_id%> -CertificateThumbprint <%Thumbprint string of certificate%> -Organization "contoso.onmicrosoft.com"
                    This example connects to Security & Compliance PowerShell in an unattended scripting scenario using a certificate thumbprint.
                    -------------------------- Example 4 --------------------------
                    Connect-IPPSSession -AppId <%App_id%> -Certificate <%X509Certificate2 object%> -Organization "contoso.onmicrosoft.com"
                    This example connects to Security & Compliance PowerShell in an unattended scripting scenario using a certificate file. This method is best suited for scenarios where the certificate is stored in remote machines and fetched at runtime. For example, the
                    certificate is stored in the Azure Key Vault.            
                    #>

                    $pltCEO=[ordered]@{                    
                        erroraction = 'STOP' ;
                        ShowBanner = $false ; # force the fugly banner hidden
                    } ;
                
                    # 9:43 AM 8/2/2022 add defaulted prefix spec
                    
                    if($Prefix){
                        if($ConnectPurview -OR $ConnectPurview){
                            $smsg = "(adding specified  Connect-IPPSSession -Prefix:$($Prefix))" ; 
                        } else { 
                            $smsg = "(adding specified Connect-ExchangeOnline -Prefix:$($Prefix))" ; 
                        } ; 
                        if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        $pltCEO.add('Prefix',$Prefix) ; 
                    } ; 

                    if ($MFA) {
                        if($credential.username -match $rgxCertThumbprint){
                            $smsg =  "(UserName:Certificate Thumbprint detected)"
                            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            # cert CBA non-basic auth
                            <# CertificateThumbPrint = $Credential.UserName ;
	                            AppID = $Credential.GetNetworkCredential().Password ;
	                            Organization = 'TENANTNAME.onmicrosoft.com' ; # org is on $xxxmeta.o365_TenantDomain
                            #>
                            $pltCEO.Add("CertificateThumbPrint", [string]$Credential.UserName);                    
                            $pltCEO.Add("AppID", [string]$Credential.GetNetworkCredential().Password);
                            if($TenDomain = (Get-Variable  -name "$($TenOrg)Meta").value.o365_TenantDomain){
                                $pltCEO.Add("Organization", [string]$TenDomain);
                            } else { 
                                $smsg = "UNABLE TO RESOLVE `$TENORG:$($TenOrg) TO FUNCTIONAL `$$($TenOrg)meta.o365_TenantDomain!" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                throw $smsg ; 
                                Break ; 
                            } ; 
                            
                            $certUname = $uRoleReturn.FriendlyName ; 
                            $certTag = $uRoleReturn.TenOrg ; 

                            <# 9:35 AM 6/25/2024 expired auth cert, need to proactively test and warn
                            # CertificateThumbPrint = $Credential.UserName ;
	                            AppID = $Credential.GetNetworkCredential().Password ;
	                            Organization = 'TENANTNAME.onmicrosoft.com' ; # org is on $xxxmeta.o365_TenantDomain
                            # warn at 2wks
                            # warn high pause at 7 days
                            #if((gci Cert:\CurrentUser\My\[string]$Credential.UserName).NotAfter -lt (get-date )){write-warning "Expired Cert!"} ;
                            "cert:$(((gci Cert:\CurrentUser\My\C5672B2D81CC828F78A93CE81CF436CC8C861F8F -ea STOP).pspath -split('::'))[1])"
                            #>
                            $prpCertgci = 'FriendlyName','Subject','Thumbprint','NotBefore','NotAfter',@{Name='Path';Expression={( "cert:$(($_.pspath -split('::'))[-1])" )}} ; 
                            $certWarnDays = 14 ; 
                            $certAlarmDays = 7 ; 
                            $oCert = gci "Cert:\CurrentUser\My\$([string]$Credential.UserName)" -ea STOP ; 
                            $certLifeDays = (new-timespan -start (get-date ) -end $oCert.NotAfter -ea STOP).days ; `
                            $hsRollCert = @"

## To roll over manually out of band:

gci "Cert:\CurrentUser\My\$([string]$Credential.UserName)" | Update-AADAppRegistrationKeyCertificate 

"@ ; 
                            if($certLifeDays -lt $certAlarmDays){
                                $smsg = "`n`n*** CERTIFICATE $($Credential.UserName) ($($certUname)) EXPIRES IN $($certLifeDays) DAYS! ***" ; 
                                $smsg += "`n$(($oCert | fl $prpCertgci |out-string).trim())`n`n" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                                $smsg = "DO YOU WANT TO ROLLOVER AND REPLACE THE CERTIFICATE & KEYCRED ON THE APP REGISTRATION? " ; 
                                if($certLifeDays -lt 0){
                                    $SMSG += "`nCERT IS ALREADY EXPIRED, THIS PROCESS WILL CRASH OUT UNTIL YOU REPLACE THE CERT!" 
                                } ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                $bRet=Read-Host "Enter YYY to continue. Anything else will exit"  ; 
                                if ($bRet.ToUpper() -eq "YYY") {
                                    $smsg = "(Moving on)" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                                    #code to rollover cert
                                    # updated name, verb-aad:Update-AADAppRegistrationKeyCertificate()
                                    #if($rolltool = (get-command -name Rollover-AADAppRegistrationCBAAuth.ps1 -ea STOP ).source){
                                    if(get-command Update-AADAppRegistrationKeyCertificate){
                                        #. $rolltool -certificate $ocert  ; 
                                        # another: & runs the script in it's own scope
                                        #& "C:\AzureFileShare\MEDsys\Powershell Scripts\B.ps1" -ServerName medsys-dev ; 
                                        #$smsg = "RUNNING:`n& $($rolltool) -certificate `$ocert ; " ; 
                                        #& $rolltool -certificate $ocert ; 
                                        # shift to func
                                        $smsg = "Running:`nUpdate-AADAppRegistrationKeyCertificate -certificate `$ocert " ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                        #Update-AADAppRegistrationKeyCertificate -certificate $ocert
                                        if($results = Update-AADAppRegistrationKeyCertificate -certificate $ocert){
                                            if($results.Certificate){ 
                                                $smsg = "Updated Certificate`n$(($results.Certificate| ft -a Subject,NotAfter,Thumbprint|out-string).trim())" ; 
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                            }else{
                                                $smsg = "NO SUMMARY CERTIFICATE RETURNED!" ; 
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                            } ; 
                                        }else{
                                            $smsg = "NO SUMMARY RETURNED!" ; 
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                                        } ; 
                                        
                                    } else {
                                        $smsg = "Unable to: get-command Update-AADAppRegistrationKeyCertificate!" ; 
                                        $smsg += "`nManually resolve location issue and run:" ; 
                                        $smsg += $hsRollCert ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                    } ;
                                } else {
                                    $smsg = "(Dropping through, continuing to attempt execution...)" ; 
                                    if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;  
                                } ;
                            }elseif($certLifeDays -lt $certWarnDays){
                                $smsg = "`n`n*** CERTIFICATE $($Credential.UserName) ($($certUname) EXPIRES IN $($certLifeDays) DAYS! ***" ; 
                                $smsg += "`n$(($oCert | fl $prpCertgci |out-string).trim())`n`n" ; 
                                $smsg += $hsRollCert ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            } else{
                                $smsg = "(Auth Certificate $($Credential.UserName) ($($certUname) remaining lifespan:$($certLifeDays) days)" ; 
                                if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            
                            }; 
                            if($certLifeDays -lt $certWarnDays){
                                
                                

                            } ; # $certLifeDays -lt $certWarnDays

                        } else { 
                            # interactive ModernAuth -UserPrincipalName
                            #$pltCXO.Add("UserPrincipalName", [string]$Credential.username);
                            if ($UserPrincipalName) {
                                $pltCEO.Add("UserPrincipalName", [string]$UserPrincipalName);
                                $smsg = "(using cred:$([string]$UserPrincipalName))" ; 
                                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            } elseif ($Credential -AND -not $UserPrincipalName){
                                $pltCEO.Add("UserPrincipalName", [string]$Credential.username);
                                $smsg = "(using cred:$($credential.username))" ; 
                                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            };
                        } 
                    } else {
                        # just use the passed $Credential vari
                        $pltCEO.Add("Credential", [System.Management.Automation.PSCredential]$Credential);
                        $smsg = "(using cred:$($credential.username))" ; 
                        if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    } ;

                    if($ConnectPurview -OR $ConnectPurview){
                        $smsg = "connect-IPPSSession w`n$(($pltCEO|out-string).trim())" ; 
                    } else { 
                        $smsg = "Connect-ExchangeOnline w`n$(($pltCEO|out-string).trim())" ; 
                    } ;                 
                    if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    TRY {
                        if($ConnectPurview){
                            connect-IPPSSession @pltCEO ;
                        } else {
                            Connect-ExchangeOnline @pltCEO ;
                        } ; 
                        #Add-PSTitleBar $sTitleBarTag ;
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #-=-record a STATUSWARN=-=-=-=-=-=-=
                        $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                        if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                        if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                        #-=-=-=-=-=-=-=-=
                        $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                    } ; 
                    # -------- $UseConnEXO 
                } ; 
            } ; #  # if-E $bExistingEXOGood

        } else { 
            $smsg = "(-not:`$isBased: running most basic Get-ConnectionInformation , Connect-ExchangeOnline connectivity)" ; 
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; # $isBased
    } ; # PROC-E
    END {
        
        <# 1:10 PM 3/1/2024 there are no more pss's in eom, rem it
        $smsg = "Existing PSSessions:`n$((get-pssession|out-string).trim())" ; 
        if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        #>
        if($isBased){

            $pltTXO=[ordered]@{erroraction = 'STOP' } ;
            if($Prefix){$pltTXO.add('Prefix',$Prefix) } ; 
            if($ConnectPurview -AND ((get-command test-EXOConnectionTDO).Parameters.Keys -contains 'ConnectPurview') ){
                $pltTXO.add('ConnectPurview',$ConnectPurview)
            } ; 
            $smsg = "test-EXOConnectionTDO w`n$(($pltTXO|out-string).trim())" ; 
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

            $bExistingEXOGood = $bExistingPrvwGood = $false ;
            if($oRet = test-EXOConnectionTDO @pltTXO ){
                foreach($xSess in $oRet){
                    if($null -eq $xSess.Organization -AND $xSess.TenantID){
                        $Tenantdomain = convert-TenantIdToDomainName -TenantId $xSess.TenantID ;
                        $smsg = "(coercing blank Session Org, to resolved TenantID equivelent TenantDomain)" ; 
                        if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        $xSess.Organization = $Tenantdomain ; 
                    } ; 
                    if($xSess.isCBA){
                        $uRoleReturn = resolve-AppIDToCBAFriendlyName -AppID $xSess.AppId -verbose:$($VerbosePreference -eq "Continue")  ;
                        $certUname = $uRoleReturn.FriendlyName ;
                        $certTag = $uRoleReturn.TenOrg ;
                    } ;
                    if($xSess.isValid){
                        $smsg = "Connected to " ;
                        if($xSess.isXO){$smsg += "XO EOM PS "}
                        elseif($xSess.isSC){$smsg += "Sec & Compl PS " }
                        else{
                            $smsg += "DISCONNECTED!" ; 
                        } ; 
                        if($xSess.isCBA){
                            $smsg += "using CBA:" ;
                            $smsg += " $($certUname)" ;
                        } else{
                            $smsg += "using Account:" ;
                            $smsg += " $($xsess.UserPrincipalName)" ;
                            if($null -eq $xSess.Organization -AND $Tenantdomain){
                                $smsg += " ($($Tenantdomain.split('.')[0]))" ;
                            }elseif($xSess.Organization){
                                $smsg += " ($($xSess.Organization.split('.')[0]))" ;
                            } ; 
                        } ; 
                        if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success

                        <# demo native get-connnectionInformation detail dump:
                        $prpConn = 'Organization','UserPrincipalName','ModulePrefix','CertificateAuthentication','AppId','TenantID','ConnectionId','IsEopSession','TokenStatus','State' ;
                        $hsDetailsConn = @"
Connection Details:
$(
    if(gcm ConvertTo-Markdowntable -ea 0){ ($xSess | select $prpConn[0..2] | ConvertTo-Markdowntable -Border -NoDashRow|out-string).trim()}
    else{($xSess | select $prpConn[0..2] | ft -a |out-string).trim()} ; 
)
$(
    if(gcm ConvertTo-Markdowntable -ea 0){ ($xSess | select $prpConn[3..5] | ConvertTo-Markdowntable -Border -NoDashRow|out-string).trim()}
    else{($xSess | select $prpConn[3..5] | ft -a |out-string).trim()} ; 
)
$(
    if(gcm ConvertTo-Markdowntable -ea 0){ ($xSess | select $prpConn[6..10] | ConvertTo-Markdowntable -Border -NoDashRow|out-string).trim()}
    else{($xSess | select $prpConn[7..10] | ft -a |out-string).trim()} ; 
)
"@ ;
                        write-verbose $hsDetails ;
                        #>
                        # output summary verbose details
                        $prpTxC = 'Organization','UserPrincipalName','Prefix','isCBA','AppId','TenantID','ConnectionId','isXO','isSC','isCBA','isValid','TokenLifeMins' ; 
                        $hsDetailsTxC = @"
Connection Details:
$(
    if(gcm ConvertTo-Markdowntable -ea 0){ ($xSess | select $prpTxC[0..2] | ConvertTo-Markdowntable -Border -NoDashRow|out-string).trim()}
    else{($xSess | select $prpTxC[0..3] | ft -a |out-string).trim()} ; 
)
$(
    if(gcm ConvertTo-Markdowntable -ea 0){ ($xSess | select $prpTxC[3..5] | ConvertTo-Markdowntable -Border -NoDashRow|out-string).trim()}
    else{($xSess | select $prpTxC[4..6] | ft -a |out-string).trim()} ; 
)
$(
    if(gcm ConvertTo-Markdowntable -ea 0){ ($xSess | select $prpTxC[6..10] | ConvertTo-Markdowntable -Border -NoDashRow|out-string).trim()}
    else{($xSess | select $prpTxC[7..10] | ft -a |out-string).trim()} ; 
)
"@ ;
                        $smsg = $hsDetailsTxC ; 
                        if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    } else {

                        # 3:17 PM 10/29/2024 disconnect them if borked!
                        $pltDXOC=[ordered]@{
                            ConnectionId = $xSess.ConnectionId ; 
                            Confirm = $false ; 
                            erroraction = 'STOP' ;
                            whatif = $($whatif) ;
                        } ;
                        $smsg = "Clear broken Connection: Disconnect-ExchangeOnline w`n$(($pltDXOC|out-string).trim())" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        Disconnect-ExchangeOnline @pltDXOC ;

                        $smsg = "Not currently connected (TokenStatus:$($xSess.connection.TokenStatus))" ;
                        $smsg += "`nPreviously: "
                        if($xSess.isXO){$smsg += "XO EOM PS "}
                        elseif($xSess.isSC){$smsg += "Sec & Compl PS " }
                        else{
                            $smsg += "DISCONNECTED!" ;
                        } ;
                        if($xSess.isCBA){
                            $smsg += " using CBA:" ;
                            $smsg += " $($certUname)" ;
                        } else{
                            $smsg += "using Account:" ;
                            $smsg += " $($xsess.UserPrincipalName)" ;
                        } ;
                        if($null -eq $xSess.Organization -AND $Tenantdomain){
                            $smsg += " ($($Tenantdomain.split('.')[0]))" ;
                        }elseif($xSess.Organization){
                            $smsg += " ($($xSess.Organization.split('.')[0]))" ;
                        } else {
                            $smsg += " (neither Organization nor TenantID is populated)" ;
                        } ;
                        if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        
                    } ; 


                } ;  # loop-E
            } else {
                $smsg = "No connection info returned" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            } ; 
            
        } else { 
            $smsg = "(-not:`$isBased: running most basic Get-ConnectionInformation , Connect-ExchangeOnline connectivity)" ; 
            #if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            #else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            
            $pltGCInfo=[ordered]@{
                Credential = $Credential ;
                verbose = $($verbose) ; 
                erroraction = 'STOP' ;
            } ;
            if($Prefix){
                $smsg = "(checking specified  -Prefix:$($Prefix))" ; 
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $pltGCInfo.add('ModulePrefix',$Prefix) ; 
            } ; 
            if($ConnectPurview){
                $smsg = "(checking against  -ConnectPurview:)" ; 
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                #$pltGCInfo.add('ModulePrefix',$Prefix) ; 
            } ; 
            
            
            $smsg = "get-ConnectionInformation w`n$(($pltGCInfo|out-string).trim())" ; 
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            if($cInfo = Get-ConnectionInformation @$pltGCInfo){
                if($ConnectPurview){
                    $cInfo = Get-ConnectionInformation @$pltGCInfo | ?{$_.ConnectionUri -match $rgxConnectionUriPrvw} ; 
                } ; 
                $smsg = "get-ConnectionInformation w`n$(($cInfo | fl |out-string).trim())" ; 
                if($silent){}elseif($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $smsg = "Get-ConnectionInformation: NO CONNECTION INFORMATION RETURNED! " ; 
                if($silent){}elseif($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;  
        } ; 

    }  # END-E
}

#*------^ Connect-EXO.ps1 ^------


#*------v connect-O365Services.ps1 v------
function connect-O365Services {
            <#
            .SYNOPSIS
            connect-O365Services - logic wrapper for my histortical scriptblock that resolves creds, svc avail and relevent status, to connect to range of Services (in o365)
            .NOTES
    
            REVISIONS
            * 4:12 PM 1/6/2026 revised for verb-MG compait
            *8:17 PM 6/1/2025 debugs functional for useexo & usesc now; 
    
            .PARAMETER EnvSummary
            Pre-resolved local environrment summary (product of output of verb-io\resolve-EnvironmentTDO())[-EnvSummary `$rvEnv]
            .PARAMETER NetSummary
            Pre-resolved local network summary (product of output of verb-network\resolve-NetworkLocalTDO())[-NetSummary `$netsettings]
            .PARAMETER useEXO
            Connect to O365 ExchangeOnlineManagement)[-useEXO]
            .PARAMETER useSC
            Connect to O365 Security & Compliance/Purview)[-useSC]
            .PARAMETER UseMSOL
            Connect to O365 MSOnline powershell module)[-UseMSOL]
            .PARAMETER UseAAD
            Connect to O365 AzureAD  powershell module)[-UseAAD]
            .PARAMETER UseMG
            Connect to O365 Microsoft.Graph powershell module(s))[-UseMG]
            .PARAMETER MGPermissionsScope
            Optional Array of MG delegated Permission Names(avoids manual discovery against configured cmdlets)[-MGPermissionsScope @('Domain.Read.All','Domain.ReadWrite.All','Directory.Read.All') ]
            .PARAMETER MGCmdlets
            Microsoft.Graph powershell module cmdlets used for this connection scope (avoids lengthy manual AST Parse of source script; used with verb-MG\get-MGCodeCmdletPermissionsTDO() to resolve connect-mgGraph delegated permissions connection -scope)[-MGCmdlets]
            .PARAMETER TenOrg
            Tenant Tag (3-letter abbrebiation)[-TenOrg 'XYZ']
            .PARAMETER Credential
            Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]
            .PARAMETER AdminAccount
            Use specific AdminAccount for service connections (defaults to Tenant-defined SvcAccount)[-AdminAccount LOGON@DOMAIN.COM]
            .PARAMETER UserRole
            Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]
            .PARAMETER useEXOv2
            Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
            .PARAMETER Silent
            Silent output (suppress status echos)[-silent]
            .PARAMETER MGPermissionsScope
            Optional Array of MG Permission Names(avoids manual discovery against configured cmdlets)[-MGPermissionsScope @('Domain.Read.All','Domain.ReadWrite.All','Directory.Read.All') ]
    
            #>
            ##Requires -Modules AzureAD, verb-AAD
            [CmdletBinding()]
            ## PSV3+ whatif support:[CmdletBinding(SupportsShouldProcess)]
            ###[Alias('Alias','Alias2')]
            PARAM(
                # environment parameters:
                [Parameter(Mandatory=$true,HelpMessage="Pre-resolved local environrment summary (product of output of verb-io\resolve-EnvironmentTDO())[-EnvSummary `$rvEnv]")]
                    $EnvSummary, # $rvEnv
                [Parameter(Mandatory=$true,HelpMessage="Pre-resolved local network summary (product of output of verb-network\resolve-NetworkLocalTDO())[-NetSummary `$netsettings]")]
                    $NetSummary, # $netsettings
                # service choices
                [Parameter(HelpMessage="Connect to O365 ExchangeOnlineManagement)[-useEXO]")]
                    [switch]$useEXO,
                [Parameter(HelpMessage="Connect to O365 Security & Compliance/Purview)[-useSC]")]
                    [switch]$useSC,
                [Parameter(HelpMessage="Connect to O365 MSOnline powershell module)[-UseMSOL]")]
                    [switch]$UseMSOL,
                [Parameter(HelpMessage="Connect to O365 AzureAD  powershell module)[-UseAAD]")]
                    [switch]$UseAAD,
                [Parameter(HelpMessage="Connect to O365 Microsoft.Graph powershell module(s))[-UseMG]")]
                    [switch]$UseMG,
                # Service Connection parameters
                [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
                    [ValidateNotNullOrEmpty()]
                    #[ValidatePattern("^\w{3}$")]
                    [string]$TenOrg = $global:o365_TenOrgDefault,
                [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
                    [System.Management.Automation.PSCredential]$Credential,
                [Parameter(Mandatory = $false, HelpMessage = "Use specific AdminAccount for service connections (defaults to Tenant-defined SvcAccount)[-AdminAccount LOGON@DOMAIN.COM]")]
                        [string]$AdminAccount,
                [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
                    # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ;
                    #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
                    # pulling the pattern from global vari w friendly err
                    [ValidateScript({
                        if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                        if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ;
                        return $true ;
                    })]
                    [string[]]$UserRole = @('SID','CSVC'),
                    # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
                [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
                    [switch] $useEXOv2=$true,
                [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
                    [switch] $silent,            
                [Parameter(HelpMessage="Optional Array of MG delegated Permission Names(avoids manual discovery against configured cmdlets)[-MGPermissionsScope @('Domain.Read.All','Domain.ReadWrite.All','Directory.Read.All') ]")]
                    [string[]]$MGPermissionsScope,
                [Parameter(HelpMessage="Microsoft.Graph powershell module cmdlets used for this connection scope (avoids lengthy manual AST Parse of source script; used with verb-MG\get-MGCodeCmdletPermissionsTDO() to resolve connect-mgGraph delegated permissions connection -scope)[-MGCmdlets]")]
                    [string[]]$MGCmdlets
            );
            BEGIN {
                # for scripts wo support, can use regions to fake BEGIN;PROCESS;END: (tho' can use the real deal in scripts as well as adv funcs, as long as all code is inside the blocks)
                # ps1 faked:#region BEGIN ; #*------v BEGIN v------
                # 8:59 PM 4/23/2025 with issues in CMW - funcs unrecog'd unless loaded before any code use - had to move the entire FUNCTIONS block to the top of BEGIN{}

                #region FUNCTIONS_INTERNAL ; #*======v FUNCTIONS_INTERNAL v======
                # Pull the CUser mod dir out of psmodpaths:
                #$CUModPath = $env:psmodulepath.split(';')|?{$_ -like '*\Users\*'} ;

                #region get_CodeProfileAST ; #*------v get-CodeProfileAST v------
                if(-not (get-childitem function:get-CodeProfileAST -ea 0)){
                      function get-CodeProfileAST {
                      <#
                      .SYNOPSIS
                      get-CodeProfileAST - Parse and return script/module/function compoonents, Module using Language.FunctionDefinitionAst parser
                      .NOTES
                  
                      REVISIONS
                      * 10:57 AM 5/19/2025 add: CBH for more extensive code profiling demo (for targeting action-verb cmds in code, from specific modules); fixed some missing CBH info.
                  
                      .PARAMETER  File
                      Path to script/module file
                      .PARAMETER scriptblock
                      Scriptblock of code[-scriptblock `$sbcode]
                      .PARAMETER Functions
                      Flag to return Functions-only [-Functions]
                      .PARAMETER Parameter
                      Flag to return Parameter-only [-Functions]
                      .PARAMETER Variables
                      Flag to return Variables-only [-Variables]
                      .PARAMETER Aliases
                      Flag to return Aliases-only [-Aliases]
                      .PARAMETER GenericCommands
                      Flag to return GenericCommands-only [-GenericCommands]
                      .PARAMETER All
                      Flag to return All [-All]
                      .PARAMETER ShowDebug
                      Parameter to display Debugging messages [-ShowDebug switch]
                      .PARAMETER Whatif
                      Parameter to run a Test no-change pass [-Whatif switch]
                  
                      #>
                      [CmdletBinding()]
                      [Alias('get-ScriptProfileAST')]
                      PARAM(
                          [Parameter(Position = 0, Mandatory = $false, ValueFromPipeline = $true, HelpMessage = "Path to script[-File path-to\script.ps1]")]
                              [ValidateScript( {Test-Path $_})][ValidatePattern( "\.(ps1|psm1|txt)$")]
                              [Alias('PSPath','File')]
                              [system.io.fileinfo]$Path,
                          [Parameter(Position = 1, Mandatory = $false, ValueFromPipeline = $true, HelpMessage = "Scriptblock of code[-scriptblock `$sbcode]")]
                              [Alias('code')]
                              $scriptblock,
                          [Parameter(HelpMessage = "Flag to return Functions-only [-Functions]")]
                              [switch] $Functions,
                          [Parameter(HelpMessage = "Flag to return Parameters-only [-Functions]")]
                              [switch] $Parameters,
                          [Parameter(HelpMessage = "Flag to return Variables-only [-Variables]")]
                              [switch] $Variables,
                          [Parameter(HelpMessage = "Flag to return Aliases-only [-Aliases]")]
                              [switch] $Aliases,
                          [Parameter(HelpMessage = "Flag to return GenericCommands-only [-GenericCommands]")]
                              [switch] $GenericCommands,
                          [Parameter(HelpMessage = "Flag to return All [-All]")]
                              [switch] $All,
                          [Parameter(HelpMessage = "Debugging Flag [-showDebug]")]
                              [switch] $showDebug,
                          [Parameter(HelpMessage = "Whatif Flag  [-whatIf]")]
                              [switch] $whatIf
                      ) ;
                      BEGIN {
                          TRY{
                              $Verbose = ($VerbosePreference -eq "Continue") ;
                              if(-NOT ($path -OR $scriptblock)){
                                  throw "neither -Path or -Scriptblock specified: Please specify one or the other when running" ; 
                                  break ; 
                              } elseif($path -AND $scriptblock){
                                  throw "BOTH -Path AND -Scriptblock specified: Please specify EITHER one or the other when running" ; 
                                  break ; 
                              } ;  
                              if ($Path -AND $Path.GetType().FullName -ne 'System.IO.FileInfo') {
                                  write-verbose "(convert path to gci)" ; 
                                  $Path = get-childitem -path $Path ; 
                              } ;
                              if ($scriptblock -AND $scriptblock.GetType().FullName -ne 'System.Management.Automation.ScriptBlock') {
                                  write-verbose "(recast -scriptblock to [scriptblock])" ; 
                                  $scriptblock= [scriptblock]::Create($scriptblock) ; 
                              } ;
                          } CATCH {
                              $ErrTrapd=$Error[0] ;
                              $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                              if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                              else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                          } ; 
                      } ;
                      PROCESS {
                          $sw = [Diagnostics.Stopwatch]::StartNew();
                          TRY{
                              write-verbose "$((get-date).ToString('HH:mm:ss')):(running AST parse...)" ; 
                              New-Variable astTokens -Force -whatif:$false -confirm:$false ; New-Variable astErr -Force -whatif:$false -confirm:$false ; 
                              if($Path){            
                                  $AST = [System.Management.Automation.Language.Parser]::ParseFile($Path, [ref]$astTokens, [ref]$astErr) ; 
                              }elseif($scriptblock){
                                  $AST = [System.Management.Automation.Language.Parser]::ParseInput($scriptblock, [ref]$astTokens, [ref]$astErr) ; 
                              } ;     
                              if($host.version.major -ge 3){$objReturn=[ordered]@{Dummy = $null ;} }
                              else {$objReturn = @{Dummy = $null ;} } ;
                              if ($Functions -OR $All) {
                                  write-verbose "$((get-date).ToString('HH:mm:ss')):(parsing Functions from AST...)" ; 
                                  $ASTFunctions = $AST.FindAll( { $args[0] -is [System.Management.Automation.Language.FunctionDefinitionAst] }, $true) ;
                                  $objReturn.add('Functions', $ASTFunctions) ;
                              } ;
                              if ($Parameters -OR $All) {
                                  write-verbose "$((get-date).ToString('HH:mm:ss')):(parsing Parameters from AST...)" ; 
                                  $ASTParameters = $ast.ParamBlock.Parameters.Name.variablepath.userpath ;
                                  $objReturn.add('Parameters', $ASTParameters) ;
                              } ;
                              if ($Variables -OR $All) {
                                  write-verbose "$((get-date).ToString('HH:mm:ss')):(parsing Variables from AST...)" ; 
                                  $AstVariableAssignments = $ast.FindAll( { $args[0] -is [System.Management.Automation.Language.VariableExpressionAst] }, $true) ;
                                  $objReturn.add('Variables', $AstVariableAssignments) ;
                              } ;
                              if ($($Aliases -OR $GenericCommands) -OR $All) {
                                  write-verbose "$((get-date).ToString('HH:mm:ss')):(parsing ASTGenericCommands from AST...)" ; 
                                  $ASTGenericCommands = $ast.FindAll( { $args[0] -is [System.Management.Automation.Language.CommandAst] }, $true) ;
                                  if ($Aliases -OR $All) {
                                      write-verbose "$((get-date).ToString('HH:mm:ss')):(post-filtering (set|new)-Alias from AST...)" ; 
                                      $ASTAliasAssigns = ($ASTGenericCommands | ? { $_.extent.text -match '(set|new)-alias' }) ;
                                      $objReturn.add('Aliases', $ASTAliasAssigns) ;
                                  } ;
                                  if ($GenericCommands -OR $All) {
                                      $objReturn.add('GenericCommands', $ASTGenericCommands) ;
                                  } ;
                              } ;
                              #$objReturn | Write-Output ;
                              New-Object PSObject -Property $objReturn | Write-Output ;
                          } CATCH {
                              $ErrTrapd=$Error[0] ;
                              $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                              if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                              else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                          } ; 
                      } ;
                      END {
                          $sw.Stop() ;
                          $smsg = ("Elapsed Time: {0:dd}d {0:hh}h {0:mm}m {0:ss}s {0:fff}ms" -f $sw.Elapsed) ; 
                          if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                          else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                      } ;
                  } ; 
                } ; 
                #endregion get_CodeProfileAST ; #*------^ END get-CodeProfileAST ^------

                #region get_MGCodeCmdletPermissionsTDO ; #*------v get-MGCodeCmdletPermissionsTDO v------
                if(-not (get-childitem function:get-MGCodeCmdletPermissionsTDO -ea 0)){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            function get-MGCodeCmdletPermissionsTDO {
                    <#
                    .SYNOPSIS
                    get-MGCodeCmdletPermissionsTDO - wrapper for verb-dev\get-codeprofileAST() that parses [verb]-MG[noun] cmdlets from a specified -file or -scriptblock, and reseolves the necessary connect-mgGraph -scope permissions, using the Find-MgGraphCommand  command.
                    .NOTES
                
                    REVISIONS
                    * 1:49 PM 5/14/2025 add: -cmdlets, bypasses AST parsing cuts right to find-mgGraphCommand expansion; additional verbose status echos (as it's returning very limited set of perms)
                
                    .PARAMETER  File
                    Path to script/module file to be parsed for matching cmdlets[-Path path-to\script.ps1]
                    .PARAMETER scriptblock
                    Scriptblock of code to be parsed for matching cmdlets[-scriptblock `$sbcode]
                    .PARAMETER CommandFilterRegex
                    Regular expression filter to match commands within GenericCommand lines parsed from subject code (defaults \w+-mg\w+)[-CommandFilterRegex '\w+-mgDomain\w+']
                    .PARAMETER ModuleFilterRegex 
                    Regular expression filter to match commands solely in matching Module (defaults 'Microsoft\.Graph')[-CommandFilterRegex 'Microsoft\.Graph\.Identity\.DirectoryManagement\s\s\s']
                    .PARAMETER Cmdlets
                    MGGraph cmdlet names to be Find-MgGraphCommand'd into delegated access -scope permissions (bypasses ASTParser discovery)
                
                    #>  
                    [CmdletBinding()]
                    ## PSV3+ whatif support:[CmdletBinding(SupportsShouldProcess)]
                    ###[Alias('Alias','Alias2')]
                    PARAM(
                        [Parameter(Position = 0,ValueFromPipeline = $true, HelpMessage = "Path to script/module file to be parsed for matching cmdlets[-Path path-to\script.ps1]")]
                            [ValidateScript( {Test-Path $_})][ValidatePattern( "\.(ps1|psm1|txt)$")]
                            [Alias('PSPath','File')]
                            [system.io.fileinfo]$Path,
                        [Parameter(Position = 1,HelpMessage = "Scriptblock of code to be parsed for matching cmdlets[-scriptblock `$sbcode]")]
                            [Alias('code')]
                            $scriptblock,
                        [Parameter(HelpMessage = "Regular expression filter to match commands within GenericCommand lines parsed from subject code (defaults \w+-mg\w+)[-CommandFilterRegex '\w+-mgDomain\w+']")]
                            [regex]$CommandFilterRegex = '\w+\-mg\w+',
                        [Parameter(HelpMessage = "Regular expression filter to match commands solely in matching Module (defaults 'Microsoft\.Graph')[-CommandFilterRegex 'Microsoft\.Graph\.Identity\.DirectoryManagement\s\s\s']")]
                            [regex]$ModuleFilterRegex = '^Microsoft\.Graph',
                        [Parameter(HelpMessage = "MGGraph cmdlet names to be Find-MgGraphCommand'd into delegated access -scope permissions (bypasses ASTParser discovery)[-Cmdlets @('get-MgDomain','get-MGContext')]")]
                            [string[]]$Cmdlets
                    );  
                    BEGIN {
                        $Verbose = ($VerbosePreference -eq "Continue") ;
                        # MG Cmdlets that don't have perms (don't bother FindMGCommanding them, wastes ~3mins for no return)
                        $MGNonPermCmdlets = 'Find-MgGraphCommand','Connect-MgGraph','Get-MgContext','Confirm-MgDomain','Get-MgDomainServiceConfigurationRecord' ; 
                        [regex]$rgxMGNonPermCmdlets = ('(' + (($MGNonPermCmdlets |%{[regex]::escape($_)}) -join '|') + ')') ;
                        if($Cmdlets){
                            $smsg = "-Cmdlets (skipping -path/-scriptblock AST parsing)" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        }else{
                            TRY{
                                if(-NOT ($path -OR $scriptblock)){
                                    throw "neither -Path or -Scriptblock specified: Please specify one or the other when running" ; 
                                    break ; 
                                } elseif($path -AND $scriptblock){
                                    throw "BOTH -Path AND -Scriptblock specified: Please specify EITHER one or the other when running" ; 
                                    break ; 
                                } ;  
                                if ($Path -AND $Path.GetType().FullName -ne 'System.IO.FileInfo'){
                                    $smsg = "(convert path to gci)" ; 
                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                    $Path = get-childitem -path $Path ; 
                                } ;
                                if ($scriptblock -AND $scriptblock.GetType().FullName -ne 'System.Management.Automation.ScriptBlock'){
                                    $smsg = "(recast -scriptblock to [scriptblock])" ; 
                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                    $scriptblock= [scriptblock]::Create($scriptblock) ; 
                                } ;
                            } CATCH {
                                $ErrTrapd=$Error[0] ;
                                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } ; 
                        } ; 
                    } ;
                    PROCESS {
                        $sw = [Diagnostics.Stopwatch]::StartNew();
                        if($Cmdlets){
                            $smsg = "-cmdlets specified:`n$(($Cmdlets|out-string).trim())" ;                     
                        }else{
                            if($host.version.major -ge 3){$pltgCPA=[ordered]@{Dummy = $null ;} }
                            else {$pltgCPA = @{Dummy = $null ;} } ;
                            if($pltgCPA.keys -contains 'dummy'){$pltgCPA.remove('Dummy') };
                            $pltgCPA.add('erroraction','STOP' ) ;
                            $pltgCPA.add('GenericCommands',$true )  ;
                            if($Path){ $pltgCPA.add('Path',$Path.fullname)}
                            if($ScriptBlock){ $pltgCPA.add('ScriptBlock',$ScriptBlock)}
                            $smsg = "get-CodeProfileAST  w`n$(($pltgCPA|out-string).trim())" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            $GCmds = (get-CodeProfileAST @pltgCPA).GenericCommands ; 
                            # shouldn't need .tostring() on a regex type, but w returns full list, wo returns just 1 item.
                            $GCmds.extent.text | ?{$_ -match $CommandFilterRegex.tostring()} | foreach-object {$cmdlets += $matches[0]} ; 
                            $smsg = "Normalize & unique names"; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            if($ModuleFilterRegex){
                                $cmdlets = $cmdlets | select -unique | foreach-object { 
                                    get-command -name $_| ?{$_.source -match $ModuleFilterRegex} 
                                } | select -expand name | select -unique ;         
                            }else {
                                $cmdlets = $cmdlets | foreach-object { 
                                    get-command -name $_| select -expand name 
                                } | select -unique ;
                            }
                            $smsg = "Parsed following matching cmdlets:`n$(($cmdlets|out-string).trim())" ;   
                        } ;               
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        if($Cmdlets | ?{$_ -match $rgxMGNonPermCmdlets}){
                            $smsg = "(Excluding non-Permission MGCmdlets from Permission discovery:" ; 
                            $smsg += "`n$(($Cmdlets | ?{$_ -match $rgxMGNonPermCmdlets}|out-string).trim())`n)" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            $Cmdlets = $Cmdlets | ?{$_ -notmatch $rgxMGNonPermCmdlets} ; 
                        } ; 
                        write-host -foregroundcolor yellow "Resolving $($cmdlets.count) cmdlets against Find-MgGraphCommand..." ; 
                        $PermsRqd = @() ;         
                        write-host -foregroundcolor yellow "[" -nonewline ; 
                        $cmdlets |foreach-object{
                            $thisCmdlet = $_ ; 
                            $smsg = "$($thisCmdlet)" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            write-host -NoNewline '.' ; 
                            #$PermsRqd += Find-MgGraphCommand -command $thisCmdlet -ea 0| Select -First 1 -ExpandProperty Permissions | Select -Unique name ; 
                            $thisPerm = $null ; 
                            #$thisPerm = Find-MgGraphCommand -command $thisCmdlet -ea 0| Select -First 1 -ExpandProperty Permissions | Select -Unique name ; 
                            $thisPerm = Find-MgGraphCommand -command $thisCmdlet -ea 0 |?{$_.permissions} | select -expand permissions | Select -Unique name ;   ; 
                            if($thisPerm){
                                $PermsRqd += $thisPerm ; 
                                $smsg = "(Find-MgGraphCommand -command $($thisCmdlet) returned Permissions:`n$(($thisPerm -join ','|out-string).trim()))" ; 
                            }else {
                                $smsg = "($($Cmdlet):no Permissions returned" ; 
                            } ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        } ; 
                        write-host -foregroundcolor yellow "]" ; 
                        $PermsRqd = $PermsRqd.name | select -unique ;
                    } ; # PROC-E  
                    END {
                        $sw.Stop() ;
                        $smsg = ("Elapsed Time: {0:dd}d {0:hh}h {0:mm}m {0:ss}s {0:fff}ms" -f $sw.Elapsed) ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        if($PermsRqd){
                            $PermsRqd | write-output ; 
                            $smsg = "(Resolved Perm Names:" ; 
                            #$smsg += "`n$((|out-string).trim())" ; 
                            $smsg += "`n'$(($PermsRqd) -join "','")'" ; 
                            $smsg += "`nCan be cached into a `$MGPermissionsScope etc, to skip this lengthy -scope discovery process)" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        } else { 
                            $false | write-output 
                        } ; 
                    } ; # END-E
                } ; 
                } ; 
                #endregion get_MGCodeCmdletPermissionsTDO ; #*------^ END get-MGCodeCmdletPermissionsTDO ^------
                #endregion FUNCTIONS_INTERNAL ; #*======^ END FUNCTIONS_INTERNAL ^======

                #region CONSTANTS_AND_ENVIRO ; #*======v CONSTANTS_AND_ENVIRO v======
        
                #region NETWORK_INFO ; #*======v NETWORK_INFO v======
                if($env:Userdomain){
                    switch($env:Userdomain){
                        'CMW'{
                            #$logon_SID = $CMW_logon_SID
                        }
                        'TORO'{
                            #$o365_SIDUpn = $o365_Toroco_SIDUpn ;
                            #$logon_SID = $TOR_logon_SID ;
                        }
                        $env:COMPUTERNAME{
                            $smsg = "%USERDOMAIN% -EQ %COMPUTERNAME%: $($env:computername) => non-domain-connected, likely edge role Ex server!" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            if($NetSummary.Workgroup){
                                $smsg = "WorkgroupName:$($NetSummary.Workgroup)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            } ;
                        } ;
                        default{
                            $smsg = "$($env:userdomain):UNRECOGIZED/UNCONFIGURED USER DOMAIN STRING!" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            THROW $SMSG
                            BREAK ;
                        }
                    } ;
                } ;  # $env:Userdomain-E
                #endregion NETWORK_INFO ; #*======^ END NETWORK_INFO ^======

                #region COMMON_CONSTANTS ; #*------v COMMON_CONSTANTS v------

                if(-not $DoRetries){$DoRetries = 4 } ;    # # times to repeat retry attempts
                if(-not $RetrySleep){$RetrySleep = 10 } ; # wait time between retries
                if(-not $RetrySleep){$DawdleWait = 30 } ; # wait time (secs) between dawdle checks
                if(-not $DirSyncInterval){$DirSyncInterval = 30 } ; # AADConnect dirsync interval
                if(-not $ThrottleMs){$ThrottleMs = 50 ;}
                if(-not $rgxDriveBanChars){$rgxDriveBanChars = '[;~/\\\.:]' ; } ; # ;~/\.:,
                if(-not $rgxCertThumbprint){$rgxCertThumbprint = '[0-9a-fA-F]{40}' } ; # if it's a 40char hex string -> cert thumbprint
                if(-not $rgxSmtpAddr){$rgxSmtpAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ; } ; # email addr/UPN
                if(-not $rgxDomainLogon){$rgxDomainLogon = '^[a-zA-Z][a-zA-Z0-9\-\.]{0,61}[a-zA-Z]\\\w[\w\.\- ]+$' } ; # DOMAIN\samaccountname
                if(-not $exoMbxGraceDays){$exoMbxGraceDays = 30} ;
                if(-not $XOConnectionUri ){$XOConnectionUri = 'https://outlook.office365.com'} ;
                if(-not $SCConnectionUri){$SCConnectionUri = 'https://ps.compliance.protection.outlook.com'} ;
                if(-not $XODefaultPrefix){$XODefaultPrefix = 'xo' };
                if(-not $SCDefaultPrefix){$SCDefaultPrefix = 'sc' }; 
                #$rgxADDistNameGAT = ",$(($TORMeta.UnreplicatedOU -split ',' | select -skip 1 ) -join ',')"
                #$rgxADDistNameAT = ",$(($TORMeta.UnreplicatedOU -split ',' | select -skip 2 ) -join ',')"

                write-verbose "Coerce configured but blank Resultsize to Unlimited" ;
                if(get-variable -name resultsize -ea 0){
                    if( ($null -eq $ResultSize) -OR ('' -eq $ResultSize) ){$ResultSize = 'unlimited' }
                    elseif($Resultsize -is [int]){} else {throw "Resultsize must be an integer or the string 'unlimited' (or blank)"} ;
                } ;
                #$ComputerName = $env:COMPUTERNAME ;
                #$NoProf = [bool]([Environment]::GetCommandLineArgs() -like '-noprofile'); # if($NoProf){# do this};
                # XXXMeta derived constants:
                # - AADU Licensing group checks
                # calc the rgxLicGrpName fr the existing $xxxmeta.rgxLicGrpDN: (get-variable tormeta).value.rgxLicGrpDN.split(',')[0].replace('^','').replace('CN=','')
                #$rgxLicGrpName = (get-variable -name "$($tenorg)meta").value.rgxLicGrpDN.split(',')[0].replace('^','').replace('CN=','')
                # use the dn vers LicGrouppDN = $null ; # | ?{$_ -match $tormeta.rgxLicGrpDN}
                #$rgxLicGrpDN = (get-variable -name "$($tenorg)meta").value.rgxLicGrpDN
                # email trigger vari, it will be semi-delimd list of mail-triggering events
                $script:PassStatus = $null ;
                # TenOrg or other looped-specific PassStatus (auto supported by 7pswlt)
                #New-Variable -Name PassStatus_$($tenorg) -scope Script -Value $null ;
                [array]$SmtpAttachment = $null ;
                #write-verbose "start-Timer:Master" ;
                $swM = [Diagnostics.Stopwatch]::StartNew() ;
                # $ByPassLocalExchangeServerTest = $true # rough in, code exists below for exempting service/regkey testing on this variable status. Not yet implemented beyond the exemption code, ported in from orig source.
                #endregion COMMON_CONSTANTS ; #*------^ END COMMON_CONSTANTS ^------

                #region LOCAL_CONSTANTS ; #*------v LOCAL_CONSTANTS v------
                # BELOW TRIGGERS/DRIVES TEST_MODS: array of: "[modname];[modDLUrl,or pscmdline install]"
                <#$tDepModules = @("Microsoft.Graph.Authentication;https://www.powershellgallery.com/packages/Microsoft.Graph/",
                "ExchangeOnlineManagement;https://www.powershellgallery.com/packages/ExchangeOnlineManagement/",
                "ActiveDirectory;get-windowscapability -name RSAT* -Online | ?{$_.name -match 'Rsat\.ActiveDirectory'} | %{Add-WindowsCapability -online -name $_.name}"
                #,"AzureAD;https://www.powershellgallery.com/packages/AzureAD"
                ) ;
                #>
                $tDepModules = @() ; 
                if($useEXO){$tDepModules += @("ExchangeOnlineManagement;https://www.powershellgallery.com/packages/ExchangeOnlineManagement/;Get-xoOrganizationConfig",'verb-exo;localRepo;connect-exo')} ;
                if($UseMSOL){$tDepModules += @("MSOnline;https://www.powershellgallery.com/packages/MSOnline/;Get-MsolDomain")} ;
                if($UseAAD){$tDepModules += @("AzureAD;https://www.powershellgallery.com/packages/AzureAD/;Get-AzureADTenantDetail")} ;
                if($UseExOP){$tDepModules += @('verb-Ex2010;localRepo;Connect-Ex2010')} ;
                if($UseMG){$tDepModules += @("Microsoft.Graph.Authentication;https://www.powershellgallery.com/packages/Microsoft.Graph/;Get-MgOrganization")} ;
                if($UseOPAD){$tDepModules += @("ActiveDirectory;get-windowscapability -name RSAT* -Online | ?{$_.name -match 'Rsat\.ActiveDirectory'} | %{Add-WindowsCapability -online -name $_.name};Get-ADDomain")} ;

                $prpMGConnDeleg = 'Account','ClientId','TenantId','AuthType','ContextScope' ; 
                $prpMGConnCBA = 'CertificateSubjectName','CertificateThumbprint','Certificate' ; 
                $prpMGConnRet = $($prpMGConnDeleg;$prpMGConnCBA) ; 

                #region ENCODED_CONTANTS ; #*------v ENCODED_CONTANTS v------
                # ENCODED CONsTANTS & SUPPORT FUNCTIONS:
                #region 2B4 ; #*------v 2B4 v------
                if(-not (get-command 2b4 -ea 0)){function 2b4{[CmdletBinding()][Alias('convertTo-Base64String')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ; PROCESS{$str|%{[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_))}  };} ; } ;
                #endregion 2B4 ; #*------^ END 2B4 ^------
                #region 2B4C ; #*------v 2B4C v------
                # comma-quoted return
                if(-not (get-command 2b4c -ea 0)){function 2b4c{ [CmdletBinding()][Alias('convertto-Base64StringCommaQuoted')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ;BEGIN{$outs = @()} PROCESS{[array]$outs += $str | %{[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_))} ; } END {'"' + $(($outs) -join '","') + '"' | out-string | set-clipboard } ; } ; } ;
                #endregion 2B4C ; #*------^ END 2B4C ^------
                #region FB4 ; #*------v FB4 v------
                # DEMO: $SitesNameList = 'THluZGFsZQ==','U3BlbGxicm9vaw==','QWRlbGFpZGU=' | fb4 ;
                if(-not (get-command fb4 -ea 0)){function fb4{[CmdletBinding()][Alias('convertFrom-Base64String')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ; PROCESS{$str | %{ [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($_)) }; } ; } ; };
                #endregion FB4 ; #*------^ END FB4 ^------
                # FOLLOWING CONSTANTS ARE USED FOR DEPENDANCY-LESS CONNECTIONS
                if(-not $CMW_logon_SID){$CMW_logon_SID = 'Q01XXGQtdG9kZC5rYWRyaWU=' | fb4 } ;
                if(-not $o365_Toroco_SIDUpn){$o365_Toroco_SIDUpn = 'cy10b2RkLmthZHJpZUB0b3JvLmNvbQ==' | fb4 } ;
                if(-not $TOR_logon_SID){$TOR_logon_SID = 'VE9ST1xrYWRyaXRzcw==' | fb4 } ;

                #endregion ENCODED_CONTANTS ; #*------^ END ENCODED_CONTANTS ^------

                #endregion CONSTANTS_AND_ENVIRO ; #*======^ CONSTANTS_AND_ENVIRO ^======

                #region SUBMAIN ; #*======v SUB MAIN v======

                #region TEST_MODS ; #*------v TEST_MODS v------
                if($tDepModules){
                    if( (test-ModulesAvailable -ModuleSpecifications $tDepModules) -contains $false ){
                        $smsg += "MISSING DEPENDANT MODULE!(see errors above)" ;
                        $smsg += "`n(may require provisioning internal function versions for this niche)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ; 
                } ;
                #endregion TEST_MODS ; #*------^ END TEST_MODS ^------

                if($host.version.major -ge 3){$ret_ccO365S=[ordered]@{Dummy = $null ;} }
                else {$ret_ccO365S = @{Dummy = $null ;} } ;
                if($ret_ccO365S.keys -contains 'dummy'){$ret_ccO365S.remove('Dummy') };
                $fieldsBoolean = 'hasEXO','hasSC','hasMSOL','hasAAD','hasMG' | select -unique  | sort ; $fieldsBoolean | % { $ret_ccO365S.add($_,$false) } ;
                $fieldsnull = 'CredentialO365','UserPrincipalNameO365','MGContext','MGtoken' | select -unique  | sort ; $fieldsnull | % { $ret_ccO365S.add($_,$null) } ;

                 # PRETUNE STEERING separately *before* pasting in balance of region
                # THIS BLOCK DEPS ON VERB-* FANCY CRED/AUTH HANDLING MODULES THAT *MUST* BE INSTALLED LOCALLY TO FUNCTION
                # NOTE: *DOES* INCLUDE *PARTIAL* DEP-LESS $useExopNoDep=$true OPT THAT LEVERAGES Connect-ExchangeServerTDO, VS connect-ex2010 & CREDS ARE ASSUMED INHERENT TO THE ACCOUNT)
                # Connect-ExchangeServerTDO HAS SUBSTANTIAL BENEFIT, OF WORKING SEAMLESSLY ON EDGE SERVER AND RANGE OF DOMAIN-=CONNECTED EXOP ROLES
                <#
                $useO365 = $true ;
                $useEXO = $true ;
                $useSC = $TRUE ; 
                $UseMSOL = $false ; # should be hard disabled now in o365
                $UseAAD = $false  ;
                $UseMG = $true ;
                #>
                #Optional Array of MG Permission Names(avoids manual discovery against configured cmdlets) @('Domain.Read.All','Domain.ReadWrite.All','Directory.Read.All') ]")]
                if($UseMG -AND -not (get-variable -name MGPermissionsScope -ea 0).value){
                    [string[]]$MGPermissionsScope = @() ;
                    # if $MGPermissionsScope is omitted, get-MGCodeCmdletPermissionsTDO will be run to discover -  via Find-MGGraphCommand - and resolve into working ACL Scopes for connect-mgGraph
                    # if $MgCmdlets is populated with a an Array of -MG*/Microsoft.Graph* cmdlets, AST Parser details will not be run by get-MGCodeCmdletPermissionsTDO, solely the leaf Find-MGGraphCommand
                    if(-not (get-variable -name MGCmdlets  -ea 0).value){[string[]]$MGCmdlets = @()} ;
                } ;
                if($env:userdomain -eq $env:computername){
                    $isNonDomainServer = $true ;
                    $UseOPAD = $false ;
                }
                if($IsEdgeTransport){
                    $UseExOP = $true ;
                    if($IsEdgeTransport -AND $psise){
                        $smsg = "powershell_ISE UNDER Exchange Edge Transport role!"
                        $smsg += "`nThis script is likely to fail the get-messagetrackingLog calls with Access Denied errors"
                        $smsg += "`nif run with this combo."
                        $smsg += "`nEXIT POWERSHELL ISE, AND RUN THIS DIRECTLY UNDER EMS FOR EDGE USE";
                        $smsg += "`n(bug appears to be a conflict in Remote EMS v EMS access permissions, not resolved yet)" ;
                        write-warning $msgs ;
                    } ;
                } ;
                $useO365 = [boolean]($useO365 -OR $useEXO -or $useSC -OR $UseMSOL -OR $UseAAD -OR $UseMG) ; 
                $UseOP = [boolean]($UseOP -OR $UseExOP -OR $UseOPAD) ;
                #*------^ END STEERING VARIS ^------
                #*------v EXO V2/3 steering constants v------
                $EOMModName =  'ExchangeOnlineManagement' ;
                $EOMMinNoWinRMVersion = $MinNoWinRMVersion = '3.0.0' ; # support both names
                #*------^ END EXO V2/3 steering constants ^------
                # assert Org from Credential specs (if not param'd)
                # 1:36 PM 7/7/2023 and revised again -  revised the -AND, for both, logic wasn't working
                if($TenOrg){
                    $smsg = "Confirmed populated `$TenOrg" ;
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                } elseif(-not($tenOrg) -and $Credential){
                    $smsg = "(unconfigured `$TenOrg: asserting from credential)" ;
                    if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    if((get-command get-TenantTag).Parameters.keys -contains 'silent'){
                        $TenOrg = get-TenantTag -Credential $Credential -silent ;;
                    }else {
                        $TenOrg = get-TenantTag -Credential $Credential ;
                    }
                } elseif(-not($tenOrg) -and $AdminAccount){
                        $smsg = "(unconfigured `$TenOrg: asserting from AdminAccount)" ;
                        if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        # convert UPN to cred for get-tenanttag handling
                        $tmpCredential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList ($AdminAccount,(convertto-securestring -string "passworddummy" -asplaintext -force)) ;
                        if((get-command get-TenantTag).Parameters.keys -contains 'silent'){
                            $TenOrg = get-TenantTag -Credential $tmpCredential -silent ;;
                        }else {
                            $TenOrg = get-TenantTag -Credential $tmpCredential ;
                        }
                } else {
                    # if not using Credentials or a TargetTenants/TenOrg loop, default the $TenOrg on the $env:USERDOMAIN
                    $smsg = "(unconfigured `$TenOrg & *NO* `$Credential: fallback asserting from `$env:USERDOMAIN)" ;
                    if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    switch -regex ($env:USERDOMAIN){
                        ([regex]('(' + (( @($TORMeta.legacyDomain,$CMWMeta.legacyDomain)  |foreach-object{[regex]::escape($_)}) -join '|') + ')')).tostring() {$TenOrg = $env:USERDOMAIN.substring(0,3).toupper() } ;
                        $TOLMeta.legacyDomain {$TenOrg = 'TOL' }
                        $env:COMPUTERNAME {
                            # non-domain-joined, no domain, but the $NetSummary.fqdn has a dns suffix that can be steered.
                            if($NetSummary.fqdn){
                                switch -regex (($NetSummary.fqdn.split('.') | select -last 2 ) -join '.'){
                                    'toro\.com$' {$tenorg = 'TOR' ; } ;
                                    '(charlesmachineworks\.com|cmw\.internal)$' { $TenOrg = 'CMW'} ;
                                    '(torolab\.com|snowthrower\.com)$'  { $TenOrg = 'TOL'} ;
                                    default {throw "UNRECOGNIZED DNS SUFFIX!:$(($NetSummary.fqdn.split('.') | select -last 2 ) -join '.')" ; break ; } ;
                                } ;
                            }else{
                                throw "NIC.ip $($NetSummary.ipaddress) does not PTR resolve to a DNS A with a full fqdn!" ;
                            } ;
                        } ;
                        default {throw "UNRECOGNIZED `$env:USERDOMAIN!:$($env:USERDOMAIN)" ; exit ; } ;
                    } ;
                } ;
                #region useO365 ; #*------v useO365 v------
                #$useO365 = $false ; # non-dyn setting, drives variant EXO reconnect & query code
                #if($CloudFirst){ $useO365 = $true } ; # expl: steering on a parameter
                if($useO365){
                    # creds are handled in cxo, don't need them for calls
                } else {
                    $smsg = "(`$useO365:$($useO365))" ;
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                } ; # if-E if($useO365 ){
                #endregion useO365 ; #*------^ END useO365 ^------

            } ; # BEG-E
            PROCESS {

                #region SERVICE_CONNECTIONS #*======v SERVICE_CONNECTIONS v======

                #region useEXO ; #*------v useEXO v------
                # 1:29 PM 9/15/2022 as of MFA & v205, have to load EXO *before* any EXOP, or gen get-steppablepipeline suffix conflict error
                if($useEXO){
                    $pltCXO = [ordered]@{
                        Prefix = $XODefaultPrefix ;
                        TenOrg = $TenOrg ; 
                        Silent = $($silent) ; 
                        #Verbose = ($PSBoundParameters['Verbose'] -eq $true); 
                    } ;
                    if($AdminAccount){
                        $pltCXO.add('UserPrincipalName',$AdminAccount) ; 
                    } ; 
                    if($Credential){
                        $pltCXO.add('Credential',$Credential) ; 
                    } ; 
                    if(-not ($AdminAccount -OR $Credential) -AND $UserRole){
                        $pltCXO.add('UserRole',$UserRole) ; 
                    } ; 
                    $smsg = "Connect-EXO w`n$(($pltCXO|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    connect-exo @pltCXO ; 
                } else {
                    $smsg = "(`$useEXO:$($useEXO))" ;
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                } ; # if-E
                #endregion useEXO ; #*------^ END useEXO ^------
                #region useSC ; #*------v useSC v------
                # 1:29 PM 9/15/2022 as of MFA & v205, have to load EXO *before* any EXOP, or gen get-steppablepipeline suffix conflict error
                if($useSC){
                    $pltCSC = [ordered]@{
                        Prefix = $SCDefaultPrefix ;
                        TenOrg = $TenOrg ; 
                        connectPurview = $true ; 
                        Silent = $($silent) ; 
                        #Verbose = ($PSBoundParameters['Verbose'] -eq $true); 
                    } ;
                    if($AdminAccount){
                        $pltCSC.add('UserPrincipalName',$AdminAccount) ; 
                    } ; 
                    if($Credential){
                        $pltCSC.add('Credential',$Credential) ; 
                    } ; 
                    if(-not ($AdminAccount -OR $Credential) -AND $UserRole){
                        $pltCSC.add('UserRole',$UserRole) ; 
                    } ; 
                    $smsg = "Connect-SC (Connect-IPPSSession Purview) w`n$(($pltCSC|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    connect-exo @pltCSC ; 
                } else {
                    $smsg = "(`$useSC:$($useSC))" ;
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                } ; # if-E
                #endregion useSC ; #*------^ END useSC ^------
                #region VALIDATE_XOSC ; #*------v VALIDATE_XOSC v------
                if($useEXO -OR $useSC){
                    $XOconnections = test-exoconnectiontdo ; 
                    foreach($xcon in $XOconnections){
                        if($xcon.connection -ANd $xcon.isXO -ANd $xcon.isValid -AND $xcon.TokenLifeMins -gt 0){$ret_rxo = $xcon; $ret_ccO365S.hasEXO = $true} # else {$ret_rxo = $null ; $ret_ccO365S.hasEXO = $false } ;
                        if($xcon.connection -ANd $xcon.isSC -ANd $xcon.isValid -AND $xcon.TokenLifeMins -gt 0){$ret_rSC = $xcon; $ret_ccO365S.hasSC = $true} # else {$ret_rSC = $null; $ret_ccO365S.hasSC = $false } ;
                    } ; 
                } ; 
                #endregion VALIDATE_XOSC ; #*------^ END VALIDATE_XOSC ^------
                #region MSOL_CONNECTION ; #*------v  MSOL CONNECTION v------
                #$UseMSOL = $false
                if($UseMSOL){
                    $smsg = "(loading MSOL...)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    connect-msol @pltRXOC ;
                    TRY{$MsolCo = Get-MsolCompanyInformation -ea stop ; $ret_ccO365S.hasMSOL = $true} CATCH {$ret_ccO365S.hasMSOL = $false } 
                } else {
                    $smsg = "(`$UseMSOL:$($UseMSOL))" ;
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                } ;
                #endregion MSOL_CONNECTION ; #*------^  MSOL CONNECTION ^------

                #region AZUREAD_CONNECTION ; #*------v AZUREAD CONNECTION v------
                #$UseAAD = $false
                if($UseAAD){
                    #$reqMods += "Connect-AAD".split(";") ;
                    #if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
                    $smsg = "(loading AAD...)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Connect-AAD @pltRXOC ;
                    TRY{$AADTenant = Get-AzureADTenantDetail -ea stop ; $ret_ccO365S.hasAAD = $true} CATCH {$ret_ccO365S.hasAAD = $false }  ; 
                } else {
                    $smsg = "(`$UseAAD:$($UseAAD))" ;
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                } ;
                #endregion AZUREAD_CONNECTION ; #*------^ AZUREAD CONNECTION ^------

                #region CONNECT_MG ; #*------v CONNECT_MG v------
                #$UseMG = $false;
                if($UseMG){
                    if(-not (get-command  test-mgconnection)){
                        TRY{
                            ipmo -fo -verb verb-mg -verbose 
                        } CATCH {$ErrTrapd=$Error[0] ;
                            write-host -foregroundcolor gray "TargetCatch:} CATCH [$($ErrTrapd.Exception.GetType().FullName)] {"  ;
                            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                            write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                            BREAK ; 
                        } ;
                    } ;
                    $MGCntxt = test-mgconnection -Verbose:($VerbosePreference -eq 'Continue') ;
                    if($MGCntxt.CertificateThumbprint -match $rgxCertThumbprint -AND $MgCntxt.AppName -AND $mgCntxt.isCBA){
                        $smsg = "CBA-auth'd existing conn: skipping RequirePermissions scope discovery" ; 
                        if($VerbosePreference -eq "Continue"){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    }elseif(-not $MGPermissionsScope){
                        if(gi function:get-MGCodeCmdletPermissionsTDO -ea 0){
                            $pltGMGP=[ordered]@{
                                #whatif = $($whatif) ;
                            } ;
                            if($MgCmdlets){
                                $pltGMGP.add('Cmdlets',$MgCmdlets)  ;
                            }else{
                                if($EnvSummary.isScript){
                                    if($EnvSummary.PSCommandPathproxy){ $prxPath = $EnvSummary.PSCommandPathproxy }
                                    elseif($script:PSCommandPath){$prxPath = $script:PSCommandPath}
                                    elseif($rPSCommandPath){$prxPath = $rPSCommandPath} ;
                                    $pltGMGP.add('Path',$prxPath)  ;
                                }elseif($EnvSummary.isFunc){
                                    $pltGMGP.add('scriptblock',(get-command -name $EnvSummary.FuncName).definition) ;
                                }else{
                                    $smsg = "MISSING or INDETERMINANT `$EnvSummary.isScript/`$EnvSummary.isFunc (should be output of verb-io\resolve-EnvironmentTDO())" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    throw $smsg ;
                                    BREAK ;
                                } ;
                            } ;
                            $smsg = "get-MGCodeCmdletPermissionsTDO w`n$(($pltGMGP|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            $RequiredScopes = $PermsRqd = get-MGCodeCmdletPermissionsTDO @pltGMGP ;
                            $smsg = "`nResolved MGPermissionsScope:`n$(($PermsRqd |out-string).trim())" ;
                            $smsg +="`n(can be hardcoded into script's `$MGPermissionsScope to save query time on future passes)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } else {
                            if(-not $MGCmdlets){
                                $smsg = "-useMG:$($useMG): Performing *manual* MGCodeCmdletPermissions expansion: (missing function)" ;
                                $smsg += "`ncannot procede with CURRENTLY EMPTY `$MGCmdlets!"
                                $smsg = "`n(should contain all [verb]-mg[noun] cmdlets to be used this session)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                throw $smsg ;
                                BREAK ;
                            } ;
                            $ttl = $MGCmdlets  |  measure | select -expand count ;
                            write-host -foregroundcolor yellow "$($ttl) Cmdlets:Collecting Permissions[" -NoNewline ;
                            $PermsRqd = @() ;
                            $MGCmdlets  |foreach-object{
                                write-host -NoNewline '.' ;
                                if($ACL = Find-MgGraphCommand -command $_ -ea 0){
                                    $PermsRqd += $ACL | Select -First 1 -ExpandProperty Permissions | Select -Unique name ;
                                } ;
                            } ;
                            write-host -foregroundcolor yellow "]" ;
                            $PermsRqd = $PermsRqd.name | select -unique ;
                            $RequiredScopes = $PermsRqd ; 
                            $smsg = "`nResolved MGPermissionsScope:`n$(($PermsRqd |out-string).trim())" ;
                            $smsg +="`n(can be hardcoded into script's `$MGPermissionsScope to save query time on future passes)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ;
                    }else{
                        $smsg = "Using explicit -MGPermissionsScope specified: $(($MGPermissionsScope | select -first 3) -join ',')..."
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        $PermsRqd = $MGPermissionsScope ;
                    }

                    #region cMG_SCAFFOLD ; #*------v cMG_SCAFFOLD v------
                    if(-not (get-command  test-mgconnection)){
                        TRY{
                            ipmo -fo -verb verb-mg -verbose 
                        } CATCH {$ErrTrapd=$Error[0] ;
                            write-host -foregroundcolor gray "TargetCatch:} CATCH [$($ErrTrapd.Exception.GetType().FullName)] {"  ;
                            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                            write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                            BREAK ; 
                        } ;
                    } ;
                    $MGCntxt = test-mgconnection -Verbose:($VerbosePreference -eq 'Continue') ;
                    $o365Cred = $null ;
                    if($Credential -AND $MGCntxt.isConnected){
                        $smsg = "Explicit -Credential:$($Credential.username) -AND `$MGCntxt.isConnected: running pre:Disconnect-MgGraph" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        # Dmg returns a get-mgcontext into pipe, if you don't cap it corrupts the pipe on your current flow
                        $dOut = Disconnect-MgGraph -Verbose:($VerbosePreference -eq 'Continue')
                        $MGCntxt = test-mgconnection -Verbose:($VerbosePreference -eq 'Continue') ;
                    };
                    if($Credential){
                        $smsg = "`Credential:Explicit credentials specified, deferring to use..." ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        write-verbose "get-TenantCredentials() return format: (emulating)" ; 
                        $o365Cred = [ordered]@{
                            Cred=$Credential ;
                            credType=$null ;
                        } ;
                        $uRoleReturn = resolve-UserNameToUserRole -UserName $Credential.username -verbose:$($VerbosePreference -eq "Continue") ; # Username
                        write-verbose "w full cred opt: $uRoleReturn = resolve-UserNameToUserRole -Credential $Credential -verbose = $($VerbosePreference -eq 'Continue')"  ; 
                        if($uRoleReturn.UserRole){
                            $o365Cred.credType = $uRoleReturn.UserRole ;
                        } else {
                            $smsg = "Unable to resolve `$credential.username ($($credential.username))"
                            $smsg += "`nto a usable 'UserRole' spec!" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            throw $smsg ;
                            Break ;
                        } ;
                    } else {
                        if($MGCntxt.isConnected){
                            if($MgCntxt.isUser){
                                $TenantTag = $TenOrg = get-TenantTag -Credential $MgCntxt.Account ;
                                $uRoleReturn = resolve-UserNameToUserRole -UserName $MgCntxt.CertificateThumbprint -verbose:$($VerbosePreference -eq "Continue") ;
                                $credential = get-TenantCredentials -TenOrg $TenOrg -UserRole $uRoleReturn.UserRole -verbose:$($VerbosePreference -eq "Continue") ;
                            } elseif($MgCntxt.isCBA -AND $MgCntxt.AppName -match 'CBACert-(\w{3})'){
                                    #$MgCntxt.AppName.split('-')[-1]
                                    $TenantTag = $TenOrg = $matches[1]
                                    # also need credential
                                    $uRoleReturn = resolve-UserNameToUserRole -UserName $MgCntxt.CertificateThumbprint -verbose:$($VerbosePreference -eq "Continue") ;
                                    write-verbose "ret'd obj:$uRoleReturn = [ordered]@{     UserRole = $null ;     Service = $null ;     TenOrg = $null ; } " ;  
                                    $credRet = get-TenantCredentials -TenOrg $TenOrg -UserRole $uRoleReturn.UserRole -verbose:$($VerbosePreference -eq "Continue")
                                    $credential = $credRet.Cred ;
                            }else{
                                $smsg = "UNABLE TO RESOLVE mgContext to a working TenOrg!" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            }
                        } ; 
                        $pltGTCred=@{TenOrg=$TenOrg ; UserRole=$null; verbose=$($verbose)} ;
                        if($UserRole){
                            $smsg = "(`$UserRole specified:$($UserRole -join ','))" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $pltGTCred.UserRole = $UserRole;
                        } else {
                            $smsg = "(No `$UserRole found, defaulting to:'CSVC','SID' " ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $pltGTCred.UserRole = 'CSVC','SID' ;
                        } ;
                        $smsg = "get-TenantCredentials w`n$(($pltGTCred|out-string).trim())" ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        $o365Cred = get-TenantCredentials @pltGTCred
                    } ;
                    if($o365Cred.credType -AND $o365Cred.Cred -AND $o365Cred.Cred.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                        $smsg = "(validated `$o365Cred contains .credType:$($o365Cred.credType) & `$o365Cred.Cred.username:$($o365Cred.Cred.username)" ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        write-verbose "populate $credential with return, if not populated (may be required for follow-on calls that pass common $Credentials through)" ; 
                        if((gv Credential) -AND $Credential -eq $null){
                            $credential = $o365Cred.Cred ;
                        }elseif($credential.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                            $smsg = "(`$Credential is properly populated; explicit -Credential was in initial call)" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        } else {
                            $smsg = "`$Credential is `$NULL, AND $o365Cred.Cred is unusable to populate!" ;
                            $smsg = "downstream commands will *not* properly pass through usable credentials!" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            throw $smsg ;
                            break ;
                        } ;
                    } else {
                        $smsg = "UNABLE TO RESOLVE FUNCTIONAL CredType/UserRole from specified explicit -Credential:$($Credential.username)!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        break ;
                    } ;         
                    $pltCMG = [ordered]@{
                        Credential = $Credential ;
                        verbose = $($VerbosePreference -eq "Continue")  ;
                        #ErrorVariable = 'err_ccMG' # connect-mg doesn't support -errvari!
                    } ;
                    <#if((get-command Connect-MG).Parameters.keys -contains 'silent'){
                        $pltCMG.add('Silent',$silent) ;
                    } ;
                    #>
                    #endregion cMG_SCAFFOLD ; #*------^ END cMG_SCAFFOLD ^------
                    #------
                    connect-MG @pltCMG 
                    # need to update the hasMG flag: TRY{$AADTenant = Get-AzureADTenantDetail -ea stop ; $ret_ccO365S.hasAAD = $true} CATCH {$ret_ccO365S.hasAAD = $false }  ; 
                    TRY{
                        $MGCntxt = test-mgconnection -Verbose:($VerbosePreference -eq 'Continue') -ea Stop ;
                        if($MGCntxt.isConnected){$ret_ccO365S.hasMG = $true}ELSE{$ret_ccO365S.hasMG = $FALSE}                        
                    } CATCH {
                        $ret_ccO365S.hasMG = $false 
                    }  
                    <#
                    if($err_ccMG -ne $null){
                        $smsg = $err_ccMG  ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        throw $smsg ;
                        BREAK ;
                    } ;
                    #>
                    <# CBA connect-mgGraph use: [Connect to Microsoft Graph PowerShell using Certificate - AdminDroid Blog](https://blog.admindroid.com/connect-to-microsoft-graph-powershell-using-certificate/)
                    # has full demo of suite of -MG cmdlets to provision & perm Apps w CBA, local copy:C:\usr\work\o365\scripts\ConnectMSGraphCertificate_admindroid-com.ps1
                    # -scope is perm hard-coded non-dyn w/in app, must have full suite of all acls it will ever need
                    $pltCCMG=[ordered]@{TenantId = $TenantID ;ClientId = $ClientID ;CertificateThumbprint = $CertificateThumbprint ;ErrorAction = 'SilentlyContinue' ;ErrorVariable = 'ApplicationConnectionError' ; } ;
                    write-host "Connect-mgGraph w`n$(($pltGMGP|out-string).trim())" ;
                    Connect-MgGraph @pltCCMG ;
                    if($ApplicationConnectionError -ne $null){
                        Write-Host $ApplicationConnectionError -ForegroundColor Red ;
                        Exit ;
                    } ; Get-MgContext ;
                    #>
                   <# 1:58 PM 1/6/2026 throws up crashes out conn attempt 
                    # resolve & store the MG goken:
                    $pltIGR = @{
                        Method = "GET" ; 
                        URI = "/v1.0/me" ; 
                        OutputType = "HttpResponseMessage" ; 
                    } ; 
                    $Response = Invoke-GraphRequest @pltIGR ; 
                    $Headers = $Response.RequestMessage.Headers ; 
                    if($TokenString = $Headers.Authorization.Parameter){
                        #$ret_ccO365S.MGtoken = $Headers.Authorization.Parameter ; 
                        $ret_ccO365S.MGtoken = ConvertTo-SecureString -String $TokenString -AsPlainText -Force ; 
                    }else {
                        $smsg = "Unable To Invoke-GraphRequest back a Token object!" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        throw $smsg ; 
                        break ; 
                    } ; 
                    #>
                } ;  # if-E $useMG
                #endregion CONNECT_MG ; #*------^ END CONNECT_MG ^------
                <# defined above
                # EXO connection
                $pltRXO = @{
                    Credential = (Get-Variable -name cred$($tenorg) ).value ;
                    verbose = $($verbose) ; } ;
                #>
                <#
                if($VerbosePreference = "Continue"){
                    $VerbosePrefPrior = $VerbosePreference ;
                    $VerbosePreference = "SilentlyContinue" ;
                    $verbose = ($VerbosePreference -eq "Continue") ;
                } ;
                disconnect-exo ;
                if ($script:useEXOv2) { Connect-EXO2 @pltRXOC }
                else { Connect-EXO @pltRXOC } ;
                # reenable VerbosePreference:Continue, if set, during mod loads
                if($VerbosePrefPrior -eq "Continue"){
                    $VerbosePreference = $VerbosePrefPrior ;
                    $verbose = ($VerbosePreference -eq "Continue") ;
                } ;
                #>
                #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                #endregion SERVICE_CONNECTIONS #*======^ END SERVICE_CONNECTIONS ^======
            } ; # PROC-E
            END {
                $swM.Stop() ;
                $smsg = ("Elapsed Time: {0:dd}d {0:hh}h {0:mm}m {0:ss}s {0:fff}ms" -f $swM.Elapsed) ;
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                <# return status obj
                $ret_ccO365S = [ordered]@{
                    CredentialO365 = $null ; 
                    hasEXO = $false ;
                    hasMSOL = $false ;
                    hasAAD = $false ;
                    hasMG = $false ;
                    MGContext = $null ; # $ctxMG
                    MGtoken = $null ; 
                } ; 
                #>
                $smsg = "Returning connection summary to pipeline:`n$(($ret_ccO365S|out-string).trim())" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                [pscustomobject]$ret_ccO365S | write-output ;
            } ; # END-E
        }

#*------^ connect-O365Services.ps1 ^------


#*------v convert-ADUserRecipientTypeRemoteSharedMailbox.ps1 v------
function convert-ADUserRecipientTypeRemoteSharedMailbox{
    <#
    .SYNOPSIS
    Convert the passed-in ADUser object RecipientType to RemoteSharedMailbox (sets ADUser.msExchRecipientTypeDetails:'34359738368' ADUUser.msExchRemoteRecipientType:'100').
    1st half of RemoteUserMailbox conversion to ReomteSharedMailbox (followed by convert-exoMailboxTypeSharedMailbox to convert the EXO mailbox type).
    Traditionally this would be applied to RemoteUserMailbox, but no pre-checking is performed, the update is applied as long as the target settings aren't already in place.
    .NOTES
    Author: Todd Kadrie
    Website:	http://www.toddomation.com
    Twitter:	@tostka, http://twitter.com/tostka
    REVISIONS   :
    * 5:22 PM 1/25/2025 dc access issues to BCC, had to add retry code & get-gcfast -exclude to autorecover on ad calls
    * 10:12 AM 5/18/2023 add: adv func beg/proc blocks: full pipeline support ; ren'd mid proc block vari added explicit loop
    * 8:46 AM 5/17/2023 add to vXO; ren'd to convert-ADUserRecipientTypeRemoteSharedMailbox (rmvd _ internal prefix), and aliased orig name(convert-ADUserRecipientType), strongly typed $ADUser as [Microsoft.ActiveDirectory.Management.ADUser]
    * 1:06 PM 8/25/2021 ren convertADUser -> convert-ADUserRecipientType
    # 2:51 PM 12/18/2018 set-adus has functional whatif, moved it into test fire
    # 12:31 PM 10/23/2018 ran full pass live, no unusual errors
    .DESCRIPTION
    Convert the passed-in ADUser object RecipientType to RemoteSharedMailbox (sets ADUser.msExchRecipientTypeDetails:'34359738368' ADUUser.msExchRemoteRecipientType:'100').
    1st half of RemoteUserMailbox conversion to ReomteSharedMailbox (followed by convert-exoMailboxTypeSharedMailbox to convert the EXO mailbox type).
    Traditionally this would be applied to RemoteUserMailbox, but no pre-checking is performed, the update is applied as long as the target settings aren't already in place.

    (does not require passed in Credentials, as all changes are with ActiveDirectory module, which does not support affirmative logon; logon is pickedup from the psdrive AD mapping) 

    .PARAMETER  ADUser
    ADUser object [-ADUser `$ADVariable]
    .PARAMETER domaincontroller
    Option to hardcode a specific DC [-domaincontroller xxxx]
    .PARAMETER Whatif
    Parameter to run a Test no-change pass, and log results [-Whatif switch]
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Returns RemoteMailbox object, or $false on failure.
    .EXAMPLE
    $adu=get-aduser -id $rmbx.DistinguishedName -server $domainController -Properties $adprops -ea 0| select $adprops ;
    $bRet=convert-ADUserRecipientType -ADUser $adu -whatif:$($whatif) -showDebug:$($showdebug) ;
    Convert the passed-in ADUser object RecipientType from RemoteUserMailbox to RemoteSharedMailbox.
    (does not require passed in Credentials, as all changes are with ActiveDirectory module, which does not support affirmative logon; logon is pickedup from the psdrive AD mapping automounted on ActieDirectory module load) 
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    [CmdletBinding()]
    [Alias('convert-ADUserRecipientType')]
    PARAM(
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,HelpMessage="ADUser object [-ADUser `$ADVariable]")]
            [ValidateNotNullOrEmpty()]
            [Microsoft.ActiveDirectory.Management.ADUser]$ADUser,
        [Parameter(HelpMessage="Option to hardcode a specific DC [-domaincontroller xxxx]")]
            [string]$domaincontroller,
        [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
            [switch] $showDebug,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
            [switch] $whatIf
    ) # PARAM BLOCK END
    BEGIN {
        if(-not $DoRetries){$DoRetries = 4 } ;    # # times to repeat retry attempts
        if(-not $RetrySleep){$RetrySleep = 10 } ; # wait time between retries
        if(-not $RetrySleep){$DawdleWait = 30 } ; # wait time (secs) between dawdle checks
        if(-not $DirSyncInterval){$DirSyncInterval = 30 } ; # AADConnect dirsync interval

    } ;  # BEGIN-E
    PROCESS {
            foreach($ADU in $ADUser) {
            $error.clear() ;
            $Exit = 0 ;
            Do {
                Try {
                    if(!$domaincontroller){$domaincontroller=get-gcfast} ;
                    $adprops="samaccountname","msExchRemoteRecipientType","msExchRecipientDisplayType","msExchRecipientTypeDetails","UserPrincipalName","DistinguishedName" ;
                    $exprops="SamAccountName","RecipientType","RecipientTypeDetails","UserPrincipalName" ;
                    if($ADU){
                        $smsg= "PRE:ADUser`n$(($ADU| format-list $adprops|out-string ).trim())" ; ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        $smsg="PRE:Ex Remotemailbox`n$((Get-RemoteMailbox $ADU.userprincipalname -domaincontroller $domaincontroller| format-list $exprops|out-string ).trim())" ;  ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        if($ADU.msExchRecipientTypeDetails -eq '34359738368' -and $ADU.msExchRemoteRecipientType -eq '100'){
                            $smsg= "PRE:$($ADU.userprincipalname) has already been converted to RemoteSharedMailbox" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } else {
                            $pltSADU=[ordered]@{
                                Identity=$ADU.samaccountname ;
                                Replace=@{msExchRemoteRecipientType=100;msExchRecipientTypeDetails=34359738368}  ;
                                server=$domaincontroller ;
                                whatif=$($whatif) ;
                            } ;
                            $smsg= "Set-aduser with:`n$(($pltSADU|out-string).trim())`n" ;
                            #expand replace values
                            $smsg += "`n$(($pltsadu.replace | fl|out-string).trim())`n" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            $Exit = 0 ;
                            Do {
                                Try {
                                    Set-ADUser @pltSADU ;
                                    $Exit = $DoRetries ;
                                } catch [Microsoft.ActiveDirectory.Management.ADServerDownException] {
                                    $ErrorTrapped=$Error[0] ;
                                    $smsg = "Failed to exec cmd because: $($ErrorTrapped.Exception.Message )" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    # re-quire a new DC
                                    $badDC = $domaincontroller ;
                                    $smsg = "PROBLEM CONTACTING $($badDC)!:Resource unavailable: $($ErrorTrapped.Exception.Message)" ;
                                    $smsg += "get-GCFast() an alterate DC (-exclude $($badDC))" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    if($domaincontroller = get-gcfast -Exclude $badDC -Verbose){
                                        $script:domaincontroller = $domaincontroller  ;
                                        write-warning "Changing DomainController:($($badDC)->$($domaincontroller)):Waiting 20seconds, for ReplSync..." ;
                                        start-sleep -Seconds 20 ;
                                        Continue ;
                                    } else {
                                        $smsg = "UNABLE TO ACQUIRE A NEW ALTERNATE DC! ABORTING" ;
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        THROW $SMSG ;
                                    } ;  ;
                                } Catch {
                                    $ErrorTrapped=$Error[0] ;
                                    $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } CATCH[$($ErrorTrapped.Exception.GetType().FullName)]{" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    #Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                                    Start-Sleep -Seconds $RetrySleep ;
                                    $Exit ++ ;
                                    $smsg = "Failed to exec cmd because: $($ErrorTrapped)" ;
                                    $smsg += "`nTry #: $Exit" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    If ($Exit -eq $DoRetries) {
                                        $smsg =  "Unable to exec cmd!" ;
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    } ;
                                    Continue ;
                                }  ;
                            } Until ($Exit -eq $DoRetries) ;
                            if(!$whatif){
                                $smsg= "POST:ADUser`n$((Get-adUser -id $ADU.samaccountname -prop $adprops -server $domaincontroller|fl $adprops | out-string).trim())`n" ;;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                $smsg= "POST:Ex Remotemailbox`n$((Get-RemoteMailbox $ADU.userprincipalname -domaincontroller $domaincontroller| format-list $exprops|out-string ).trim())" ; ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } else {
                                write-host -fore yellow "(whatif detected, skipping update)"
                            } ;
                        } ;
                        $true | write-output ;
                    } else {
                        $smsg="`n:`$tEmlAddr:$($tEmlAddr): not matched against ADUser`n" ;  ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $DoRetries ;
                } Catch {
                    Start-Sleep -Seconds $RetrySleep ;
                    $Exit ++ ;
                    $smsg = "Failed to exec cmd because: $($Error[0])" ;
                    $smsg += "`nTry #: $Exit" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    If ($Exit -eq $DoRetries) {
                        $smsg =  "Unable to exec cmd!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    Continue ;
                }  ;
            } Until ($Exit -eq $DoRetries) ;
        } ;  # loop-E
    } ;  # PROC-E
}

#*------^ convert-ADUserRecipientTypeRemoteSharedMailbox.ps1 ^------


#*------v convert-ADUserRecipientTypeRemoteUserMailbox.ps1 v------
function convert-ADUserRecipientTypeRemoteUserMailbox{
    <#
    .SYNOPSIS
    Convert the passed-in ADUser object RecipientType to RemoteUserMailbox (Sets ADUser.msExchRecipientTypeDetails:'2147483648' & ADUser.msExchRemoteRecipientType:'4')
    1st half of RemoteUserMailbox conversion to ReomteSharedMailbox (followed by convert-exoMailboxTypeUserMailbox to convert the EXO mailbox type).
    Traditionally this would be applied to RemoteSharedMailbox, but no pre-checking is performed, the update is applied as long as the target settings aren't already in place.
    .NOTES
    Author: Todd Kadrie
    Website:	http://www.toddomation.com
    Twitter:	@tostka, http://twitter.com/tostka
    REVISIONS   :
    * 5:22 PM 1/25/2025 dc access issues to BCC, had to add retry code & get-gcfast -exclude to autorecover on ad calls
    * 8:46 AM 5/17/2023 add to vXO; ren'd back to convert-ADUserRecipientTypeRemoteUserMailbox (rmvd _ internal prefix), and aliased orig name(revert-ADuserRecipientType);
            strongly typed $ADUser as [Microsoft.ActiveDirectory.Management.ADUser]; updated CBH ; 
    1:08 PM 8/25/2021 ren revertADuser -> _revert-ADuserRecipientType
    # 2:51 PM 12/18/2018 set-adus has functional whatif, moved it into test fire
    # 1:34 PM 12/17/2018 initi vers
    .DESCRIPTION
    Convert the passed-in ADUser object RecipientType to RemoteUserMailbox (Sets ADUser.msExchRecipientTypeDetails:'2147483648' & ADUser.msExchRemoteRecipientType:'4')
    1st half of RemoteUserMailbox conversion to ReomteSharedMailbox (followed by convert-exoMailboxTypeUserMailbox to convert the EXO mailbox type).
    Traditionally this would be applied to RemoteSharedMailbox, but no pre-checking is performed, the update is applied as long as the target settings aren't already in place.

    (does not require passed in Credentials, as all changes are with ActiveDirectory module, which does not support affirmative logon; logon is pickedup from the psdrive AD mapping) 

    .PARAMETER  ADUser
    ADUser object [-ADUser `$ADVariable]
    .PARAMETER domaincontroller
    Option to hardcode a specific DC [-domaincontroller xxxx]
    .PARAMETER Whatif
    Parameter to run a Test no-change pass, and log results [-Whatif switch]
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Returns RemoteMailbox object, or $false on failure.
    .EXAMPLE
    $adu=get-aduser -id $rmbx.DistinguishedName -server $domainController -Properties $adprops -ea 0| select $adprops ;
    $bRet=convert-ADUserRecipientTypeRemoteUserMailbox -ADUser $adu -whatif:$($whatif) -showDebug:$($showdebug) ;
    Convert the passed-in ADUser object RecipientType from RemoteUserMailbox to RemoteSharedMailbox.
    (does not require passed in Credentials, as all changes are with ActiveDirectory module, which does not support affirmative logon; logon is pickedup from the psdrive AD mapping automounted on ActieDirectory module load) 
    .LINK
    #>
    [CmdletBinding()]
    [Alias('revert-ADuserRecipientType')]
    PARAM(
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,HelpMessage="ADUser object [-ADUser `$ADVariable]")]
            [ValidateNotNullOrEmpty()]
            [Microsoft.ActiveDirectory.Management.ADUser]$ADUser,
        [Parameter(HelpMessage="Option to hardcode a specific DC [-domaincontroller xxxx]")]
            [string]$domaincontroller,
        [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
            [switch] $showDebug,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
            [switch] $whatIf
    ) # PARAM BLOCK END
    BEGIN {
        if(-not $DoRetries){$DoRetries = 4 } ;    # # times to repeat retry attempts
        if(-not $RetrySleep){$RetrySleep = 10 } ; # wait time between retries
        if(-not $RetrySleep){$DawdleWait = 30 } ; # wait time (secs) between dawdle checks
        if(-not $DirSyncInterval){$DirSyncInterval = 30 } ; # AADConnect dirsync interval

    } ;  # BEGIN-E
    PROCESS {
        foreach($ADU in $ADUser) {
            $error.clear() ;
            $Exit = 0 ;
            Do {
                Try {
                    if(!$domaincontroller){$domaincontroller=get-gcfast} ;
                    $adprops="samaccountname","msExchRemoteRecipientType","msExchRecipientDisplayType","msExchRecipientTypeDetails","UserPrincipalName","DistinguishedName" ;
                    $exprops="SamAccountName","RecipientType","RecipientTypeDetails","UserPrincipalName" ;
                    if($ADU){
                        $smsg= "PRE:ADUser`n$(($ADU| format-list $adprops|out-string ).trim())" ; ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $smsg="PRE:Ex Remotemailbox`n$((Get-RemoteMailbox $ADU.userprincipalname -domaincontroller $domaincontroller| format-list $exprops|out-string ).trim())" ;  ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        # convert remoteshared back to remote user:
                        if($ADU.msExchRecipientTypeDetails -eq '2147483648' -and $ADU.msExchRemoteRecipientType -eq '4'){
                            #$smsg= "PRE:$($ADU.userprincipalname) has already been converted to RemoteSharedMailbox" ;
                            $smsg= "PRE:$($ADU.userprincipalname) has already been converted to RemoteUserMailbox" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } else {
                            <# remoteusermbx -> remoteshared
                            $pltSADU=[ordered]@{
                                Identity=$ADU.samaccountname ;
                                Replace=@{msExchRemoteRecipientType=100;msExchRecipientTypeDetails=34359738368}  ;
                                server=$domaincontroller ;
                                whatif=$($whatif) ;
                            } ;
                            #>
                            # remoteshared -> remoteuser
                            $pltSADU=[ordered]@{
                                Identity=$ADU.samaccountname ;
                                Replace=@{msExchRemoteRecipientType=4;msExchRecipientTypeDetails=2147483648}  ;
                                server=$domaincontroller ;
                                #ErrorAction = 'STOP'
                                whatif=$($whatif) ;
                            } ;
                            # whatif=$($whatif) ;

                            $smsg = "Set-aduser with:`n$(($pltSADU|out-string).trim())`n" ;
                            #expand replace values
                            $smsg += "`n$(($pltsadu.replace | fl|out-string).trim())`n" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            $Exit = 0 ;
                            Do {
                                Try {
                                    Set-ADUser @pltSADU ;
                                    $Exit = $DoRetries ;
                                } catch [Microsoft.ActiveDirectory.Management.ADServerDownException] {
                                    $ErrorTrapped=$Error[0] ;
                                    $smsg = "Failed to exec cmd because: $($ErrorTrapped.Exception.Message )" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    # re-quire a new DC
                                    $badDC = $domaincontroller ;
                                    $smsg = "PROBLEM CONTACTING $($badDC)!:Resource unavailable: $($ErrorTrapped.Exception.Message)" ;
                                    $smsg += "get-GCFast() an alterate DC (-exclude $($badDC))" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    if($domaincontroller = get-gcfast -Exclude $badDC -Verbose){
                                        $script:domaincontroller = $domaincontroller  ;
                                        write-warning "Changing DomainController:($($badDC)->$($domaincontroller)):Waiting 20seconds, for ReplSync..." ;
                                        start-sleep -Seconds 20 ;
                                        Continue ;
                                    } else {
                                        $smsg = "UNABLE TO ACQUIRE A NEW ALTERNATE DC! ABORTING" ;
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        THROW $SMSG ;
                                    } ;  ;
                                } Catch {
                                    $ErrorTrapped=$Error[0] ;
                                    $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } CATCH[$($ErrorTrapped.Exception.GetType().FullName)]{" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    #Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                                    Start-Sleep -Seconds $RetrySleep ;
                                    $Exit ++ ;
                                    $smsg = "Failed to exec cmd because: $($ErrorTrapped)" ;
                                    $smsg += "`nTry #: $Exit" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    If ($Exit -eq $DoRetries) {
                                        $smsg =  "Unable to exec cmd!" ;
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    } ;
                                    Continue ;
                                }  ;
                            } Until ($Exit -eq $DoRetries) ;
                            if(!$whatif){
                                $smsg= "POST:ADUser`n$((Get-adUser -id $ADU.samaccountname -prop $adprops -server $domaincontroller|fl $adprops | out-string).trim())`n" ;;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                $smsg= "POST:Ex Remotemailbox`n$((Get-RemoteMailbox $ADU.userprincipalname -domaincontroller $domaincontroller| format-list $exprops|out-string ).trim())" ; ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } else { write-host -fore yellow "(whatif detected, skipping update)"} ;
                        } ;
                        $true | write-output ;
                    } else {
                        $smsg="`n:`$tEmlAddr:$($tEmlAddr): not matched against ADUser`n" ;  ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $DoRetries ;
                } Catch {
                    Start-Sleep -Seconds $RetrySleep ;
                    $Exit ++ ;
                    $smsg = "Failed to exec cmd because: $($Error[0])" ;
                    $smsg += "`nTry #: $Exit" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    If ($Exit -eq $DoRetries) {
                        $smsg =  "Unable to exec cmd!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    Continue ;
                }  ;
            } Until ($Exit -eq $DoRetries) ;
        } ;  # loop-E
    } ;  # PROC-E
}

#*------^ convert-ADUserRecipientTypeRemoteUserMailbox.ps1 ^------


#*------v convert-exoMailboxTypeSharedMailbox.ps1 v------
function convert-exoMailboxTypeSharedMailbox{
    <#
    .SYNOPSIS
    convert-exoMailboxTypeSharedMailbox() - Set specified EXO mailbox to Shared ('SharedMailbox) type (part of coordinated on-prem ADUser recipienttype hack to make it work without moving mbxs back onprem to convert).
    .NOTES
    Author: Todd Kadrie
    Website:	http://www.toddomation.com
    Twitter:	@tostka, http://twitter.com/tostka
    REVISIONS   :
    * 10:38 AM 1/13/2026 ADD: -ea stop  to try splats
    * 8:46 AM 5/17/2023 add to vXO; ren'd to convert-exoMailboxTypeSharedMailbox (rmvd _ internal prefix), and aliased orig name(convert-xoShared), strongly typed $Mailbox as [System.Object] (get-xomailbox returns that type, not a real 'Mailbox' class).
    # 1:09 PM 8/25/2021 ren convertExoShared -> _convert-xoShared
    # 10:00 AM 12/19/2018 revertExoUserMbx : added post confirm echo
    # 12:31 PM 10/23/2018 ran full pass live, no unusual errors
    .DESCRIPTION
    convert-exoMailboxTypeSharedMailbox() - Set specified EXO mailbox to Shared ('SharedMailbox) type (part of coordinated on-prem ADUser recipienttype hack to make it work without moving mbxs back onprem to convert).
    .PARAMETER  Mailbox, EXO Mailbox Object
    EXO Mailbox Object
    .PARAMETER  Credential
    Credential to use for this connection [-credential 'account@domain.com']
    .PARAMETER silent
    Switch to specify suppression of all but warn/error echos.
    .PARAMETER Whatif
    Parameter to run a Test no-change pass, and log results [-Whatif switch]
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Returns RemoteMailbox object, or $false on failure.
    .EXAMPLE
    $ombx = get-xomailbox -id $targUPN -ea stop ;
    $bRet = convert-exoMailboxTypeSharedMailbox -Mailbox $ombx -whatif -showDebug ;
    Pull the target cloud-first EXO mailbox, and pass it as an object in to the convert-exoMailboxTypeSharedMailbox(), with whatif & showdebug
    .LINK
    #>
    [CmdletBinding()]
    [Alias('convert-xoShared')]
    PARAM(
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,HelpMessage="UPN [-upn fname.lname@DOMAIN.COM]")]
            [ValidateNotNullOrEmpty()]
            [System.Object]$Mailbox,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent,
        [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
            [switch] $showDebug,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
        [switch] $whatIf
    ) # PARAM BLOCK END
    BEGIN {
        $exprops="SamAccountName","RecipientType","RecipientTypeDetails","UserPrincipalName" ;
        # recycling the inbound above into next call in the chain
        $pltRXO = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
            silent = $silent ;
        } ;
    } ;  # BEGIN-E
    PROCESS {
        $Error.Clear() ;
        foreach($MBX in $Mailbox) {
            Reconnect-EXO @pltRXO;

            # 2:43 PM 10/11/2018 add precheck
            if($MBX |?{$_.recipienttypedetails -eq 'SharedMailbox'}){
                $smsg= "PRE:$($MBX.userprincipalname) has already been converted to RemoteSharedMailbox" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $pltSxM=[ordered]@{
                    Identity=$MBX.userprincipalname ;
                    Type="Shared" ;
                    whatif=$($whatif) ;
                    ErrorAction = 'STOP'
                } ;
                $smsg="set-xomailbox with:`n$(($pltSxM|out-string).trim())`n" ; ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                $Exit = 0 ;
                Do {
                    Try {
                        set-xomailbox @pltSxM ;
                        $Exit = $DoRetries ;
                        $true | write-output ;
                    } Catch {
                        $smsg = "Failed to exec cmd because: $($Error[0])" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Start-Sleep -Seconds $RetrySleep ;
                        $tryNo = 0 ;
                        Reconnect-exo @pltRXO;
                        $Exit ++ ;
                        $smsg = "Try #: $Exit" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        If ($Exit -eq $DoRetries) {
                        $smsg =  "Unable to exec cmd!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                        Continue ;
                    }  ;
                } Until ($Exit -eq $DoRetries) ;

                if(-not $whatif){
                    $smsg = "(waiting for get-xoMailbox to return RecipientTypeDetails -eq 'SharedMailbox')" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $1F=$false ;
                    Do {
                        if($1F){Sleep -s 5} ;
                        write-host "." -NoNewLine ;
                        $1F=$true ;
                        $Exit = 0 ;
                        Do {
                            Try {
                                $pexombx = get-xomailbox -id $pltSxM.identity -ea stop ;
                                $Exit = $DoRetries ;
                            } Catch {
                                $smsg = "Failed to exec cmd because: $($Error[0])" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                Start-Sleep -Seconds $RetrySleep ;
                                $tryNo = 0 ;
                                Reconnect-exo @pltRXO;
                                $Exit ++ ;
                                $smsg = "Try #: $Exit" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                If ($Exit -eq $DoRetries) {
                                    $smsg =  "Unable to exec cmd!" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                } ;
                                Continue ;
                            }  ;
                        } Until ($Exit -eq $DoRetries) ;
                    } Until ($pexombx.RecipientTypeDetails -eq 'SharedMailbox') ;

                    $smsg= "POST:EXO Mailbox`n$(($pexombx| format-list $exprops|out-string ).trim())" ; ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                } else {
                        set-xomailbox @pltSxM ; 
                        $smsg = "(whatif detected, skipping post test)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }  else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;
            } ; # if-E Not Converted test
        } ;  # loop-E
    } ;  # PROC-E
}

#*------^ convert-exoMailboxTypeSharedMailbox.ps1 ^------


#*------v convert-exoMailboxTypeUserMailbox.ps1 v------
function convert-exoMailboxTypeUserMailbox{
    <#
    .SYNOPSIS
    convert-exoMailboxTypeUserMailbox() - Set specified EXO mailbox to Regular ('UserMailbox')
    .NOTES
    Author: Todd Kadrie
    Website:	http://www.toddomation.com
    Twitter:	@tostka, http://twitter.com/tostka
    REVISIONS   :
    * 8:46 AM 5/17/2023 add to vXO; ren'd to convert-exoMailboxTypeSharedMailbox (rmvd _ internal prefix), and aliased orig name(convert-xoShared), strongly typed $Mailbox as [System.Object] (get-xomailbox returns that type, not a real 'Mailbox' class).
    #1:10 PM 8/25/2021 ren revertExoUserMbx -> _revert-xoUserMbx
    # 10:00 AM 12/19/2018 _revert-xoUserMbx: added post confirm echo
    # 3:19 PM 12/17/2018 coding revert
    # 12:31 PM 10/23/2018 ran full pass live, no unusual errors
    .DESCRIPTION
    convert-exoMailboxTypeUserMailbox() - Set specified EXO mailbox to Regular (from Shared) type (part of coordinated on-prem ADUser recipienttype hack to make it work without movnig mbxs back onprem to convert).
    .PARAMETER  Mailbox, EXO Mailbox Object
    EXO Mailbox Object
    .PARAMETER  Credential
    Credential to use for this connection [-credential 'account@domain.com']
    .PARAMETER silent
    Switch to specify suppression of all but warn/error echos.
    .PARAMETER Whatif
    Parameter to run a Test no-change pass, and log results [-Whatif switch]
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Returns RemoteMailbox object, or $false on failure.
    .EXAMPLE
    $ombx = get-xomailbox -id $targUPN -ea stop ;
    $bRet = convert-exoMailboxTypeUserMailbox -Mailbox $ombx -whatif -showDebug ;
    Pull the target cloud-first EXO mailbox, and pass it as an object in to the convert-exoMailboxTypeUserMailbox(), with whatif & showdebug
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    [CmdletBinding()]
    [Alias('revert-xoUserMbx')]
    PARAM(
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="UPN [-upn fname.lname@DOMAIN.COM]")]
        [ValidateNotNullOrEmpty()]
            [System.Object]$Mailbox,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent,
        [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
            [switch] $showDebug,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
            [switch] $whatIf
    ) # PARAM BLOCK END
    BEGIN {
        $exprops="SamAccountName","RecipientType","RecipientTypeDetails","UserPrincipalName" ;
        # recycling the inbound above into next call in the chain
        $pltRXO = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
            silent = $silent ;
        } ;
    } ;  # BEGIN-E
    PROCESS {
        foreach($MBX in $Mailbox){
            $Error.Clear() ;
            Reconnect-EXO @pltRXO;

            # usermailbox -> sharedmailbox
            if($MBX |?{$_.recipienttypedetails -eq 'UserMailbox'}){
                $smsg= "PRE:$($MBX.userprincipalname) has already been converted to RemoteMailbox" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                <# convert TO SHARED
                $pltSADU=[ordered]@{
                    Identity=$MBX.userprincipalname ;
                    Type="Shared" ;
                    whatif=$($whatif) ;
                } ;
                #>
                # convert FROM SHARED
                $pltSxM=[ordered]@{
                    Identity=$MBX.userprincipalname ;
                    Type="Regular" ;
                    whatif=$($whatif) ;
                    ErrorAction = 'STOP' ;
                } ;
                $smsg="set-xomailbox with:`n$(($pltSxM|out-string).trim())`n" ; ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                # 9:48 AM 12/19/2018 move out here, get the whatif confirm
                $Exit = 0 ;
                Do {
                    Try {
                        set-xomailbox @pltSxM ;
                        $Exit = $DoRetries ;
                        $true | write-output ;
                    } Catch {
                        $smsg = "Failed to exec cmd because: $($Error[0])" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Start-Sleep -Seconds $RetrySleep ;
                        $tryNo = 0 ;
                        Reconnect-EXO @pltRXO;
                        $Exit ++ ;
                        $smsg = "Try #: $Exit" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        If ($Exit -eq $DoRetries) {
                        $smsg =  "Unable to exec cmd!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                        Continue ;
                    }  ;
                } Until ($Exit -eq $DoRetries) ;

                if(!$whatif){
                    $smsg = "(waiting for get-xoMailbox to return RecipientTypeDetails -eq 'UserMailbox')" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $1F=$false ;
                    Do {
                        if($1F){Sleep -s 5} ;
                        write-host  "." -NoNewLine ;
                        $1F=$true ;
                        $Exit = 0 ;
                        Do {
                            Try {
                                $pexombx = get-xomailbox -id $pltSxM.identity -ea stop ;
                                $Exit = $DoRetries ;
                            } Catch {
                                $smsg = "Failed to exec cmd because: $($Error[0])" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                Start-Sleep -Seconds $RetrySleep ;
                                $tryNo = 0 ;
                                Reconnect-exo @pltRXO;
                                $Exit ++ ;
                                $smsg = "Try #: $Exit" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                If ($Exit -eq $DoRetries) {
                                    $smsg =  "Unable to exec cmd!" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                } ;
                                Continue ;
                            }  ;
                        } Until ($Exit -eq $DoRetries) ;
                    } Until ($pexombx.RecipientTypeDetails -eq 'UserMailbox') ;

                    $smsg= "POST:EXO Mailbox`n$(($pexombx| format-list $exprops|out-string ).trim())" ; ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                } else { 
                    set-xomailbox @pltSxM ;
                    $smsg = "(whatif detected, skipping post test)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }  else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            
                } ;
            } ;  # if-E Not Converted test
        } ;  # loop-E
    } ;  # PROC-E
}

#*------^ convert-exoMailboxTypeUserMailbox.ps1 ^------


#*------v convert-HistoricalSearchCSV.ps1 v------
function convert-HistoricalSearchCSV {
    <#
    .SYNOPSIS
    convert-HistoricalSearchCSV - Summarize (to XML) or re-expand(to CSV), MS EXO HistoricalSearch (or Portal) MTSummary or MTDetail csv output files, to permit MessageTrace-style parsing of the output for delivery patterns.
    .NOTES
    Version     : 1.0.2
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-04-23
    FileName    : convert-HistoricalSearchCSV.ps1
    License     : MIT License
    Copyright   : (c) 2024 Todd Kadrie
    Github      : https://github.com/tostka/verb-EXO
    Tags        : Powershell,ExchangeOnline,MessageTrace,Conversion
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 4:08 PM 7/1/2024 spliced over code from convertfrom ConvertFrom-exoMTSummaryToEvents.ps1; wasn't sure portal and HistoricalSearch output same files, turns out, this already supports both; 
        Added wh color splats for banners; 
        added index field in MTSummary toCSV conversion (provides sub MessageID sort order, to reflect order in Recipient Status entries). 
        Added -Ticket param; Add alias:ConvertFrom-exoMTSummaryToEvents; added reverse on parsed reciient_status (put in proper recevie,resolve,delivery order); 
        pulled ParameterSets, defaulted unspec'd to -ToCSV ; added CBH exmple w Ticket
        Finally if/then'd out processing detail for dotcrawl, if DoDots is in use (default)
    * 1:58 PM 12/15/2021 revised expan code, implemented split MTDetail/MTSummary processing; normalized fieldnames against the MessageTrace output (goal is to make HS look and process more like MT)
    * 1:05 PM 12/14/2021 added full range of Expanded Rpt fields, tweaked the 
        non-recip statuses to look like recips (using primary recip & recipStat for the 
        record) ; fixed defaulted iscsv, modified param pipeline defaults; switched 
        Files from typeless to string[]; found extended gui trace had date fields with 
        diff names, added tests & support to suppress errors. ; updated Catch blocks to 
        curr spec (errors not being echoed). 
    * 11:21 AM 9/15/2021 updated Example to demo pipline-input, and post-processing to group Status (like you could a MessageTrace); added $DotsInterval param.
    * 2:54 PM 4/23/2021 wrote as freestanding .ps1, decided to flip it into func in verb-EXO
    .DESCRIPTION
    convert-HistoricalSearchCSV - Summarize (to XML) or re-expand(to CSV), MS EXO HistoricalSearch (or Portal) MTSummary or MTDetail csv output files, to permit MessageTrace-style parsing of the output for delivery patterns.

    Also works with stock Portal Mail Flow > Message Trace searches (which are the same underlying MTSummary or MTDetail format csv reports produced by Start-xoHistoricalSearch). 

    Issue is that HistoricalSearch/Portal output csv files summarize a lot of detail from the normal MessageTrace .csv output, into the single Recipient_status field,
    which is a concatonated combo of every recipient, double-hash (##) delimited with the following information per recipient
    <email address>##<status>
    And there can be a series of Status entries logged, for the single email address.

    - If ToXML is chosen, the RecipientAddress & RecipientEvents are nested as an array of CustomObjects in a field named 'RecipientStatuses'
    - If ToCsv is chosen, each transaction is unpacked back into separate 'Status' lines for each RecipientStatus (closer to the way get-MessageTrace returns records)

    The benefit of expanded CSV, over the native HS output, is you can do MessageTrace-like parsing of the results:
    $msgsx = import-csv -path path-to\MTSummary_History-expanded.csv ; 
    $msgsx | group status | ft -auto count,name
    Count Name
    ----- ----
      119 Receive
      117 Deliver
        2 Fail

    .PARAMETER  Files
    Array of HistoricalSearch/Portal download MTSummary or MTDetail .csv file paths[-Files c:\pathto\HistSearch.csv]
    .PARAMETER ToXML
    ToXML switch (generates nested summary XML)[-ToXML]
    .PARAMETER ToCSV
    ToCSV switch (Defaults True ; expands transactions into a logged entry per RecipientStatus)[-ToCSV]
    .PARAMETER Ticket
    Optional Ticket number (used for prefixing output file)[-ticket 123456]
    .PARAMETER DoDots
    Use progress dotcrawl over explicit x/y echo.
    .PARAMETER DotsInterval
    Progress dotcrawl interval (dot per every X proceessed, defaults to 3)[-DotsInterval 5]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    outputs .csv or .xml with variant [originalname]-Expanded.[ext] filename of source .csv file.
    System.String is returned (filepath of each converted file)
    .EXAMPLE
    convert-HistoricalSearchCSV -ToXML -Files "C:\usr\work\incid\123456-fname.lname@domain.com-EXOHistSrch,-60D-History,From-ANY@mssociety.org,20210222-0000AM-20210423-0919AM,run-20210423-1007AM.csv" ; 
    Convert a HistoricalSearch .csv report, to XML (with filename:[originalname]-Expanded.xml)
    .EXAMPLE
    PS> $ifile = "C:\pathTo\MTSummary_History.csv" ;
    PS> $ofile = convert-HistoricalSearchCSV -ToCSV -Files $ifile  ; 
    PS> $msgsx = import-csv -path $ofile ; 
    PS> $msgsx | group status | ft -auto count,name
    Convert a HistoricalSearch .csv report, to -expanded.CSV, and then group the Status (as you could a normal MessageTrace). 
    .EXAMPLE
    PS> "HistReport1.csv","HistReport2.csv | convert-HistoricalSearchCSV -ToCSV ; 
    Pipeline convert multiple Hist reort csvs to xxx-expanded.csv files.
    .EXAMPLE
    PS> convert-HistoricalSearchCSV -Files 'D:\scripts\logs\849746_MTSummary_from-turfequipment@toro.com 90d - _2024-06-28T195527.734Z__67565bac-bf7a-46d7-85fe-7b1906326a27.csv' -ToCSV -ticket 849746
    Example specifying -Ticket ; 
    .LINK
    https://github.com/tostka/verb-exo
    .LINK
    https://docs.microsoft.com/en-us/powershell/module/exchange/get-historicalsearch
    .LINK
    https://docs.microsoft.com/en-us/powershell/module/exchange/get-messagetrace
    .LINK
    https://admin.exchange.microsoft.com/#/messagetrace
    #>
    #Requires -Version 3
    #[CmdletBinding(DefaultParameterSetName='CSV')]
    [CmdletBinding()]
    [Alias('convertfrom-HistoricalSearch')]
    PARAM(
        #[Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Array of HistoricalSearch .csv file paths[-Files c:\pathto\HistSearch.csv]")]
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,HelpMessage="Array of HistoricalSearch/Portal download MTSummary or MTDetail .csv file paths[-Files c:\pathto\HistSearch.csv]")]
            #[ValidateNotNullOrEmpty()]
            [ValidateScript({
                Test-Path $_ 
                $_ -match '\.csv$'
            })]
            #[string[]]$Files,
            [system.io.fileinfo[]]$Files,
        #[Parameter(ParameterSetName='XML',HelpMessage="ToXML switch (generates nested summary XML)[-ToXML]")]
        [Parameter(HelpMessage="ToXML switch (generates nested summary XML)[-ToXML]")]
            [switch] $ToXML,
        #[Parameter(ParameterSetName='CSV',HelpMessage="ToCSV switch (expands transactions into a line per RecipientStatus)[-ToCSV]")]
        [Parameter(HelpMessage="ToCSV switch (expands transactions into a line per RecipientStatus)[-ToCSV]")]
            [switch] $ToCSV,
        [Parameter(HelpMessage="Optional Ticket number (used for prefixing output file)[-ticket 123456]")]
        [string]$Ticket,
        [Parameter(HelpMessage="Use progress dotcrawl over explicit x/y echo switch[-DoDots]")]
            [switch]$DoDots=$true, 
        [Parameter(HelpMessage="Progress dotcrawl interval (dot per every X proceessed, defaults to 3)[-DotsInterval 5]")]
            [int]$DotsInterval=10
    ) ;
    BEGIN{
        if(-not ($ToCsv -OR $ToXML)){
            # default to csv
            write-host -foregroundcolor yellow "Neither -ToCSV or -ToXML specified: Defaulting to: -ToCSV" ; 
        } ; 
        if($ToCsv -AND $ToXML){
            write-warning "Both -ToCSV -AND -ToXML specified!`nPlease specify one or the other" ; 
        } ; 
        $verbose = ($VerbosePreference -eq "Continue") ; 
        $pltXCsv = [ordered]@{
            path = $null ; 
            NoTypeInformation = $true ;
        } ;
        $whBnr = @{BackgroundColor = 'Magenta' ; ForegroundColor = 'Black' } ;
        $whBnrS =@{BackgroundColor = 'Blue' ; ForegroundColor = 'Cyan' } ;
    } ; # BEG-E
    PROCESS{
        foreach($file in $files){
            $sBnr="#*======v PROCESSING : $($file.fullname) v======" ; 
            write-host @whBnr -obj "$((get-date).ToString('HH:mm:ss')):$($sBnr)" ;
        
            $error.clear() ;
            TRY {
                #$ifile= gci -path $file; 
                write-verbose "(import-csv:$($file.fullname))" ; 
                $records = import-csv -path $file.fullname -Encoding Unicode ; 
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #-=-record a STATUSWARN=-=-=-=-=-=-=
                $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                #-=-=-=-=-=-=-=-=
                $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
            } ; 
        
            <# Recipient_status: The status of the delivery of the message to the recipient. 
            If the message was sent to multiple recipients, it will show all the recipients 
            and the corresponding status for each, in the format: <email address>##<status>.
            For example: 
            ##Receive, Send means the message was received by the service and was sent to the intended destination.
            ##Receive, Fail means the message was received by the service but delivery to the intended destination failed.
            ##Receive, Deliver means the message was received by the service and was delivered to the recipient?s mailbox.
            Multi recipients appear like:
            Fname.Lname@domain.com##Receive, Deliver;Fname.Lname@domain.com##Receive, Deliver;Fname.Lname@domain.com##Receive, Deliver;Fname.Lname@domain.com##Receive, Deliver;Fname.Lname@domain.com##Receive, Deliver;Fname.Lname@domain.com##Receive, Deliver;Fname.Lname@domain.com##Receive, Deliver;Fname.Lname@domain.com##Receive, Deliver
            #>
            $aggreg = @() ; 
            $procd = 0 ; $ttl = (($records|measure).count) ; $ino=0 ; 
            if($DoDots){write-host -foregroundcolor Red "[" -NoNewline } ; 

            $isMTDetail = $false ; 
            # MTSummary has 'origin_timestamp_utc'
            # MTDetail has 'date_time_utc'
            if(($records[0] | gm | ?{$_.membertype -eq 'NoteProperty'}).name -contains 'origin_timestamp_utc'){
                $isMTDetail = $false ;
                $smsg = "(MTSummary csv file detected)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            }elseif(($records[0] | gm | ?{$_.membertype -eq 'NoteProperty'}).name -contains 'date_time_utc'){
                $isMTDetail = $true ;
                $smsg = "(MTDetail 'Extended' csv file detected)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            } else { 
                throw "Unable to determine if source is an MTSummary or MTDetail csv!"
                break ; 
            } ;  

            foreach ($record in $records){
                $procd++ ; 
                # echo every $DotsInterval'th record
                if(($procd % $DotsInterval) -eq 0){
                    if($DoDots){
                          $ino++ ; 
                          if(($ino % 80) -eq 0){
                            write-host "." ; $ino=0 ;
                          } else {write-host "." -NoNewLine} ;
                    } else { 
                        write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):($($procd)/$($ttl)):" ; 
                    } ; 
                } ; 
                if(-not $DoDots){
                    #write-verbose "$((get-date).ToString('HH:mm:ss')):(record $($procd)/$($ttl)):"  ; 
                    $sBnrS="`n#*------v PROCESSING : $($procd)/$($ttl) v------" ; 
                    write-host @whBnrS -obj "$((get-date).ToString('HH:mm:ss')):$($sBnrS)" ;
                } ; 
            

                <# typical HistoricalSearch csv record & fields:
                origin_timestamp_utc : 2021-03-23T10:00:09.3284899Z
                sender_address       : Fname.Lname@domain.com
                recipient_status     : Fname.Lname@domain.com##Receive, Deliver;"Fname LName<fname.lname"@domain.com##Receive, Fail
                message_subject      : AW: Fwd: SOME SUBJECT 123456 22-03-2021
                total_bytes          : 49790
                message_id           : <PH0PR04MB73657A6BEBB3F89D9F4FC85A8C649@PH0PR04MB7365.namprd04.prod.outlook.com>
                network_message_id   : 81945af2-cab7-45ad-ba23-08d8ede2715d
                original_client_ip   : 123.456.789.012
                directionality       : Originating
                connector_id         : To_DefaultOpportunisticTLS
                delivery_priority    : Normal
                #>
                <# Extended report 8:59 AM 12/14/2021
                date_time_utc             : 2021-11-23T19:49:37.6050000Z
                client_ip                 :
                client_hostname           : CH0PR04MB8081.namprd04.prod.outlook.com
                server_ip                 :
                server_hostname           : BY5PR04MB6279.namprd04.prod.outlook.com
                source_context            : 08D9AE1AA4FEA27C;2021-11-23T19:49:37.215Z;ClientSubmitTime:2021-11-23T19:49:36.380Z
                connector_id              :
                source                    : STOREDRIVER
                event_id                  : DELIVER
                internal_message_id       : 132697
                message_id                : <CH0PR04MB8114A61AF981D65F07EA6A0C8B609@CH0PR04MB8114.namprd04.prod.outlook.com>
                network_message_id        : f955f718-d5ff-40a7-137f-08d9aeba6116
                recipient_address         : recip@domain.com
                recipient_status          :
                total_bytes               : 89464
                recipient_count           : 1
                related_recipient_address :
                reference                 :
                message_subject           : SENDER Last Day Details - List
                sender_address            : SENDER@domain.com
                return_path               : SENDER@domain.com
                message_info              : 2021-11-23T19:49:36.395Z;SRV=CH0PR04MB8114.namprd04.prod.outlook.com:TOTAL-SUB=0.218|SA=0.021|MTSS-PEN=0.197(MTSSD-PEN=0.197(MTSORGC=0.052|MTSSDC=0.073|MTSSDSDM=0.026 (MTSSDSDM-Mailbox Submission Filter
                                            Agent=0.025)|SDSSO-PEN=0.019(SMSC-PEN=0.019)));SRV=CH0PR04MB8081.namprd04.prod.outlook.com:TOTAL-HUB=0.504|SMRI=0.118(RENV=0.036|REOD=0.027|CMSGC=0.052|R-CMSG=0.026(R-CMSGC=0.023(R-HSRR=0.023
                                            )))|CAT=0.297(CATOS=0.068(CATSM=0.068(CATSM-DC Pre Content Filter Agent=0.062))|CATORES=0.187 (CATRS=0.187(CATRS-Transport Rule Agent=0.026(X-ETREX=0.022)|CATRS-DLP Policy Agent=0.043 (X-DLPEX=0.037)|CATRS-DC
                                            Content Filter Agent=0.106))|CATCC=0.024)|D-PEN=0.053(HSDSP=0.052
                                            (HSRR=0.051))|HSDN=0.031;SRV=BY5PR04MB6279.namprd04.prod.outlook.com:TOTAL-DEL=0.501|HSDR=0.113(HSDRR=0.097)|SDD=0.389(SDDPM=0.087(SDDPM-Mailbox Delivery Filter Agent=0.040|SDDPM-Inference Classification
                                            Agent=0.026)|SDDSDMG=0.268(SDDR=0.268)|X-SDDS=0.097)
                directionality            : Originating
                tenant_id                 : 549366ae-e80a-44b9-8adc-52d0c29ba08b
                original_client_ip        : 192.168.1.251
                original_server_ip        : 2603:10b6:610:f9::20
                custom_data               : S:IncludeInSla=True;S:MailboxDatabaseGuid=4ba0d02d-8b59-4bab-80e0-73f70ce64d61;S:ActivityId=77d7390c-af4d-4e43-99c5-aea5e353c61a;S:BCL=0;S:Mailboxes=f5436253-dbf4-428f-bb5c-08944e5f30e9;S:StoreObjectIds=AAAAAN
                                            4COUMvw7VMjllHB1/AorIHANlpuQRlrZxKlXO5Qqnh9vMAAAClXpkAAL34su7JVyNBoQgZmMcaJOoAAu1n1K8AAA==;S:FromEntity=Hosted;S:ToEntity=Hosted;S:P2RecipStat=0.008/9;S:MsgRecipCount=9;S:SubRecipCount=9;S:HttpRequestId=9cfd3b
                                            b0-f5cb-446d-b57e-a73440081811;S:DeliveredViaHttps=True;S:MapiMessageClass=IPM.Note;S:DeliveryLatency=1.207;S:AttachCount=1;S:E2ELatency=1.211;S:DeliveryPriority=Normal;S:PrioritizationReason=EnvelopePriority;
                                            S:AccountForest=NAMPR04A008.PROD.OUTLOOK.COM
                #>
        
                $error.clear() ;
                TRY {
                    <# fields from a typical MessageTrace (emulate the same names):
                    PSComputerName
                    RunspaceId
                    PSShowComputerName
                    Organization
                    MessageId
                    Received
                    SenderAddress
                    RecipientAddress
                    Subject
                    Status
                    ToIP
                    FromIP
                    Size
                    MessageTraceId
                    StartDate
                    EndDate
                    Index
                    #>
                
                    $TransSummary = [ordered]@{
                        Received=$null ;
                        ReceivedGMT=$null ;
                        SenderAddress=$record.sender_address ;
                        RecipientAddress= $null # $record.recipient_address ; only populated on MTDetail, imputed from recipinet_status for MTSummary
                        Status = $null ; 
                        Subject=$record.message_subject ;
                        Size=$record.total_bytes ;
                        MessageID=$record.message_id ;
                        OriginalClientIP=$record.original_client_ip ;
                        Directionality=$record.directionality ;
                        ConnectorID=$record.connector_id ;
                        DeliveryPriority=$record.delivery_priority ;
                        FromIP = $record.original_client_ip ; 
                        #ToIP = $record. ; 
                    } ; 
                
                    #if($record.origin_timestamp_utc){
                    if( -not $isMTDetail){
                        $TransSummary.Received=([datetime]$record.origin_timestamp_utc).ToLocalTime() ; # converting HistSearch GMT to LocalTime
                        $TransSummary.ReceivedGMT=$record.origin_timestamp_utc ;
                    #} elseif($record.date_time_utc){
                    } elseif($isMTDetail){
                        $TransSummary.Received=([datetime]$record.date_time_utc).ToLocalTime() ; # converting HistSearch GMT to LocalTime
                        $TransSummary.ReceivedGMT=$record.date_time_utc ;
                        write-verbose "(Expanded Report fields detected, and adding...)" ; 
                        # extended rpts include a raft of extra fields
                        #date_time_utc
                        $TransSummary.ADD('client_ip',$record.client_ip) ;
                        $TransSummary.ADD('client_hostname',$record.client_hostname) ;
                        $TransSummary.ADD('server_ip',$record.server_ip) ;
                        $TransSummary.ADD('server_hostname',$record.server_hostname) ;
                        $TransSummary.ADD('source_context',$record.source_context) ;
                        #$TransSummary.ADD('connector_id',$record.connector_id) ;
                        $TransSummary.ADD('source',$record.source) ;
                        $TransSummary.ADD('event_id',$record.event_id) ;
                        $TransSummary.ADD('internal_message_id',$record.internal_message_id) ;
                        #$TransSummary.ADD('message_id',$record.message_id) ;
                        $TransSummary.ADD('network_message_id',$record.network_message_id) ;

                        #$TransSummary.ADD('recipient_address',$record.recipient_address) ;
                        $TransSummary.RecipientAddress = $record.recipient_address ; 
                        #$TransSummary.ADD('recipient_status',$record.recipient_status) ;
                        $TransSummary.Status = $record.recipient_status ;  
                    
                        #$TransSummary.ADD('total_bytes',$record.total_bytes) ;
                        $TransSummary.ADD('recipient_count',$record.recipient_count) ;
                        $TransSummary.ADD('related_recipient_address',$record.related_recipient_address) ;
                        $TransSummary.ADD('reference',$record.reference) ;
                        #$TransSummary.ADD('message_subject',$record.message_subject) ;
                        #$TransSummary.ADD('sender_address',$record.sender_address) ;
                        #$TransSummary.SenderAddress = $record.sender_address
                        $TransSummary.ADD('return_path',$record.return_path) ;
                        $TransSummary.ADD('message_info',$record.message_info) ;
                        #$TransSummary.ADD('directionality',$record.directionality) ;
                        $TransSummary.ADD('tenant_id',$record.tenant_id) ;
                        $TransSummary.ADD('original_client_ip',$record.original_client_ip) ; # covered in base hash
                        $TransSummary.ADD('original_server_ip',$record.original_server_ip) ;
                        #$TransSummary.ADD('ToIP', $record.original_server_ip) ;
                        $TransSummary.ToIP = $record.server_ip ; 
                        $TransSummary.ADD('custom_data',$record.custom_data) ;

                    } ;

                    if($record.recipient_status.contains(";")){
                        $rcpRecs = $record.recipient_status.split(';') ; # if semi-delim'd we have multi recipients & status, split them for processing below
                    } else {
                         $rcpRecs = $record.recipient_status ; 
                    } ;  ; 
                    
                    if($ToXML){
                        if( -not $isMTDetail){
                            $RecipientStatuses=@() ; 
                            # the only one's that need expansion, are the one's delimited and with ##, all 
                            # others have a RecipientAddress & Status pulled from $record.recipient_address & 
                            # full $record.recipient_status value; 

                            #looks like non ## recipient_statu's have an entry corresponding to the number of $record.recipient_address's: [recipientAddr]:UserMailbox.Forwardable.Resolver.CreateRecipientItems.40
                            #split both and use/assign them in like order
                            if($record.recipient_status.contains(';')){
                                $rcpStatusSets = $record.recipient_status.split(';') ; 
                            } else { 
                                $rcpStatusSets = $record.recipient_status
                            } ; 
                            foreach($rcpStatusSet in $rcpStatusSets){
                                $statusRpt = [ordered]@{
                                    RecipientAddress = $null ; 
                                    Status = $null ; 
                                } ; 
                                if($rcpStatusSet.contains('##')){
                                    write-verbose "(RecipientAddress event)" ;
                                    $statusRpt.RecipientAddress =  ($rcpStatusSet -split '##')[0] ; 
                                    $statusRpt.Status = ($rcpStatusSet -split '##')[1] -split ', ' ; 
                                } else {
                                    $smsg = "MTSummary CSV that contains non-##-delimited recipient_status!"
                                    write-warning $smsg ; 
                                    throw $smsg ; 
                                    break ; 
                                    <# shouldn't have the below, all status should have ## delim ; 
                                    write-verbose "(RecipientEvent)" ;
                                    # fake the primary into the same format
                                    #$statusRpt.RecipientAddress =  $record.recipient_address ; 
                                    #$statusRpt.Status = $record.recipient_status ; 
                                    $statusRpt.RecipientAddress = $rcpRecipientSplit[$rcpRecNo] ; 
                                    $statusRpt.Status = $rcpStatusSet ; 
                                    #>
                                } ; 
                                $RecipientStatuses += New-Object PSObject -Property $statusRpt ; 
                            } ; 
                            $TransSummary.RecipientStatuses = $RecipientStatuses ; 
                        } else { 
                            # MTDetail report, has native recipient_address  & recipient_status
                            #$rcpRecipientSplit = $record.recipient_address.split(';') ; 
                            #$rcpStatusSets = $record.recipient_status.split(';') ; 
                            if($record.recipient_address.contains(';')){
                                $rcpRecipientSplit = $record.recipient_address.split(';') ; 
                            } else { 
                                $rcpRecipientSplit = $record.recipient_address ;
                            } ; 
                            if($record.recipient_status.contains(';')){
                                $rcpStatusSets = $record.recipient_status.split(';') ; 
                            } else { 
                                $rcpStatusSets = $record.recipient_status ;
                            } ; 
                            # if there's both -gt 1 recipient & -gt 1 status, do the loop, 
                            # otherwise, append the set (only reason to expand is per-recipoient status failure reporting/parsing)
                            if( ($rcpRecipientSplit|measure).count -gt 1 -AND ($rcpStatusSets|measure).count -gt 1){
                                $rcpRecNo = 0 ; 
                                foreach($rcp in $rcpRecipientSplit){
                                    $statusRpt = [ordered]@{
                                        RecipientAddress = $rcp ; 
                                        Status = $rcpStatusSets[$rcpRecNo] ; 
                                    } ; 
                                    $rcpRecNo ++ ; 
                                } ; 
                            } else { 
                                $TransSummary.RecipientAddress = $record.recipient_address ; 
                                $TransSummary.Status = $record.recipient_status ; 
                                $aggreg += New-Object PSObject -Property $TransSummary ; 
                            } ; 
                        } ; 
                        $aggreg += New-Object PSObject -Property $TransSummary ; 

                    } elseif($ToCSV){
                    
                        if( -not $isMTDetail){
                            #looks like non ## recipient_statu's have an entry corresponding to the number of $record.recipient_address's

                            if($record.recipient_status.contains(';')){
                                $rcpStatusSets = $record.recipient_status.split(';') ; 
                                [array]::Reverse($rcpStatusSets) ; # reverse the order of events, (otherwise deliver appears before receive & resolve)
                            } else { 
                                $rcpStatusSets = $record.recipient_status ;
                            } ; 
                            $index = 0 ; # we'll unpacking back into dupe message summaries with the key'd recipientaddr, one new event per logged status, assign a unique incrementing index to each
                            $TransSummary.add('index',$index) ; 
                            foreach($rcpStatusSet in $rcpStatusSets){
                                if($rcpStatusSet.contains('##')){
                                    write-verbose "(RecipientAddress event)" ;
                                    $TransSummary.RecipientAddress =  ($rcpStatusSet -split '##')[0] ; 
                                    #$statusRpt.Status = ($rcpStatusSet -split '##')[1] -split ', ' ; 
                                    foreach ($status in ($rcpStatusSet -split '##')[1] -split ', '){
                                        $index++ ;
                                        $TransSummary.index = $index ; 
                                        $TransSummary.Status = $status ;
                                        # add an entire new duped line for the status record
                                        $aggreg += New-Object PSObject -Property $TransSummary ; 
                                    } ; 
                                } else {
                                    $smsg = "MTSummary CSV that contains non-##-delimited recipient_status!"
                                    write-warning $smsg ; 
                                    throw $smsg ; 
                                    break ; 
                                } ; 
                            }

                        } else { 
                            # MTDetail report, has native recipient_address  & recipient_status
                            #$TransSummary.RecipientAddress = $rcpRecipientSplit[$rcpRecNo] ; 
                            #$TransSummary.Status = $rcpRec ; 
                            # ---
                            if($record.recipient_address.contains(';')){
                                $rcpRecipientSplit = $record.recipient_address.split(';') ; 
                            } else { 
                                $rcpRecipientSplit = $record.recipient_address ;
                            } ; 
                            if($record.recipient_status.contains(';')){
                                $rcpStatusSets = $record.recipient_status.split(';') ; 
                            } else { 
                                $rcpStatusSets = $record.recipient_status ;
                            } ; 
                            # if there's both -gt 1 recipient & -gt 1 status, do the loop, 
                            # otherwise, append the set (only reason to expand is per-recipoient status failure reporting/parsing)
                            if( ($rcpRecipientSplit|measure).count -gt 1 -AND ($rcpStatusSets|measure).count -gt 1){
                                $rcpRecNo = 0 ; 
                                foreach($rcp in $rcpRecipientSplit){
                                    #$statusRpt = [ordered]@{
                                        #RecipientAddress = $rcp ; 
                                        $TransSummary.RecipientAddress = $rcp ; 
                                        $TransSummary.Status = $rcpStatusSets[$rcpRecNo] ; 
                                    #} ; 
                                    # add a whole dupe status set for each variant 
                                    $aggreg += New-Object PSObject -Property $TransSummary ; 
                                    $rcpRecNo ++ ; 
                                } ; 
                            } else { 
                                $TransSummary.RecipientAddress = $record.recipient_address ; 
                                $TransSummary.Status = $record.recipient_status ; 
                                $aggreg += New-Object PSObject -Property $TransSummary ; 
                            } ; 
                            # ---
                            #$aggreg += New-Object PSObject -Property $TransSummary ; 
                        } ; 
                    } else { throw "neither ToCSV or ToXML specified!" } ; 
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #-=-record a STATUSWARN=-=-=-=-=-=-=
                    $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                    if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                    if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                    #-=-=-=-=-=-=-=-=
                    $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                } ; 
                
                if(-not $DoDots){
                    write-host @whBnrS -obj "$((get-date).ToString('HH:mm:ss')):$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
                } ; 
            } ; 
            if($DoDots){write-host -foregroundcolor Red "]" } ; 
            TRY{
                if($ToCSV){
                    if($ticket){
                        if(-not ($file.BaseName -match "^$($ticket)")){
                            write-host "-Ticket $($ticket) specified, and input path wasn't prefixed with Ticket#: Prefixing output filename with Ticket specified" ;
                            $pltXCsv.path = join-path -Path ($file.DirectoryName) -ChildPath "$($Ticket)-$($file.BaseName)-EXPANDED$($file.Extension)" ; 
                        } else { 
                            $pltXCsv.path = join-path -Path ($file.DirectoryName) -ChildPath "$($file.BaseName)-EXPANDED$($file.Extension)" ; 
                        } ; 
                    } else {
                        $pltXCsv.path = join-path -Path ($file.DirectoryName) -ChildPath "$($file.BaseName)-EXPANDED$($file.Extension)" ; 
                    } ; 
                    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):export-csv w`n$(($pltXCsv |out-string).trim())" ; 
                    $aggreg | export-csv @pltXCsv ;
                    write-verbose "Returning exported csv path to pipeline" ;
                    $pltXCsv.path | write-output ;
                } elseif ($ToXML){
                    if($ticket){
                        if(-not ($file.BaseName -match "^$($ticket)")){
                            write-host "-Ticket $($ticket) specified, and input path wasn't prefixed with Ticket#: Prefixing output filename with Ticket specified" ;
                            $pltXCsv.path = join-path -Path ($file.DirectoryName) -ChildPath "$($Ticket)-$($file.BaseName)-EXPANDED.xml" ; 
                        } else { 
                            $pltXCsv.path = join-path -Path ($file.DirectoryName) -ChildPath "$($file.BaseName)-EXPANDED.xml" ; 
                        } ; 
                    } ; 
                    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):export-cliXML to`n$(($opath|out-string).trim())" ; 
                    $aggreg | export-clixml -Path $opath  ;
                    write-verbose "Returning exported xml path to pipeline" ;
                    $opath | write-output ;
                } else { 

                } ; 
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                Continue
            } ;

            write-host @whBnr -obj "$((get-date).ToString('HH:mm:ss')):$($sBnr.replace('=v','=^').replace('v=','^='))" ;
        } ;  # loop-E $files
    } ; # PROC-E 
}

#*------^ convert-HistoricalSearchCSV.ps1 ^------


#*------v copy-XPermissionGroupToCloudOnly.ps1 v------
function copy-XPermissionGroupToCloudOnly {
    <#
    .SYNOPSIS
    copy-XPermissionGroupToCloudOnly.ps1 - Copy an onprem replicated Mail-Enabled Security Group, used for Mailbox Access grants, to a cloud-only EXO DistributionGroup, to grant EXO perms to foreign-hybrid multi-HCW federated objects in the tenant
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-07-13
    FileName    : copy-XPermissionGroupToCloudOnly.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 2:16 PM 6/24/2024: rem'd out #Requires -RunasAdministrator; sec chgs in last x mos wrecked RAA detection ; pulled msol too
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 2:40 PM 12/10/2021 more cleanup 
    * 3:51 PM 8/17/2021 added $MembersCloudOnly | select -unique - kept leaking in duplicates in the inputs.
    * 1:40 PM 8/11/2021 ADDED & debugged -Mailbox param (spec target of grants), and code to add-mailboxperm/add-(ad|recipient)permission to OP or EXO target mailbox, and more detailed follow up dump report. Ran against exo-mailbox wio issues. Need to dbug against a still onprem mbx next.
    * 2:19 PM 8/3/2021 step-debugged, looks functional ; init 
    .DESCRIPTION
    copy-XPermissionGroupToCloudOnly.ps1 - Copy an onprem replicated Mail-Enabled Security Group, used for Mailbox Access grants, to a cloud-only EXO DistributionGroup, to grant EXO perms to foreign-hybrid multi-HCW federated objects in the tenant
    This function comes into use when your o365 Tenant/EXO org has hybrid-federated objects. That is, one set of EXO mailboxes federated (and HCW'd) from one on-prem ActiveDirectory/Exchange org, 
    and another set of EXO mailboxes federated (and HCW'd) from *a second separate* on-prem ActiveDirectory/Exchange org. 
    If your Mailbox permission grants are generally performed via OnPrem mail-enabled security groups (which are replicated to cloud), those groups cannot properly accomodate
    Security principals in the second AD org. 
    So this function duplicates a local mail-enabled security group, as a new EXO distributiongroup, with a similar name, and the appended suffixe '_C1' 
    (n.b. in my org, all grant groups end in '-G' by policy, you'll need to tweak the name generation code below if yours lack a '-G' to target for the renames )
    The resulting EXO DG is intended to hold those SecPrincipals that can't be represented in the on-prem Org. 
    In effect you'll have one onprem DG granting permissions for locally federated SecPrins, 
    And this newly duplicated EXO DG granting permissions for externally federated SecPrins.
    .PARAMETER ticket
    ticket number[-ticket nnnnn]
    .PARAMETER SourceGroupName
    Name of on-prem replicated Exchange DistributionGroup to be copied to a cloud-only variant[-SourceGroupName somegroup]
    .PARAMETER Mailbox
    Identifier for the mailbox/mailuser object that the new group should be granted access to (generally matches target of on-prem SourceGroupName permissions grants)[-Mailbox email@domain.com]
    .PARAMETER Owner
    Identifier for the mailbox/mailuser object that will be the Owner of the new group[-Owner email@domain.com]
    .PARAMETER MembersCloudOnly
    Array of cloud-only unreplicated mailbox/mailuser designators to be added as members of the newly copied group[-MembersCloudOnly email@domain.com,email2@domain.com]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER Whatif
    Parameter to run a Test no-change pass [-Whatif switch]
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .EXAMPLE
    PS> $whatif = $true ;
        [array]$tgroups = @("627192;LYN-SEC-Email-COMPANYMobilityTeam-G;COMPANYMobilityTeam@COMPANY.com;dccoldiron@charlesmachine.works;member1@domain.com,dccoldiron@charlesmachine.works") ;
        [array]$tgroups += "123457;SIT-SEC-Email-GrantMailbox2-G;GrantMailbox2@domain.com;owner2@domain.com;member1@domain.com,member2@domain.com" ;
        foreach($tgrp in $tgroups){
            $pltCXPermGrp=[ordered]@{
                ticket = $tgrp.split(';')[0] ;
                SourceGroupName = $tgrp.split(';')[1] ;
                Mailbox = $tgrp.split(';')[2] ;
                Owner = $tgrp.split(';')[3] ;
                MembersCloudOnly = $tgrp.split(';')[4].split(',') ;
                verbose=$true ;
                whatif=$($whatif) ;
            } ;
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):copy-XPermissionGroupToCloudOnly w`n$(($pltCXPermGrp|out-string).trim())" ;
            copy-XPermissionGroupToCloudOnly @pltCXPermGrp ;
        } ; 
    Example demoing processing of an array of descriptors, as a semicolon-delimited summary of inputs (useful for stacking bulk-creations)
    Schema for the $tgroups input is "[SourceGroupName];[Mailbox];[Owner];[MembersCloudOnly array]"
    .LINK
    https://github.com/tostka/verb-exo
    .LINK
    #>
    ###Requires -Version 5
    ##Requires -Modules ActiveDirectory, MSOnline, AzureAD, ExchangeOnlineManagement, verb-AAD, verb-ADMS, verb-Ex2010, verb-Text
    # 2:49 PM 3/8/2022 pull verb-ex2010 ref - I think it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    #Requires -Modules ActiveDirectory, AzureAD, ExchangeOnlineManagement, verb-AAD, verb-ADMS, verb-Text
    ## MSOnline, 
    ##Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("(lyn|bcc|spb|adl)ms6(4|5)(0|1).(china|global)\.ad\.COMPANY\.com")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    ##[Alias('somealias')]
    PARAM(
        [Parameter(Mandatory=$true,HelpMessage="ticket number[-ticket nnnnn]")]
        $ticket, 
        [Parameter(Mandatory=$true,HelpMessage="Name of on-prem replicated Exchange DistributionGroup to be copied to a cloud-only variant[-SourceGroupName somegroup]")]
        $SourceGroupName, 
        [Parameter(Mandatory=$true,HelpMessage="Identifier for the mailbox/mailuser object that the new group should be granted access to (generally matches target of on-prem SourceGroupName permissions grants)[-Mailbox email@domain.com]")]
        $Mailbox, 
        [Parameter(Mandatory=$true,HelpMessage="Identifier for the mailbox/mailuser object that will be the Owner of the new group[-Owner email@domain.com]")]
        $Owner, 
        [Parameter(Mandatory=$true,HelpMessage="Array of cloud-only unreplicated mailbox/mailuser designators to be added as members of the newly copied group[-MembersCloudOnly email@domain.com,email2@domain.com]")]
        [array]$MembersCloudOnly, 
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
        [switch] $whatIf
    ) ;
    BEGIN{
        $Verbose = ($VerbosePreference -eq 'Continue') ; 
        $propsdg = 'SamAccountName','ManagedBy','AcceptMessagesOnlyFrom','AcceptMessagesOnlyFromDLMembers','AddressListMembership',
            'Alias','DisplayName','EmailAddresses','ExternalDirectoryObjectId','HiddenFromAddressListsEnabled','EmailAddressPolicyEnabled',
            'PrimarySmtpAddress','RecipientType','RecipientTypeDetails','WindowsEmailAddress','Name','DistinguishedName','WhenChanged','WhenCreated'; 
        $rgxMbxPermLocal = '^(S-\d-\d-\d{2}-\d{10}-\d{9}-\d{10}-\d{5}|NT\sAUTHORITY\\SELF)' ;
        $propsmbxperm = 'User','AccessRights','IsInherited','Deny';
        $propsrcpperm = 'trustee','AccessRights','IsInherited','Deny';
        $propsadperm = 'User','AccessRights','ExtendedRights','IsInherited','Deny';

        connect-AD -Verbose:$false | out-null ; 
        rx10 -Verbose:$false ; rxo  -Verbose:$false ; #cmsol  -Verbose:$false ;
        
    } 
    PROCESS{
        # check ExternalDirectoryObjectId to ensure unfederated
        $sBnr="===v $($SourceGroupName) - $($Owner) v===" ;
        $smsg = $sBnr ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $smsg = "==Checking for existing:$($SourceGroupName)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        <# New-exoDistributionGroup -ModeratedBy -RequireSenderAuthenticationEnabled -ModerationEnabled -DisplayName -Confirm -MemberDepartRestriction -IgnoreNamingPolicy -RoomList -HiddenGroupMembershipEnabled -BypassNestedModerationEnabled -CopyOwnerToMember -BccBlocked -Members -MemberJoinRestriction -Type -Alias -ManagedBy -WhatIf -PrimarySmtpAddress -SendModerationNotifications -Notes -OrganizationalUnit -Name -AsJob 
        Set-exoDistributionGroup -HiddenFromAddressListsEnabled
        New-exoDistributionGroup -DisplayName -Name -Members -Type -Alias -PrimarySmtpAddress -ManagedBy -WhatIf -Notes -whatif ; 
        -ManagedBy "Name|Display name|Alias|Distinguished name (DN)|Canonical DN|<domain name>\<account name>|Email address|GUID|LegacyExchangeDN|SamAccountName|User ID or user principal name (UPN)"
        Set-exoDistributionGroup -EmailAddresses -RejectMessagesFromDLMembers -AcceptMessagesOnlyFromSendersOrMembers -AcceptMessagesOnlyFromDLMembers -SimpleDisplayName -MailTip -GrantSendOnBehalfTo -AcceptMessagesOnlyFrom -RejectMessagesFromSendersOrMembers -Alias -DisplayName -ManagedBy -PrimarySmtpAddress -Name -whatif ;
        #>
        if($dg = get-distributiongroup -id $SourceGroupName){
            $tdgName = $dg.Name.replace('-G','-G_C1') ; 
            $nameClean=Remove-StringDiacritic -string $tdgName ;
            $nameClean= Remove-StringLatinCharacters -string $nameClean ;
            $samaccountname=$( ([System.Text.RegularExpressions.Regex]::Replace($nameClean,"[^1-9a-zA-Z_]","").tostring().substring(0,[math]::min([System.Text.RegularExpressions.Regex]::Replace($nameClean,"[^1-9a-zA-Z_]","").tostring().length,20))).toLower() )  ;
            $samaccountname = "$($samaccountname)-$((new-guid).guid.split('-')[0])-C1" ;
            $smsg = "Resolving potential members:`n$(($MembersCloudOnly| select -unique | sort | out-string).trim())" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $rmbrs = $MembersCloudOnly | select -unique | sort |foreach-object {get-exorecipient -id $_} | select -expand primarysmtpaddress ; 
            $pltNxDG=[ordered]@{
                Notes="$((get-group -id ($dg.alias)).notes),$($ticket) for $($Owner)(Cloud-only replica of on-prem group)" ;
                DisplayName=$tdgName ;
                Name=$tdgName ;
                ManagedBy= $Owner ;
                Members = $rmbrs ; 
                Alias=$samaccountname  ;
                RequireSenderAuthenticationEnabled=$true ; 
                Type = 'Security' ; 
                whatif=$($whatif) ;
                ErrorAction='STOP';
            } ;

            $pltSxDG=[ordered]@{
                identity = $null; 
                HiddenFromAddressListsEnabled=$true;
                whatif=$($whatif) ;
                ErrorAction='STOP';
            } ;
            $smsg = "==Checking for existing:$($tdgName)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            if($xdg = get-exodistributiongroup -id $pltNxDG.DisplayName -ea 0){
                $smsg = "(confirmed existing Dname:'$($xdg.DisplayName)'" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }     else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $smsg = "$((get-date).ToString('HH:mm:ss')):xDG:NotFound:$($tgrpName)`nCreating missing SecGrp" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            
                $smsg = "new-exodistributiongroup  w`n$(($pltNxDG|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                TRY {
                    $xdg = new-exodistributiongroup  @pltNxDG ;
                    # $xdg captures equiv to get-distibutiongroup 
                    $smsg = "Result:`n$(($xdg|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } CATCH {
                    $smsg = "Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Continue ;
                } ;
            } ;
            if(!$whatif){
                $pltSxDG.identity = $xdg.primarysmtpaddress ; 
                $smsg = "set-exodistributiongroup w`n$(($pltSxDG|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                TRY {
                    set-exodistributiongroup @pltSxDG ;
                    $pxdg = get-exodistributiongroup -id $pltNxDG.DisplayName ;
                    $pxDGm = get-exodistributiongroupmember -id $pltNxDG.DisplayName ;
                } CATCH {
                    $smsg = "Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Continue ;
                } ;

                if($tmbxr = get-recipient -id $Mailbox -ea 0 ){
                    $smsg = "(-Mailbox:$($tmbxr.PrimarySmtpAddress) specified, adding $($xdg.name) to it's permissions...)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    TRY {
                        # aliased ExOP|EXO|EXOv2 cmdlets (permits simpler single code block for any of the three variants of targets & syntaxes)
                        # each is '[aliasname];[exOPcmd];[exOcmd] (xOv2cmd is converted from [exocmd])
                        [array]$cmdletMaps= 'ps1GetMbx;get-mailbox;get-exomailbox','ps1SetMbx;Set-Mailbox;Set-exoMailbox','ps1GetMUsr;Get-MailUser;Get-exoMailUser',
                                            'ps1SetMUsr;Set-MailUser;Set-exoMailUser','ps1AddMbxPrm;Add-MailboxPermission;Add-exoMailboxPermission;',
                                            'ps1GetMbxPrm;Get-MailboxPermission;Get-exoMailboxPermission;','ps1RmvMbxPrm;Remove-MailboxPermission;Remove-exoMailboxPermission;',
                                            'ps1AddRcpPrm;Add-ADPermission;Add-exoRecipientPermission;','ps1GetRcpPrm;Get-ADPermission;Get-exoRecipientPermission;',
                                            'ps1RmvRcpPrm;Remove-ADPermission;Remove-exoRecipientPermission;'
                        $OpRcp=$tmbxr ;
                        $pltRXO = [ordered]@{
                            credential =  $credO365TORSID ;
                            Verbose = $($VerbosePreference -eq 'Continue');
                        } ; 
                        reconnect-exo @pltRXO ;
                        foreach($cmdletMap in $cmdletMaps){
                            switch ($OpRcp.recipienttype){
                                "MailUser" {
                                    $iIndex = 2 ;
                                    if($script:useEXOv2){
                                        reconnect-eXO2 @pltRXO ; 
                                        if(!($cmdlet= Get-Command $cmdletMap.split(';')[$iIndex ].replace('-exo','-xo') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                                        $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                                        write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                                    } else {
                                        reconnect-exo @pltRXO ;
                                        if(!($cmdlet= Get-Command $cmdletMap.split(';')[$iIndex ])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                                        $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                                        write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                                    } ;
                                }
                                "UserMailbox" { 
                                    $iIndex = 1 ;
                                    reconnect-ex2010 ;
                                    if(!($cmdlet= Get-Command $cmdletMap.split(';')[$iIndex ])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                                    $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                                    write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                                }
                                default { throw "Unrecognized recipienttype!:$($OpRcp.recipienttype)" }
                            } ; 
                        } ; 
                        
                        # exo mbx, need to flip to exo rcp, if we're going to get a functional DN for recipientperms cmds: pull the actual mbx instead of rcp (which provided RecipientType to steer balance)
                        $pltGmbx=[ordered]@{
                            Identity=$tmbxr.PrimarySmtpAddress ; 
                            ErrorAction='STOP' ;};

                        $smsg = "$((get-alias ps1GetMbx).definition) w`n$(($pltGmbx|out-string).trim())" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $tmbxr = ps1GetMbx @pltGmbx ; 
                        
                        $pltAMP=[ordered]@{
                            Identity=$tmbxr.PrimarySmtpAddress ; 
                            User=$pxdg.primarysmtpaddress ; 
                            AccessRights="FullAccess";
                            confirm = $false ; # suppress prompts
                            ErrorAction='STOP' ;
                            whatif=$($whatif);};

                        $pltARP=@{
                            identity=$tmbxr.DistinguishedName ; 
                            trustee=$pxdg.primarysmtpaddress ;
                            AccessRights="SendAs" ;
                            confirm = $false ; # suppress prompts
                            ErrorAction='STOP' ;
                            whatif=$($whatif);}; 
                        # SendAs perms target user onprem, trustee in exo:
                        $smsg = "$((get-alias ps1GetMbxPrm).definition) -Identity $($pltAMP.Identity) | `n?{`$_.user -eq '$($pxdg.name)' -AND `$_.AccessRights -eq '$($pltARP.AccessRights)'}" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        if($mbxperm = ps1GetMbxPrm -Identity $pltAMP.Identity | ?{$_.user -eq $pxdg.name -AND $_.AccessRights -eq $pltAMP.AccessRights}){
                            $smsg = "($($pdxg.name) already granted $($pltAMP.AccessRights) perms on $($pltAMP.identity))" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } else {
                            $smsg = "$((get-alias ps1AddMbxPrm).definition) w`n$(($pltAMP|out-string).trim())" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $xmp = ps1AddMbxPrm @pltAMP ;
                        } ; 
                        $mbxperm = ps1GetMbxPrm -Identity $pltAMP.Identity -user $pltAMP.user ; 
                        $smsg = "$((get-alias ps1GetMbxPrm).definition):`n$(($mbxperm|ft -wrap $propsmbxperm |out-string).trim())" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        switch ($OpRcp.recipienttype){
                                "MailUser" {
                                    $pltARP.identity = $tmbxr.distinguishedname ; 
                                    $smsg = "$((get-alias ps1GetRcpPrm).definition) -Identity $($pltARP.Identity) | `n?{`$_.trustee -eq '$($pxdg.name)' -AND `$_.AccessRights -eq '$($pltARP.AccessRights)'}" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    if($rcpperm = ps1GetRcpPrm -Identity $pltARP.Identity | ?{$_.trustee -eq $pxdg.name -AND $_.AccessRights -eq $pltARP.AccessRights}){
                                        $smsg = "(Trustee:$($pxdg.name) already granted AccessRights:$($pltARP.AccessRights) perms on `n$($pltARP.identity))" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    } else {
                                        $smsg = "$((get-alias ps1AddRcpPrm).definition) w`n$(($pltARP|out-string).trim())" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        $xmp = ps1AddRcpPrm @pltARP ;
                                    } ; 
                                    $rcpperm= ps1GetRcpPrm -Identity $pltARP.Identity -Trustee $pltARP.trustee -errorAction STOP ; 
                                    $smsg = "$((get-alias ps1GetRcpPrm).definition):`n$(($rcpperm|ft -wrap $propsrcpperm |out-string).trim())" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                } ;
                                "UserMailbox" { 
                                    $pltARP.remove('AccessRights') ; 
                                    $pltARP.add('ExtendedRights','Send As') ; 
                                    $pltARP.identity = $tmbxr.distinguishedname ; 
                                    $smsg = "$((get-alias ps1GetRcpPrm).definition) -Identity $($pltARP.Identity) | ?{`$_.user -eq '$($pxdg.name)' -AND `$_.ExtendedRights -eq '$($pltARP.AccessRights)'}" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    if($rcpperm = ps1GetRcpPrm -Identity $pltARP.Identity | ?{$_.user -eq $pxdg.name -AND $_.ExtendedRights -eq $pltARP.AccessRights}){
                                        $smsg = "($($pdxg.name) already granted $($pltARP.AccessRights) perms on $($pltARP.identity))" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    } else {
                                        $smsg = "$((get-alias ps1AddRcpPrm).definition) w`n$(($pltARP|out-string).trim())" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        $xmp = ps1AddRcpPrm @pltARP ;
                                    } ; 
                                    $rcpperm= $rcpperm = ps1GetRcpPrm -Identity $pltARP.Identity | ?{$_.user -eq $pxdg.name -AND $_.ExtendedRights -eq $pltARP.AccessRights} ; 
                                    $smsg = "$((get-alias ps1GetRcpPrm).definition) w`n$(($rcpperm|ft -wrap $propsadperm |out-string).trim())" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    # set common props for final report
                                    $propsrcpperm = $propsadperm ; 
                                } ;
                        } ;  # switch-E

                    } CATCH {
                        $smsg = "Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Continue ;
                    } ;


                } else { 
                    $smsg = "(No -Mailbox specified, slipping $($xdg.name) permissions grant...)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;
                

                $hMsg = @"

*------v REVIEW RESULTS v------

POST:exodistributiongroup
-----------
$(($pxdg|fl $propsdg|out-string).trim())
-----------

Members:
-----------
$(($pxDGm.PrimarySmtpAddress|out-string).trim())
-----------
"@ ; 

            if($Mailbox){
                $hMsg += "Associated Mailbox Permissions:`n$(($mbxperm|ft -wrap $propsmbxperm |out-string).trim())`n`n" ;     

                $hMsg += "Associated Recipient Permissions:`n$(($rcpperm|ft -wrap $propsrcpperm  |out-string).trim())`n`n" ; 
            } ;
            $hMsg += "*------^ REVIEW RESULTS ^------`n" ; 

            $smsg = $hMsg ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            } else {
                $smsg = "(-whatif detected, skipping:set-exodistributiongroup @pltNxDG" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
        } else { 
            $smsg = "Unable to get-distributiongroup -id $($SourceGroupName) ; aborting!" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ;
        $smsg = $sBnr.replace('=v','=^').replace('v=','^=') ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        
    }
    END{}
 }

#*------^ copy-XPermissionGroupToCloudOnly.ps1 ^------


#*------v cxotol.ps1 v------
function cxoTOL {
    <#
    .SYNOPSIS
    cxoTOL - wrapper for Connect-EXO to connect to specified Tenant
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-07-29
    FileName    : cxoTOL.ps1
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    REVISIONS   :
    * 11:32 AM 4/18/2023 alias into cxotol, retiring
    .DESCRIPTION
    cxoTOL - wrapper for Connect-EXO to connect to specified Tenant
    .EXAMPLE
    cxoTOL
    #>
    [CmdletBinding()]
    [Alias('cxo2cmw' )]
    PARAM()
    Connect-EXO -cred $credO365TOLSID -Verbose:$($VerbosePreference -eq 'Continue') ; 
}

#*------^ cxotol.ps1 ^------


#*------v cxotor.ps1 v------
function cxoTOR {
    <#
    .SYNOPSIS
    cxoTOR - wrapper for Connect-EXO to connect to specified Tenant
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-07-29
    FileName    : cxoTOR.ps1
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    REVISIONS   :
    * 11:32 AM 4/18/2023 alias into cxoTOR, retiring
    .DESCRIPTION
    cxoTOR - wrapper for Connect-EXO to connect to specified Tenant
    .EXAMPLE
    cxoTOR
    #>
    [CmdletBinding()]
    [Alias('cxo2cmw' )]
    PARAM()
    Connect-EXO -cred $credO365TORSID -Verbose:$($VerbosePreference -eq 'Continue') ; 
}

#*------^ cxotor.ps1 ^------


#*------v Disconnect-EXO.ps1 v------
Function Disconnect-EXO {
    <#
    .SYNOPSIS
    Disconnect-EXO - Remove all the existing exchange online connections (incl EMOv1/2 PSSessions & EOM3+ nonWinRM - closes anything ConfigurationName: Microsoft.Exchange -AND Name: ExchangeOnlineInternalSession*)
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-03-03
    FileName    : 
    License     : 
    Copyright   : 
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    AddedCredit : ExactMike Perficient
    AddedWebsite:	https://social.technet.microsoft.com/Forums/msonline/en-US/f3292898-9b8c-482a-86f0-3caccc0bd3e5/exchange-powershell-monitoring-remote-sessions?forum=onlineservicesexchange
    AddedTwitter:	
    REVISIONS   :
    * 11:31 AM 7/9/2024 subd in silent for write-verbose 
    * 1:25 PM 7/8/2024 spliced in cxo constatns
    * 9:47 am 4/9/2024:validated updated disconnect-exo -prefix cc -verbose ; 
    * 10:59 AM 4/18/2023 step debugs ; consolidating Disconnect-EXO2 into Disconnect-EXO, aliasing dxo2,Disconnect-EXO2; removing those originals
    * 2:02 PM 4/17/2023 rev: $MinNoWinRMVersion from 2.0.6 => 3.0.0.
    * 12:42 PM 4/17/2023 restored *dxo* 7/26/21 vers; had overwritten on 3/29/22 wiith a copy of dxo2! Needs a verb-exo rebuild to complete.
    * 11:02 AM 4/4/2023 reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not; 
    add $exov3Good and diff EMOv2 from EMOv3 sessions.
    * 3:14 pm 3/29/2023: REN'D $modname => $EOMModName
    * 3:59 PM 8/2/2022 got through dbugging EOM v205 SID interactive pass, working ; added -MinNoWinRMVersion ; fully works from mybox w v206p6, cEOM connection, with functional prefix.
    * 4:07 PM 7/26/2022 found that MS code doesn't chk for multi vers's installed, when building .dll paths: wrote in code to take highest version.
    * 3:30 PM 7/25/2022 tests against CBA & SID interactive creds on EOM v205, need to debug now against EOM v206p6, to accomodate PSSession-less connect & test code.
    * 10:34 AM 4/4/2022 updated CBH; added -MinimumVersion, defaulted, to support on-the-fly exemption
    * 3:54 PM 4/1/2022 add missing $silent param (had support, but no param)
    * 3:03 PM 3/29/2022 rewrote to reflect current specs in v2.0.5 of ExchangeOnlineManagement:Disconnect-ExchangeOnlineManagement cmds
    # here down is dxo orig revs
    * 11:54 AM 3/31/2021 added verbose suppress on remove-module/session commands
    * 1:14 PM 3/1/2021 added color reset
    * 3:24 PM 7/24/2020 updated to support tenant-alignment & sub'd out showdebug for verbose
    * 11:50 AM 5/27/2020 added alias:dxo win func
    * 2:34 PM 4/20/2020 added local $rgxExoPsHostName
    * 8:45 AM 3/3/2020 public cleanup
    * 9:52 AM 11/20/2019 reviewed for credential matl, no way to see the credential on a given pssession, so there's no way to target and disconnect discretely. It's a shotgun close.
    # 10:27 AM 6/20/2019 switched to common $rgxExoPsHostName
    # 1:12 PM 11/7/2018 added Disconnect-PssBroken
    # 11:23 AM 7/10/2018: made exo-only (was overlapping with CCMS)
    # 8:47 AM 6/2/2017 cleaned up deadwood, simplified pshelp
    * 8:49 AM 3/15/2017 Disconnect-EXO: add Remove-PSTitleBar 'EXO' to clean up on disconnect
    * 2/10/14 posted version
    .DESCRIPTION
    Disconnect-EXO - Remove all the existing exchange online connections (incl EMOv1/2 PSSessions & EOM3+ nonWinRM - closes anything ConfigurationName: Microsoft.Exchange -AND Name: ExchangeOnlineInternalSession*)
    Updated to match v2.0.5 of ExchangeOnlineMangement: Unlike the  v1.0.1 'disconnect', 
    this also implements new Clear-ActiveToken support, to reset the token as well as the session. 
    Doesn't support targeting session id, just wacks all sessions matching the configurationname & name of an EXOv2 pssession.
    .PARAMETER  Prefix
    [verb]-PREFIX[command] PREFIX string for clearly marking cmdlets sourced in this connection [-Prefix tag]
    PARAMETER MinimumVersion
    MinimumVersion required for ExchangeOnlineManagement module (defaults to '2.0.5')[-MinimumVersion '2.0.6']
    .PARAMETER MinNoWinRMVersion
    MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']
    .PARAMETER silent
    Switch to suppress all non-error echos
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    Disconnect-EXO;
    Disconnect all EXOv2 ConfigurationName: Microsoft.Exchange -AND Name: ExchangeOnlineInternalSession* pssession
    .EXAMPLE
    Disconnect-EXO -silent;
    Demos use of the silent parameter to suppress output of details
    .LINK
    Github      : https://github.com/tostka/verb-exo
    #>
    [CmdletBinding()]
    [Alias('dxo','dxo2','Disconnect-EXO2')]
    Param(
        [Parameter(HelpMessage = "[verb]-PREFIX[command] PREFIX string for clearly marking cmdlets sourced in this connection [-Prefix tag]")]
            [string]$Prefix = 'xo',
        [Parameter(HelpMessage = "MinimumVersion required for ExchangeOnlineManagement module (defaults to '2.0.5')[-MinimumVersion '2.0.6']")]
            [version] $MinimumVersion = '2.0.5',
        [Parameter(HelpMessage = "MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']")]
            [version] $MinNoWinRMVersion = '3.0.0',
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent

    ) 
    $verbose = ($VerbosePreference -eq "Continue") ; 
    
    #*------v PSS & GMO VARIS v------
    # move into a param
    #$MinNoWinRMVersion = '3.0.0' ; 
    # get-pssession session varis
    # select key differentiating properties:
    $pssprops = 'Id','ComputerName','ComputerType','State','ConfigurationName','Availability', 
        'Description','Guid','Name','Path','PrivateData','RootModuleModule', 
        @{name='runspace.ConnectionInfo.ConnectionUri';Expression={$_.runspace.ConnectionInfo.ConnectionUri} },  
        @{name='runspace.ConnectionInfo.ComputerName';Expression={$_.runspace.ConnectionInfo.ComputerName} },  
        @{name='runspace.ConnectionInfo.Port';Expression={$_.runspace.ConnectionInfo.Port} },  
        @{name='runspace.ConnectionInfo.AppName';Expression={$_.runspace.ConnectionInfo.AppName} },  
        @{name='runspace.ConnectionInfo.Credentialusername';Expression={$_.runspace.ConnectionInfo.Credential.username} },  
        @{name='runspace.ConnectionInfo.AuthenticationMechanism';Expression={$_.runspace.ConnectionInfo.AuthenticationMechanism } },  
        @{name='runspace.ExpiresOn';Expression={$_.runspace.ExpiresOn} } ; 
    $EOMmodname = 'ExchangeOnlineManagement' ;
    $EXOv1ConfigurationName = $EXOv2ConfigurationName = $EXoPConfigurationName = "Microsoft.Exchange" ;
    if(-not (gv EXOv1ComputerName -ea 0 )){$EXOv1ComputerName = 'ps.outlook.com' };
    if(-not (gv EXOv1runspaceConnectionInfoAppName -ea 0 )){$EXOv1runspaceConnectionInfoAppName = '/PowerShell-LiveID'  };
    if(-not (gv EXOv1runspaceConnectionInfoPort -ea 0 )){$EXOv1runspaceConnectionInfoPort = '443' };

    if(-not (gv EXOv2ComputerName -ea 0 )){$EXOv2ComputerName = 'outlook.office365.com' ;}
    if(-not (gv EXOv2Name -ea 0 )){$EXOv2Name = "ExchangeOnlineInternalSession*" ; }
    #if(-not (gv rgxEXoPrunspaceConnectionInfoAppName -ea 0 )){$rgxEXoPrunspaceConnectionInfoAppName = '^/(exadmin|powershell)$'}; 
    #if(-not (gv EXoPrunspaceConnectionInfoPort -ea 0 )){$EXoPrunspaceConnectionInfoPort = '80' } ; 
    # gmo varis
    #if(-not (gv rgxExoPsHostName -ea 0 )){ $rgxExoPsHostName = "^(ps\.outlook\.com|outlook\.office365\.com)$" } ;
    #if(-not (gv rgxEXOv1gmoDescription -ea 0 )){$rgxEXOv1gmoDescription = "^Implicit\sremoting\sfor\shttps://ps\.outlook\.com/PowerShell" }; 
    #if(-not (gv EXOv1gmoprivatedataImplicitRemoting -ea 0 )){$EXOv1gmoprivatedataImplicitRemoting = $true };
    #if(-not (gv rgxEXOv2gmoDescription -ea 0 )){$rgxEXOv2gmoDescription = "^Implicit\sremoting\sfor\shttps://outlook\.office365\.com/PowerShell" }; 
    #if(-not (gv EXOv2gmoprivatedataImplicitRemoting -ea 0 )){$EXOv2gmoprivatedataImplicitRemoting = $true } ;
    #if(-not (gv rgxExoPsessionstatemoduleDescription -ea 0 )){$rgxExoPsessionstatemoduleDescription = '/(exadmin|powershell)$' };
    #if(-not (gv EXOv2StateOK -ea 0 )){$EXOv2StateOK = 'Opened'} ; 
    #if(-not (gv EXOv2AvailabilityOK -ea 0 )){$EXOv2AvailabilityOK = 'Available'} ; 
    #if(-not (gv EXOv2RunStateBad -ea 0 )){ $EXOv2RunStateBad = 'Broken'} ;
    #if(-not (gv EXOv1GmoFilter -ea 0 )){$EXOv1GmoFilter = 'tmp_*' } ; 
    if(-not (gv EXOv2GmoNoWinRMFilter -ea 0 )){$EXOv2GmoNoWinRMFilter = 'tmpEXO_*' };
    # add get-connectioninformation.ConnectionURI targeting rgxs for CCMS vs EXO
    if(-not $rgxConnectionUriEXO){$rgxConnectionUriEXO = 'https://outlook\.office365\.com'} ; 
    if(-not $rgxConnectionUriEXO){$rgxConnectionUriCCMS = 'https://ps\.compliance\.protection\.outlook\.com'} ; 
    $sTitleBarTag = @("EXO2") ;
    #*------^ END PSS & GMO VARIS ^------

    $pssProps = 'Id','Name','ComputerType','ComputerName','ConfigurationName','State','Availability',
        @{name="TokenExpiryTime";expression={get-date $_.TokenExpiryTime.date -format 'yyyyMMdd-HHmmtt'}};
    
    # disable prefix spec, unless actually blanked (e.g. centrally spec'd in profile).
    if (-not $Prefix) {
        $Prefix = 'xo' ; # 4:31 PM 7/29/2020 MS has RESERVED use of the 'exo' prefix [facepalm]
        #$Prefix = 'cc' ; # ccms variant
        $smsg = "(asserting Prefix:$($Prefix)" ;
        if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
    } ;
    if (($Prefix) -and ($Prefix -eq 'EXO')) {
        throw "Prefix 'EXO' is a reserved Prefix, please use a different prefix."
    }
    if($Prefix -eq 'cc'){
        # build in hybrid xo & ccms support, switch on the prefix spec
        $useCCMSConn = $true ; 
    }; 
    if($useCCMSConn){
        # respec userrole
        $UserRole = @('SID') ; 
        $sTitleBarTag = @("CCMS") ;
    } ; 

    # it's pulling the verb-EXO vers of disconnect-exchangeonline, force load the v206:
    #region EOMREV ; #*------v EOMREV Check v------
    # reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not
    $pltIMod = @{Name = $EOMmodname ; ErrorAction = 'Stop' ; verbose=$false} ;
    if($xmod = Get-Module $EOMmodname -ErrorAction Stop| sort version | select -last 1 ){ } else {
        $smsg = "Import-Module w`n$(($pltIMod|out-string).trim())" ;
        if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        Try {
            Import-Module @pltIMod | out-null ;
            $xmod = Get-Module $EOMmodname -ErrorAction Stop | sort version | select -last 1 ;
        } Catch {
            $ErrTrapd=$Error[0] ;
            $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $smsg = $ErrTrapd.Exception.Message ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break ;
        } ;
    } ; # IsImported
    if([version]$xmod.version -ge $MinNoWinRMVersion){
        $MinNoWinRMVersion = $xmod.version.tostring() ;
        $IsNoWinRM = $true ; 
    }
    [boolean]$UseConnEXO = [boolean]([version]$xmod.version -ge $MinNoWinRMVersion) ; 
    #endregion EOMREV ; #*------^ END EOMREV Check  ^------
    if($useConnExo){
        # 2:28 PM 8/1/2022 issue: it sometimes defers to the verb-EXO obsolete disconnect-exchangeonline (which doesn't properly resolve .dll paths, and doesn't exist/conflict in EOMv205), force load it out of the module
        if(-not (get-command -mod $EOMmodname -name Disconnect-ExchangeOnline -ea 0 )){
            $smsg = "(found dxo2, *not* sourced from EOM: ipmo -forcing EOM)" ; 
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            import-module -Name $EOMmodname -force -RequiredVersion $MinNoWinRMVersion ; 
        } ; 

        # just alias disconnect-ExchangeOnline, it retires token etc as well as closing PSS, but biggest reason is it's got a confirm, hard-coded, needs a function to override
        # flip back to the old d-eom call.

        if($xmod | where-object {$_.version -ge $MinNoWinRMVersion} ){
            $smsg = "EOM v3+ connection detected" ;
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            TRY{
                $conns = Get-ConnectionInformation -ea STOP ;
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ;
                BREAK ;
            } ;
            if($Prefix){
                $conns = $conns | ?{$_.ModulePrefix -eq $Prefix} ;
            } ;
            switch -regex ($conns.ConnectionUri){
                $rgxConnectionUriEXO {
                    if ($conns.tokenStatus -eq 'Active') {
                        $smsg = "(connected to EXO)" ;
                        if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        $bExistingEXOGood = $isEXOValid = $true ;
                    } ;
                }
                $rgxConnectionUriCCMS {
                    if ($conns.tokenStatus -eq 'Active') {
                        $smsg = "(connected to CCMS)" ;
                        if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        $bExistingCCMSGood = $isCCMSValid = $true ;
                    } ;
                }
                default {
                    $bExistingEXOGood = $isEXOValid = $bExistingCCMSGood = $isCCMSValid = $FALSE
                }
            } ;
        }
        # you can use -ConnectionID or -ModulePrefix, but not both, we've already filtered w connid, so use it
        $pltDXO=[ordered]@{
            #ModulePrefix = $Prefix ;
            confirm = $false ;
            erroraction = 'STOP' ;
            whatif = $($whatif) ;
        } ;
        #$prpConnInf = 'ConnectionId','ConnectionUri','State','TokenStatus' ; 
        if($xmod | where-object {$_.version -ge $MinNoWinRMVersion } ){
            if($conns.ConnectionID){
                $pltDXO.add('ConnectionId',$conns.ConnectionID)
                $smsg = "targeting filtered ConnectionID:$($conns.ConnectionID)`n$(($conns | ft -a $prpConnInf |out-string).trim())" ; 
                if($silent){}elseif($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            } ; 
        } ; 
        if ($conns) {
            $smsg = "Disconnect-ExchangeOnline w`n$(($pltDXO|out-string).trim())" ;
            if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            Disconnect-ExchangeOnline @pltDXO ;
            #Disconnect-ExchangeOnline -confirm:$false ; 
            # just use the updated RemoveExistingEXOPSSession
            #PRIOR: RemoveExistingEXOPSSession -Verbose:$false ;
            # v2.0.5 3:01 PM 3/29/2022 no longer exists
        } else { 
            $smsg = "(no existing session matched)" ; 
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; 
    } else { 
        $smsg = "(EXOv2 EOM v205 nonWinRM code in use...)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $smsg = "EXOv2 EOM v205 and below are NO LONGER SUPPORTED!" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        THROW $SMSG ; 
        BREAK ; 
    } ; 
    # poll session types
    $existingPSSession = Get-PSSession | 
        Where-Object {$_.ConfigurationName -like "Microsoft.Exchange" -and $_.Name -like "ExchangeOnlineInternalSession*"} ;
    if ($existingPSSession.count -gt 0) {
        for ($index = 0; $index -lt $existingPSSession.count; $index++){
            $session = $existingPSSession[$index]
            $smsg = "Remove-PSSession w`n$(($session | format-table -a  $pssprops|out-string).trim())" ; 
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            Remove-PSSession -session $session
            $smsg = "Removed the PSSession $($session.Name) connected to $($session.ComputerName)"
            if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # Remove any active access token from the cache
            $pltCAT=[ordered]@{
                TokenProvider=$session.TokenProvider ; 
            } ;
            if(get-command Clear-ActiveToken -ea 0){
                $smsg = "Clear-ActiveToken w`n$(($pltCAT|out-string).trim())" ; 
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                Clear-ActiveToken @pltCAT ;
            } ; 
            # Remove any previous modules loaded because of the current PSSession
            if ($session.PreviousModuleName -ne $null){
                if ((Get-Module $session.PreviousModuleName).Count -ne 0){
                    Remove-Module -Name $session.PreviousModuleName -ErrorAction SilentlyContinue
                }
                $session.PreviousModuleName = $null
            } ; 
            # Remove any leaked module in case of removal of broken session object
            if ($session.CurrentModuleName -ne $null){
                if ((Get-Module $session.CurrentModuleName).Count -ne 0){
                    Remove-Module -Name $session.CurrentModuleName -ErrorAction SilentlyContinue ; 
                } ;  
            }  ; 
        } ;  # loop-E
    } ; # if-E $existingPSSession.count -gt 0
    
    #Disconnect-PssBroken -verbose:$false ;
    Remove-PSTitlebar $sTitleBarTag #-verbose:$($VerbosePreference -eq "Continue");
    #[console]::ResetColor()  # reset console colorscheme
}

#*------^ Disconnect-EXO.ps1 ^------


#*------v get-AADlicensePlanList.ps1 v------
function get-AADlicensePlanList {
    <#
    .SYNOPSIS
    get-AADlicensePlanList - Resolve Get-AzureADSubscribedSku into an indexed hash of Tenant License detailed specs
    .NOTES
    Version     : 1.0.0.1
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-08-10
    FileName    : get-AADlicensePlanList
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/
    REVISIONS
    * 1:20 PM 6/18/2024 fixed credential code, spliced over code to resolve creds, and assign to $Credential
    * 2:33 PM 5/17/2023 added cred/silent/pltrxo support; 
    * 3:19 PM 5/15/2023 get-AADlicensePlanList() works w latest aad/exo-eom updates
    * 12:54 PM 3/24/2022 added addition of resolved 'friendlyname' (via verb-aad:get-AADLicenseFullName), to the datatable returned, when in NON-Raw mode
    * 4:37 PM 3/23/2022 rem'd spurious managedby param
    * 9:31 AM 3/22/2022 add: 
        -raw (returns raw property outputs, vs default which is now a summarized table closer to *useful* get-MsolAccountSku output:
        -indexonName indexed-hash keyed on 'Name' (SkuPartNumber), vs default hash-keyed on SkuID values (for sku->name/details lookups, vs name->Sku lookups)
        - updated CBH with examples on above
    * 2:27 PM 3/1/2022 updated CBH
    * 8:34 AM 2/28/2022 updated CBH example1, added conditional ordered to hash, defaulted Cred to a global varia
    * 11:05 AM 9/16/2021 fixed Examples to functional 
    * 2:06 PM 10/12/2020 ported to verb-AAD
    * 9:03 AM 8/10/2020 init
    .DESCRIPTION
    get-AADlicensePlanList - Resolve Get-AzureADSubscribedSku into an indexed hash of Tenant License detailed specs
    .PARAMETER Raw
    Switch specifies to return the raw get-AADlicensePlanList properties, indexed on SkuID
    .PARAMETER IndexOnName
    Switch specifies to return the raw get-AADlicensePlanList properties, indexed on Name (for name -> details/skuid lookups; default is indexed on SkuID for sku->details/name lookups)
     .PARAMETER  Credential
    Credential to use for this connection [-credential 'account@domain.com']
    .PARAMETER silent
    Switch to specify suppression of all but warn/error echos.
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .PARAMETER Whatif
    Parameter to run a Test no-change pass [-Whatif switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    [| get-member the output to see what .NET obj TypeName is returned, to use here]
    .EXAMPLE
    PS>  $pltGLPList=[ordered]@{
    PS>      TenOrg= $TenOrg;
    PS>      verbose=$($VerbosePreference -eq "Continue") ;
    PS>      credential= $pltRXO.credential ;
    PS>      #(Get-Variable -name cred$($tenorg) ).value ;
    PS>  } ;
    PS>  $smsg = "$($tenorg):get-AADlicensePlanList w`n$(($pltGLPList|out-string).trim())" ;
    PS>  if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
    PS>  else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    PS>  $objRet = $null ;
    PS>  $objRet = get-AADlicensePlanList @pltGLPList ;
    PS>  if( ($objRet|Measure-Object).count -AND $objRet.GetType().FullName -match $rgxHashTableTypeName ){
    PS>      $smsg = "get-AADlicensePlanList:$($tenorg):returned populated LicensePlanList" ;
    PS>      if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
    PS>      else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    PS>      $licensePlanListHash = $objRet ;
    PS>  } else {
    PS>      $smsg = "get-AADlicensePlanList:$($tenorg)FAILED TO RETURN populated [hashtable] LicensePlanList" ;
    PS>      if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } 
    PS>      else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    PS>      THROW $SMSG ; 
    PS>      break ; 
    PS>  } ;
    PS>  $aadu = get-azureaduser -obj someuser@domain.com ; 
    PS>  $userList = $aadu | Select -ExpandProperty AssignedLicenses | Select SkuID  ;
    PS>  $userLicenses=@() ;
    PS>  $userList | ForEach {
    PS>     $sku=$_.SkuId ;
    PS>     $userLicenses+=$licensePlanListHash[$sku].SkuPartNumber ;
    PS>  } ;
    .EXAMPLE
    PS> PS> $lplist =  get-AADlicensePlanList ;
    PS> $lplist['18181a46-0d4e-45cd-891e-60aabd171b4e']
        SkuId         : 18181a46-0d4e-45cd-891e-60aabd171b4e
        SkuPartNumber : STANDARDPACK
        Enabled       : 418
        Consumed      : 284
        Available     : 134
        Warning       : 0
        Suspended     : 0
    Demo indexed hash lookup of SkuID (to details) under default behavior (summary output table, and indexed on SKUID)
    .EXAMPLE
    PS> $lplist =  get-AADlicensePlanList -raw ;
    PS> $lplist['18181a46-0d4e-45cd-891e-60aabd171b4e']
        ObjectId                                                                  SkuPartNumber PrepaidUnits                                               
        --------                                                                  ------------- ------------                                               
        549366ae-e80a-44b9-8adc-52d0c29ba08b_18181a46-0d4e-45cd-891e-60aabd171b4e STANDARDPACK  class LicenseUnitsDetail {...
    Demo indexed hash lookup of SkuID (to details) under -Raw behavior (raw object output, and indexed on SKUID)
    .EXAMPLE
    PS> $lplist =  get-AADlicensePlanList -verbose -IndexOnName ;
    PS> $lplist['EXCHANGESTANDARD'] | ft -auto 
        SkuId                                SkuPartNumber    Enabled Consumed Available Warning Suspended
        -----                                -------------    ------- -------- --------- ------- ---------
        4b9405b0-7788-4568-add1-99614e613b69 EXCHANGESTANDARD      58       53         5       0         0
    Demo use of -IndexOnName, and indexed hash lookup of Name (to details) under Default behavior (summary output table, and indexed on SkuPartNumber)
    .LINK
    https://github.com/tostka
    #>
    ##ActiveDirectory, MSOnline, 
    #Requires -Version 3
    ##requires -PSEdition Desktop
    #Requires -Modules AzureAD, verb-Text
    #Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\sregex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory=$false,HelpMessage="Switch specifies to return the raw get-AADlicensePlanList properties, indexed on SkuID")]
            [switch]$Raw,
        [Parameter(Mandatory=$false,HelpMessage="Switch specifies to return the raw get-AADlicensePlanList properties, indexed on Name (for name -> details/skuid lookups; default is indexed on SkuID for sku->details/name lookups)")]
            [switch]$IndexOnName,
        [Parameter(Mandatory=$false,HelpMessage="Tenant Tag to be processed[-PARAM 'TEN1']")]
            [ValidateNotNullOrEmpty()]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent,
        [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
        [switch] $showDebug,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
        [switch] $whatIf=$true
    ) ;
    BEGIN {
        #${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        # Get parameters this function was invoked with
        #$PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        #$script:PassStatus = $null ;
        #if(!$GroupSpecifications ){$GroupSpecifications = "ENT-SEC-Guest-TargetUsers;AzureAD Guest User Population","ENT-SEC-Guest-BlockedUsers;AzureAD Guest Blocked Users","ENT-SEC-Guest-AlwaysUsers;AzureAD Guest Force-include Users" ; } ;
        # more useful summary table output (Better matches the *useful* get-MsolAccountSku output!)
        $propsAADL = 'SkuId',  'SkuPartNumber',  @{name='Enabled';Expression={$_.PrepaidUnits.enabled }},  
            @{name='Consumed';Expression={$_.ConsumedUnits} }, @{name='Available';Expression={$_.PrepaidUnits.enabled - $_.ConsumedUnits} }, 
            @{name='Warning';Expression={$_.PrepaidUnits.warning} }, @{name='Suspended';Expression={$_.PrepaidUnits.suspended} } ;

        <#
        # recycling the inbound above into next call in the chain
        # downstream commands
        $pltRXO = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
        } ;
        #>
        # 9:26 AM 6/17/2024 this needs cred resolution splice over latest get-exomailboxlicenses
        $o365Cred = $null ;
        if($Credential){
            $smsg = "`Credential:Explicit credentials specified, deferring to use..." ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                # get-TenantCredentials() return format: (emulating)
                $o365Cred = [ordered]@{
                Cred=$Credential ;
                credType=$null ;
            } ;
            $uRoleReturn = resolve-UserNameToUserRole -UserName $Credential.username -verbose:$($VerbosePreference -eq "Continue") ; # Username
            #$uRoleReturn = resolve-UserNameToUserRole -Credential $Credential -verbose = $($VerbosePreference -eq "Continue") ;   # full Credential support
            if($uRoleReturn.UserRole){
                $o365Cred.credType = $uRoleReturn.UserRole ;
            } else {
                $smsg = "Unable to resolve `$credential.username ($($credential.username))"
                $smsg += "`nto a usable 'UserRole' spec!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ;
                Break ;
            } ;
        } else {
            $pltGTCred=@{TenOrg=$TenOrg ; UserRole=$null; verbose=$($verbose)} ;
            if($UserRole){
                $smsg = "(`$UserRole specified:$($UserRole -join ','))" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $pltGTCred.UserRole = $UserRole;
            } else {
                $smsg = "(No `$UserRole found, defaulting to:'CSVC','SID' " ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                $pltGTCred.UserRole = 'CSVC','SID' ;
            } ;
            $smsg = "get-TenantCredentials w`n$(($pltGTCred|out-string).trim())" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            $o365Cred = get-TenantCredentials @pltGTCred
        } ;
        if($o365Cred.credType -AND $o365Cred.Cred -AND $o365Cred.Cred.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
            $smsg = "(validated `$o365Cred contains .credType:$($o365Cred.credType) & `$o365Cred.Cred.username:$($o365Cred.Cred.username)" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            # 9:58 AM 6/13/2024 populate $credential with return, if not populated (may be required for follow-on calls that pass common $Credentials through)
            if((gv Credential) -AND $Credential -eq $null){
                $credential = $o365Cred.Cred ;
            }elseif($credential.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                $smsg = "(`$Credential is properly populated; explicit -Credential was in initial call)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else {
                $smsg = "`$Credential is `$NULL, AND $o365Cred.Cred is unusable to populate!" ;
                $smsg = "downstream commands will *not* properly pass through usable credentials!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ;
                break ;
            } ;
        } else {
            $smsg = "UNABLE TO RESOLVE FUNCTIONAL CredType/UserRole from specified explicit -Credential:$($Credential.username)!" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            break ;
        } ; 

        # downstream commands
        $pltRXO = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
        } ;
        if((get-command Connect-AAD).Parameters.keys -contains 'silent'){
            $pltRxo.add('Silent',$silent) ;
        } ;
        # default connectivity cmds - force silent false
        $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$true) ; 
        if((get-command ReConnect-AAD).Parameters.keys -notcontains 'silent'){
            $pltRxo.remove('Silent') ;
        } ; 
    } ;
    PROCESS {
        $Error.Clear() ;
        #$ObjReturn=@() ; 
        <#$hshRet=[ordered]@{
            Cred=$null ; 
            credType=$null ; 
        } ; 
        #>
        $smsg = "$($TenOrg):Retrieving licensePlanList..." ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $licensePlanList = $null ; 

        Connect-AAD @pltRXOC ; 

        $error.clear() ;
        TRY {
            if($Raw){
                $smsg = "(-raw: returning indexed-hash of raw Get-AzureADSubscribedSku properties)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $licensePlanList = Get-AzureADSubscribedSku ;
            } else {
                $smsg = "(default: returning indexed-hash of summarized Get-AzureADSubscribedSku properties)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $licensePlanList = Get-AzureADSubscribedSku | select-object $propsAADL ;
            } ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            Start-Sleep -Seconds $RetrySleep ;
            $Exit ++ ;
            $smsg= "Failed to exec cmd because: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error} ; #Error|Warn
            $smsg= "Try #: $($Exit)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error} ; #Error|Warn
            $script:PassStatus += ";ERROR";
            $smsg= "Unable to exec cmd!" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error} ; #Error|Warn
            Exit ;#Continue/Exit/Stop
        } ; 

        $smsg = "(converting `$licensePlanList to `$licensePlanListHash indexed hash)..." ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        # can't use convert-ObjectToIndexedHash as the key/index is a split version of a property, rather than the entire property
        $swMstr = [Diagnostics.Stopwatch]::StartNew();
        if($host.version.major -gt 2){$licensePlanListHash = [ordered]@{} } 
        else { $licensePlanListHash = @{} };
        if($IndexOnName){
            $smsg = "(IndexOnName indexing: returning indexed-hash keyed on 'Name' (SkuPartNumber))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } else { 
            $smsg = "(default indexing: returning indexed-hash keyed on SkuID)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; 
        foreach($lic in $licensePlanList) {
            # update the content with the friendly name
            $data=[ordered]@{
                SkuId = $lic.SkuId
                SkuPartNumber = $lic.SkuPartNumber
                SkuDesc = get-AADLicenseFullName -name $lic.SkuPartNumber ; 
                Enabled = $lic.Enabled ; 
                Consumed = $lic.Consumed ; 
                Available = $lic.Available ; 
                Warning = $lic.Warning ; 
                Suspended = $lic.Suspended ; 
            } ;
            if($IndexOnName){
                if($raw){
                    $licensePlanListHash[$lic.SkuPartNumber] = $lic ;
                } else { 
                    $licensePlanListHash[$lic.SkuPartNumber] = New-Object PSObject -Property $data ;
                } ; 
            } else { 
                if($raw){
                    $licensePlanListHash[$lic.skuid] = $lic ;    
                } else { 
                    $licensePlanListHash[$lic.skuid] = New-Object PSObject -Property $data ;
                } ;            
            } ; 
        } ;
    
        $swMstr.Stop() ;
        $smsg = "($(($licensePlanList|measure).count) records converted in $($swMstr.Elapsed.ToString()))" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        # purge the original (reduce mem)
        $licensePlanList = $null ; 
        #now can lookup user AssignedLicense.SKUID's eqiv licName as $licensePlanListHash[$skuid].skupartnumber

    } ;  # PROC-E
    END{
        $licensePlanListHash | write-output ; 
    } ;
}

#*------^ get-AADlicensePlanList.ps1 ^------


#*------v get-ADUsersWithSoftDeletedxoMailboxes.ps1 v------
function get-ADUsersWithSoftDeletedxoMailboxes {
    <#
    .SYNOPSIS
    get-ADUsersWithSoftDeletedxoMailboxes.ps1 - Get *existing* ADUsers with SoftDeleted xoMailboxes
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2022-01-14
    FileName    : get-ADUsersWithSoftDeletedxoMailboxes
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-xo
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 2:16 PM 6/24/2024: rem'd out #Requires -RunasAdministrator; sec chgs in last x mos wrecked RAA detection
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 2:51 PM 1/14/2022 init
    .DESCRIPTION
    get-ADUsersWithSoftDeletedxoMailboxes.ps1 - Get *existing* ADUsers with SoftDeleted xoMailboxes
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    None. Returns no objects or output (.NET types)
    System.Boolean
    [| get-member the output to see what .NET obj TypeName is returned, to use here]
    .EXAMPLE
    PS> .\get-ADUsersWithSoftDeletedxoMailboxes.ps1 -verbose
    Run with verbose
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    # 2:49 PM 3/8/2022 pull verb-ex2010 ref - I think it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    #Requires -Modules ActiveDirectory, ExchangeOnlineManagement, verb-ADMS, verb-Auth, verb-IO, verb-logging, verb-Network, verb-Text
    ##Requires -RunasAdministrator
    #Requires -Version 3
    #requires -PSEdition Desktop
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\sregex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    ###[Alias('Alias','Alias2')]
    PARAM(
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2
    ) ;
    
    BEGIN { 
        #region CONSTANTS-AND-ENVIRO #*======v CONSTANTS-AND-ENVIRO v======
        # function self-name (equiv to script's: $MyInvocation.MyCommand.Path) ;
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        # Get parameters this function was invoked with
        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
        $Verbose = ($VerbosePreference -eq 'Continue') ; 
        if ($PSScriptRoot -eq "") {
            if ($psISE) { $ScriptName = $psISE.CurrentFile.FullPath } 
            elseif ($context = $psEditor.GetEditorContext()) {$ScriptName = $context.CurrentFile.Path } 
            elseif ($host.version.major -lt 3) {
                $ScriptName = $MyInvocation.MyCommand.Path ;
                $PSScriptRoot = Split-Path $ScriptName -Parent ;
                $PSCommandPath = $ScriptName ;
            } else {
                if ($MyInvocation.MyCommand.Path) {
                    $ScriptName = $MyInvocation.MyCommand.Path ;
                    $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                } else {throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" } ;
            };
            $ScriptDir = Split-Path -Parent $ScriptName ;
            $ScriptBaseName = split-path -leaf $ScriptName ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($ScriptName) ;
        } else {
            $ScriptDir = $PSScriptRoot ;
            if ($PSCommandPath) {$ScriptName = $PSCommandPath } 
            else {
                $ScriptName = $myInvocation.ScriptName
                $PSCommandPath = $ScriptName ;
            } ;
            $ScriptBaseName = (Split-Path -Leaf ((& { $myInvocation }).ScriptName))  ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
        } ;
        if ($showDebug) { write-debug -verbose:$true "`$ScriptDir:$($ScriptDir)`n`$ScriptBaseName:$($ScriptBaseName)`n`$ScriptNameNoExt:$($ScriptNameNoExt)`n`$PSScriptRoot:$($PSScriptRoot)`n`$PSCommandPath:$($PSCommandPath)" ; } ;
        $ComputerName = $env:COMPUTERNAME ;
        $NoProf = [bool]([Environment]::GetCommandLineArgs() -like '-noprofile'); # if($NoProf){# do this};
        # silently stop any running transcripts
        $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ; 
        #endregion CONSTANTS-AND-ENVIRO #*======^ END CONSTANTS-AND-ENVIRO ^======
        
        #region START-LOG #*======v START-LOG OPTIONS v======
        #region START-LOG-HOLISTIC #*------v START-LOG-HOLISTIC v------
        # Single log for script/function example that accomodates detect/redirect from AllUsers scope'd installed code, and hunts a series of drive letters to find an alternate logging dir (defers to profile variables)
        #${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        if(!(get-variable LogPathDrives -ea 0)){$LogPathDrives = 'd','c' };
        foreach($budrv in $LogPathDrives){if(test-path -path "$($budrv):\scripts" -ea 0 ){break} } ;
        if(!(get-variable rgxPSAllUsersScope -ea 0)){
            $rgxPSAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps(((d|m))*)1|dll)$" ;
        } ;
        if(!(get-variable rgxPSCurrUserScope -ea 0)){
            $rgxPSCurrUserScope="^$([regex]::escape([Environment]::GetFolderPath('MyDocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps((d|m)*)1|dll)$" ;
        } ;
        $pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($whatif) ;} ;
        $pltSL.Tag = $ModuleName ; 
        if($script:PSCommandPath){
            if(($script:PSCommandPath -match $rgxPSAllUsersScope) -OR ($script:PSCommandPath -match $rgxPSCurrUserScope)){
                $bDivertLog = $true ; 
                switch -regex ($script:PSCommandPath){
                    $rgxPSAllUsersScope{$smsg = "AllUsers"} 
                    $rgxPSCurrUserScope{$smsg = "CurrentUser"}
                } ;
                $smsg += " context script/module, divert logging into [$budrv]:\scripts" 
                write-verbose $smsg  ;
                if($bDivertLog){
                    if((split-path $script:PSCommandPath -leaf) -ne $cmdletname){
                        # function in a module/script installed to allusers|cu - defer name to Cmdlet/Function name
                        $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
                    } else {
                        # installed allusers|CU script, use the hosting script name
                        $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $script:PSCommandPath -leaf)) ;
                    }
                } ;
            } else {
                $pltSL.Path = $script:PSCommandPath ;
            } ;
        } else {
            if(($MyInvocation.MyCommand.Definition -match $rgxPSAllUsersScope) -OR ($MyInvocation.MyCommand.Definition -match $rgxPSCurrUserScope) ){
                 $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $script:PSCommandPath -leaf)) ;
            } elseif(test-path $MyInvocation.MyCommand.Definition) {
                $pltSL.Path = $MyInvocation.MyCommand.Definition ;
            } elseif($cmdletname){
                $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
            } else {
                $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$CMDLETNAME, FROM WHICH TO BUILD A START-LOG.PATH!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                BREAK ;
            } ; 
        } ;
        write-verbose "start-Log w`n$(($pltSL|out-string).trim())" ; 
        $logspec = start-Log @pltSL ;
        $error.clear() ;
        TRY {
            if($logspec){
                $logging=$logspec.logging ;
                $logfile=$logspec.logfile ;
                $transcript=$logspec.transcript ;
                $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                start-Transcript -path $transcript ;
            } else {throw "Unable to configure logging!" } ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ;
        #endregion START-LOG-HOLISTIC #*------^ END START-LOG-HOLISTIC ^------
        #region START-LOG-SIMPLE #*------v START-LOG-SIMPLE v------
        #Configure default logging from parent script name
        # Configure default logging from parent script name
        $pltSL=@{ NoTimeStamp=$true ; Tag="($TenOrg)-LASTPASS" ; showdebug=$($showdebug) ; whatif=$($whatif) ; Verbose=$($VerbosePreference -eq 'Continue') ; } ;
        if($PSCommandPath){   $logspec = start-Log -Path $PSCommandPath @pltSL ;
        } else { $logspec = start-Log -Path ($MyInvocation.MyCommand.Definition) @pltSL ; } ;
        if($logspec){
            $logging=$logspec.logging ;
            $logfile=$logspec.logfile ;
            $transcript=$logspec.transcript ;
            if(Test-TranscriptionSupported){
                $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                start-transcript -Path $transcript ;
            } ;
        } else {throw "Unable to configure logging!" } ;
        #endregion START-LOG-SIMPLE #*------^ END START-LOG SIMPLE ^------
        #endregion START-LOG #*======^ START-LOG OPTIONS ^======
        
        #region EXCH-CMD-ALIASING-OPTS ; #*======v EXCH-CMD-ALIASING-OPTS v======
        #region EXO-v-EXOv2-ALIASING #*------v Function EXO v EXOv2 ALIASING on $useEXOv2 v------
        # simple loop to stock the set, no set->get conversion, roughed in $Exov2 exo->xo replace. Do specs in exo, and flip to suit under $exov2
        #configure EXO EMS aliases to cover useEXOv2 requirements
        # have to preconnect, as it gcm's the targets
        if ($script:useEXOv2) { reconnect-eXO2 }
        else { reconnect-EXO } ;
        # aliased ExOP|EXO|EXOv2 cmdlets (permits simpler single code block for any of the three variants of targets & syntaxes)
        # each is '[aliasname];[exOcmd] (xOv2cmd & exop are converted from [exocmd])
        [array]$cmdletMaps = 'ps1GetxRcp;get-exorecipient;','ps1GetxMbx;get-exomailbox;','ps1SetxMbx;Set-exoMailbox;','ps1GetxUser;get-exoUser;',
            'ps1GetxMUsr;Get-exoMailUser','ps1SetxMUsr;Set-exoMailUser','ps1SetxCalProc;set-exoCalendarprocessing;',
            'ps1GetxCalProc;get-exoCalendarprocessing;','ps1GetxMbxFldrPerm;get-exoMailboxfolderpermission;',
            'ps1GetxMbxFldrPerm;get-exoMailboxfolderpermission','ps1AddxMbxPrm;Add-exoMailboxPermission','ps1GetxMbxPrm;Get-exoMailboxPermission',
            'ps1RmvxMbxPrm;Remove-exoMailboxPermission','ps1AddRcpPrm;Add-exoRecipientPermission','ps1GetRcpPrm;Get-exoRecipientPermission',
            'ps1RmvRcpPrm;Remove-exoRecipientPermission','ps1GetxAccDom;Get-exoAcceptedDomain;','ps1GetxRetPol;Get-exoRetentionPolicy',
            'ps1GetxDistGrp;get-exoDistributionGroup;','ps1GetxDistGrpMbr;get-exoDistributionGroupmember;','ps1GetxMsgTrc;get-exoMessageTrace;',
            'ps1GetxMsgTrcDtl;get-exoMessageTraceDetail;','ps1GetxMbxFldrStats;get-exoMailboxfolderStatistics','ps1GetxMContact;Get-exomailcontact;',
            'ps1SetxMContact;Set-exomailcontact;','ps1NewxMContact;New-exomailcontact','ps1TestxMapi;Test-exoMAPIConnectivity',
            'ps1GetxOrgCfg;Get-exoOrganizationConfig','ps1GetxMbxRegionCfg;Get-exoMailboxRegionalConfiguration',
            'ps1TestxOAuthConn;Test-exoOAuthConnectivity','ps1NewxDistGrp;new-exoDistributionGroup','ps1SetxDistGrp;set-exoDistributionGroup',
            'ps1AddxDistGrpMbr;Add-exoDistributionGroupMember','ps1RmvxDistGrpMbr;remove-exoDistributionGroupMember',
            'ps1GetxDDG;Get-exoDynamicDistributionGroup','ps1NewxDDG;New-exoDynamicDistributionGroup','ps1SetxDDG;Set-exoDynamicDistributionGroup' ;
            'ps1GetxCasMbx;Get-exoCASMailbox','ps1GetxMbxStat;Get-exoMailboxStatistics','ps1GetxMobilDevStats;Get-exoMobileDeviceStatistics'
        [array]$XoOnlyMaps = 'ps1GetxMsgTrcDtl','ps1TestxOAuthConn' ; # cmdlet alias names from above that are skipped for aliasing in EXOP
        # cmdlets from above that have diff names EXO v EXoP: these each have  schema: [alias];[xoCmdlet];[opCmdlet]; op Aliases use the opCmdlet as target
        [array]$XoRenameMaps = 'ps1GetxMsgTrc;get-exoMessageTrace;get-MessageTrackingLog','ps1AddRcpPrm;Add-exoRecipientPermission;Add-AdPermission',
                'ps1GetRcpPrm;Get-exoRecipientPermission;Get-AdPermission','ps1RmvRcpPrm;Remove-exoRecipientPermission;Remove-ADPermission' ;
        [array]$Xo2VariantMaps =   'ps1GetxCasMbx;Get-exoCASMailbox', 'ps1GetxMbx;get-exomailbox;', 'ps1GetxMbxFldrPerm;get-exoMailboxfolderpermission;',
            'ps1GetxMbxFldrStats;get-exoMailboxfolderStatistics', 'ps1GetxMbxPrm;Get-exoMailboxPermission', 'ps1GetxMbxStat;Get-exoMailboxStatistics',
            'ps1GetxMobilDevStats;Get-exoMobileDeviceStatistics', 'ps1GetxRcp;get-exorecipient;', 'ps1AddRcpPrm;Add-exoRecipientPermission' ; 
        # cmdlets above have XO2 enhanced variant-named versions to target (they never are prefixed verb-xo[noun], always/only verb-exo[noun])
        # code to summarize & indexed-hash the renamed cmdlets for variant processing
        $XoRenameMapNames = @() ; 
        $oxoRenameMaps = @{} ;
        $XoRenameMaps | foreach {     $XoRenameMapNames += $_.split(';')[0] ;     $name = $_.split(';')[0] ;     $oxoRenameMaps[$name] = $_.split(';')  ;  } ;
        $Xo2VariantMapNames = @() ;
        $oXo2VariantMaps = @{} ;
        $Xo2VariantMaps | foreach {  $Xo2VariantMapNames += $_.split(';')[0] ;  $name = $_.split(';')[0] ;  $oXo2VariantMaps[$name] = $_.split(';') ; } ; 
        #$cmdletMapsFltrd = $cmdletmaps|?{$_.split(';')[1] -like '*DistributionGroup*'} ;  # filtering subset
        #$cmdletMapsFltrd += $cmdletmaps|?{$_.split(';')[1] -like '*recipient'}
        $cmdletMapsFltrd = $cmdletmaps ; # or use full set
        foreach($cmdletMap in $cmdletMapsFltrd){
            if($script:useEXOv2){
                if($Xo2VariantMapNames -contains $cmdletMap.split(';')[0]){
                    write-verbose "$($cmdletMap.split(';')[1]) has an XO2-VARIANT cmdlet, renaming for XOV2 enhanced variant" ;
                    # sub -exoNOUN -> -NOUN using ExOP variant cmdlet
                    if(!($cmdlet= Get-Command $oXo2VariantMaps[($cmdletMap.split(';')[0])][2] )){ throw "unable to gcm Alias definition!:$($oxoRenameMaps[($cmdletMap.split(';')[0])][2])" ; break }
                    $nAName = ($cmdletMap.split(';')[0]);
                    if(-not(get-alias -name $naname -ea 0 |?{$_.Definition -eq $cmdlet.name})){
                        $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                        write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                    } ;
                } else { 
                    # common cmdlets between all 3 systems
                    if(!($cmdlet= Get-Command $cmdletMap.split(';')[1].replace('-exo','-xo') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                    $nAName = ($cmdletMap.split(';')[0]) ;
                    if(-not(get-alias -name $naname -ea 0 |?{$_.Definition -eq $cmdlet.name})){
                        $nalias = set-alias -name $nAName -value ($cmdlet.name) -passthru ;
                        write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                    } ;
                } ; 
            } else {
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nAName = ($cmdletMap.split(';')[0]);
                if(-not(get-alias -name $naname -ea 0 |?{$_.Definition -eq $cmdlet.name})){
                    $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                    write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                } ;
            } ;
        } ;# ...
        # cleanup
        get-alias -scope Script |?{$_.name -match '^ps1.*'} | %{Remove-Alias -alias $_.name} ; 
        #endregion EXO-v-EXOv2-ALIASING #*------^ END Function EXO V EXOv2 ALIASING ^------
        
        #endregion EXCH-CMD-ALIASING-OPTS #*======^ END EXCH-CMD-ALIASING-OPTS ^======
        
        #region useEXOP ; #*------v useEXOP v------
        $useEXOP = $false ; 
        if($useEXOP){
            #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
            # do the OP creds too
            $OPCred=$null ;
            # default to the onprem svc acct
            $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC' ;verbose=$($verbose)} ;
            if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                #-=-record a STATUSERROR=-=-=-=-=-=-=
                $statusdelta = ";ERROR"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                if(gv passstatus -scope Script){$script:PassStatus += $statusdelta } ;
                if(gv -Name PassStatus_$($tenorg) -scope Script){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                #-=-=-=-=-=-=-=-=
                $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                BREAK ;
            } ;
            $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;  
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            <# CALLS ARE IN FORM: (cred$($tenorg))
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                verbose = $($verbose) ; }
            ReConnect-Ex2010XO @pltRX10 ; # cross-prem conns
            Reconnect-Ex2010 @pltRX10 ; # local org conns
            #$pltRx10 creds & .username can also be used for local ADMS connections
            #>
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                verbose = $($verbose) ; } ;     
            # TEST
            #if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; BREAK ;}  ;
            # defer cx10/rx10, until just before get-recipients qry
            #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
            # connect to ExOP X10
            <#
            if($pltRX10){
                ReConnect-Ex2010 @pltRX10 ;
            } else { Reconnect-Ex2010 ; } ; 
            #>
        } ;  # if-E $useEXOP
        #endregion useEXOP ; #*------^ END useEXOP ^------
        #region useOPAD ; #*------v useOPAD v------
        if($useEXOP){
            # resolve $domaincontroller dynamic, cross-org
            # setup ADMS PSDrives per tenant 
            if(!$global:ADPsDriveNames){
                $smsg = "(connecting X-Org AD PSDrives)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $global:ADPsDriveNames = mount-ADForestDrives -verbose:$($verbose) ;
            } ; 
            if(($global:ADPsDriveNames|measure).count){
                $useEXOforGroups = $false ; 
                $smsg = "Confirming ADMS PSDrives:`n$(($global:ADPsDriveNames.Name|%{get-psdrive -Name $_ -PSProvider ActiveDirectory} | ft -auto Name,Root,Provider|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                # returned object
                #         $ADPsDriveNames
                #         UserName                Status Name        
                #         --------                ------ ----        
                #         DOM\Samacctname   True  [forestname wo punc] 
                #         DOM\Samacctname   True  [forestname wo punc]
                #         DOM\Samacctname   True  [forestname wo punc]
                
            } else { 
                #-=-record a STATUSERROR=-=-=-=-=-=-=
                $statusdelta = ";ERROR"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                if(gv passstatus -scope Script){$script:PassStatus += $statusdelta } ;
                if(gv -Name PassStatus_$($tenorg) -scope Script){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                #-=-=-=-=-=-=-=-=
                $smsg = "Unable to detect POPULATED `$global:ADPsDriveNames!`n(should have multiple values, resolved to $()"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                BREAK ;
            } ; 
        }  else { 
            <# have to defer to get-azuread, or use EXO's native cmds to poll grp members
            # TODO 1/15/2021
            $useEXOforGroups = $true ; 
            $smsg = "$($TenOrg):HAS NO ON-PREM ACTIVEDIRECTORY, DEFERRING ALL GROUP ACCESS & MGMT TO NATIVE EXO CMDS!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #>
        } ; 
        #endregion useOPAD ; #*------^ END useOPAD ^------

        <#
        if($pltRX10){
            ReConnect-Ex2010 @pltRX10 ;
        } else { Reconnect-Ex2010 ; } ;     
        #>
        if ($PSCmdlet.MyInvocation.ExpectingInput) {
            $smsg = "Data received from pipeline input: '$($InputObject)'" ; 
        } else {
            #write-verbose "Data received from parameter input: '$($InputObject)'" ; 
        } ; 
        
        #### NEW CODE/CONSTANTS HERE ####
        
    } ; # BEGIN-E
    PROCESS {
        $Error.Clear() ; 
        # call func with $PSBoundParameters and an extra (includes Verbose)
        #call-somefunc @PSBoundParameters -anotherParam
        
        # - Pipeline support will iterate the entire PROCESS{} BLOCK, with the bound - $array - 
        #   param, iterated as $array=[pipe element n] through the entire inbound stack. 
        # $_ within PROCESS{}  is also the pipeline element (though it's safer to declare and foreach a bound $array param).
        
        # - foreach() below alternatively handles _named parameter_ calls: -array $objectArray
        # which, when a pipeline input is in use, means the foreach only iterates *once* per 
        #   Process{} iteration (as process only brings in a single element of the pipe per pass) 
        
        #foreach($item in $array) {
            # dosomething w $item
            
            # put your real processing in here, and assume everything that needs to happen per loop pass is within this section.
            # that way every pipeline or named variable param item passed will be processed through. 
            
            $smsg = "getting *existing* ADUsers with SoftDeletedxoMailboxes" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            
            $smsg = "(get all SoftDeleted xoMbxs)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            $error.clear() ;
            TRY {
                $pltGxMbx=[ordered]@{ Resultsize='Unlimited' ;SoftDeletedMailbox=$true ;ErrorAction = 'STOP';} ; 
                $smsg = "$((get-alias ps1GetxMbx).definition) w`n$(($pltGxMbx|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $allsdmbx = ps1GetxMbx @pltGxMbx ;
                $smsg = "(get all LegalHeld mailboxes (InactiveMailboxOnly))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $pltGxMbx=[ordered]@{ Resultsize='Unlimited' ;InactiveMailboxOnly=$true ;ErrorAction = 'STOP';} ; 
                $smsg = "$((get-alias ps1GetxMbx).definition) w`n$(($pltGxMbx|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $allimbx = ps1GetxMbx @pltGxMbx ;
                $smsg = "(compare the populations)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $pltComp=[ordered]@{ReferenceObject=$allsdmbx ;DifferenceObject=$allimbx ;PassThru=$true;Property='userprincipalname' ;} ; 
                $smsg = "compare-object w`n$(($pltComp|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $cmpare = compare-object @pltComp ;
                $smsg = "(isolate all SoftDeleted mbxs that are *not* Inactive/legal-held)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $nonHeldSDs = $allsdmbx | ? isinactivemailbox -eq $false | sort whensoftdeleted ;  
                $smsg = "Filter for non-LegalHeld SoftDeleted mailboxes, with non-Deleted ADUsers...`n" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $availSoftDeleteADUsers = $nonHeldSDs | %{$upn = $_.userprincipalname ; get-adobject -filter 'userprincipalname -eq  $upn' -IncludeDeletedObjects -properties IsDeleted,LastKnownParent,userprincipalname -ea continue} |?{$_.isdeleted -eq $false } ; 
                if($availSoftDeleteADUsers){ 
                    #$availSoftDeleteADUsers | ft -auto name,IsDeleted,lastknownparent,userp*
                    $smsg = "`n$(($availSoftDeleteADUsers | ft -auto name,IsDeleted,lastknownparent,userp*|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $smsg = "(returning matches to pipeline)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $availSoftDeleteADUsers | write-output ; 
                } else {
                    $smsg = "`$availSoftDeleteADUsers: none found" 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ; 
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)"  ;
                Break ; 
            } ; 
        #} ;  # loop-E process loop

    } ;  # PROC-E
    END {
        # clean-up dyn-created vars & those created by a dot sourced script.
        #((Compare-Object -ReferenceObject (Get-Variable).Name -DifferenceObject $DefVaris).InputObject).foreach{Remove-Variable -Name $_} ; 
    } ;  # END-E
}

#*------^ get-ADUsersWithSoftDeletedxoMailboxes.ps1 ^------


#*------v get-ExoGxMTEventType.ps1 v------
function get-ExoGxMTEventType {
<#
    .SYNOPSIS
    get-ExoGxMTEventType - Provides a prefab array indexed hash of Exchange-Online Get-xoMessageTrace Event Types Note: This is a static non-query-based list of events. The function must be manually updated to accomodate MS MessageTrace event types changes over time).
    .PARAMETER Mailboxes
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2022-02-25
    FileName    : get-ExoGxMTEventType.ps1
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-ex2010
    Tags        : Powershell
    REVISIONS
    * 10:27 AM 5/17/2024 addapted from vxo\get-ExoMailboxLicenses()
    .DESCRIPTION
    get-ExoGxMTEventType - Provides a prefab array indexed hash of Exchange-Online Get-xoMessageTrace Event Types Note: This is a static non-query-based list of events. The function must be manually updated to accomodate MS MessageTrace event types changes over time).
    .PARAMETER EventID
    MessageTrace event-id to be resolved to details[-EventID 'AGENTINFO']
    .EXAMPLE
    PS> $eventInfo = get-ExoGxMTEventType -eventid AGENTINFO -verbose ; 
    PS> $hQuotas['database2']
    Name           ProhibitSendReceiveQuotaGB ProhibitSendQuotaGB IssueWarningQuotaGB
    ----           -------------------------- ------------------- -------------------
    database2      12.000                     10.000              9.000
    Retrieve local org on-prem MailboxDatabase quotas and assign to a variable, with verbose outputs. Then output the retrieved quotas from the indexed hash returned, for the mailboxdatabase named 'database2'.
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    #Requires -Modules verb-IO, verb-logging, verb-Text
    [OutputType('System.Collections.Hashtable')]
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory=$FALSE,HelpMessage="MessageTrace event-id to be resolved to details[-EventID 'AGENTINFO']")]
        [ValidateNotNullOrEmpty()]
        [string]$EventID
    ) ;
    
    ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
    $verbose = ($VerbosePreference -eq "Continue") ;
    
    # check if using Pipeline input or explicit params:
    if ($PSCmdlet.MyInvocation.ExpectingInput) {
        write-verbose "Data received from pipeline input: '$($InputObject)'" ;
    } else {
        # doesn't actually return an obj in the echo
        #write-verbose "Data received from parameter input: '$($InputObject)'" ;
    } ;
    

    # input table of Exchange Online assignable licenses that include a UserMailbox:
    $ExoEventIDsTbl = @"
|EventName |Description|
|---|---|
|AGENTINFO |This event is used by transport agents to log custom data.|
|BADMAIL |A message submitted by the Pickup directory or the Replay directory that can't be delivered or returned.|
|CLIENTSUBMISSION |A message was submitted from the Outbox of a mailbox.|
|DEFER |Message delivery was delayed.|
|DELIVER |A message was delivered to a local mailbox.|
|DELIVERFAIL |An agent tried to deliver the message to a folder that doesn't exist in the mailbox.|
|DROP |A message was dropped without a delivery status notification (also known as a DSN, bounce message, non-delivery report, or NDR). For example:<br/>* Completed moderation approval request messages.<br/>* Spam messages that were silently dropped without an NDR.|
|DSN |A delivery status notification (DSN) was generated.|
|DUPLICATEDELIVER |A duplicate message was delivered to the recipient. Duplication may occur if a recipient is a member of multiple nested distribution groups. Duplicate messages are detected and removed by the information store.|
|DUPLICATEEXPAND |During the expansion of the distribution group, a duplicate recipient was detected.|
|DUPLICATEREDIRECT |An alternate recipient for the message was already a recipient.|
|EXPAND |A distribution group was expanded.|
|FAIL |Message delivery failed. Sources include SMTP, DNS, QUEUE, and ROUTING.|
|HADISCARD |A shadow message was discarded after the primary copy was delivered to the next hop. For more information, see Shadow redundancy in Exchange Server.|
|HARECEIVE |A shadow message was received by the server in the local database availability group (DAG) or Active Directory site.|
|HAREDIRECT |A shadow message was created.|
|HAREDIRECTFAIL |A shadow message failed to be created. The details are stored in the source-context field.|
|INITMESSAGECREATED |A message was sent to a moderated recipient, so the message was sent to the arbitration mailbox for approval. For more information, see Manage message approval.|
|LOAD |A message was successfully loaded at boot.|
|MODERATIONEXPIRE |A moderator for a moderated recipient never approved or rejected the message, so the message expired. For more information about moderated recipients, see Manage message approval.|
|MODERATORAPPROVE |A moderator for a moderated recipient approved the message, so the message was delivered to the moderated recipient.|
|MODERATORREJECT |A moderator for a moderated recipient rejected the message, so the message wasn't delivered to the moderated recipient.|
|MODERATORSALLNDR |All approval requests sent to all moderators of a moderated recipient were undeliverable, and resulted in non-delivery reports (also known as NDRs or bounce messages).|
|NOTIFYMAPI |A message was detected in the Outbox of a mailbox on the local server.|
|NOTIFYSHADOW |A message was detected in the Outbox of a mailbox on the local server, and a shadow copy of the message needs to be created.|
|POISONMESSAGE |A message was put in the poison message queue or removed from the poison message queue.|
|PROCESS |The message was successfully processed.|
|PROCESSMEETINGMESSAGE |A meeting message was processed by the Mailbox Transport Delivery service.|
|RECEIVE |A message was received by the SMTP receive component of the transport service or from the Pickup or Replay directories (source: SMTP), or a message was submitted from a mailbox to the Mailbox Transport Submission service (source: STOREDRIVER).|
|REDIRECT |A message was redirected to an alternative recipient after an Active Directory lookup.|
|RESOLVE |A message's recipients were resolved to a different email address after an Active Directory lookup.|
|RESUBMIT |A message was automatically resubmitted from Safety Net. For more information, see Safety Net in Exchange Server.|
|RESUBMITDEFER |A message resubmitted from Safety Net was deferred.|
|RESUBMITFAIL |A message resubmitted from Safety Net failed.|
|SEND |A message was sent by SMTP between transport services.|
|SUBMIT |The Mailbox Transport Submission service successfully transmitted the message to the Transport service. For SUBMIT events, the source-context property contains the following details:<br/> * MDB: The mailbox database GUID.<br/> * Mailbox: The mailbox GUID.<br/> * Event: The event sequence number.<br/> * MessageClass: The type of message. For example, IPM.Note.<br/> * CreationTime: Date-time of the message submission.<br/> * ClientType: For example, User, OWA, or ActiveSync.|
|SUBMITDEFER |The message transmission from the Mailbox Transport Submission service to the Transport service was deferred.|
|SUBMITFAIL |The message transmission from the Mailbox Transport Submission service to the Transport service failed.|
|SUPPRESSED |The message transmission was suppressed.|
|THROTTLE |The message was throttled.|
|TRANSFER |Recipients were moved to a forked message because of content conversion, message recipient limits, or agents. Sources include ROUTING or QUEUE.|
"@ ;
    $ExoEventIDs = $ExoEventIDsTbl | convertfrom-markdowntable ;

    # building a CustObj (actually an indexed hash) with the EventName|Descriptions. The 'index' for each event, is the EventName 
    $smsg = "(converting $(($ExoEventIDs|measure).count) Get-xoMessageTrace-supported Event-ID types, to indexed hash)" ;     
    if($verbose){
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    } ; 
    if($host.version.major -gt 2){$hExoEventIDs = [ordered]@{} } 
    else { $hExoEventIDs = @{} } ;
    
    $ttl = ($ExoEventIDs|measure).count ; $Procd = 0 ; 
    foreach ($Sku in $ExoEventIDs){
        $Procd ++ ; 
        $sBnrS="`n#*------v PROCESSING : ($($Procd)/$($ttl)) $($Sku.SKU) v------" ; 
        $smsg = $sBnrS ; 
        if($verbose){
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
        
        $name =$($Sku | select -expand SKU) ; 
        $hExoEventIDs[$name] = $Sku ; 

        $smsg = "$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
        if($verbose){
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
    } ;  # loop-E

    if($hExoEventIDs){
        $smsg = "(Returning summary objects to pipeline)" ; 
        if($verbose){
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
        $hExoEventIDs | Write-Output ; 
    } else {
        $smsg = "NO RETURNABLE `$hExoEventIDs OBJECT!" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        THROW $smsg ;
    } ; 
}

#*------^ get-ExoGxMTEventType.ps1 ^------


#*------v get-ExoMailboxLicenses.ps1 v------
function get-ExoMailboxLicenses {
<#
    .SYNOPSIS
    get-ExoMailboxLicenses - Provides a prefab indexed hash of Exchange-Online mailbox-supporting licenses (at least one of which is required to accomodate an EXO Usermailbox - This now dynamically calls Get-MgSubscribedSku and postfilters the ServicePlan list for matches on the $ServicePlanName array (which reflects Exchange mailbox ServicePlanNames). The ServicePlanName array must be manually updated to accomodate MS licensure changes over time).
    .PARAMETER Mailboxes
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2022-02-25
    FileName    : get-ExoMailboxLicenses.ps1
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-ex2010
    Tags        : Powershell
    REVISIONS
    * 10:48 AM 1/19/2026 bugfix: $pltCcOPSvcs.UserRole (postfilter, not match test)
    # 2:23 PM 1/12/2026 fixed op break: #804, FORCE:  $useOP = $false ; : This has NO NEED FOR ONPREM, IT JUST DOES A Get-MgSubscribedSku AND RUNS THE STATIC SERVICEPLANLIST CHECK, NOTHING ELSE!
    * 1:30 PM 1/7/2026 WIP unupdated port from AADLicense -> MGUDLicense
    * 10:23 AM 11/27/2024 cleaned up CBH expls, pulled spurious quota #1, added in its place a simple call & review; updated #2's comment to actually reflect what's going on (vs the original indexed hash pull for quotas, it wass lifted from).
    * 1:22 PM 6/18/2024 updated SERVICE_CONNECTIONS block; reflects latest variant; 
    * 4:16 PM 6/17/2024 add: ServicePlanName to the detailed output ; pulled transcript END block (unused, would kill other process logging) ; adding -OutDetail, need to implement to return avail etc full details in outobject
    * 5:12 PM 6/13/2024 update to make dynamic, querying for plans serviceplans.serviceplanname -match  EXCHANGE_S_ENTERPRISE','EXCHANGE_S_STANDARD','EXCHANGE_S_DESKLESS (-ne MCOCAP 	Common Area Phone)
    * 12:45 PM 6/21/2022 added cbh expl that rolls up a rgx to use for independant manual tests against 
    * 2:21 PM 3/1/2022 updated CBH
    * 4:27 PM 2/25/2022 init vers
    .DESCRIPTION
    get-ExoMailboxLicenses - Provides a prefab indexed hash of Exchange-Online mailbox-supporting licenses (at least one of which is required to accomodate an EXO Usermailbox - This now dynamically calls Get-MgSubscribedSku and postfilters the ServicePlan list for matches on the $ServicePlanName array (which reflects Exchange mailbox ServicePlanNames). The ServicePlanName array must be manually updated to accomodate MS licensure changes over time).

    This feeds my test-EXOIsLicensed(), and is usable for feeding add-EXOLicense & remove-EXOLicense
    Underlying goal is to *dynamically* pursue the current supported licensure, but calling Get-MgSubscribedSku and postfiltering the ServicePlan list for matches on the $ServicePlanName array 
    (which reflects Exchange mailbox ServicePlanNames). The ServicePlanName array must be manually updated to accomodate MS licensure changes over time).

    ## Tracking changes in Microsoft Licensing Service Plan Names over time. 
    
    At the current time, there is a _five year out of date_ json here: 
    [Compare Microsoft Exchange Online Plans Microsoft 365](https://www.microsoft.com/en-us/microsoft-365/exchange/compare-microsoft-exchange-online-plans)

    ... which they claim is no longer needed because of online non-code-ingestable/non-filterable giant listing
    Or you can also use the GraphAPI and chase that ball of ugly over time. 
    So for now, I'm basing it off of the out of date json's plan names, and leaving gapi for a later more-freetimey time.

    ## MS Exchange plan compairson's posted (as of 6/17/2024)

    ### Exchange Online (Plan 1) $4.00 user/month
    - 50g mbx, OWA, inplace archive
    

    ### Exchange Online (Plan 2)  $8.00  user/month
    - above/owa ++100g mbx, DLP, Vmail

    ### Microsoft 365 Business Standard $12.50 user/month
    - ++Outlook
    - reflects use of the EXCHANGE_S_ENTERPRISE ServicePlanName

    ## Extracting ServicePlans broadly

    [Azure-AD-Licensing-DB/ProductLicensesDb.json at master · jpawlowski/Azure-AD-Licensing-DB · GitHub](https://github.com/jpawlowski/Azure-AD-Licensing-DB/blob/master/ProductLicensesDb.json) 
    has a json db of all plan details

    1. click the download link on the page, dl to file
    2. import & convert it
    ```powershell
    $licdb = gc C:\sc\powershell\EXOScripts\o365-ProductLicensesDb.json | ConvertFrom-Json ; 
    ```
    3. Filter for targets, exclude 'EXCHANGE_ANALYTICS, EXCHANGE_S_ARCHIVE, EXCHANGE_S_ARCHIVE_ADDON non-mailbox-granting
    ```powershell
    $licdb.items | ?{$_.ServicePlans -match 'Exchange'} | select -expand ServicePlans | ?{$_ -match 'EXCHANGE_' -AND $_-notmatch '_(ANALYTICS|ARCHIVE|FOUNDATION)'} | SELECT -UNIQUE  | sort ;
    EXCHANGE_B_STANDARD
    EXCHANGE_L_STANDARD
    EXCHANGE_S_DESKLESS
    EXCHANGE_S_ENTERPRISE
    EXCHANGE_S_ESSENTIALS
    EXCHANGE_S_STANDARD
    EXCHANGE_S_STANDARD_MIDMARKET

    ```
    4. So we can take any give Get-MgSubscribedSku and filter for licenses which include the above, to pick out suitable Exchange-Mailbox-supporting licenses. This filtered list goes in the default $ServicePlanName list


    ## Discussion of the topic - dynamically finding ongoing licenses as they mess with the licenses

    [Service plans that indicate an exchange license? - Microsoft Q&A](https://learn.microsoft.com/en-us/answers/questions/967768/service-plans-that-indicate-an-exchange-license)

        #-=-=-=-=-=-=-=-=
        Service plans that indicate an exchange license?
        isaac parsons 6 Reputation points
        Aug 15, 2022, 2:34 PM
        From what I gather EXCHANGE_S_STANDARD, EXCHANGE_B_STANDARD, EXCHANGE_L_STANDARD, EXCHANGE_S_ENTERPRISE, EXCHANGE_S_STANDARD_GOV, EXCHANGE_S_ENTERPRISE_GOV, EXCHANGE_S_STANDARD_MIDMARKET are service plans that indicate an exchange license, are there any others that I'm missing?
        Microsoft Exchange Online Management 
        ---
        Dillon Silzer 54,926 Reputation points
        Aug 16, 2022, 9:58 PM
        Hey @isaac parsons
        If you navigate to https://learn.microsoft.com/en-us/azure/active-directory/enterprise-users/licensing-service-plan-reference you can scroll down to the Exchange plans under Enterprise Mobility + Security G5 GCC:
        You can also use CTRL+F and type the work EXCHANGE and search the page for all the plans that include it.
        You can also download the CSV version here.

        #-=-=-=-=-=-=-=-=

    ## [Mailbox plans in Exchange Online | Microsoft Learn](https://learn.microsoft.com/en-us/exchange/recipients-in-exchange-online/manage-user-mailboxes/mailbox-plans)

    ### Mailbox plans in Exchange Online

        Article
        02/21/2023
        The following table describes the mailbox plans that you're likely to see in Exchange Online.
        Subscription or license 	Mailbox plan display name
        Exchange Online Kiosk
        Microsoft 365 or Office 365 Enterprise F3
	        ExchangeOnlineDeskless
        Microsoft 365 Business Basic
        Microsoft 365 or Office 365 Enterprise E1
        Exchange Online Plan 1
	        ExchangeOnline
        Microsoft 365 or Office 365 Enterprise E3
        Microsoft 365 or Office 365 Enterprise E5
        Exchange Online Plan 2
    

    .PARAMETER ServicePlanName
    ServicePlanName values that identify Exchange-mailbox supporting licenses (defaults to EXCHANGE_S_DESKLESS|EXCHANGE_S_STANDARD|EXCHANGE_S_ENTERPRISE)[-ServicePlanName 'EXCHANGE_S_DESKLESS']
    .PARAMETER rgxbannedSPN
    Regular Expression for ServicePlanName values should be excluded from results (Common Area Phone license etc)[-rgxBannedSPN 'EXCHANGE_S_DESKLESS']
    .PARAMETER OutDetail
    Switch to enable expanded non-legacy return (legacy returned SKU|Label|Notes; -outdetail adds Enabled|Consumed|Available|Warning|Suspended specs)[-OutDetail]
    .PARAMETER Unfiltered
    Switch to suppress normal post-filter Availability checks (Available -gt 0 & Enabled -gt 0) and return *any* matched supporting licenses in the Tenant [-unfiltered]
    .PARAMETER TenOrg
    Tenant Tag (3-letter abbrebiation)[-TenOrg 'XYZ']
    .PARAMETER Credential
    Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]
    .PARAMETER UserRole
    Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER Silent
    Switch to specify suppression of all but warn/error echos.(unimplemented, here for cross-compat)
    .EXAMPLE
    PS> $ExMbxLicenses = get-ExoMailboxLicenses ;
    PS> $ExMbxLicenses

        Name                           Value
        ----                           -----
        SPE_F1                         @{SKU=SPE_F1; Label=F1; Notes=Enabled:5681|Consumed:5179|Avail:502|Warn:0|Susp:0}
        SPE_E3                         @{SKU=SPE_E3; Label=E3; Notes=Enabled:5326|Consumed:5298|Avail:28|Warn:0|Susp:0}
        STANDARDPACK                   @{SKU=STANDARDPACK; Label=STANDARDPACK; Notes=Enabled:268|Consumed:241|Avail:27|Warn:0|Susp:0}    

    Simplest demo, unformatted output, that is still fast-readable to find usables
    .EXAMPLE
    PS>  $pltGXML=[ordered]@{
    PS>      #TenOrg= $TenOrg;
    PS>      verbose=$($VerbosePreference -eq "Continue") ;
    PS>      #credential= $pltRXO.credential ;
    PS>      #(Get-Variable -name cred$($tenorg) ).value ;
    PS>  } ;
    PS>  $smsg = "$($tenorg):get-ExoMailboxLicenses w`n$(($pltGXML|out-string).trim())" ;
    PS>  if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
    PS>  else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    PS>  $objRet = $null ;
    PS>  $objRet = get-ExoMailboxLicenses @pltGXML ;
    PS>  if( ($objRet|Measure-Object).count -AND $objRet.GetType().FullName -match $rgxHashTableTypeName ){
    PS>      $smsg = "get-ExoMailboxLicenses:$($tenorg):returned populated ExMbxLicenses" ;
    PS>      if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
    PS>      else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    PS>      $ExMbxLicenses = $objRet ;
    PS>  } else {
    PS>      $smsg = "get-ExoMailboxLicenses:$($tenorg):FAILED TO RETURN populated [hashtable] ExMbxLicenses" ;
    PS>      if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } 
    PS>      else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    PS>      THROW $SMSG ; 
    PS>      break ; 
    PS>  } ;
    PS>  $smsg = "$(($ExMbxLicenses.Values|measure).count) EXO UserMailbox-supporting License summaries returned)" ;
    PS>  if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
    PS>  else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;    
    PS>  $smsg = "$(($ExMbxLicenses.Values|measure).count) EXO UserMailbox-supporting License summaries returned)" ;
    PS>  if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
    PS>  else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    PS> $aadu = get-azureaduser -obj someuser@domain.com ; 
    PS> $IsExoLicensed = $false ;
    PS> foreach($pLic in $aadu.AssignedLicenses){
    PS>     $smsg = "--(LicSku:$($plic): checking EXO UserMailboxSupport)" ; 
    PS>     if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    PS>     else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;                                     
    PS>     if($ExMbxLicenses[$plic]){
    PS>         $hSummary.IsExoLicensed = $true ;
    PS>         $smsg = "$($mbx.userprincipalname) HAS EXO UserMailbox-supporting License:$($ExMbxLicenses[$sku].SKU)|$($ExMbxLicenses[$sku].Label)" ; 
    PS>         if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    PS>         else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    PS> } ; 
    PS> if(-not $hSummary.IsExoLicensed){
    PS>     $smsg = "$($mbx.userprincipalname) WAS FOUND TO HAVE *NO* EXO UserMailbox-supporting License!" ; 
    PS>     if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
    PS>     else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    PS> } ;
    Expanded example with testing of returned object, and demoes use of the returned hash against a AzureADUser spec
    .EXAMPLE
    PS> $pltGXML=[ordered]@{
    PS>    #TenOrg= $TenOrg;
    PS>    verbose=$($VerbosePreference -eq "Continue") ;
    PS>    #credential= $pltRXO.credential ;
    PS>    #(Get-Variable -name cred$($tenorg) ).value ;
    PS>    Unfiltered = $true ; 
    PS>    OutDetail = $true ; 
    PS> } ;
    PS> $smsg = "$($tenorg):get-ExoMailboxLicenses w`n$(($pltGXML|out-string).trim())" ;
    PS> if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
    PS> else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    PS> $objRet = $null ;
    PS> $objRet = get-ExoMailboxLicenses @pltGXML ;
    Demo that shows retrieving unfiltered full detail - as this now returns filtered usable/assignable licenses by default.
    .EXAMPLE
    PS> $ExMbxLicenses = get-ExoMailboxLicenses ;
    PS> [regex]$rgxExLics = ('(' + (($ExMbxLicenses.GetEnumerator().name |%{[regex]::escape($_)}) -join '|') + ')') ; 
    Demo pulling the underlying licenses list and building a regex for static use
    .EXAMPLE
    PS> $TenOrg = 'ABC' ; 
    PS> $ExMbxLicenses = get-ExoMailboxLicenses ;
    PS> $licOrdered = @() ; 
    PS> 'EXCHANGE_S_DESKLESS','EXCHANGE_S_STANDARD','EXCHANGE_S_ENTERPRISE' | %{
    PS>     $SPN = $_ ; 
    PS>     $licOrdered += $ExMbxLicenses.values | ?{$_.ServicePlanName -eq $SPN } | sort Enabled,Available -Descending; 
    PS> } ; 
    PS> $TenDom = (gv -name "$($TenOrg)Meta").value['o365_TenantDom'].tolower() ; 
    PS> $LicenseSkuIds = $licOrdered.sku  | %{"$($TenDom):$($_)"} ;
    Demo pushing the licenses into application preference order from cheapest to most $$ class, and sorted subs on Enabled & Available (lifted from Add-EXOLicense()).
    .EXAMPLE
    PS> TRY{
    PS>     $url = 'https://github.com/jpawlowski/Azure-AD-Licensing-DB/blob/master/ProductLicensesDb.json' ; 
    PS>     $tfile = join-path 'C:\usr\work\o365\scripts\' ($url.split('/')[-1]) ; 
    PS>     write-host "DL source json db of licenses to:`n$($tfile)" ; 
    PS>     Invoke-WebRequest -Uri $url -OutFile $tfile ; 
    PS>     write-verbose "import the json into a vari" ; 
    PS>     $licdb = gc $tfile | ConvertFrom-Json ; 
    PS>     write-host "filter licenses with ServicePlans named with Exchange, filter & exclude non-mailbox variants, select unique, and output a sorted list, for use in the `$ServicePlanName array" ; 
    PS>     $licdb.items | ?{$_.ServicePlans -match 'Exchange'} | select -expand ServicePlans | ?{$_ -match 'EXCHANGE_' -AND $_-notmatch '_(ANALYTICS|ARCHIVE|FOUNDATION)'} | SELECT -UNIQUE  | sort ;
    PS> } CATCH {
    PS>     $ErrTrapd=$Error[0] ;
    PS>     $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
    PS>     write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
    PS> } ;
    Demo that downloads a json db of licenses and filters out the Exchange mailbox supporting licenses.
    .LINK
    https://github.com/tostka/verb-ex2010
    #>
    #Requires -Modules verb-IO, verb-logging, verb-Text, AzureAD
    [OutputType('System.Collections.Hashtable')]
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory=$FALSE,HelpMessage="ServicePlanName values that identify Exchange-mailbox supporting licenses[-ServicePlanName 'EXCHANGE_S_DESKLESS']")]
            #[ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string[]]$ServicePlanName = @('EXCHANGE_B_STANDARD','EXCHANGE_L_STANDARD','EXCHANGE_S_DESKLESS','EXCHANGE_S_ENTERPRISE','EXCHANGE_S_ESSENTIALS','EXCHANGE_S_STANDARD','EXCHANGE_S_STANDARD_MIDMARKET'),
            # above is full list of ServicePlans extracted from o365-ProductLicensesDb.json, other than 'EXCHANGE_ANALYTICS','EXCHANGE_S_ARCHIVE','EXCHANGE_S_ARCHIVE_ADDON'
            # our list
            #@('EXCHANGE_S_DESKLESS','EXCHANGE_S_STANDARD','EXCHANGE_S_ENTERPRISE'),
        [Parameter(Mandatory=$FALSE,HelpMessage="Regular Expression for ServicePlanName values should be excluded from results (Common Area Phone license etc)[-rgxBannedSPN 'EXCHANGE_S_DESKLESS']")]
            #[ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$rgxbannedSPN = '^MCOCAP$',
        [Parameter(Mandatory=$FALSE,HelpMessage="Switch to enable expanded non-legacy return (legacy returned SKU|Label|Notes; -outdetail adds Enabled|Consumed|Available|Warning|Suspended specs)[-OutDetail]")]
            #[ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [switch]$OutDetail,
        [Parameter(Mandatory=$FALSE,HelpMessage="Switch to suppress normal post-filter Availability checks (Available -gt 0 & Enabled -gt 0) and return *any* matched supporting licenses in the Tenant [-unfiltered]")]
            #[ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [switch]$Unfiltered,
        # Service Connection Supporting Varis (AAD, EXO, EXOP)
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
            [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ;
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ;
                return $true ;
            })]
            [string[]]$UserRole = @('ESvcCBA','CSvcCBA','SIDCBA','SID'),
            #@('SID','CSVC'),
            # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
            [switch] $useEXOv2=$true,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent
    ) ;
    BEGIN { 
        # for scripts wo support, can use regions to fake BEGIN;PROCESS;END:
        # ps1 faked:#region BEGIN ; #*------v BEGIN v------
        #region CONSTANTS_AND_ENVIRO ; #*======v CONSTANTS_AND_ENVIRO v======
        #region ENVIRO_DISCOVER ; #*------v ENVIRO_DISCOVER v------
        push-TLSLatest
        $Verbose = [boolean]($VerbosePreference -eq 'Continue') ; 
        $rPSCmdlet = $PSCmdlet ; # an object that represents the cmdlet or advanced function that's being run. Available on functions w CmdletBinding (& $args will not be available). (Blank on non-CmdletBinding/Non-Adv funcs).
        $rPSScriptRoot = $PSScriptRoot ; # the full path of the executing script's parent directory., PS2: valid only in script modules (.psm1). PS3+:it's valid in all scripts. (Funcs: ParentDir of the file that hosts the func)
        $rPSCommandPath = $PSCommandPath ; # the full path and filename of the script that's being run, or file hosting the funct. Valid in all scripts.
        $rMyInvocation = $MyInvocation ; # populated only for scripts, function, and script blocks.
        # - $MyInvocation.MyCommand.Name returns name of a function, to identify the current command,  name of the current script (pop'd w func name, on Advfuncs)
        # - Ps3+:$MyInvocation.PSScriptRoot : full path to the script that invoked the current command. The value of this property is populated only when the caller is a script (blank on funcs & Advfuncs)
        # - Ps3+:$MyInvocation.PSCommandPath : full path and filename of the script that invoked the current command. The value of this property is populated only when the caller is a script (blank on funcs & Advfuncs)
        #     ** note: above pair contain information about the _invoker or calling script_, not the current script
        $rPSBoundParameters = $PSBoundParameters ; 
        #region PREF_VARI_DUMP ; #*------v PREF_VARI_DUMP v------
        <#$script:prefVaris = @{
            whatifIsPresent = $whatif.IsPresent
            whatifPSBoundParametersContains = $rPSBoundParameters.ContainsKey('WhatIf') ; 
            whatifPSBoundParameters = $rPSBoundParameters['WhatIf'] ;
            WhatIfPreferenceIsPresent = $WhatIfPreference.IsPresent ; # -eq $true
            WhatIfPreferenceValue = $WhatIfPreference;
            WhatIfPreferenceParentScopeValue = (Get-Variable WhatIfPreference -Scope 1).Value ;
            ConfirmPSBoundParametersContains = $rPSBoundParameters.ContainsKey('Confirm') ; 
            ConfirmPSBoundParameters = $rPSBoundParameters['Confirm'];
            ConfirmPreferenceIsPresent = $ConfirmPreference.IsPresent ; # -eq $true
            ConfirmPreferenceValue = $ConfirmPreference ;
            ConfirmPreferenceParentScopeValue = (Get-Variable ConfirmPreference -Scope 1).Value ; 
            VerbosePSBoundParametersContains = $rPSBoundParameters.ContainsKey('Confirm') ; 
            VerbosePSBoundParameters = $rPSBoundParameters['Verbose'] ;
            VerbosePreferenceIsPresent = $VerbosePreference.IsPresent ; # -eq $true
            VerbosePreferenceValue = $VerbosePreference ;
            VerbosePreferenceParentScopeValue = (Get-Variable VerbosePreference -Scope 1).Value;
            VerboseMyInvContains = '-Verbose' -in $rPSBoundParameters.UnboundArguments ; 
            VerbosePSBoundParametersUnboundArgumentContains = '-Verbose' -in $rPSBoundParameters.UnboundArguments 
        } ;
        write-verbose "`n$(($script:prefVaris.GetEnumerator() | Sort-Object Key | Format-Table Key,Value -AutoSize|out-string).trim())`n" ; 
        #>
        #endregion PREF_VARI_DUMP ; #*------^ END PREF_VARI_DUMP ^------
        #region RV_ENVIRO ; #*------v RV_ENVIRO v------
        $pltRvEnv=[ordered]@{
            PSCmdletproxy = $rPSCmdlet ; 
            PSScriptRootproxy = $rPSScriptRoot ; 
            PSCommandPathproxy = $rPSCommandPath ; 
            MyInvocationproxy = $rMyInvocation ;
            PSBoundParametersproxy = $rPSBoundParameters
            verbose = [boolean]($PSBoundParameters['Verbose'] -eq $true) ; 
        } ;
        write-verbose "(Purge no value keys from splat)" ; 
        $mts = $pltRVEnv.GetEnumerator() |?{$_.value -eq $null} ; $mts |%{$pltRVEnv.remove($_.Name)} ; rv mts -ea 0 -whatif:$false -confirm:$false; 
        $smsg = "resolve-EnvironmentTDO w`n$(($pltRVEnv|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        if(get-command resolve-EnvironmentTDO -ea STOP){}ELSE{
            $smsg = "UNABLE TO gcm resolve-EnvironmentTDO!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            BREAK ; 
        } ; 
        $rvEnv = resolve-EnvironmentTDO @pltRVEnv ; 
        $smsg = "`$rvEnv returned:`n$(($rvEnv |out-string).trim())" ; 
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        #endregion RV_ENVIRO ; #*------^ END RV_ENVIRO ^------
        #region NETWORK_INFO ; #*======v NETWORK_INFO v======
        if(get-command resolve-NetworkLocalTDO  -ea STOP){}ELSE{
            $smsg = "UNABLE TO gcm resolve-NetworkLocalTDO !" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            BREAK ; 
        } ; 
        $netsettings = resolve-NetworkLocalTDO ; 
        if($env:Userdomain){ 
            switch($env:Userdomain){
                'CMW'{
                    #$logon_SID = $CMW_logon_SID 
                }
                'TORO'{
                    #$o365_SIDUpn = $o365_Toroco_SIDUpn ; 
                    #$logon_SID = $TOR_logon_SID ; 
                }
                $env:COMPUTERNAME{
                    $smsg = "%USERDOMAIN% -EQ %COMPUTERNAME%: $($env:computername) => non-domain-connected, likely edge role Ex server!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    if($netsettings.Workgroup){
                        $smsg = "WorkgroupName:$($netsettings.Workgroup)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;                    
                    } ; 
                } ; 
                default{
                    $smsg = "$($env:userdomain):UNRECOGIZED/UNCONFIGURED USER DOMAIN STRING!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    THROW $SMSG 
                    BREAK ; 
                }
            } ; 
        } ;  # $env:Userdomain-E
        #endregion NETWORK_INFO ; #*======^ END NETWORK_INFO ^======
        #region OS_INFO ; #*------v OS_INFO v------
        <# os detect, covers Server 2016, 2008 R2, Windows 10, 11
        if (get-command get-ciminstance -ea 0) {$OS = (Get-ciminstance -class Win32_OperatingSystem)} else {$Os = Get-WMIObject -class Win32_OperatingSystem } ;
        #$isWorkstationOS = $isServerOS = $isW2010 = $isW2011 = $isS2016 = $isS2008R2 = $false ;
        write-host "Detected:`$Os.Name:$($OS.name)`n`$Os.Version:$($Os.Version)" ;
        if ($OS.name -match 'Microsoft\sWindows\sServer') {
            $isServerOS = $true ;
            if ($os.name -match 'Microsoft\sWindows\sServer\s2016'){$isS2016 = $true ;} ;
            if ($os.name -match 'Microsoft\sWindows\sServer\s2008\sR2') { $isS2008R2 = $true ; } ;
        } else { 
            if ($os.name -match '^Microsoft\sWindows\s11') {
                $isWorkstationOS = $true ;
                if ($os.name -match 'Microsoft\sWindows\s11') { $isW2011 = $true ; } ;
            } elseif ($os.name -match '^Microsoft\sWindows\s10') {
                $isWorkstationOS = $true ; $isW2010 = $true
            } else {
                $isWorkstationOS = $true ;
            } ;         
        } ; 
        #>
        #endregion OS_INFO ; #*------^ END OS_INFO ^------
        #region TEST_EXOPLOCAL ; #*------v TEST_EXOPLOCAL v------
        if(get-command test-LocalExchangeInfoTDO -ea STOP){}ELSE{
            $smsg = "UNABLE TO gcm test-LocalExchangeInfoTDO !" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            BREAK ; 
        } ; 
        $lclExOP = test-LocalExchangeInfoTDO ; 
        write-verbose "Expand returned NoteProperty properties into matching local variables" ; 
        if($host.version.major -gt 2){
            $lclExOP.PsObject.Properties | ?{$_.membertype -eq 'NoteProperty'} | foreach-object{set-variable -name $_.name -value $_.value -verbose -whatif:$false -Confirm:$false ;} ;
        }else{
            write-verbose "Psv2 lacks the above expansion capability; just create simpler variable set" ; 
            $ExVers = $lclExOP.ExVers ; $isLocalExchangeServer = $lclExOP.isLocalExchangeServer ; $IsEdgeTransport = $lclExOP.IsEdgeTransport ;
        } ;
        #
        #endregion TEST_EXOPLOCAL ; #*------^ END TEST_EXOPLOCAL ^------

        <#
        #region PsParams ; #*------v PSPARAMS v------
        $PSParameters = New-Object -TypeName PSObject -Property $rPSBoundParameters ;
        # DIFFERENCES $PSParameters vs $PSBoundParameters:
        # - $PSBoundParameters: System.Management.Automation.PSBoundParametersDictionary (native obj)
        # test/access: ($PSBoundParameters['Verbose'] -eq $true) ; $PSBoundParameters.ContainsKey('Referrer') #hash syntax
        # CAN use as a @PSBoundParameters splat to push through (make sure populated, can fail if wrong type of wrapping code)
        # - $PSParameters: System.Management.Automation.PSCustomObject (created obj)
        # test/access: ($PSParameters.verbose -eq $true) ; $PSParameters.psobject.Properties.name -contains 'SenderAddress' ; # cobj syntax
        # CANNOT use as a @splat to push through (it's a cobj)
        write-verbose "`$rPSBoundParameters:`n$(($rPSBoundParameters|out-string).trim())" ;
        # pre psv2, no $rPSBoundParameters autovari to check, so back them out:
        #>
        <# recycling $rPSBoundParameters into @splat calls: (can't use $psParams, it's a cobj, not a hash!)
        # rgx for filtering $rPSBoundParameters for params to pass on in recursive calls (excludes keys matching below)
        $rgxBoundParamsExcl = '^(Name|RawOutput|Server|Referrer)$' ; 
        if($rPSBoundParameters){
                $pltRvSPFRec = [ordered]@{} ;
                # add the specific Name for this call, and Server spec (which defaults, is generally not 
                $pltRvSPFRec.add('Name',"$RedirectRecord" ) ;
                $pltRvSPFRec.add('Referrer',$Name) ; 
                $pltRvSPFRec.add('Server',$Server ) ;
                $rPSBoundParameters.GetEnumerator() | ?{ $_.key -notmatch $rgxBoundParamsExcl} | foreach-object { $pltRvSPFRec.add($_.key,$_.value)  } ;
                write-host "Resolve-SPFRecord w`n$(($pltRvSPFRec|out-string).trim())" ;
                Resolve-SPFRecord @pltRvSPFRec  | write-output ;
        } else {
            $smsg = "unpopulated `$rPSBoundParameters!" ;
            write-warning $smsg ;
            throw $smsg ;
        };     
        #>
        #endregion PsParams ; #*------^ END PSPARAMS ^------    
        #endregion ENVIRO_DISCOVER ; #*------^ END ENVIRO_DISCOVER ^------

        #region COMMON_CONSTANTS ; #*------v COMMON_CONSTANTS v------
    
        if(-not $DoRetries){$DoRetries = 4 } ;    # # times to repeat retry attempts
        if(-not $RetrySleep){$RetrySleep = 10 } ; # wait time between retries
        if(-not $RetrySleep){$DawdleWait = 30 } ; # wait time (secs) between dawdle checks
        if(-not $DirSyncInterval){$DirSyncInterval = 30 } ; # AADConnect dirsync interval
        if(-not $ThrottleMs){$ThrottleMs = 50 ;}
        if(-not $rgxDriveBanChars){$rgxDriveBanChars = '[;~/\\\.:]' ; } ; # ;~/\.:,
        if(-not $rgxCertThumbprint){$rgxCertThumbprint = '[0-9a-fA-F]{40}' } ; # if it's a 40char hex string -> cert thumbprint  
        if(-not $rgxSmtpAddr){$rgxSmtpAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ; } ; # email addr/UPN
        if(-not $rgxDomainLogon){$rgxDomainLogon = '^[a-zA-Z][a-zA-Z0-9\-\.]{0,61}[a-zA-Z]\\\w[\w\.\- ]+$' } ; # DOMAIN\samaccountname 
        if(-not $exoMbxGraceDays){$exoMbxGraceDays = 30} ; 
        if(-not $XOConnectionUri ){$XOConnectionUri = 'https://outlook.office365.com'} ; 
        if(-not $SCConnectionUri){$SCConnectionUri = 'https://ps.compliance.protection.outlook.com'} ; 
        if(-not $XODefaultPrefix){$XODefaultPrefix = 'xo' };
        if(-not $SCDefaultPrefix){$SCDefaultPrefix = 'sc' };
        #$rgxADDistNameGAT = ",$(($TORMeta.UnreplicatedOU -split ',' | select -skip 1 ) -join ',')" 
        #$rgxADDistNameAT = ",$(($TORMeta.UnreplicatedOU -split ',' | select -skip 2 ) -join ',')"

        write-verbose "Coerce configured but blank Resultsize to Unlimited" ; 
        if(get-variable -name resultsize -ea 0){
            if( ($null -eq $ResultSize) -OR ('' -eq $ResultSize) ){$ResultSize = 'unlimited' }
            elseif($Resultsize -is [int]){} else {throw "Resultsize must be an integer or the string 'unlimited' (or blank)"} ;
        } ; 
        #$ComputerName = $env:COMPUTERNAME ;
        #$NoProf = [bool]([Environment]::GetCommandLineArgs() -like '-noprofile'); # if($NoProf){# do this};
        # XXXMeta derived constants:
        # - AADU Licensing group checks
        # calc the rgxLicGrpName fr the existing $xxxmeta.rgxLicGrpDN: (get-variable tormeta).value.rgxLicGrpDN.split(',')[0].replace('^','').replace('CN=','')
        #$rgxLicGrpName = (get-variable -name "$($tenorg)meta").value.rgxLicGrpDN.split(',')[0].replace('^','').replace('CN=','')
        # use the dn vers LicGrouppDN = $null ; # | ?{$_ -match $tormeta.rgxLicGrpDN}
        #$rgxLicGrpDN = (get-variable -name "$($tenorg)meta").value.rgxLicGrpDN
        # email trigger vari, it will be semi-delimd list of mail-triggering events
        $script:PassStatus = $null ;
        # TenOrg or other looped-specific PassStatus (auto supported by 7pswlt)
        #New-Variable -Name PassStatus_$($tenorg) -scope Script -Value $null ;
        [array]$SmtpAttachment = $null ;
        #write-verbose "start-Timer:Master" ; 
        $swM = [Diagnostics.Stopwatch]::StartNew() ;
        # $ByPassLocalExchangeServerTest = $true # rough in, code exists below for exempting service/regkey testing on this variable status. Not yet implemented beyond the exemption code, ported in from orig source.
        #endregion COMMON_CONSTANTS ; #*------^ END COMMON_CONSTANTS ^------
              
        #region LOCAL_CONSTANTS ; #*------v LOCAL_CONSTANTS v------

        # BELOW TRIGGERS/DRIVES TEST_MODS: array of: "[modname];[modDLUrl,or pscmdline install]"    
        $tDepModules = @() ;
        $useVerbCore = $true ; 
        if($useVerbCore){
            $tDepModules += @('verb-logging;localRepo;write-log') ; #start-log; write-log ;
            $tDepModules += @('verb-io;localRepo;resolve-EnvironmentTDO') ; #resolve-EnvironmentTDO
            $tDepModules += @('verb-Network;localRepo;resolve-NetworkLocalTDO') ; #resolve-NetworkLocalTDO; Send-EmailNotif
        } ;
        <# NOTE: Svc modules are tested as needed by connect-O365Servicees() & connect-OPServices()
        if($useEXO){$tDepModules += @("ExchangeOnlineManagement;https://www.powershellgallery.com/packages/ExchangeOnlineManagement/;Get-xoOrganizationConfig",'verb-exo;localRepo;connect-exo')} ;
        if($UseMSOL){$tDepModules += @("MSOnline;https://www.powershellgallery.com/packages/MSOnline/;Get-MsolDomain")} ;
        if($UseAAD){$tDepModules += @("AzureAD;https://www.powershellgallery.com/packages/AzureAD/;Get-AzureADTenantDetail")} ;
        if($UseExOP){$tDepModules += @('verb-Ex2010;localRepo;Connect-Ex2010')} ;
        if($UseMG){$tDepModules += @("Microsoft.Graph.Authentication;https://www.powershellgallery.com/packages/Microsoft.Graph/;Get-MgOrganization")} ;
        if($UseOPAD){$tDepModules += @("ActiveDirectory;get-windowscapability -name RSAT* -Online | ?{$_.name -match 'Rsat\.ActiveDirectory'} | %{Add-WindowsCapability -online -name $_.name};Get-ADDomain")} ;
        #>

        $prpMGConnDeleg = 'Account','ClientId','TenantId','AuthType','ContextScope' ; 
        $prpMGConnCBA = 'CertificateSubjectName','CertificateThumbprint','Certificate' ; 
        $prpMGConnRet = $($prpMGConnDeleg;$prpMGConnCBA) ; 

        #endregion LOCAL_CONSTANTS ; #*------^ END LOCAL_CONSTANTS ^------  
          
        #region ENCODED_CONTANTS ; #*------v ENCODED_CONTANTS v------
        # ENCODED CONsTANTS & SUPPORT FUNCTIONS:
        #region 2B4 ; #*------v 2B4 v------
        if(-not (get-command 2b4 -ea 0)){function 2b4{[CmdletBinding()][Alias('convertTo-Base64String')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ; PROCESS{$str|%{[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_))}  };} ; } ; 
        #endregion 2B4 ; #*------^ END 2B4 ^------
        #region 2B4C ; #*------v 2B4C v------
        # comma-quoted return
        if(-not (get-command 2b4c -ea 0)){function 2b4c{ [CmdletBinding()][Alias('convertto-Base64StringCommaQuoted')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ;BEGIN{$outs = @()} PROCESS{[array]$outs += $str | %{[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_))} ; } END {'"' + $(($outs) -join '","') + '"' | out-string | set-clipboard } ; } ; } ; 
        #endregion 2B4C ; #*------^ END 2B4C ^------
        #region FB4 ; #*------v FB4 v------
        # DEMO: $SitesNameList = 'THluZGFsZQ==','U3BlbGxicm9vaw==','QWRlbGFpZGU=' | fb4 ;
        if(-not (get-command fb4 -ea 0)){function fb4{[CmdletBinding()][Alias('convertFrom-Base64String')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ; PROCESS{$str | %{ [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($_)) }; } ; } ; }; 
        #endregion FB4 ; #*------^ END FB4 ^------
        # FOLLOWING CONSTANTS ARE USED FOR DEPENDANCY-LESS CONNECTIONS
        if(-not $o365_Toroco_SIDUpn){$o365_Toroco_SIDUpn = 'cy10b2RkLmthZHJpZUB0b3JvLmNvbQ==' | fb4 } ;
        $o365_SIDUpn = $o365_Toroco_SIDUpn ; 
        switch($env:Userdomain){
            'CMW'{
                if(-not $CMW_logon_SID){$CMW_logon_SID = 'Q01XXGQtdG9kZC5rYWRyaWU=' | fb4 } ; 
                $logon_SID = $CMW_logon_SID ; 
            }
            'TORO'{
                if(-not $TOR_logon_SID){$TOR_logon_SID = 'VE9ST1xrYWRyaXRzcw==' | fb4 } ; 
                $logon_SID = $TOR_logon_SID ; 
            }
            $env:COMPUTERNAME{
                $smsg = "%USERDOMAIN% -EQ %COMPUTERNAME%: $($env:computername) => non-domain-connected, likely edge role Ex server!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                if($WorkgroupName = (Get-WmiObject -Class Win32_ComputerSystem).Workgroup){
                    $smsg = "WorkgroupName:$($WorkgroupName)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                }
                if(($isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup')) -or (
                        $isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\Setup')) -or
                            $ByPassLocalExchangeServerTest){
                            $smsg = "We are on Exchange Server"
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            $IsEdgeTransport = $false
                            if((Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\EdgeTransportRole') -or (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\EdgeTransportRole')){
                                $smsg = "We are on Exchange Edge Transport Server"
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                $IsEdgeTransport = $true
                            } ; 
                } else {
                    $isLocalExchangeServer = $false 
                    $IsEdgeTransport = $false ;
                } ;
            } ; 
            default{
                $smsg = "$($env:userdomain):UNRECOGIZED/UNCONFIGURED USER DOMAIN STRING!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                THROW $SMSG 
                BREAK ; 
            }
        } ; 
        #endregion ENCODED_CONTANTS ; #*------^ END ENCODED_CONTANTS ^------
    
        #endregion CONSTANTS_AND_ENVIRO ; #*======^ CONSTANTS_AND_ENVIRO ^======

        #region SUBMAIN ; #*======v SUB MAIN v======
    
        #region BANNER ; #*------v BANNER v------
        $sBnr="#*======v $(${CmdletName}): v======" ;
        $smsg = $sBnr ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #endregion BANNER ; #*------^ END BANNER ^------

        <#
        $useO365 = $true ;
        $useEXO = $true ; 
        $UseOP=$true ; 
        $UseExOP=$true ;
        $useExopNoDep = $true ; # switch to use Connect-ExchangeServerTDO, vs connect-ex2010 (creds are assumed inherent to the account)
        $ExopVers = 'Ex2010' # 'Ex2019','Ex2016','Ex2013','Ex2010','Ex2007','Ex2003','Ex2000', Null for All versions
        if($Version){
            $ExopVers = $Version ; #defer to local script $version if set
        } ; 
        $useForestWide = $true ; # flag to trigger cross-domain/forest-wide code in AD & EXoP
        $UseOPAD = $false ; 
        $UseMSOL = $false ; # should be hard disabled now in o365
        $UseAAD = $true ; 
        #>

        #region SERVICE_CONNECTIONS #*======v END SERVICE_CONNECTIONS v======
    
        #region BROAD_SVC_CONTROL_VARIS ; #*======v BROAD_SVC_CONTROL_VARIS  v======   
        $useO365 = $true ; 
        $useOP = $true ;     
        # (config individual svcs in each block)
        #endregion BROAD_SVC_CONTROL_VARIS ; #*======^ END BROAD_SVC_CONTROL_VARIS ^======

        #region CALL_CONNECT_O365SERVICES ; #*======v CALL_CONNECT_O365SERVICES v======
        #$useO365 = $true ; 
        if($useO365){
            $pltCco365Svcs=[ordered]@{
                # environment parameters:
                EnvSummary = $rvEnv ; 
                NetSummary = $netsettings ; 
                # service choices
                useEXO = $true ;
                useSC = $false ; 
                UseMSOL = $false ;
                UseAAD = $false ; # M$ is actively blocking all AAD access now: Message: Access blocked to AAD Graph API for this application. https://aka.ms/AzureADGraphMigration.
                UseMG = $true ;
                # Service Connection parameters
                TenOrg = $TenOrg ; # $global:o365_TenOrgDefault ; 
                Credential = $Credential ;
                AdminAccount = $AdminAccount ; 
                #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
                UserRole = $UserRole ; # @('SID','CSVC') ;
                # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
                silent = $silent ;
                MGPermissionsScope = $MGPermissionsScope ;
                MGCmdlets = $MGCmdlets ;
            } ;
            write-verbose "(Purge no value keys from splat)" ; 
            $mts = $pltCco365Svcs.GetEnumerator() |?{$_.value -eq $null} ; $mts |%{$pltCco365Svcs.remove($_.Name)} ; rv mts -ea 0 ; 
            if((get-command connect-O365Services -EA STOP).parameters.ContainsKey('whatif')){
                $pltCco365SvcsnDSR.add('whatif',$($whatif))
            } ; 
            $smsg = "connect-O365Services w`n$(($pltCco365Svcs|out-string).trim())" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # add rertry on fail, up to $DoRetries
            $Exit = 0 ; # zero out $exit each new cmd try/retried
            # do loop until up to 4 retries...
            Do {
                $smsg = "connect-O365Services w`n$(($pltCco365Svcs|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $ret_ccSO365 = connect-O365Services @pltCco365Svcs ; 
                #region CONFIRM_CCEXORETURN ; #*------v CONFIRM_CCEXORETURN v------
                # matches each: $plt.useXXX:$true to matching returned $ret.hasXXX:$true 
                $vplt = $pltCco365Svcs ; $vret = 'ret_ccSO365' ; $ACtionCommand = 'connect-O365Services' ; $vtests = @() ; $vFailMsgs = @()  ; 
                $vplt.GetEnumerator() |?{$_.key -match '^use' -ANd $_.value -match $true} | foreach-object{
                    $pltkey = $_ ;
                    $smsg = "$(($pltkey | ft -HideTableHeaders name,value|out-string).trim())" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    $tprop = $pltkey.name -replace '^use','has';
                    if($rProp = (gv $vret).Value.psobject.properties | ?{$_.name -match $tprop}){
                        $smsg = "$(($rprop | ft -HideTableHeaders name,value |out-string).trim())" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        if($rprop.Value -eq $pltkey.value){
                            $vtests += $true ; 
                            $smsg = "Validated: $($pltKey.name):$($pltKey.value) => $($rprop.name):$($rprop.value)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        } else {
                            $smsg = "NOT VALIDATED: $($pltKey.name):$($pltKey.value) => $($rprop.name):$($rprop.value)" ;
                            $vtests += $false ; 
                            $vFailMsgs += "`n$($smsg)" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        };
                    } else{
                        $smsg = "Unable to locate: $($pltKey.name):$($pltKey.value) to any matching $($rprop.name)!)" ;
                        $smsg = "" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    } ; 
                } ; 
                if($vtests -notcontains $false){
                    $smsg = "==> $($ACtionCommand): confirmed specified connections *all* successful " ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    $Exit = $DoRetries ;
                } else {
                    $smsg = "==> $($ACtionCommand): FAILED SOME SPECIFIED CONNECTIONS" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $smsg = "MISSING SOME KEY CONNECTIONS. DO YOU WANT TO IGNORE, AND CONTINUE WITH CONNECTED SERVICES?" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $Exit ++ ;
                    $smsg = "Try #: $Exit" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    if($Exit -eq $DoRetries){
                        $smsg = "Unable to exec cmd!"; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        #-=-=-=-=-=-=-=-=
                        $sdEmail.SMTPSubj = "FAIL Rpt:$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"
                        $sdEmail.SmtpBody = "`n===Processing Summary:" ;
                        if($vFailMsgs){
                            $sdEmail.SmtpBody += "`n$(($vFailMsgs|out-string).trim())" ; 
                        } ; 
                        $sdEmail.SmtpBody += "`n" ;
                        if($SmtpAttachment){
                            $sdEmail.SmtpAttachment = $SmtpAttachment
                            $sdEmail.smtpBody +="`n(Logs Attached)" ;
                        };
                        $sdEmail.SmtpBody += "Pass Completed $([System.DateTime]::Now)" ;
                        $smsg = "Send-EmailNotif w`n$(($sdEmail|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Send-EmailNotif @sdEmail ;
                        $bRet=Read-Host "Enter YYY to continue. Anything else will exit"  ;
                        if ($bRet.ToUpper() -eq "YYY") {
                            $smsg = "(Moving on), WITH THE FOLLOW PARTIAL CONNECTION STATUS" ;
                            $smsg += "`n`n$(($ret_CcOPSvcs|out-string).trim())" ; 
                            write-host -foregroundcolor green $smsg  ;
                        } else {
                            throw $smsg ; 
                            break ; #exit 1
                        } ;  
                    } ;        
                } ; 
                #endregion CONFIRM_CCEXORETURN ; #*------^ END CONFIRM_CCEXORETURN ^------
            } Until ($Exit -eq $DoRetries) ; 
        } ; #  useO365-E
        #endregion CALL_CONNECT_O365SERVICES ; #*======^ END CALL_CONNECT_O365SERVICES ^======
    
        #region TEST_EXO_CONN ; #*------v TEST_EXO_CONN v------
        # ALT: simplified verify EXO conn: ALT to full CONNECT_O365SERVICES block - USE ONE OR THE OTHER!
        $useEXO = $true ; 
        $useSC = $false ; 
        if(-not $XOConnectionUri ){$XOConnectionUri = 'https://outlook.office365.com'} ;
        if(-not $SCConnectionUri){$SCConnectionUri = 'https://ps.compliance.protection.outlook.com'} ;
        $EXOtestCmdlet = 'Get-xoOrganizationConfig' ; 
        if(gcm $EXOtestCmdlet -ea 0){
            $conns = Get-ConnectionInformation -ea STOP  ; 
            $hasEXO = $hasSC = $false ; 
            #if($conns | %{$_ | ?{$_.ConnectionUri -eq 'https://outlook.office365.com' -AND $_.State -eq 'Connected' -AND $_.TokenStatus -eq 'Active'}}){
            $conns | %{
                if($_ | ?{$_.ConnectionUri -eq $XOConnectionUri}){$hasEXO = $true } ; 
                if($_ | ?{$_.ConnectionUri -eq $SCConnectionUri}){$hasSC = $true } ; 
            }
            if($useEXO -AND $hasEXO){
                write-verbose "EXO ConnectionURI present" ; 
            }elseif(-not $useEXO){}else{
                $smsg = "No Active EXO connection: Run - Connect-ExchangeOnline -Prefix xo -  before running this script!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                BREAK ; 
            } ; 
            if($useSC -AND $hasSC){
                write-verbose "SCI ConnectionURI present" ; 
            }elseif(-not $useSC){}else{
                $smsg = "No Active SC connection: Run - Connect-IPPSSession -Prefix SC -  before running this script!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                BREAK ; 
            } ; 
        }else {
            $smsg = "Missing gcm get-xoMailboxFolderStatistics: ExchangeOnlineManagement module *not* loaded!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            BREAK ; 
        } ;     
        #endregion TEST_EXO_CONN ; #*------^ END TEST_EXO_CONN ^------
    
        #region CALL_CONNECT_OPSERVICES ; #*======v CALL_CONNECT_OPSERVICES v======
        # 2:23 PM 1/12/2026 #804, FORCE:  $useOP = $false ; : This has NO NEED FOR ONPREM, IT JUST DOES A Get-MgSubscribedSku AND RUNS THE STATIC SERVICEPLANLIST CHECK, NOTHING ELSE!
        $useOP = $false ; 
        if($useOP){
            $pltCcOPSvcs=[ordered]@{
                # environment parameters:
                EnvSummary = $rvEnv ;
                NetSummary = $netsettings ;
                XoPSummary = $lclExOP ;
                # service choices
                UseExOP = $true ;
                useForestWide = $true ;
                useExopNoDep = $false ;
                ExopVers = 'Ex2010' ;
                UseOPAD = $true ;
                useExOPVers = $useExOPVers; # 'Ex2010' ;
                # Service Connection parameters
                TenOrg = $TenOrg ; # $global:o365_TenOrgDefault ;
                Credential = $Credential ;
                #[ValidateSet("SID","ESVC","LSVC")]
                #UserRole = $UserRole ; # @('SID','ESVC') ;
                # if inheriting same $userrole param/default, that was already used for cloud conn, filter out the op unsupported CBA roles
                # exclude csvc as well, go with filter on the supported ValidateSet from get-HybridOPCredentials: ESVC|LSVC|SID
                UserRole = $UserRole |?{$_ -match '(ESVC|LSVC|SID)' -AND $_ -notmatch 'CBA'} ; 
                # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
                silent = $silent ;
            } ;

            write-verbose "(Purge no value keys from splat)" ;
            $mts = $pltCcOPSvcs.GetEnumerator() |?{$_.value -eq $null} ; $mts |%{$pltCcOPSvcs.remove($_.Name)} ; rv mts -ea 0 ;
            if((get-command connect-OPServices -EA STOP).parameters.ContainsKey('whatif')){
                $pltCcOPSvcsnDSR.add('whatif',$($whatif))
            } ;
            $smsg = "connect-OPServices w`n$(($pltCcOPSvcs|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $ret_CcOPSvcs = connect-OPServices @pltCcOPSvcs ; 

            # #region CONFIRM_CCOPRETURN ; #*------v CONFIRM_CCOPRETURN v------
            # matches each: $plt.useXXX:$true to matching returned $ret.hasXXX:$true
            $vplt = $pltCcOPSvcs ; $vret = 'ret_CcOPSvcs' ;  ; $ACtionCommand = 'connect-OPServices' ; 
            $vplt.GetEnumerator() |?{$_.key -match '^use' -ANd $_.value -match $true} | foreach-object{
                $pltkey = $_ ;
                $smsg = "$(($pltkey | ft -HideTableHeaders name,value|out-string).trim())" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $vtests = @() ;  $vFailMsgs = @()  ; 
                $tprop = $pltkey.name -replace '^use','has';
                if($rProp = (gv $vret).Value.psobject.properties | ?{$_.name -match $tprop}){
                    $smsg = "$(($rprop | ft -HideTableHeaders name,value |out-string).trim())" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    if($rprop.Value -eq $pltkey.value){
                        $vtests += $true ; 
                        $smsg = "Validated: $($pltKey.name):$($pltKey.value) => $($rprop.name):$($rprop.value)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    } else {
                        $smsg = "NOT VALIDATED: $($pltKey.name):$($pltKey.value) => $($rprop.name):$($rprop.value)" ;
                        $vtests += $false ; 
                        $vFailMsgs += "`n$($smsg)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    };
                } else{
                    $smsg = "Unable to locate: $($pltKey.name):$($pltKey.value) to any matching $($rprop.name)!)" ;
                    $smsg = "" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                } ; 
            } ; 
            if($useOP -AND $vtests -notcontains $false){
                $smsg = "==> $($ACtionCommand): confirmed specified connections *all* successful " ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            }elseif($vtests -contains $false -AND (get-variable ret_CcOPSvcs) -AND (gv -name "$($tenorg)meta").value.o365_opdomain.split('.')[0].toupper() -ne $env:userdomain){
                $smsg = "==> $($ACtionCommand): FAILED SOME SPECIFIED CONNECTIONS" ; 
                $smsg += "`nCROSS-ORG ONPREM CONNECTION: ATTEMPTING TO CONNECT TO ONPREM '$((gv -name "$($tenorg)meta").value.o365_Prefix)' $((gv -name "$($tenorg)meta").value.o365_opdomain.split('.')[0].toupper()) domain, FROM $($env:userdomain)!" ;
                $smsg += "`nEXPECTED ERROR, SKIPPING ONPREM ACCESS STEPS (force `$useOP:$false)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $useOP = $false ; 
            }elseif(-not $useOP -AND -not (get-variable ret_CcOPSvcs)){
                $smsg = "-useOP: $($useOP), skipped connect-OPServices" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else {
                $smsg = "==> $($ACtionCommand): FAILED SOME SPECIFIED CONNECTIONS" ; 
                $smsg += "`n`$ret_CcOPSvcs:`n$(($ret_CcOPSvcs|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $sdEmail.SMTPSubj = "FAIL Rpt:$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"
                $sdEmail.SmtpBody = "`n===Processing Summary:" ;
                if($vFailMsgs){
                    $sdEmail.SmtpBody += "`n$(($vFailMsgs|out-string).trim())" ; 
                } ; 
                $sdEmail.SmtpBody += "`n" ;
                if($SmtpAttachment){
                    $sdEmail.SmtpAttachment = $SmtpAttachment
                    $sdEmail.smtpBody +="`n(Logs Attached)" ;
                };
                $sdEmail.SmtpBody += "Pass Completed $([System.DateTime]::Now)" ;
                $smsg = "Send-EmailNotif w`n$(($sdEmail|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Send-EmailNotif @sdEmail ;
                throw $smsg ; 
                BREAK ; 
            } ; 
            #endregion CONFIRM_CCOPRETURN ; #*------^ END CONFIRM_CCOPRETURN ^------
            
            #region CONFIRM_OPFORESTWIDE ; #*------v CONFIRM_OPFORESTWIDE v------    
            if($useOP -AND $pltCcOPSvcs.useForestWide -AND $ret_CcOPSvcs.hasForestWide -AND $ret_CcOPSvcs.AdGcFwide){
                $smsg = "==> $($ACtionCommand): confirmed has BOTH .hasForestWide & .AdGcFwide ($($ret_CcOPSvcs.AdGcFwide))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success        
            }elseif($pltCcOPSvcs.useForestWide -AND (get-variable ret_CcOPSvcs) -AND (gv -name "$($tenorg)meta").value.o365_opdomain.split('.')[0].toupper() -ne $env:userdomain){
                $smsg = "`nCROSS-ORG ONPREM CONNECTION: ATTEMPTING TO CONNECT TO ONPREM '$((gv -name "$($tenorg)meta").value.o365_Prefix)' $((gv -name "$($tenorg)meta").value.o365_opdomain.split('.')[0].toupper()) domain, FROM $($env:userdomain)!" ;
                $smsg += "`nEXPECTED ERROR, SKIPPING ONPREM FORESTWIDE SPEC" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $useOP = $false ; 
            }elseif($useOP -AND $pltCcOPSvcs.useForestWide -AND -NOT $ret_CcOPSvcs.hasForestWide){
                $smsg = "==> $($ACtionCommand): MISSING CRITICAL FORESTWIDE SUPPORT COMPONENT:" ; 
                if(-not $ret_CcOPSvcs.hasForestWide){
                    $smsg += "`n----->$($ACtionCommand): MISSING .hasForestWide (Set-AdServerSettings -ViewEntireForest `$True) " ; 
                } ; 
                if(-not $ret_CcOPSvcs.AdGcFwide){
                    $smsg += "`n----->$($ACtionCommand): MISSING .AdGcFwide GC!:`n((Get-ADDomainController -Discover -Service GlobalCatalog).hostname):326) " ; 
                } ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $smsg = "MISSING SOME KEY CONNECTIONS. DO YOU WANT TO IGNORE, AND CONTINUE WITH CONNECTED SERVICES?" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $bRet=Read-Host "Enter YYY to continue. Anything else will exit"  ;
                if ($bRet.ToUpper() -eq "YYY") {
                    $smsg = "(Moving on), WITH THE FOLLOW PARTIAL CONNECTION STATUS" ;
                    $smsg += "`n`n$(($ret_CcOPSvcs|out-string).trim())" ; 
                    write-host -foregroundcolor green $smsg  ;
                } else {
                    throw $smsg ; 
                    break ; #exit 1
                } ;         
            }; 
            #endregion CONFIRM_OPFORESTWIDE ; #*------^ END CONFIRM_OPFORESTWIDE ^------
        } ; 
        #endregion CALL_CONNECT_OPSERVICES ; #*======^ END CALL_CONNECT_OPSERVICES ^======
    
        #endregion SERVICE_CONNECTIONS #*======^ END SERVICE_CONNECTIONS ^======

        # check if using Pipeline input or explicit params:
        if ($rPSCmdlet.MyInvocation.ExpectingInput) {
            $smsg = "Data received from pipeline input: '$($InputObject)'" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } else {
            # doesn't actually return an obj in the echo
            #$smsg = "Data received from parameter input: '$($InputObject)'" ;
            #if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            #else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ;

        #endregion SUBMAIN ; #*======^ END SUB MAIN ^======
    } ;  # BEGIN-E
    PROCESS {
        $Error.Clear() ; 
        <#$propsAADL = 'SkuId',  'SkuPartNumber',  @{name='Enabled';Expression={$_.PrepaidUnits.enabled }},
            @{name='Consumed';Expression={$_.ConsumedUnits} }, @{name='Available';Expression={$_.PrepaidUnits.enabled - $_.ConsumedUnits} },
            @{name='Warning';Expression={$_.PrepaidUnits.warning} }, @{name='Suspended';Expression={$_.PrepaidUnits.suspended} } ;
            #>
        $propsAADL = 'SkuId',  'SkuPartNumber',  @{name='Enabled';Expression={$_.PrepaidUnits.enabled }},
            @{name='Consumed';Expression={$_.ConsumedUnits} }, @{name='Available';Expression={$_.PrepaidUnits.enabled - $_.ConsumedUnits} },
            @{name='Warning';Expression={$_.PrepaidUnits.warning} }, @{name='Suspended';Expression={$_.PrepaidUnits.suspended} },
            @{name='ServicePlanName';Expression={(($_.ServicePlans).ServicePlanName |?{$_ -match 'EXCHANGE_'})}} ;
        # 1:48 PM 1/7/2026 MG vers
        $propsMGL = 'SkuId',  'SkuPartNumber',  @{name='Enabled';Expression={$_.PrepaidUnits.enabled }},  
            @{name='Consumed';Expression={$_.ConsumedUnits} }, @{name='Available';Expression={$_.PrepaidUnits.enabled - $_.ConsumedUnits} }, 
            @{name='Warning';Expression={$_.PrepaidUnits.warning} }, @{name='Suspended';Expression={$_.PrepaidUnits.suspended} } ;

        $rgxExSvcPlans = ('(' + (($ServicePlanName |%{[regex]::escape($_)}) -join '|') + ')') ; 

        $ExMbxLicenses = @() ; 
        foreach($SPName in $ServicePlanName){
            $smsg = $sBnrS="`n#*------v PROCESSING $($spname): v------" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            
            TRY{
                #if($thisPlan = Get-AzureADSubscribedSku | ?{$_.serviceplans.serviceplanname -match $SPName} | select $propsAADL | ?{$_.SkuPartNumber -notmatch $rgxbannedSPN}){
                if($thisPlan = Get-MgSubscribedSku | ?{$_.serviceplans.serviceplanname -match $SPName} | select $propsMGL | ?{$_.SkuPartNumber -notmatch $rgxbannedSPN}){
                    if(-not $Unfiltered){
                        $smsg = "Postfilter:`$_.available -gt 0 -AND `$_.Enabled -gt 0 " ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $thisplan = $thisplan |?{$_.available -gt 0 -AND $_.Enabled -gt 0} ; 
                    } else {} ; 
                    if($thisplan){
                        #$OutDetail, $Unfiltered
                        foreach($item in $thisplan){
                            $smsg = $sBnr3="`n#*~~~~~~v $($item.SkuPartNumber) : v~~~~~~" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            if($OutDetail){
                                $oReturn = [ordered]@{
                                    SKU = $item.SkuPartNumber ;                                 
                                    Label= $item.SkuPartNumber.split('_')[-1] ; 
                                    Notes= "$($item.SkuPartNumber):Detailed usage" ; 
                                    ServicePlanName = $item.ServicePlanName ; 
                                    Enabled  = $item.Enabled ; 
                                    Consumed = $item.Consumed ; 
                                    Available = $item.Available ; 
                                    warning = $item.Warning ; 
                                    Suspended = $item.Suspended ; 
                                } ; 
                            }else {
                                $oReturn = [ordered]@{
                                    SKU = $item.SkuPartNumber ;                                 
                                    Label= $item.SkuPartNumber.split('_')[-1] ; 
                                    Notes= "Enabled:{0}|Consumed:{1}|Avail:{2}|Warn:{3}|Susp:{4}" -f $item.Enabled,$item.Consumed,$item.Available,$item.WArning,$item.Suspended ; 
                                } ; 
                            } ; 
                            $ExMbxLicenses += New-Object PSObject -Property $oReturn ;

                            $smsg = "$($sBnr3.replace('~v','~^').replace('v~','^~'))`n" ;
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        } ; 
                    } else { 
                        #$smsg = "NOTE:serviceplans.serviceplanname -match $($SPName) yielded *NONE* with Available and Enabled -gt 0!" ; 
                        #if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                        #else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    } ; 
                } else { } ; 

            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
    

            

            
            $smsg = "$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

        } ; 

    # ===========

<#
        # input table of Exchange Online assignable licenses that include a UserMailbox:
    $ExMbxLicensesTbl = @"
|SKU|Label|Notes|
|ENTERPRISEPACK|Office 365 Enterprise E3|OfficE; EXO (OL,OWA,OM,100G mbx)|
|EXCHANGESTANDARD|Exchange Online Plan 1|No Office; no Services; 50G mbx, No ArchiveMbx|
|SPE_F1|Microsoft 365 F3| OfficeWeb, OfficeMobile; EXO (OWA,OM 2G Mbx)|(formerly Microsoft 365 F1, renamed Mar2020)
|STANDARDPACK|OFFICE 365 E1| OfficeWeb, OfficeMobile; EXO (OWA,OM 50G Mbx)
|EXCHANGEENTERPRISE_FACULTY|Exch Online Plan 2 for Faculty|No Office; no Services; 100G mbx, +ArchiveMbx, +vmail, +DLP|
|EXCHANGE_L_STANDARD|Exchange Online (Plan 1)|No Office; no Services; 50G mbx, No ArchiveMbx|
|EXCHANGE_S_ENTERPRISE|Exchange Online Plan 2 S|No Office; no Services; 100G mbx, +ArchiveMbx, +vmail, +DLP|
|EXCHANGEENTERPRISE|Exchange Online Plan 2|No Office; no Services; 50G mbx, +ArchiveMbx, +vmail, +DLP|
|STANDARDWOFFPACK_STUDENT|O365 Education E1 for Students|OfficeWeb, OfficeMobile; EXO (OWA,OM 50G Mbx)|
|STANDARDWOFFPACK_IW_FACULTY|O365 Education for Faculty||
|STANDARDWOFFPACK_IW_STUDENT|O365 Education for Students||
|STANDARDPACK_STUDENT|Office 365 (Plan A1) for Students||
|ENTERPRISEPACKLRG|Office 365 (Plan E3)||
|STANDARDWOFFPACK_FACULTY|Office 365 Education E1 for Faculty|OfficeWeb, OfficeMobile; EXO (OWA,OM 50G Mbx)|
|ENTERPRISEWITHSCAL_FACULTY|Office 365 Education E4 for Faculty||
|ENTERPRISEWITHSCAL_STUDENT|Office 365 Education E4 for Students||
|STANDARDPACK|Office 365 Enterprise E1|OfficeWeb, OfficeMobile; EXO (OWA,OM 50G Mbx)|
|STANDARDWOFFPACK|Office 365 Enterprise E2|OfficeWeb, OfficeMobile; EXO (OWA,OM 50G Mbx), No ArchiveMbx|
|ENTERPRISEPACKWITHOUTPROPLUS|Office 365 Enterprise E3 without ProPlus Add-on||
|ENTERPRISEWITHSCAL|Office 365 Enterprise E4||
|ENTERPRISEPREMIUM|Office 365 Enterprise E5|OfficE; EXO (OL,OWA,OM,100G mbx),AAD P1 & P2, Az Info Protection Plan 2; UC; ATP|
|DESKLESSPACK_YAMMER|Office 365 Enterprise K1 with Yammer||
|DESKLESSPACK|Office 365 Enterprise K1 without Yammer||
|DESKLESSWOFFPACK|Office 365 Enterprise K2||
|MIDSIZEPACK|Office 365 Midsize Business||
|STANDARDWOFFPACKPACK_FACULTY|Office 365 Plan A2 for Faculty||
|STANDARDWOFFPACKPACK_STUDENT|Office 365 Plan A2 for Students||
|ENTERPRISEPACK_FACULTY|Office 365 Plan A3 for Faculty||
|ENTERPRISEPACK_STUDENT|Office 365 Plan A3 for Students||
|OFFICESUBSCRIPTION_FACULTY|Office 365 ProPlus for Faculty||
|LITEPACK_P2|Office 365 Small Business Premium||
|SPE_E3|MICROSOFT 365 E3|OfficeWeb, OfficeMobile; EXO (OL,OWA,OM 2G Mbx)||
|SPE_E5|MICROSOFT 365 E5||
"@ ;
        $ExMbxLicenses = $ExMbxLicensesTbl | convertfrom-markdowntable ;
#>
        # building a CustObj (actually an indexed hash) with the data. The 'index' for each license, is the Sku/SkuPartNumber
        $smsg = "(converting $(($ExMbxLicenses|measure).count) UserMailbox-supporting o365 Licenses to indexed hash)" ;     
        if($verbose){
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ; 
        if($host.version.major -gt 2){$hExMbxLicenses = [ordered]@{} } 
        else { $hExMbxLicenses = @{} } ;
    
        $ttl = ($ExMbxLicenses|measure).count ; $Procd = 0 ; 
        foreach ($Sku in $ExMbxLicenses){
            $Procd ++ ; 
            $sBnrS="`n#*------v PROCESSING : ($($Procd)/$($ttl)) $($Sku.SKU) v------" ; 
            $smsg = $sBnrS ; 
            if($verbose){
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
        
            $name =$($Sku | select -expand SKU) ; 
            $hExMbxLicenses[$name] = $Sku ; 

            $smsg = "$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
            if($verbose){
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
        } ;  # loop-E

        if($hExMbxLicenses){
            $smsg = "(Returning summary objects to pipeline)" ; 
            if($verbose){
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
            $hExMbxLicenses | Write-Output ; 
        } else {
            $smsg = "NO RETURNABLE `$hExMbxLicenses OBJECT!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            THROW $smsg ;
        } ; 
    } ;  # PROC-E
    END {
        $smsg = "$($sBnr.replace('=v','=^').replace('v=','^='))" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    } ;  # END-E
}

#*------^ get-ExoMailboxLicenses.ps1 ^------


#*------v get-ExoMessageTraceEventType.ps1 v------
function get-ExoMessageTraceEventType {
<#
    .SYNOPSIS
    get-ExoMessageTraceEventType - Provides a prefab array indexed hash of Exchange-Online Get-xoMessageTrace Event Types Note: This is a static non-query-based list of events. The function must be manually updated to accomodate MS MessageTrace event types changes over time.
    .PARAMETER Mailboxes
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2024-05-17
    FileName    : get-ExoMessageTraceEventType.ps1
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-ex2010
    Tags        : Powershell,ExchangeOnline,MessageTrace,Reporting
    REVISIONS
    * 3:55 PM 5/17/2024 adapted from vxo\get-ExoMailboxLicenses(); ren get-ExoGxMTEventType -> get-ExoMessageTraceEventType; added array support on the EventID & Type
    .DESCRIPTION
    get-ExoMessageTraceEventType - Provides a prefab array indexed hash of Exchange-Online Get-xoMessageTrace Event Types Note: This is a static non-query-based list of events. The function must be manually updated to accomodate MS MessageTrace event types changes over time.
    Run it without an -EventID and it returns the entire indexed hash to the pipeline

    I have assigned arbitrary 'Type's to each, to make it easy to filter MessageTrace output events into those relevent for demonstrating delivery (transport), those that indicate issues (problem), and those that provide additional information (info).

    .PARAMETER EventID
    Optional MessageTrace event-id(s) to be resolved to details[-EventID 'AGENTINFO']
    .PARAMETER Type
    Optional type classification subset(s) to be returned from the entire EventID set[-Type 'Problem','Transport']
    .EXAMPLE
    PS> $eventInfo = get-ExoMessageTraceEventType -eventid AGENTINFO -verbose ; 
    PS> $eventInfo | out-string ; 

        EventName Description                                                Type
        --------- -----------                                                ----
        AGENTINFO This event is used by transport agents to log custom data. info

    Retrieve Resolve 'AGENTINFO' to it's stock MS description & type, and output to console
    .EXAMPLE
    PS> $eventIdsDetail = get-ExoMessageTraceEventType ; 
    PS> $eventIdsDetail | out-string ; 

        Name                           Value                                                                                                                                                                                                                             
        ----                           -----                                                                                                                                                                                                                             
        AGENTINFO                      @{EventName=AGENTINFO; Description=This event is used by transport agents to log custom data.; Type=info}                   
        ...[TRIMMED]...
        TRANSFER                       @{EventName=TRANSFER; Description=Recipients were moved to a forked message because of content conversion, message recipient limits, or agents. Sources include ROUTING or QUEUE.; Type=info}                                     

    Retrive the entire indexed hash of EventID details, and output the results to console. 
    PS> $eventIdsDetail['AGENTINFO'] | out-string ; 

        EventName Description                                                Type
        --------- -----------                                                ----
        AGENTINFO This event is used by transport agents to log custom data. info

    PS> $eventIdsDetail.values | group type |  ft -a count,name 

        Count Name     
        ----- ----     
           18 info     
           18 problem  
            5 transport

    PS> $rgxEvtIDProblem = ('(' + (($eventIdsDetail.values | ?{$_.type -eq 'problem'} | select -expand EventName |%{[regex]::escape($_)}) -join '|') + ')') ;
    PS> $rgxEvtIDTransp = ('(' + (($eventIdsDetail.values | ?{$_.type -eq 'transport'} | select -expand EventName|%{[regex]::escape($_)}) -join '|') + ')') ;
    PS> $rgxEvetIDInfo =  ('(' + (($eventIdsDetail.values | ?{$_.type -eq 'info'} | select -expand EventName|%{[regex]::escape($_)}) -join '|') + ')') ;
    PS> $rgxEvtIDProblem

        (BADMAIL|DEFER|DELIVERFAIL|DROP|DSN|FAIL|HAREDIRECTFAIL|INITMESSAGECREATED|MODERATIONEXPIRE|MODERATORREJECT|MODERATORSALLNDR|POISONMESSAGE|RESUBMITDEFER|RESUBMITFAIL|SUBMITDEFER|SUBMITFAIL|SUPPRESSED|THROTTLE)

    PS> $rgxEvetIDInfo

        (AGENTINFO|CLIENTSUBMISSION|DUPLICATEDELIVER|DUPLICATEEXPAND|DUPLICATEREDIRECT|EXPAND|HADISCARD|HARECEIVE|HAREDIRECT|LOAD|NOTIFYMAPI|NOTIFYSHADOW|PROCESS|PROCESSMEETINGMESSAGE|RESOLVE|RESUBMIT|SUBMIT|TRANSFER)

    PS> $rgxEvtIDTransp 

        (DELIVER|MODERATORAPPROVE|RECEIVE|REDIRECT|SEND)

    Retrieve the entire set of defined event-id's returned as an indexed hash. Output the hash to console; lookup and return the AGENTINFO event-id details; group the assigned types; Build & output regexes for the Problem, Transport & Info types.
    .EXAMPLE
    PS> $eventInfo = get-ExoMessageTraceEventType -type problem ; 
    PS> $eventInfo | write-output ;

        EventName          Description                                                                                                                                                                                                           
        ---------          -----------                                                                                                                                                                                                           
        BADMAIL            A message submitted by the Pickup directory or the Replay directory that can't be delivered or returned.                                                                                                              
        DEFER              Message delivery was delayed.                                                                                                                                                                                         
        DELIVERFAIL        An agent tried to deliver the message to a folder that doesn't exist in the mailbox.                                                                                                                                  
        DROP               A message was dropped without a delivery status notification (also known as a DSN, bounce message, non-delivery report, or NDR). For example:\n* Completed moderation approval request messages.\n* Spam messages t...
        DSN                A delivery status notification (DSN) was generated.                                                                                                                                                                   
        FAIL               Message delivery failed. Sources include SMTP, DNS, QUEUE, and ROUTING.                                                                                                                                               
        HAREDIRECTFAIL     A shadow message failed to be created. The details are stored in the source-context field.                                                                                                                            
        INITMESSAGECREATED A message was sent to a moderated recipient, so the message was sent to the arbitration mailbox for approval. For more information, see Manage message approval.                                                      
        MODERATIONEXPIRE   A moderator for a moderated recipient never approved or rejected the message, so the message expired. For more information about moderated recipients, see Manage message approval.                                   
        MODERATORREJECT    A moderator for a moderated recipient rejected the message, so the message wasn't delivered to the moderated recipient.                                                                                               
        MODERATORSALLNDR   All approval requests sent to all moderators of a moderated recipient were undeliverable, and resulted in non-delivery reports (also known as NDRs or bounce messages).                                               
        POISONMESSAGE      A message was put in the poison message queue or removed from the poison message queue.                                                                                                                               
        RESUBMITDEFER      A message resubmitted from Safety Net was deferred.                                                                                                                                                                   
        RESUBMITFAIL       A message resubmitted from Safety Net failed.                                                                                                                                                                         
        SUBMITDEFER        The message transmission from the Mailbox Transport Submission service to the Transport service was deferred.                                                                                                         
        SUBMITFAIL         The message transmission from the Mailbox Transport Submission service to the Transport service failed.                                                                                                               
        SUPPRESSED         The message transmission was suppressed.                                                                                                                                                                              
        THROTTLE           The message was throttled.  

    Retrieve EventID details for all -type Problem events, and output results to console. 
    .EXAMPLE
    PS> $eventInfo = get-ExoMessageTraceEventType -type 'problem','transport' ; 
    PS> $eventInfo | write-output ;
    PS> $rgxEvtIDTransProb = ('(' + (($eventInfo.EventName |%{[regex]::escape($_)}) -join '|') + ')') ;
    Retrieve the Type:Problem & Transport EventIDs and build a regex out of the combonation
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    #Requires -Modules verb-IO, verb-logging, verb-Text
    [OutputType('System.Collections.Hashtable')]
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory=$FALSE,HelpMessage="Optional MessageTrace event-id(s) to be resolved to details[-EventID 'AGENTINFO']")]
            [ValidateNotNullOrEmpty()]
            [string[]]$EventID,
        [Parameter(Mandatory=$FALSE,HelpMessage="Optional type classification subset(s) to be returned from the entire EventID set[-Type 'Problem','Transport']")]
            [ValidateSet('transport','problem','info')]
            [string[]]$Type
    ) ;
    if($EventID -AND $Type){
        $smsg = "Both -EventID & -Type specified: Please specify one or the other (or none, to return all defined EventIDs)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    } ; 
    ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
    $verbose = ($VerbosePreference -eq "Continue") ;
    
    # check if using Pipeline input or explicit params:
    if ($PSCmdlet.MyInvocation.ExpectingInput) {
        write-verbose "Data received from pipeline input: '$($InputObject)'" ;
    } else {
        # doesn't actually return an obj in the echo
        #write-verbose "Data received from parameter input: '$($InputObject)'" ;
    } ;
    

    # input table of Exchange Online assignable licenses that include a UserMailbox:
    $ExoEventIDsTbl = @"
|EventName |Description|Type|
|---|---|---|
|AGENTINFO |This event is used by transport agents to log custom data.|info|
|BADMAIL |A message submitted by the Pickup directory or the Replay directory that can't be delivered or returned.|problem|
|CLIENTSUBMISSION |A message was submitted from the Outbox of a mailbox.|info|
|DEFER |Message delivery was delayed.|problem|
|DELIVER |A message was delivered to a local mailbox.|transport|
|DELIVERFAIL |An agent tried to deliver the message to a folder that doesn't exist in the mailbox.|problem|
|DROP |A message was dropped without a delivery status notification (also known as a DSN, bounce message, non-delivery report, or NDR). For example:<br/>* Completed moderation approval request messages.<br/>* Spam messages that were silently dropped without an NDR.|problem|
|DSN |A delivery status notification (DSN) was generated.|problem|
|DUPLICATEDELIVER |A duplicate message was delivered to the recipient. Duplication may occur if a recipient is a member of multiple nested distribution groups. Duplicate messages are detected and removed by the information store.|info|
|DUPLICATEEXPAND |During the expansion of the distribution group, a duplicate recipient was detected.|info|
|DUPLICATEREDIRECT |An alternate recipient for the message was already a recipient.|info|
|EXPAND |A distribution group was expanded.|info|
|FAIL |Message delivery failed. Sources include SMTP, DNS, QUEUE, and ROUTING.|problem|
|HADISCARD |A shadow message was discarded after the primary copy was delivered to the next hop. For more information, see Shadow redundancy in Exchange Server.|info|
|HARECEIVE |A shadow message was received by the server in the local database availability group (DAG) or Active Directory site.|info|
|HAREDIRECT |A shadow message was created.|info|
|HAREDIRECTFAIL |A shadow message failed to be created. The details are stored in the source-context field.|problem|
|INITMESSAGECREATED |A message was sent to a moderated recipient, so the message was sent to the arbitration mailbox for approval. For more information, see Manage message approval.|problem|
|LOAD |A message was successfully loaded at boot.|info|
|MODERATIONEXPIRE |A moderator for a moderated recipient never approved or rejected the message, so the message expired. For more information about moderated recipients, see Manage message approval.|problem|
|MODERATORAPPROVE |A moderator for a moderated recipient approved the message, so the message was delivered to the moderated recipient.|transport|
|MODERATORREJECT |A moderator for a moderated recipient rejected the message, so the message wasn't delivered to the moderated recipient.|problem|
|MODERATORSALLNDR |All approval requests sent to all moderators of a moderated recipient were undeliverable, and resulted in non-delivery reports (also known as NDRs or bounce messages).|problem|
|NOTIFYMAPI |A message was detected in the Outbox of a mailbox on the local server.|info|
|NOTIFYSHADOW |A message was detected in the Outbox of a mailbox on the local server, and a shadow copy of the message needs to be created.|info|
|POISONMESSAGE |A message was put in the poison message queue or removed from the poison message queue.|problem|
|PROCESS |The message was successfully processed.|info|
|PROCESSMEETINGMESSAGE |A meeting message was processed by the Mailbox Transport Delivery service.|info|
|RECEIVE |A message was received by the SMTP receive component of the transport service or from the Pickup or Replay directories (source: SMTP), or a message was submitted from a mailbox to the Mailbox Transport Submission service (source: STOREDRIVER).|transport|
|REDIRECT |A message was redirected to an alternative recipient after an Active Directory lookup.|transport|
|RESOLVE |A message's recipients were resolved to a different email address after an Active Directory lookup.|info|
|RESUBMIT |A message was automatically resubmitted from Safety Net. For more information, see Safety Net in Exchange Server.|info|
|RESUBMITDEFER |A message resubmitted from Safety Net was deferred.|problem|
|RESUBMITFAIL |A message resubmitted from Safety Net failed.|problem|
|SEND |A message was sent by SMTP between transport services.|transport|
|SUBMIT |The Mailbox Transport Submission service successfully transmitted the message to the Transport service. For SUBMIT events, the source-context property contains the following details:<br/> * MDB: The mailbox database GUID.<br/> * Mailbox: The mailbox GUID.<br/> * Event: The event sequence number.<br/> * MessageClass: The type of message. For example, IPM.Note.<br/> * CreationTime: Date-time of the message submission.<br/> * ClientType: For example, User, OWA, or ActiveSync.|info|
|SUBMITDEFER |The message transmission from the Mailbox Transport Submission service to the Transport service was deferred.|problem|
|SUBMITFAIL |The message transmission from the Mailbox Transport Submission service to the Transport service failed.|problem|
|SUPPRESSED |The message transmission was suppressed.|problem|
|THROTTLE |The message was throttled.|problem|
|TRANSFER |Recipients were moved to a forked message because of content conversion, message recipient limits, or agents. Sources include ROUTING or QUEUE.|info|
"@ ;
    $ExoEventIDs = $ExoEventIDsTbl | convertfrom-markdowntable ;

    # building a CustObj (actually an indexed hash) with the EventName|Descriptions. The 'index' for each event, is the EventName 
    $smsg = "(converting $(($ExoEventIDs|measure).count) Get-xoMessageTrace-supported Event-ID types, to indexed hash)" ;     
    if($verbose){
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    } ; 
    if($host.version.major -gt 2){$hExoEventIDs = [ordered]@{} } 
    else { $hExoEventIDs = @{} } ;
    
    $ttl = ($ExoEventIDs|measure).count ; $Procd = 0 ; 
    foreach ($EID in $ExoEventIDs){
        $Procd ++ ; 
        $sBnrS="`n#*------v PROCESSING : ($($Procd)/$($ttl)) $($EID.EventName) v------" ; 
        $smsg = $sBnrS ; 
        if($verbose){
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
        
        $name =$EID.EventName ; 
        $hExoEventIDs[$name] = $EID ; 
        if($EID.Description -match '<br/>'){
            $hExoEventIDs[$name].Description = $hExoEventIDs[$name].Description -replace '<br/>','\n'
        } ;

        $smsg = "$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
        if($verbose){
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
    } ;  # loop-E

    if($hExoEventIDs){
        if($EventID){
            foreach($Evt in $EventID){
                if($hexoeventids[$Evt]){
                    $smsg = "(Returning matched EventID:$($Evt) details to pipeline)" ; 
                    if($verbose){
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ; 
                    $hexoeventids[$Evt] | Write-Output ; 
                }else {
                    $smsg = "Unable to resolve EventID: $($Evt) to a matching documented event-id string!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    throw $smsg ; 
                } ; 
            }  ; 
        }elseif($Type){
            foreach($Typ in $Type){
                $smsg = "(Returning matched Type:$($Typ) event details to pipeline)" ; 
                if($verbose){
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ; 
                $hexoeventids.values | ?{$_.type -eq $Typ} | write-output ;
            } ; 
        }else{
            $smsg = "(Returning full set of summary objects to pipeline)" ; 
            if($verbose){
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
            $hexoeventids | Write-Output ;
        } ; 
    } else {
        $smsg = "NO RETURNABLE `$hExoEventIDs OBJECT!" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        THROW $smsg ;
    } ; 
}

#*------^ get-ExoMessageTraceEventType.ps1 ^------


#*------v Get-EXOMessageTraceExportedTDO.ps1 v------
function Get-EXOMessageTraceExportedTDO {
    <#
    .SYNOPSIS
    Get-EXOMessageTraceExportedTDO - Run a MessageTrace with output summarizing Fails, expanding Qurantines, (expand TransportRules opt), and export to csv, with optional followup with Get-xoMessageTraceDetail, 
    .NOTES
    Version     : 2.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-11-05
    FileName    : Get-EXOMessageTraceExportedTDO.ps1
    License     : MIT License
    Copyright   : (c) 2024 Todd Kadrie
    Github      : https://github.com/tostka/verb-EXO
    Tags        : Powershell,Exchange,ExchangeOnline,Tracking,Delivery
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 10:48 AM 1/19/2026 bugfix: $pltCcOPSvcs.UserRole (postfilter, not match test)
    * 4:25 PM 1/6/2026 pulled in latest CONNECT_O365SERVICES, CALL_CONNECT_O365SERVICES, CALL_CONNECT_OPSERVICES, START_LOG_OPTIONS; 
        fundemental retool, porting from AzureAD -> MgGraph (f M$!), working again, for first time since they disabled AAD access! fundemental retooling in the CONNECT_O365SERVICES block, added test-MGConnection() etc. 
    * 4:27 PM 10/21/2025 fixed /tested more: loop (M$ v2 pagination offload) ; add: -ResultSize; fundemental update to use Get-xoMessageTraceV2 & Get-xoMessageTraceDetailV2 mandates (gxmt & gxmtd are now borked; fail) ; 
        fixed connect-ExchangeServerTDO() return (brought over updated latest), post-import requirement; remove refs to removed reconnect-eXO2; typo fix, WARNING->WARN
    * 12:58 PM 5/5/2025 cx10 was out of date (prompting for manual creds); brought in fresh cbp copies of all internal funcs, and replaced svcs_conn block, logging etc from scratch. Working now, no prompts.
    * 2:28 PM 5/2/2025 main Catch wasn't returning underlying EOM cmdlet errors; added code to -force, dump; 
        -As gxmtd is now flaking out, adapting the $QuarExpandLimitPerSender support to per-Recipient (when -SenderAddress used), and per-Sender (when -RecipientAddress used), to cut down on repetitive 
            lengthy Get-xoMessageTraceDetail calls. If you want more, push up the QuarExpandLimitPerSender count; cleaned up rem'd code obso'd by pull-GetxoMessageTraceDetail(), along with other broad code rems.
        - functionalized Get-xoMessageTraceDetail w retry (pull-GetxoMessageTraceDetail()) to address null gxmtd back, & retrying pulled, rewrote all Get-xoMessageTraceDetail to use the func
        - updated all supporting core functions, moved functions block to top (matching issues-addressing seen w cmw boxes, unless funcs preloaded - no local mods)
        - prior: had issues getting gxmtd's out using pipeline, so expanded into a loop with a throttlems wait -> seems working; 
        - split Fail|Failed into 2 lines (as it's a lookup, both on one line never matches); expanded CBH with splat of full range of usable params (dupes psb-psMsgTrkEXO)
        - updated cbh with all useful params in demo.
    * 2:47 PM 5/1/2025 getting Status:GettingStatus on SAP confirmation passes, added Get-xoMessageTraceDetail pass on last 20 of the set, seems to expose actual delivery resolution wihere Get-xoMessageTrace has the bozo status. 
        Aggregates findings of the 20 and adds them to the returned vari. updated CBH with output sample 
    * 9:35 AM 4/23/2025 reduced MessageTraceDetailLimit default from 100-> 20 (too time consuming, if not really needed), flipped it's effect to filtering last xx, not first.
        added alias: 'Get-EXOMessageTraceTDO', matches concept on Get-MessageTrackingLogTDO() naming. 
    * 6:08 PM 4/22/2025 post cmw testing, spliced over updated svc_conn block, full write-log() (simplified lacks success lvl etc);
         ADD: resolve-environment() & support, and updated start-log support; TLS_LATEST_FORCE ; missing regions; SWRITELOG ; SSTARTLOG ; 
        updated -Version supporting Connect-ExchangeServerTDO  ; convertFrom-MarkdownTable() to support... ; Initialize-exoStatusTable; 
        fixed bug in -resultsize code; code to leverage Initialize-exoStatusTable and output uniqued eventid's returnedon gmtl passes (doc output inline)
        copied over latest service conn code & slog for renv()
    * # 8:57 AM 12/6/2024 it's taking *5mins* to Get-xoQuarantineMessage; there's no point in running that 15 times, for the same sender,
         w same header & senderID specs. We need to down group the SenderAddress, and just process the last most-recent 'x', $QuarExpandLimitPerSender
         Added: -QuarExpandLimitPerSender 
    * 4:39 PM 12/3/2024 add: updated CBH demos; FailReason, to cover other fails with a Detail: Reason:\s string, and echo out some of the Get-xoMessageTraceDetail detail (though it should be stored in the export as well).
    * 1:45 PM 11/27/2024 minor updates, appears functional;  updated Fail echos for OtherAccount block, citing DDG exclusion setting under CA4 of UserMailbox types.
    * 4:20 PM 11/25/2024 updated from get-exomessagetraceexportedtdo(), more silent suppression, integrated dep-less ExOP conn support
        add: constants for rgxFailSecBlock, $rgxFailOOO, $rgxFailRecallSubj, $rgxFailOtherAcctBlock, $FailOtherAcctBlockExemptionGroup, $rgxFailConfRmExtBlock
    * 5:34 PM 11/22/2024 fundmental rework of the output, looping single & multip failcode entries, and outputing summary for types; removed inline processing outputs, in favor of condenced explanations in the $hsFailxxx outputs herestring reports ; also added the recipienttypedetails, aduser.enabled & TermOU status etc to the output on each Fail message exported as MsgsFail;
        added ConfRm block explicit, and expanded Security* transportrule echo's to cite the rule (if can be parsed from Detail); added recipienttypedetails support for shared|room|equpiment mailboxes
    * 2:59 PM 11/21/2024 working, added code to target 'otherfails', non-OOO, non-Recall, expaanded into Get-xoMessageTraceDetail, then id mail loops, and transport rule blocks (OtherAccounts currently); 
        added considerable expansion and profiling to the fails, also added new sub objects to the return object: 'MsgLast','MsgsFail','MsgsFailOther','MsgsFailOtherDetail','MTMessages','MTMessagesCSVFile','StatusHisto'
    * 5:12 PM 11/20/2024 added -DetailedOtherFails, to force Get-xoMessageTraceDetail on any 'Other' fails, only;
    * 12:41 PM 11/20/2024: update: #1352, 1357, fixed typo in senderaddress/recipaddr $ofile construction
    * 12:54 PM 10/24/2024 confirmed still func;  rename to a more variant of the stock Get-xoMessageTrace : get-EXOMsgTraceDetailed -> Get-EXOMessageTraceExportedTDO; alias Get-EXOMessageTraceExported & prior name: get-EXOMsgTraceDetailed
    * 12:54 PM 10/14/2024 added fully enumerated splat demo    
    * 2:00 PM 10/7/2024 
    * 3:22 PM 9/27/2024 substantial retool, to make it a single goto middleware func for msgtracks, appears working; added params to better approx both Get-xoMessageTrace and existing 7psmsgtrkexo BP calls;
        Added aliases for all Get-MessageTrackingLog & new-xoHistoricalSearch equiv params as well (to cut down on confusion, it takes any synonym for the field)
    * 4:38 PM 1/24/2022 retooled start/enddateto convert 'local tz' inputs, to t 
        GMT/UTC; and track/convert content back to local time ; added testing of 
        msgtrace splat params, only when populated ;  updated CBH & Examples (covering 
        variant formats of booking response msgs); converted hash summary output to 
        psobject ; ren -doMTD -> -Detailed ; validate $days is a positive integer;
        swapped strings with new central constants: $sFulltimeStamp, $sFiletimestamp
    * 4:04 PM 11/19/2021 flipped wh,wv,ww to wlt - added -days ; updated logic testing for dates/days against MS 10d limit (stored as new constant) ; checks out functional; needs 7pswlt rplcments of write-*
    * 12:40 PM 11/15/2021 - expanded subject -match/-like to post test and use the opposing option where the detected failed to yield filtered msgs. 
    * 3:46 pm 11/12/2021 - added -Subject test-IsRegexPattern() and autoflip tween -match & -like post filtering. 
    * 2:37 PM 11/5/2021 init
    .DESCRIPTION
    Get-EXOMessageTraceExportedTDO - Run a MessageTrace with output summarizing Fails, expanding Qurantines, (expand TransportRules opt), and export to csv, with optional followup with Get-xoMessageTraceDetail, 

    This function wraps the EXO get-MessageTrace & get-MessageTraceDetail, to run structured message traces with export to CSV, optional follow-on Get-MessageTraceDetail, post-filtering on specified Subject, and outputs a summary hashtable object with the following:

        Returns summary object to pipeline, with following properties:
        
        [obj].MTMessagesCSVFile full path to exported MTMessages as csv file
        [obj].MTMessages: MessageTracking messages matched
        [obj].StatusHisto: Histogram of Status entries for MTMessages array
        [obj].MsgLast: Last Message returned on track
        [obj].MsgsFail: Status:Fail messages returned on track
        [obj].MsgsFailOOO: Status:Fail messages returned on track that are a product of sender OutOfOffice external Sec Pol Blocks
        [obj].MsgsFailRecall: Status:Fail messages returned on track that are a product of sender Recall attempts
        [obj].MsgsFailOther: Status:Fail messages returned on track that are not OutOfOffice SecPol blocks, or Recalls
        [obj].MsgsFailOtherDetail: Get-xoMessageTraceDetail on .MsgsFailOther messages
        [obj].MTDetails: MessageTrackingDetail refactored summary of MTD as transactions
        [obj].MTDReport: expanded Detail summary output
        [obj].MTDCSVFile: full path to exported MTDs as csv file 

        Exports the object to .xml file as well (named for the main $ofile, renamed ext to .xml)

        For MsgsFailOther, that trace to Mail Loops, runs get-xorecipient, get-recipient & get-aduser on problem Recipient and profiles for incomplete offboard issues.

        -Status, underlying Get-xoMessageTrace supports: Delivered|Expanded|Failed|FilteredAsSpam|GettingStatus|None|Quarantined
            But the range of documented Status returns (via results post-filtering) is currently:
            Defer|Deliver|Delivered|Expand|Expanded|Fail|Failed|FilteredAsSpam|GettingStatus|None|Pending|Quarantined|Receive|Resolved|Send|Transfer
            
            Get-xoMessageTraceDetail also returns additional, undocumented: 'Submit|The message was submitted' (expanding GettingStatus items)

        > Note: As of 4/2021, MS wrecked utility of get-MessageTrace, dropping range from 30 days to 10 days, with silent failure to return -gt 10d (not even a range error). 
        > So there's not a lot of utility to supporting -Enddate (date) -Days 11, to pull historical 11day windows: If it's more than 10d old, you've got to use HistSearch regardless. 

    .PARAMETER ticket
    Ticket [-ticket 999999]
    .PARAMETER Requestor
    Ticket Customer email identifier. [-Requestor 'fname.lname@domain.com']
    .PARAMETER Tag
    Tag string (Variable Name compatible: no spaces A-Za-z0-9_ only) that is used for Variables and export file name construction. [-Tag 'LastDDGSend']
    .PARAMETER SenderAddress
    SenderAddress (an array runs search on each)[-SenderAddress addr@domain.com]
    .PARAMETER RecipientAddress
    RecipientAddress (an array runs search on each)[-RecipientAddress addr@domain.com]
    .PARAMETER StartDate
    Start of range to be searched[-StartDate '11/5/2021 2:16 PM']
    .PARAMETER EndDate
    End of range to be searched (defaults to current time if unspecified)[-EndDate '11/5/2021 5:16 PM']
    .PARAMETER Days
    Days to be searched, back from current time(Alt to use of StartDate & EndDate; Note:MS won't search -gt 10 days)[-Days 7]
    .PARAMETER Subject
    Subject of target message (emulated via post filtering, not supported param of Get-xoMessageTrace) [-Subject 'Some subject']
    .PARAMETER SubjectFilterType
    You specify how the value is evaluated in the message subject by using the SubjectFilterType parameter (Contains|EndsWith|StartsWith)
    .PARAMETER Status
    The Status parameter filters the results by the delivery status of the message (None|GettingStatus|Failed|Pending|Delivered|Expanded|Quarantined|FilteredAsSpam),an array runs search on each). [-Status 'Failed']
    .PARAMETER MessageId
    MessageId of target message(s) (include any <> and enclose in quotes; an array runs search on each)[-MessageId '<nnnn-nn.xxx....outlook.com>']
    .PARAMETER MessageTraceId
    The MessageTraceId parameter can be used with the recipient address to uniquely identify a message trace and obtain more details. A message trace ID is generated for every message that's processed by the system. [-MessageTraceId 'nnnneacn-ccnn-ndnb-annn-nednfncnnnna']
    .PARAMETER FromIP
    The FromIP parameter filters the results by the source IP address. For incoming messages, the value of FromIP is the public IP address of the SMTP email server that sent the message. For outgoing messages from Exchange Online, the value is blank. [-FromIP '123.456.789.012']
    .PARAMETER ToIP
    The ToIP parameter filters the results by the destination IP address. For outgoing messages, the value of ToIP is the public IP address in the resolved MX record for the destination domain. For incoming messages to Exchange Online, the value is blank. [-ToIP '123.456.789.012']
    .PARAMETER ResultSize
    The ResultSize parameter specifies the maximum number of results to return. A valid value is from 1 to 5000. The default value is 1000. Note: This parameter replaces the PageSize parameter that was available on the Get-MessageTrace cmdlet.
    .PARAMETER SimpleTrack
    Switch to just return the net messages on the initial track (no Fail/Quarantine, MTDetail or other post-processing summaries) [-simpletrack]
    .PARAMETER Detailed
    Switch to perform MessageTrackingDetail pass, after intial MessageTrace (up to limit specified in -MessageTraceDetailLimit (defaults true) [-Detailed]
    .PARAMETER DetailedOtherFails
    Switch to perform MessageTrackingDetail pass, for any 'Other' Fails (up to limit specified in -MessageTraceDetailLimit (defaults true) [-DetailedOtherFails]
    .PARAMETER DetailedReportRuleHits
    Switch to do Summarize & Expansion of any MTD TransportRule events (defaults true) [-DetailedReportRuleHits]
    .PARAMETER MessageTraceDetailLimit
    Integer number of maximum messages to be follow-up MessageTraceDetail'd (defaults to 20) [-MessageTraceDetailLimit 100]
    .PARAMETER NoQuarCheck
    NoQuarCheck
    Switch to DISABLE expansion of status:'Quarantined' messages into slow Get-QuarantineMessage & Get-QuarantineMessageHeader details[-NoQuarCheck]
    .PARAMETER QuarExpandLimitPerSender
    Integer number of maximum most-recent messages per SenderAddress, to be Expanded into Quarantine details & Quarantine Headers (defaults to 1)[-QuarExpandLimitPerSender 2]
    .PARAMETER DoExports
    Switch to perform configured csv exports of results (defaults true) [-DoExports]
    .PARAMETER TenOrg
    Tenant Tag (3-letter abbrebiation)[-TenOrg 'XYZ']
    .PARAMETER Credential
    Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]
    .PARAMETER UserRole
    Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER Silent
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    None. Returns no objects or output (.NET types)
    System.Boolean
    [| get-member the output to see what .NET obj TypeName is returned, to use here]
    .EXAMPLE
        PS> $results = Get-EXOMessageTraceExportedTDO -ticket 651268 -SenderAddress='SENDER@DOMAIN.COM' -RecipientAddress='RECIPIENT@DOMAIN.COM' -StartDate='11/1/2021  4:35:39 PM' -Subject 'Accepted: Exmark/RLC Bring Up' -verbose ;
        # dump messages table and group Status
        $results.MTMessages | ft -a ReceivedLocal,Sender*,Recipient*,subject,*status,*ip ;
        $results.MTMessages | group status | ft -auto count,name ;
        # dump MessageTraceDetail table
        $results.MTDetails | sort Date | ft -a date,event,action,detail,sender*,recipient* ;
        # dump MessageTraceDetail Summary Report as table
        $results.MTDReport| sort date | ft -a DateLocal,Event,Action,Detail ;
        # echo csv output files
        $results.MTMessagesCSVFile ;
        $results.MTDRptCSVFile ;
        Run a typical MessageTrace on sender & recipient, specified start/end dates, and subject, with default 100-message MessageTraceDetail report, with verbose output.
        And then demo of working with the data returned
        .EXAMPLE
        PS> $results = Get-EXOMessageTraceExportedTDO -ticket 651268 -SenderAddress='ATTENDEE@DOMAIN.COM' -RecipientAddress='ORGANIZER@DOMAIN.COM' -StartDate='11/1/2021  4:35:39 PM' -Subject 'Accepted: [MEETINGSUBJ]' -verbose ;
        Run a Meeting ACCEPTED MessageTrace - 
            no booking conflict, 
            From: Attendee To: Originator
            Subject: 'Accepted: [MEETINGSUBJ]'
        - with default 100-message MessageTraceDetail report, with verbose output.
        .EXAMPLE
        PS> $results = Get-EXOMessageTraceExportedTDO -ticket 651268 -SenderAddress='ROOM@DOMAIN.COM' -RecipientAddress='ORGANIZER@DOMAIN.COM' -StartDate='11/1/2021  4:35:39 PM' -Subject 'Declined: [MEETINGSUBJ]' -verbose ;
        Run a Meeting DECLINED MessageTrace - 
             Booking conflict, 
             From: Room, To: Originator (and copy to any SendOnBehalf delegate that actually created the meeting)
             Subject is: 'Declined: [MEETINGSUBJ]'
        - with default 100-message MessageTraceDetail report, with verbose output.
        .EXAMPLE
        PS> $results = Get-EXOMessageTraceExportedTDO -ticket 651268 -SenderAddress='ROOM@DOMAIN.COM' -RecipientAddress='ORGANIZER@DOMAIN.COM' -StartDate='11/1/2021  4:35:39 PM' -Subject 'Tentative: [MEETINGSUBJ]' -verbose ;
        Run a Meeting TENTATIVE response (Moderated resource), MessageTrace, - 
            reflects a AllRequestinPolicy:`$true resource ;
            w ResourceDelegates; 
            no booking conflict;
            but pending ResDelegate approval
            From: Room, To: Originator (and copy to any SendOnBehalf delegate that actually created the meeting)
            Subject is: 'Tentative: [MEETINGSUBJ]'
         -  with default 100-message MessageTraceDetail report, with verbose output. 
        .EXAMPLE
        PS> $results = Get-EXOMessageTraceExportedTDO -ticket 651268 -SenderAddress='ORGANIZER@DOMAIN.COM' -RecipientAddress='RESDELEGATE@DOMAIN.COM' -StartDate='11/1/2021  4:35:39 PM' -Subject 'FW: [MEETINGSUBJ]' -verbose ;
        Run a Meeting 'FW: [MEETINGSUBJ]' MODERATION REQUEST MessageTrace - 
            TO: ResourceDelegates (redirected Forward) FROM: ORGANIZER
            reflects a Resource with: AllRequestinPolicy:`$true; 
            ResourceDelegates configured; 
            no booking conflict, but pending ResDelegate approval 
        - MessageTrace (which will come from Meeting Originator email address), to the ResDelegate addresses, with default 100-message MessageTraceDetail report, with verbose output.
        .EXAMPLE
        PS> $pltGxMT=[ordered]@{
        PS>    Ticket = '999999' ; 
        PS>    Requestor = 'fname.lname@domain.tld' ; 
        PS>    Tag = 'TestGxmtD' ;
        PS>    RecipientAddress  = 'fname.lname@domain.tld','fname.lname@domain2.TLD' ;
        PS>    senderaddress = 'fname.lname@domain.tld','fname.lname@domain2.TLD' ;
        PS>    StartDate = (get-date ).AddDays(-1) ;
        PS>    EndDate = (get-date ) ;
        PS>    Subject="" ;
        PS>    Status='' ;
        PS>    MessageTraceId='' ;
        PS>    MessageId='' ;
        PS>    FromIP='' ;
        PS>    ToIP='' ;
        PS>    SimpleTrack = $false ;
        PS>    Detailed = $false ;
        PS>    DetailedReportRuleHits = $false ;
        PS>    DetailedOtherFails = $true ;
        PS>    MessageTraceDetailLimit = 20 ;
        PS>    NoQuarCheck='';
        PS>    QuarExpandLimitPerSender = 1 ;
        PS>    DoExports = $true ;
        PS>    TenOrg = $global:o365_TenOrgDefault ; 
        PS>    silent = $false ;      
        PS>    verbose = $true ; 
        PS> } ;
        PS> $pltGxMT = [ordered]@{} ;
        PS> $pltI.GetEnumerator() | ?{ $_.value}  | ForEach-Object { $pltGxMT.Add($_.Key, $_.Value) } ;
        PS> $vn = (@("xoMsgs$($pltI.ticket)",$pltI.Tag) | ?{$_}) -join '_' ;
        PS> write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):Get-EXOMessageTraceExportedTDO w`n$(($pltGxMT|out-string).trim())`n(assign to `$$($vn))" ;
        PS> if(gv $vn -ea 0){rv $vn} ;
        PS> if($tmsgs = Get-EXOMessageTraceExportedTDO @pltGxMT){sv -na $vn -va $tmsgs ;
        PS> write-host "(assigned to `$$vn)"} ;

            ...
            14:51:33:Raw sender/recipient events:1850
            14:51:33:(1850 events | export-csv d:\scripts\logs\900881_x2xxxx,Txxxxx-xxxxxx.xxxxxxx@xxxx.com-EXOMsgTrc,TO_xxxxxxx@xxxx.com-2d-20250429-1951-run20250501-1451.csv)
            14:51:34:export-csv'd to:
            D:\scripts\logs\900881_x2xxxx,Txxxxx-xxxxxx.xxxxxxx@xxxx.com-EXOMsgTrc,TO_xxxxxxx@xxxx.com-2d-20250429-1951-run20250501-1451.csv
            14:51:34:(adding $hReports.MTMessages)
            14:51:34:(adding $hReports.MTMessagesCSVFile:d:\scripts\logs\900881_x2xxxx,Txxxxx-xxxxxx.xxxxxxx@xxxx.com-EXOMsgTrc,TO_xxxxxxx@xxxx.com-2d-20250429-1951-run20250501-1451.csv)
            14:51:34:
            #*------v Status DISTRIB v------

            14:51:34:
            Count Name
            ----- ----
              963 Resolved
              881 Delivered
                5 FilteredAsSpam
                1 GettingStatus
            14:51:34:

            #*------^ Status DISTRIB ^------

            14:51:34:

            ## Status Definitions:
            Resolved The message was redirected to the new recipient address based on an Active Directory lookup. When this happens, the original recipient address will be listed in a separate row in the message trace along with the final delivery status for the message.
            Delivered The message was delivered to its destination.
            FilteredAsSpam The message was marked as spam (and moved to the mailbox 'Junk Email' folder).
            GettingStatus The message is waiting for status update.

            14:51:34:

            #*------v MOST RECENT MATCH v------

            14:51:34:
            ReceivedLocal    : 5/1/2025 2:49:11 PM
            Status           : Resolved
            SenderAddress    : xxxxxxx@xx-xxxxxxx.xxx
            RecipientAddress : xxxxxxx@xxxx.com
            Subject          : FW: help per below, need detail
            14:51:34:

            #*------^ MOST RECENT MATCH ^------

            WARNING: 14:51:34:Status:GettingStatus returned on some traces - INDETERMINANT STATUS THOSE ITEMS (PENDING TRACKABLE LOGGING), RERUN IN A FEW MINS TO GET FUNCTIONAL DATA! (EXO-SIDE ISSUE)
            14:51:34:

            #*------v GettingStatus's Attempt to Re-Resolve via Get-xoMessageTraceDetail (up to last 20 messages) v------

            14:51:40:

            ===#1: MsgId: <CH2PR04MB6619FCF5E2194B8622AAB01EED822@CH2PR04MB6619.namprd04.prod.outlook.com> : Status:GettingStatus
            Received            SenderAddress           RecipientAddress Subject
            --------            -------------           ---------------- -------
            5/1/2025 2:01:05 PM xxxxx.xxxxxxxx@xxxx.com xxxxxxx@xxxx.com xxxxxxxxxx xxxxxxxx xxxxxx      FW: xxxx - xxxxxxx  xxxxxx xxxx 40643310
            DetailDisposition:
            Date                Event  Detail
            ----                -----  ------
            5/1/2025 2:01:06 PM Submit The message was submitted.
            14:51:40:

            #*------^  GettingStatus's Attempt to Re-Resolve via Get-xoMessageTraceDetail (up to last 20 messages)  ^------

            14:51:40:(log file confirmed)
            14:51:40:1850 matches output to:
            'd:\scripts\logs\900881_x2xxxx,Txxxxx-xxxxxx.xxxxxxx@xxxx.com-EXOMsgTrc,TO_xxxxxxx@xxxx.com-2d-20250429-1951-run20250501-1451.csv'
            (copied to CB)
            14:51:40:(Returning summary object to pipeline)
            14:51:40:(exporting $hReports summary object to xml:d:\scripts\logs\900881_x2xxxx,Txxxxx-xxxxxx.xxxxxxx@xxxx.com-EXOMsgTrc,TO_xxxxxxx@xxxx.com-2d-20250429-1951-run20250501-1451.xml)

        Splatted demo, all configurable params, depict some common output profile features (conditional on content in the trace)
        .EXAMPLE
        PS> $pltGxMT=[ordered]@{
        PS>     Ticket = '99999' ;
        PS>     Requestor = 'fname.lname@domain.tld' ; 
        PS>     Tag = 'AnyTraffic' ;
        PS>     senderaddress = '*@DOMAIN.COM' ;
        PS>     StartDate = (get-date ).AddDays(-10) ;
        PS>     EndDate = (get-date ) ;
        PS>     erroraction = 'STOP' ;
        PS>     verbose = $true ;
        PS> } ;
        PS> $pltGxMT = [ordered]@{} ;
        PS> $pltI.GetEnumerator() | ?{ $_.value}  | ForEach-Object { $pltGxMT.Add($_.Key, $_.Value) } ;
        PS> $vn = (@("xoMsgs$($pltI.ticket)",$pltI.Tag) | ?{$_}) -join '_' ;
        PS> write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):Get-EXOMessageTraceExportedTDO w`n$(($pltGxMT|out-string).trim())`n(assign to `$$($vn))" ;
        PS> if(gv $vn -ea 0){rv $vn} ;
        PS> if($tmsgs = Get-EXOMessageTraceExportedTDO @pltGxMT){sv -na $vn -va $tmsgs ;
        PS> write-host "(assigned to `$$vn)"} ;
        Demo search on wildcard sender address (using * wildcard character)
        .EXAMPLE
        PS> $pltGxMT=[ordered]@{
        PS>     Ticket = '999999' ; 
        PS>     Requestor = 'fname.lname@domain.tld' ; 
        PS>     Tag = 'SEARCHTAG' ;
        PS>     senderaddress = 'fname.lname@domain.tld','fname.lname@domain2.TLD' ;
        PS>     StartDate = (get-date ).AddDays(-1) ;
        PS>     EndDate = (get-date ) ;
        PS>     RecipientAddress = 'fname.lname@domain.tld'  ; 
        PS>     Days = 10 ; 
        PS>     subject = 'MSGSUBJECT' ; 
        PS>     Status = $null ; # 'None|GettingStatus|Failed|Pending|Delivered|Expanded|Quarantined|FilteredAsSpam'
        PS>     MessageId = '<NNNN.NA.NNNNNNNNNNNN@SUB.DOMAIN.TLD>'; 
        PS>     MessageTraceId = 'nnnnccdn-nnen-nfnn-nnan-nnnendnebnce' ; 
        PS>     FromIP = $null ; 
        PS>     ToIP = $null ; 
        PS>     SimpleTrack = $false ;
        PS>     DetailedReportRuleHits= $true ; 
        PS>     NoQuarCheck = $false ; 
        PS>     DoExports=$TRUE ; 
        PS>     Detailed = $false ; 
        PS>     #TenOrg = global:o365_TenOrgDefault ; 
        PS>     #Credential = $null ;
        PS>     #UserRole = @('SIDCBA','SID','CSVC') ; 
        PS>     #useEXOv2 = $true
        PS>     #silent = $false ;
        PS>     verbose = $true ; 
        PS>     Tag='' ;
        PS> } ;
        PS> $pltGxMT = [ordered]@{} ;
        PS> $pltI.GetEnumerator() | ?{ $_.value}  | ForEach-Object { $pltGxMT.Add($_.Key, $_.Value) } ;
        PS> $vn = (@("xoMsgs$($pltI.ticket)",$pltI.Tag) | ?{$_}) -join '_' ;
        PS> write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):Get-EXOMessageTraceExportedTDO w`n$(($pltGxMT|out-string).trim())`n(assign to `$$($vn))" ;
        PS> if(gv $vn -ea 0){rv $vn} ;
        PS> if($tmsgs = Get-EXOMessageTraceExportedTDO @pltGxMT){sv -na $vn -va $tmsgs ;
        PS> write-host "(assigned to `$$vn)"} ;
        Fully eunmerated splat parameters demo, with constructed variable output (uses $pltI.ticket & $pltI.tag)
        .LINK
        https://docs.microsoft.com/en-us/powershell/module/exchange/get-messagetrace
        .LINK
        https://docs.microsoft.com/en-us/powershell/module/exchange/get-messagetracedetail
        .LINK
        https://github.com/tostka/verb-exo
    #>
    #Requires -Modules AzureAD, ExchangeOnlineManagement 
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\sregex\sexpr")][ValidateSet("US","GB","AU")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)]#positiveInt:[ValidateRange(0,[int]::MaxValue)]#negativeInt:[ValidateRange([int]::MinValue,0)][ValidateCount(1,3)]
    [CmdletBinding(DefaultParameterSetName='Days')]
    [Alias('get-EXOMsgTraceDetailed','Get-EXOMessageTraceExported','Get-EXOMessageTraceTDO')]
    PARAM(
        [Parameter(Mandatory=$false,HelpMessage="Ticket [-ticket 999999]")]
            [ValidateNotNullOrEmpty()]    
            [string]$ticket,
         [Parameter(HelpMessage="Ticket Customer email identifier. [-Requestor 'fname.lname@domain.com']")] 
            [Alias('UID')]
            [string]$Requestor,
        [Parameter(HelpMessage="Tag string (Variable Name compatible: no spaces A-Za-z0-9_ only) that is used for Variables and export file name construction. [-Tag 'LastDDGSend']")] 
            [ValidatePattern('^[A-Za-z0-9_]*$')]
            [string]$Tag,
        [Parameter(HelpMessage="SenderAddress (an array runs search on each)[-SenderAddress addr@domain.com]")]
            [Alias('Sender')]
            [string[]]$SenderAddress, # MultiValuedProperty
        [Parameter(HelpMessage="RecipientAddress (an array runs search on each)[-RecipientAddress addr@domain.com]")]
            [Alias('Recipients')]
            [string[]]$RecipientAddress, # MultiValuedProperty
        [Parameter(ParameterSetName='Dates',HelpMessage="Start of range to be searched[-StartDate '11/5/2021 2:16 PM']")]
            [Alias('Start')]
            [DateTime]$StartDate,
        [Parameter(ParameterSetName='Dates',HelpMessage="End of range to be searched (defaults to current time if unspecified)[-EndDate '11/5/2021 5:16 PM']")]
            [Alias('End')]
            [DateTime]$EndDate=(get-date),
        [Parameter(ParameterSetName='Days',HelpMessage="Days to be searched, back from current time(Alt to use of StartDate & EndDate; Note:MS won't search -gt 10 days)[-Days 7]")]
            #[ValidateRange(0,[int]::MaxValue)]
            [ValidateRange(0,10)] # MS won't search beyond 10, and silently returns incomplete results
            [int]$Days,
        [Parameter(HelpMessage="Subject of target message (emulated via post filtering, not supported param of Get-xoMessageTrace) [-Subject 'Some subject']")]
            [Alias('MessageSubject')]
            [string]$subject,
        [Parameter(HelpMessage="You specify how the value is evaluated in the message subject by using the SubjectFilterType parameter (Contains|EndsWith|StartsWith) [-SubjectFilterType 'StartsWith']")]
            [ValidateSet("Contains","EndsWith","StartsWith")]
            #[Alias('MessageSubject')]
            [string]$SubjectFilterType,
        [Parameter(HelpMessage="The Status parameter filters the results by the delivery status of the message (None|GettingStatus|Failed|Pending|Delivered|Expanded|Quarantined|FilteredAsSpam),an array runs search on each, post-filter results to target full range of Status values). [-Status 'Failed']")]
            [Alias('DeliveryStatus','EventId')]
            [ValidateSet('None','GettingStatus','Failed','Pending','Delivered','Expanded','Quarantined','FilteredAsSpam')]
            [string[]]$Status, # MultiValuedProperty
        [Parameter(HelpMessage="MessageId of target message(s) (include any <> and enclose in quotes; an array runs search on each)[-MessageId '<nnnn-nn.xxx....outlook.com>']")]
            # Get-xoMessageTrace specs <MultiValuedProperty>: "just means that you can provide multiple values (i.e. an array) as the argument to the parameter. If your users input something like alice@example.com,bob@example.com,charlie@example.com, you need to split the delims"
            [string[]]$MessageId, # MultiValuedProperty
        [Parameter(HelpMessage="The MessageTraceId parameter can be used with the recipient address to uniquely identify a message trace and obtain more details. A message trace ID is generated for every message that's processed by the system. [-MessageTraceId 'nnnneacn-ccnn-ndnb-annn-nednfncnnnna']")] 
            [Guid]$MessageTraceId,
        [Parameter(HelpMessage="The FromIP parameter filters the results by the source IP address. For incoming messages, the value of FromIP is the public IP address of the SMTP email server that sent the message. For outgoing messages from Exchange Online, the value is blank. [-FromIP '123.456.789.012']")] 
            [string]$FromIP, 
        [Parameter(HelpMessage="The ToIP parameter filters the results by the destination IP address. For outgoing messages, the value of ToIP is the public IP address in the resolved MX record for the destination domain. For incoming messages to Exchange Online, the value is blank. [-ToIP '123.456.789.012']")] 
            [string]$ToIP,            
            [Parameter(HelpMessage="The ResultSize parameter specifies the maximum number of results to return. A valid value is from 1 to 5000. The default value is 1000. Note: This parameter replaces the PageSize parameter that was available on the Get-MessageTrace cmdlet. [-ResultSize 2000]")]             
            [int32]$ResultSize,
        [Parameter(HelpMessage="Switch to just return the net messages on the initial track (no Fail/Quarantine, MTDetail or other post-processing summaries) [-simpletrack]")]
            [switch]$SimpleTrack,
        [Parameter(HelpMessage="Switch to do Summarize & Expansion of any MTD TransportRule events (defaults true) [-DetailedReportRuleHits]")]
            [switch]$DetailedReportRuleHits= $true,
        [Parameter(HelpMessage="Integer number of maximum messages to be follow-up MessageTraceDetail'd (defaults to 20) [-MessageTraceDetailLimit 100]")]
            [int]$MessageTraceDetailLimit = 20,
        [Parameter(HelpMessage="Switch to DISABLE expansion of status:'Quarantined' messages into slow Get-QuarantineMessage & Get-QuarantineMessageHeader details[-NoQuarCheck]")]
            [switch]$NoQuarCheck,
        [Parameter(HelpMessage="Integer number of maximum most-recent messages per SenderAddress, to be Expanded into Quarantine details & Quarantine Headers (defaults to 1)[-QuarExpandLimitPerSender 2]")]
            [int]$QuarExpandLimitPerSender = 1,
        [Parameter(HelpMessage="Switch to perform configured csv exports of results (defaults true) [-DoExports]")]
            [switch]$DoExports=$TRUE,
        [Parameter(HelpMessage="Switch to perform Get-xoMessageTraceDetail pass, after intial MessageTrace (up to limit specified in -MessageTraceDetailLimit (defaults false) [-Detailed]")]
            [switch]$Detailed,
        [Parameter(HelpMessage="Switch to perform Get-xoMessageTraceDetail pass, for any 'Other' Fails (up to limit specified in -MessageTraceDetailLimit (defaults true) [-DetailedOtherFails]")]
            [switch]$DetailedOtherFails = $true,
        # Service Connection Supporting Varis (AAD, EXO, EXOP)
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
            [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ;
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ;
                return $true ;
            })]
            [string[]]$UserRole = @('SIDCBA','SID','CSVC'),
            #@('SID','CSVC'),
            # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
            [switch] $useEXOv2=$true,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent
    ) ;
    BEGIN{
        
        # Pull the CUser mod dir out of psmodpaths:
        #$CUModPath = $env:psmodulepath.split(';')|?{$_ -like '*\Users\*'} ;
    
        # 2b4() 2b4c() & fb4() are located up in the CONSTANTS_AND_ENVIRO\ENCODED_CONTANTS block ( to convert Constant assignement strings)

        #region FUNCTIONS_FULLYEXTERNAL ; #*======v FUNCTIONS_FULLYEXTERNAL v======
        # Optional block that relies on local module installs (vs the FUNCTIONS_LOCAL integrated block that follows below, and the FUNCTIONS_LOCAL_INTERNAL that is used for completely non-shared local functions.)

        #region RESOLVE_ENVIRONMENTTDO ; #*------v verb-io\resolve-EnvironmentTDO v------
        if(-not(gi function:resolve-EnvironmentTDO -ea 0)){
            $smsg = "MISSING DEPENDANT: verb-io\resolve-EnvironmentTDO !" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            break ; 
        } ;
        #endregion RESOLVE_ENVIRONMENTTDO ; #*------^ END verb-io\resolve-EnvironmentTDO ^------

        #region WRITE_LOG ; #*------v verb-logging\write-log v------
        if(-not(gi function:write-log -ea 0)){
            $smsg = "MISSING DEPENDANT: verb-logging\write-log !" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            break ; 
        } ; 
        #endregion WRITE_LOG ; #*------^ END verb-logging\write-log  ^------
    
        #region START_LOG ; #*------v verb-logging\Start-Log v------
        if(-not(gi function:start-log -ea 0)){
            $smsg = "MISSING DEPENDANT: verb-logging\start-log !" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            break ; 
        } ; 
        #endregion START_LOG ; #*------^ END verb-logging\start-log ^------
    
        #region RESOLVE_NETWORKLOCALTDO ; #*------v verb-Network\resolve-NetworkLocalTDO v------
        if(-not(gi function:resolve-NetworkLocalTDO -ea 0)){
            $smsg = "MISSING DEPENDANT: verb-Network\resolve-NetworkLocalTDO!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            break ; 
        }
        #endregion RESOLVE_NETWORKLOCALTDO ; #*------^ END verb-Network\resolve-NetworkLocalTDO ^------

        #region PUSH_TLSLATEST ; #*------v verb-Network\push-TLSLatest v------
        if(-not(gi function:push-TLSLatest -ea 0)){
            $smsg = "MISSING DEPENDANT: verb-Network\push-TLSLatest!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            break ; 
        } ; 
        #endregion PUSH_TLSLATEST ; #*------^ END verb-Network\push-TLSLatest ^------
    
        #region TEST_EXCHANGEINFO ; #*------v verb-Ex2010\test-LocalExchangeInfoTDO v------
        if(-not (get-item function:test-LocalExchangeInfoTDO -ea 0)){
            $smsg = "MISSING DEPENDANT: verb-Ex2010\test-LocalExchangeInfoTDO!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            break ; 
        } ; 
        #endregion TEST_EXCHANGEINFO ; #*------^ END verb-Ex2010\test-LocalExchangeInfoTDO ^------
    
        #region CONNECT_O365SERVICES ; #*======v verb-exo\connect-O365Services v======
        if(-not (get-childitem function:connect-O365Services -ea 0)){
            $smsg = "MISSING DEPENDANT: verb-exo\connect-O365Services!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            break ; 
        } ;
        #endregion CONNECT_O365SERVICES ; #*======^ END verb-exo\connect-o365services ^======

        #region OUT_CLIPBOARD ; #*------v verb-IO\out-Clipboard v------
        if(-not(gci function:out-Clipboard -ea 0)){
            $smsg = "MISSING DEPENDANT: verb-IO\out-Clipboard!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            break ; 
        } ; 
        #endregion OUT_CLIPBOARD ; #*------^ END verb-IO\out-Clipboard ^------

        #region START_SLEEPCOUNTDOWN ; #*------v verb-IO\start-sleepcountdown v------
        if (-not (get-command start-sleepcountdown -ea 0)) {
            $smsg = "MISSING DEPENDANT: verb-IO\start-sleepcountdown!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            break ; 
        } ;
        #endregion START_SLEEPCOUNTDOWN ; #*------^ END verb-IO\start-sleepcountdown ^------

        #region CONVERTFROM_MARKDOWNTABLE ; #*------v verb-IO\convertFrom-MarkdownTable v------
        if(-not(gci function:convertFrom-MarkdownTable -ea 0)){
            $smsg = "MISSING DEPENDANT: verb-IO\convertFrom-MarkdownTable!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            break ; 
        } ; 
        #endregion CONVERTFROM_MARKDOWNTABLE ; #*------^ END verb-IO\convertFrom-MarkdownTable ^------

        #region REMOVE_INVALIDVARIABLENAMECHARS ; #*------v verb-IO\Remove-InvalidVariableNameChars v------        
        if(-not (gcm Remove-InvalidVariableNameChars -ea 0)){
            Function Remove-InvalidVariableNameChars ([string]$Name) {
                ($Name.tochararray() -match '[A-Za-z0-9_]') -join '' | write-output ;
            };
        } ;
        #endregion REMOVE_INVALIDVARIABLENAMECHARS ; #*------^ END verb-IO\Remove-InvalidVariableNameChars ^------
        
        #endregion FUNCTIONS_FULLYEXTERNAL ; #*======^ END FUNCTIONS_FULLYEXTERNAL ^======

        #region FUNCTIONS_LOCAL_INTERNAL ; #*======v FUNCTIONS_LOCAL_INTERNAL v======

        #region INITIALIZE_EXOSTATUSTABLE ; #*------v Initialize-exoStatusTable v------
        #*------v Initialize-exoStatusTable.ps1 v------
        function Initialize-exoStatusTable {
            <#
            .SYNOPSIS
            Initialize-exoStatusTable - Builds an indexed hash tabl of Exchange Server Get-MessageTrackingLog Statuss
            .NOTES
            Version     : 1.0.0
            Author      : Todd Kadrie
            Website     : http://www.toddomation.com
            Twitter     : @tostka / http://twitter.com/tostka
            CreatedDate : 2025-04-22
            FileName    : Initialize-exoStatusTable
            License     : (none asserted)
            Copyright   : (none asserted)
            Github      : https://github.com/tostka/verb-Ex2010
            Tags        : Powershell,EmailAddress,Version
            AddedCredit : Bruno Lopes (brunokktro )
            AddedWebsite: https://www.linkedin.com/in/blopesinfo
            AddedTwitter: @brunokktro / https://twitter.com/brunokktro
            REVISIONS
            * 1:47 PM 7/9/2024 CBA github field correction
            * 1:22 PM 5/22/2024init
            .DESCRIPTION
            Initialize-exoStatusTable - Builds an indexed hash tabl of Exchange Server Get-MessageTrackingLog Statuses

            .OUTPUT
            String
            .EXAMPLE
            PS> $StatusLookupTbl = Initialize-StatusTable ; 
            PS> $smsg = "`n`n## Status Definitions:" ; 
            PS> $TrackMsgs | group Status | select -expand Name | foreach-object{                   
            PS>     $smsg += "`n$(($StatusLookupTbl[$_]| ft -hidetableheaders | out-string).trim())" ; 
            PS> } ; 
            PS> $smsg += "`n`n" ; 
            PS> if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
            PS> else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Demo resolving histogram Status uniques, to MS documented meansings of each event id in the msgtrack.
            .EXAMPLE
            ps> Initialize-exoStatusTable -EmailAddress 'monitoring+SolarWinds@toro.com;notanemailaddresstoro.com,todd+spam@kadrie.net' -verbose ;
            PS> 
            Demo with comma and semicolon delimiting, and an invalid address (to force a regex match fail error).
            .LINK
            https://github.com/brunokktro/EmailAddress/blob/master/Get-ExchangeEnvironmentReport.ps1
            .LINK
            https://github.com/tostka/verb-Ex2010
            #>
            [CmdletBinding()]
            #[Alias('rvExVers')]
            PARAM() ;
            BEGIN {
                ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
                $verbose = $($VerbosePreference -eq "Continue")
                $sBnr="#*======v $($CmdletName): v======" ;
                write-verbose  "$((get-date).ToString('HH:mm:ss')):$($sBnr)" ;
                
                $StatussMD = @"
Status|Description
---|---
Defer|The message delivery to the intended recipient was postponed and might be re-attempted later
Deliver|The message was delivered to its destination.
Delivered|The message was delivered to its destination.
Expand|The message was sent to a distribution group that was recently expanded.
Expanded|There was no message delivery because the message was addressed to a distribution group and the membership of the distribution was expanded (to the individual recipients)
Fail|Message delivery was attempted and it failed or the message was filtered as spam or malware, or by transport rules.
Failed|Message delivery was attempted and it failed or the message was filtered as spam or malware, or by transport rules.
FilteredAsSpam|The message was marked as spam (and moved to the mailbox 'Junk Email' folder).
GettingStatus|The message is waiting for status update.
None|The message has no delivery status because it was rejected or redirected to a different recipient.
Pending|Message delivery is underway or was deferred and is being retried.
Quarantined|The message was quarantined.
Receive|The message was received by the service (via Outlook submission or via SMTP from another server).
Resolved|The message was redirected to the new recipient address based on an Active Directory lookup. When this happens, the original recipient address will be listed in a separate row in the message trace along with the final delivery status for the message.|
Send|The message was sent by the service (via SMTP to another server).
Transfer|The recipient was moved to a bifurcated message because of content conversion, message recipient limits, or agents.
"@ ;

                $Object = $StatussMD | convertfrom-MarkdownTable ; 
                $Key = 'Status' ; 
                $Hashtable = @{}
            }
            PROCESS {
                Foreach ($Item in $Object){
                    $Procd++ ; 
                    $Hashtable[$Item.$Key.ToString()] = $Item ; 
                    if($ShowProgress -AND ($Procd -eq $Every)){
                        write-host -NoNewline '.' ; $Procd = 0 
                    } ; 
                } ;                 
            } # PROC-E
            END{
                $Hashtable | write-output ; 
                write-verbose  "$((get-date).ToString('HH:mm:ss')):$($sBnr.replace('=v','=^').replace('v=','^='))" ;
            }
        }; 
        #*------^ Initialize-exoStatusTable.ps1 ^------
        #endregion INITIALIZE_EXOSTATUSTABLE ; #*------^ END INITIALIZE_EXOSTATUSTABLE ^------

        #region pull-GetxoMessageTraceDetail ; #*------v pull-GetxoMessageTraceDetail v------
        function pull-GetxoMessageTraceDetail {
            <#
            .SYNOPSIS
            pull-GetxoMessageTraceDetail - wrap Get-xoMessageTraceDetail, with retry around `$null returns
            .NOTES
            REVISIONS
            * 10:57 AM 5/2/2025 INIT
            .DESCRIPTION
            pull-GetxoMessageTraceDetail - wrap Get-xoMessageTraceDetail, with retry around `$null returns
            .PARAMETER  Messages
            Array of Get-xoMessageTrace Message returns to be expanded into Get-xoMessageTraceDetail 
            .INPUTS
            Array of Get-xoMessageTrace Message returns
            .OUTPUTS
            SystemObject Returns array of resolved Get-xoMessageTraceDetail results
            .EXAMPLE
            PS> $mtds = pull-GetxoMessageTraceDetail -Messages $mtdmsgs ; 
            EXSAMPLEOUTPUT
            Run with whatif & verbose
            #>
            [CmdletBinding()]
            PARAM(
                [Parameter(Mandatory=$True,HelpMessage="Array of Get-xoMessageTrace Message returns to be expanded into Get-xoMessageTraceDetail ")]
                [array]$Messages
            ) ; 
            BEGIN{
                if(-not $RetrySleep){$RetrySleep = 10 } ; # wait time between retries
                if(-not $DawdleWait){$DawdleWait = 30 } ; # wait time (secs) between dawdle checks
                if(-not $RetryThrottle){$RetryThrottle = 60 } ; # wait time (secs) after Throttle error $errtest.Exception ||Your recent queries have surpassed the permitted limit, please try again later
                if(-not $rgxEXOThrottle){$rgxEXOThrottle = 'Your\srecent\squeries\shave\ssurpassed\sthe\spermitted\slimit,\splease\stry\sagain\slater' } 
            } ; 
            PROCESS{
                $mtds = @() ; 
                foreach( $mtdm in  $Messages){
                    $smsg = "--Get-xoMessageTraceDetail: MsgID: $($mtdm.MessageId) : To: $($mtdm.recipientaddress)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    $pltgXMTD=[ordered]@{
                        MessageTraceId = $mtdm.MessageTraceId ;
                        RecipientAddress = $mtdm.RecipientAddress
                        erroraction = 'STOP' ;
                        #whatif = $($whatif) ;
                    } ;
                    $smsg = "Get-xoMessageTraceDetail w`n$(($pltgXMTD|out-string).trim())" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    $Exit = 0 ;
                    Do {
                        TRY {                            
                            #if($rmtd = Get-xoMessageTraceDetail @pltgXMTD){
                            # 1:21 PM 10/21/2025 try to splice in Get-xoMessageTraceDetailV2
                            # doesn't seem to support the same -StartingRecipientAddress etc params, no evidence does warning pushback, lacks the gxmt's native params for those features. 
                            # does throttle HARD, just kills the connection
                            if($rmtd = Get-xoMessageTraceDetailV2 @pltgXMTD){
                                $mtds += $rmtd ;
                            } else {
                                write-warning "No Return: #$($Exit):MTId: $($pltgXMTD.MessageTraceId) : To: $($pltgXMTD.RecipientAddress)" ; 
                                throw "no Get-xoMessageTraceDetail return" ; 
                            } ; 
                            $Exit = $Retries ;
                        } CATCH [System.Exception] {
                            $ErrTrapd=$Error[0] ;
                            if($ErrTrapd.Exception -match $rgxEXOThrottle){
                                $smsg = "MS 100-qry limit/5mins throttling detected, waiting $(RetryThrottle)s to retry..." ; 
                                $smsg += "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                #Start-Sleep -Milliseconds $ThrottleMs 
                                start-sleepcountdown -seconds $RetryThrottle -Rolling ; 
                                $Exit ++ ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                $smsg= "Try #: $($Exit)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error }  #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                If ($Exit -eq $Retries) {
                                    $smsg= "Unable to exec cmd!" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error }  #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    BREAK ; 
                                } ;
                            } ; 
                        } CATCH {
                            $ErrTrapd=$Error[0] ;
                            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                            Start-Sleep -Milliseconds $ThrottleMs 
                            $Exit ++ ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $smsg= "Try #: $($Exit)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error }  #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            If ($Exit -eq $Retries) {
                                $smsg= "Unable to exec cmd!" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error }  #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                BREAK ; 
                            } ;
                        }  ;
                    } Until ($Exit -eq $Retries) ; 
                    start-sleep -Milliseconds $ThrottleMs  ;
                } ; 
            } ;  # PROC-E
            END{
                $mtds | write-output 
            } ; 
        } ;
        #endregion pull-GetxoMessageTraceDetail ; #*------^ END pull-GetxoMessageTraceDetail ^------
                
        #endregion FUNCTIONS_LOCAL_INTERNAL ; #*======^ END FUNCTIONS_LOCAL_INTERNAL ^======

        #region CONSTANTS_AND_ENVIRO ; #*======v CONSTANTS_AND_ENVIRO v======
        #region ENVIRO_DISCOVER ; #*------v ENVIRO_DISCOVER v------
        push-TLSLatest
        $Verbose = [boolean]($VerbosePreference -eq 'Continue') ; 
        $rPSCmdlet = $PSCmdlet ; # an object that represents the cmdlet or advanced function that's being run. Available on functions w CmdletBinding (& $args will not be available). (Blank on non-CmdletBinding/Non-Adv funcs).
        $rPSScriptRoot = $PSScriptRoot ; # the full path of the executing script's parent directory., PS2: valid only in script modules (.psm1). PS3+:it's valid in all scripts. (Funcs: ParentDir of the file that hosts the func)
        $rPSCommandPath = $PSCommandPath ; # the full path and filename of the script that's being run, or file hosting the funct. Valid in all scripts.
        $rMyInvocation = $MyInvocation ; # populated only for scripts, function, and script blocks.
        # - $MyInvocation.MyCommand.Name returns name of a function, to identify the current command,  name of the current script (pop'd w func name, on Advfuncs)
        # - Ps3+:$MyInvocation.PSScriptRoot : full path to the script that invoked the current command. The value of this property is populated only when the caller is a script (blank on funcs & Advfuncs)
        # - Ps3+:$MyInvocation.PSCommandPath : full path and filename of the script that invoked the current command. The value of this property is populated only when the caller is a script (blank on funcs & Advfuncs)
        #     ** note: above pair contain information about the _invoker or calling script_, not the current script
        $rPSBoundParameters = $PSBoundParameters ; 
        #region PREF_VARI_DUMP ; #*------v PREF_VARI_DUMP v------
        <#$script:prefVaris = @{
            whatifIsPresent = $whatif.IsPresent
            whatifPSBoundParametersContains = $rPSBoundParameters.ContainsKey('WhatIf') ; 
            whatifPSBoundParameters = $rPSBoundParameters['WhatIf'] ;
            WhatIfPreferenceIsPresent = $WhatIfPreference.IsPresent ; # -eq $true
            WhatIfPreferenceValue = $WhatIfPreference;
            WhatIfPreferenceParentScopeValue = (Get-Variable WhatIfPreference -Scope 1).Value ;
            ConfirmPSBoundParametersContains = $rPSBoundParameters.ContainsKey('Confirm') ; 
            ConfirmPSBoundParameters = $rPSBoundParameters['Confirm'];
            ConfirmPreferenceIsPresent = $ConfirmPreference.IsPresent ; # -eq $true
            ConfirmPreferenceValue = $ConfirmPreference ;
            ConfirmPreferenceParentScopeValue = (Get-Variable ConfirmPreference -Scope 1).Value ; 
            VerbosePSBoundParametersContains = $rPSBoundParameters.ContainsKey('Confirm') ; 
            VerbosePSBoundParameters = $rPSBoundParameters['Verbose'] ;
            VerbosePreferenceIsPresent = $VerbosePreference.IsPresent ; # -eq $true
            VerbosePreferenceValue = $VerbosePreference ;
            VerbosePreferenceParentScopeValue = (Get-Variable VerbosePreference -Scope 1).Value;
            VerboseMyInvContains = '-Verbose' -in $rPSBoundParameters.UnboundArguments ; 
            VerbosePSBoundParametersUnboundArgumentContains = '-Verbose' -in $rPSBoundParameters.UnboundArguments 
        } ;
        write-verbose "`n$(($script:prefVaris.GetEnumerator() | Sort-Object Key | Format-Table Key,Value -AutoSize|out-string).trim())`n" ; 
        #>
        #endregion PREF_VARI_DUMP ; #*------^ END PREF_VARI_DUMP ^------
        #region RV_ENVIRO ; #*------v RV_ENVIRO v------
        $pltRvEnv=[ordered]@{
            PSCmdletproxy = $rPSCmdlet ; 
            PSScriptRootproxy = $rPSScriptRoot ; 
            PSCommandPathproxy = $rPSCommandPath ; 
            MyInvocationproxy = $rMyInvocation ;
            PSBoundParametersproxy = $rPSBoundParameters
            verbose = [boolean]($PSBoundParameters['Verbose'] -eq $true) ; 
        } ;
        write-verbose "(Purge no value keys from splat)" ; 
        $mts = $pltRVEnv.GetEnumerator() |?{$_.value -eq $null} ; $mts |%{$pltRVEnv.remove($_.Name)} ; rv mts -ea 0 -whatif:$false -confirm:$false; 
        $smsg = "resolve-EnvironmentTDO w`n$(($pltRVEnv|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        if(get-command resolve-EnvironmentTDO -ea STOP){}ELSE{
            $smsg = "UNABLE TO gcm resolve-EnvironmentTDO!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            BREAK ; 
        } ; 
        $rvEnv = resolve-EnvironmentTDO @pltRVEnv ; 
        $smsg = "`$rvEnv returned:`n$(($rvEnv |out-string).trim())" ; 
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        #endregion RV_ENVIRO ; #*------^ END RV_ENVIRO ^------
        #region NETWORK_INFO ; #*======v NETWORK_INFO v======
        if(get-command resolve-NetworkLocalTDO  -ea STOP){}ELSE{
            $smsg = "UNABLE TO gcm resolve-NetworkLocalTDO !" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            BREAK ; 
        } ; 
        $netsettings = resolve-NetworkLocalTDO ; 
        if($env:Userdomain){ 
            switch($env:Userdomain){
                'CMW'{
                    #$logon_SID = $CMW_logon_SID 
                }
                'TORO'{
                    #$o365_SIDUpn = $o365_Toroco_SIDUpn ; 
                    #$logon_SID = $TOR_logon_SID ; 
                }
                $env:COMPUTERNAME{
                    $smsg = "%USERDOMAIN% -EQ %COMPUTERNAME%: $($env:computername) => non-domain-connected, likely edge role Ex server!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    if($netsettings.Workgroup){
                        $smsg = "WorkgroupName:$($netsettings.Workgroup)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;                    
                    } ; 
                } ; 
                default{
                    $smsg = "$($env:userdomain):UNRECOGIZED/UNCONFIGURED USER DOMAIN STRING!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    THROW $SMSG 
                    BREAK ; 
                }
            } ; 
        } ;  # $env:Userdomain-E
        #endregion NETWORK_INFO ; #*======^ END NETWORK_INFO ^======
        #region OS_INFO ; #*------v OS_INFO v------
        <# os detect, covers Server 2016, 2008 R2, Windows 10, 11
        if (get-command get-ciminstance -ea 0) {$OS = (Get-ciminstance -class Win32_OperatingSystem)} else {$Os = Get-WMIObject -class Win32_OperatingSystem } ;
        #$isWorkstationOS = $isServerOS = $isW2010 = $isW2011 = $isS2016 = $isS2008R2 = $false ;
        write-host "Detected:`$Os.Name:$($OS.name)`n`$Os.Version:$($Os.Version)" ;
        if ($OS.name -match 'Microsoft\sWindows\sServer') {
            $isServerOS = $true ;
            if ($os.name -match 'Microsoft\sWindows\sServer\s2016'){$isS2016 = $true ;} ;
            if ($os.name -match 'Microsoft\sWindows\sServer\s2008\sR2') { $isS2008R2 = $true ; } ;
        } else { 
            if ($os.name -match '^Microsoft\sWindows\s11') {
                $isWorkstationOS = $true ;
                if ($os.name -match 'Microsoft\sWindows\s11') { $isW2011 = $true ; } ;
            } elseif ($os.name -match '^Microsoft\sWindows\s10') {
                $isWorkstationOS = $true ; $isW2010 = $true
            } else {
                $isWorkstationOS = $true ;
            } ;         
        } ; 
        #>
        #endregion OS_INFO ; #*------^ END OS_INFO ^------
        #region TEST_EXOPLOCAL ; #*------v TEST_EXOPLOCAL v------
        if(get-command test-LocalExchangeInfoTDO -ea STOP){}ELSE{
            $smsg = "UNABLE TO gcm test-LocalExchangeInfoTDO !" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            BREAK ; 
        } ; 
        $lclExOP = test-LocalExchangeInfoTDO ; 
        write-verbose "Expand returned NoteProperty properties into matching local variables" ; 
        if($host.version.major -gt 2){
            $lclExOP.PsObject.Properties | ?{$_.membertype -eq 'NoteProperty'} | foreach-object{set-variable -name $_.name -value $_.value -verbose -whatif:$false -Confirm:$false ;} ;
        }else{
            write-verbose "Psv2 lacks the above expansion capability; just create simpler variable set" ; 
            $ExVers = $lclExOP.ExVers ; $isLocalExchangeServer = $lclExOP.isLocalExchangeServer ; $IsEdgeTransport = $lclExOP.IsEdgeTransport ;
        } ;
        #
        #endregion TEST_EXOPLOCAL ; #*------^ END TEST_EXOPLOCAL ^------

        <#
        #region PsParams ; #*------v PSPARAMS v------
        $PSParameters = New-Object -TypeName PSObject -Property $rPSBoundParameters ;
        # DIFFERENCES $PSParameters vs $PSBoundParameters:
        # - $PSBoundParameters: System.Management.Automation.PSBoundParametersDictionary (native obj)
        # test/access: ($PSBoundParameters['Verbose'] -eq $true) ; $PSBoundParameters.ContainsKey('Referrer') #hash syntax
        # CAN use as a @PSBoundParameters splat to push through (make sure populated, can fail if wrong type of wrapping code)
        # - $PSParameters: System.Management.Automation.PSCustomObject (created obj)
        # test/access: ($PSParameters.verbose -eq $true) ; $PSParameters.psobject.Properties.name -contains 'SenderAddress' ; # cobj syntax
        # CANNOT use as a @splat to push through (it's a cobj)
        write-verbose "`$rPSBoundParameters:`n$(($rPSBoundParameters|out-string).trim())" ;
        # pre psv2, no $rPSBoundParameters autovari to check, so back them out:
        #>
        <# recycling $rPSBoundParameters into @splat calls: (can't use $psParams, it's a cobj, not a hash!)
        # rgx for filtering $rPSBoundParameters for params to pass on in recursive calls (excludes keys matching below)
        $rgxBoundParamsExcl = '^(Name|RawOutput|Server|Referrer)$' ; 
        if($rPSBoundParameters){
                $pltRvSPFRec = [ordered]@{} ;
                # add the specific Name for this call, and Server spec (which defaults, is generally not 
                $pltRvSPFRec.add('Name',"$RedirectRecord" ) ;
                $pltRvSPFRec.add('Referrer',$Name) ; 
                $pltRvSPFRec.add('Server',$Server ) ;
                $rPSBoundParameters.GetEnumerator() | ?{ $_.key -notmatch $rgxBoundParamsExcl} | foreach-object { $pltRvSPFRec.add($_.key,$_.value)  } ;
                write-host "Resolve-SPFRecord w`n$(($pltRvSPFRec|out-string).trim())" ;
                Resolve-SPFRecord @pltRvSPFRec  | write-output ;
        } else {
            $smsg = "unpopulated `$rPSBoundParameters!" ;
            write-warning $smsg ;
            throw $smsg ;
        };     
        #>
        #endregion PsParams ; #*------^ END PSPARAMS ^------    
        #endregion ENVIRO_DISCOVER ; #*------^ END ENVIRO_DISCOVER ^------

        #region COMMON_CONSTANTS ; #*------v COMMON_CONSTANTS v------
    
        if(-not $DoRetries){$DoRetries = 4 } ;    # # times to repeat retry attempts
        if(-not $RetrySleep){$RetrySleep = 10 } ; # wait time between retries
        if(-not $RetrySleep){$DawdleWait = 30 } ; # wait time (secs) between dawdle checks
        if(-not $DirSyncInterval){$DirSyncInterval = 30 } ; # AADConnect dirsync interval
        if(-not $ThrottleMs){$ThrottleMs = 50 ;}
        if(-not $rgxDriveBanChars){$rgxDriveBanChars = '[;~/\\\.:]' ; } ; # ;~/\.:,
        if(-not $rgxCertThumbprint){$rgxCertThumbprint = '[0-9a-fA-F]{40}' } ; # if it's a 40char hex string -> cert thumbprint  
        if(-not $rgxSmtpAddr){$rgxSmtpAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ; } ; # email addr/UPN
        if(-not $rgxDomainLogon){$rgxDomainLogon = '^[a-zA-Z][a-zA-Z0-9\-\.]{0,61}[a-zA-Z]\\\w[\w\.\- ]+$' } ; # DOMAIN\samaccountname 
        if(-not $exoMbxGraceDays){$exoMbxGraceDays = 30} ; 
        if(-not $XOConnectionUri ){$XOConnectionUri = 'https://outlook.office365.com'} ; 
        if(-not $SCConnectionUri){$SCConnectionUri = 'https://ps.compliance.protection.outlook.com'} ; 
        if(-not $XODefaultPrefix){$XODefaultPrefix = 'xo' };
        if(-not $SCDefaultPrefix){$SCDefaultPrefix = 'sc' };
        #$rgxADDistNameGAT = ",$(($TORMeta.UnreplicatedOU -split ',' | select -skip 1 ) -join ',')" 
        #$rgxADDistNameAT = ",$(($TORMeta.UnreplicatedOU -split ',' | select -skip 2 ) -join ',')"

        write-verbose "Coerce configured but blank Resultsize to Unlimited" ; 
        if(get-variable -name resultsize -ea 0){
            if( ($null -eq $ResultSize) -OR ('' -eq $ResultSize) ){$ResultSize = 'unlimited' }
            elseif($Resultsize -is [int]){} else {throw "Resultsize must be an integer or the string 'unlimited' (or blank)"} ;
        } ; 
        #$ComputerName = $env:COMPUTERNAME ;
        #$NoProf = [bool]([Environment]::GetCommandLineArgs() -like '-noprofile'); # if($NoProf){# do this};
        # XXXMeta derived constants:
        # - AADU Licensing group checks
        # calc the rgxLicGrpName fr the existing $xxxmeta.rgxLicGrpDN: (get-variable tormeta).value.rgxLicGrpDN.split(',')[0].replace('^','').replace('CN=','')
        #$rgxLicGrpName = (get-variable -name "$($tenorg)meta").value.rgxLicGrpDN.split(',')[0].replace('^','').replace('CN=','')
        # use the dn vers LicGrouppDN = $null ; # | ?{$_ -match $tormeta.rgxLicGrpDN}
        #$rgxLicGrpDN = (get-variable -name "$($tenorg)meta").value.rgxLicGrpDN
        # email trigger vari, it will be semi-delimd list of mail-triggering events
        $script:PassStatus = $null ;
        # TenOrg or other looped-specific PassStatus (auto supported by 7pswlt)
        #New-Variable -Name PassStatus_$($tenorg) -scope Script -Value $null ;
        [array]$SmtpAttachment = $null ;
        #write-verbose "start-Timer:Master" ; 
        $swM = [Diagnostics.Stopwatch]::StartNew() ;
        # $ByPassLocalExchangeServerTest = $true # rough in, code exists below for exempting service/regkey testing on this variable status. Not yet implemented beyond the exemption code, ported in from orig source.
        #endregion COMMON_CONSTANTS ; #*------^ END COMMON_CONSTANTS ^------
              
        #region LOCAL_CONSTANTS ; #*------v LOCAL_CONSTANTS v------

        # BELOW TRIGGERS/DRIVES TEST_MODS: array of: "[modname];[modDLUrl,or pscmdline install]"    
        $tDepModules = @() ;
        $useVerbCore = $true ; 
        if($useVerbCore){
            $tDepModules += @('verb-logging;localRepo;write-log') ; #start-log; write-log ;
            $tDepModules += @('verb-io;localRepo;resolve-EnvironmentTDO') ; #resolve-EnvironmentTDO
            $tDepModules += @('verb-Network;localRepo;resolve-NetworkLocalTDO') ; #resolve-NetworkLocalTDO; Send-EmailNotif
        } ;
        <# NOTE: Svc modules are tested as needed by connect-O365Servicees() & connect-OPServices()
        if($useEXO){$tDepModules += @("ExchangeOnlineManagement;https://www.powershellgallery.com/packages/ExchangeOnlineManagement/;Get-xoOrganizationConfig",'verb-exo;localRepo;connect-exo')} ;
        if($UseMSOL){$tDepModules += @("MSOnline;https://www.powershellgallery.com/packages/MSOnline/;Get-MsolDomain")} ;
        if($UseAAD){$tDepModules += @("AzureAD;https://www.powershellgallery.com/packages/AzureAD/;Get-AzureADTenantDetail")} ;
        if($UseExOP){$tDepModules += @('verb-Ex2010;localRepo;Connect-Ex2010')} ;
        if($UseMG){$tDepModules += @("Microsoft.Graph.Authentication;https://www.powershellgallery.com/packages/Microsoft.Graph/;Get-MgOrganization")} ;
        if($UseOPAD){$tDepModules += @("ActiveDirectory;get-windowscapability -name RSAT* -Online | ?{$_.name -match 'Rsat\.ActiveDirectory'} | %{Add-WindowsCapability -online -name $_.name};Get-ADDomain")} ;
        #>

        #$prpGXMTfta = 'ReceivedLocal','Status','SenderAddress','RecipientAddress','Subject','MessageId' ;
        #$prpGXQMfta = 'ReceivedTime','Type','Direction','SenderAddress','RecipientAddress','Subject','MessageId','Size','ReleaseStatus','Expires','ReleasedBy' ;
        [regex]$rgxHdrSenderIDKeys = ('(?i:' + (('spf','dkim','dmarc','d=','smtp.mailfrom','smtp.rcpttodomain','header.from=','helo','Return-Path:','From:','Subject:','Sender:','Submitter:','Reply-To:','To:','Message-ID:','client-ip','X-Mailer:','X-Received:','Received: from','ARC-Authentication-Results:','arc=','oda=','compauth=','reason=' |%{[regex]::escape($_)}) -join '|') + ')') ;
        [regex]$rgxReturnPath = "Return-Path:((\n|\r|\s)*)([0-9a-zA-Z]+[-._+&='])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}" ;

        $propsMT = 'Received',@{N='ReceivedLocal';E={[datetime]$_.Received.ToLocalTime()}},'SenderAddress','RecipientAddress','Subject','Status','ToIP','FromIP','Size','MessageId','MessageTraceId','Index' ;
        # setup a refactor of Receivedlocal on Received, but return *all* properties
        $propsMTAll = 'RunspaceId','Organization','MessageId','Received', @{N='ReceivedLocal';E={[datetime]$_.Received.ToLocalTime()}},'SenderAddress','RecipientAddress','Subject','Status','ToIP','FromIP','Size','MessageTraceId','StartDate','EndDate','Index'
        #$propsMTD = 'Date','Event','Action','Detail','Data' ;
        # add a locatltime variant
        $propsMTD = @{N='DateLocal';E={$_.Date.ToLocalTime()}},'Date','Event','Action','Detail','Data' ;

        $propsMsgDump = @{N='ReceivedLocal';E={$_.Received.ToLocalTime()}},'Status','SenderAddress','RecipientAddress','Subject' ;
        $DaysLimit = 10 # reflect the current MS get-messagetrace window limit
        #$sFulltimeStamp = 'MM/dd/yyyy-HH:mm:ss.fff' ;
        #$sFiletimestamp = 'yyyyMMdd-HHmm' ;
        $s24HTimestamp = 'yyyyMMdd-HHmm'
        $sFiletimestamp =  $s24HTimestamp

        # block identifying filters
        $rgxFailOOOSubj = '^Automatic\sreply:\s' ; 
        $rgxFailRecallSubj = '^Recall:\s' ; 
        $rgxFailOtherAcctBlock = 'OtherAccts-External-Mail-Rejection' ; 
        $FailOtherAcctBlockExemptionGroup = 'LYN-DL-OPExch-OtherAcctMbxs-ExternalMailOK@toro.com' ; 
        $rgxFailConfRmExtBlock = 'ConfRm-External-Mail-Rejection' ; 
        $rgxFailSecBlock = '^Security(\s-\s|-)' ; 

        #endregion LOCAL_CONSTANTS ; #*------^ END LOCAL_CONSTANTS ^------  
          
        #region ENCODED_CONTANTS ; #*------v ENCODED_CONTANTS v------
        # ENCODED CONsTANTS & SUPPORT FUNCTIONS:
        #region 2B4 ; #*------v 2B4 v------
        if(-not (get-command 2b4 -ea 0)){function 2b4{[CmdletBinding()][Alias('convertTo-Base64String')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ; PROCESS{$str|%{[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_))}  };} ; } ; 
        #endregion 2B4 ; #*------^ END 2B4 ^------
        #region 2B4C ; #*------v 2B4C v------
        # comma-quoted return
        if(-not (get-command 2b4c -ea 0)){function 2b4c{ [CmdletBinding()][Alias('convertto-Base64StringCommaQuoted')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ;BEGIN{$outs = @()} PROCESS{[array]$outs += $str | %{[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_))} ; } END {'"' + $(($outs) -join '","') + '"' | out-string | set-clipboard } ; } ; } ; 
        #endregion 2B4C ; #*------^ END 2B4C ^------
        #region FB4 ; #*------v FB4 v------
        # DEMO: $SitesNameList = 'THluZGFsZQ==','U3BlbGxicm9vaw==','QWRlbGFpZGU=' | fb4 ;
        if(-not (get-command fb4 -ea 0)){function fb4{[CmdletBinding()][Alias('convertFrom-Base64String')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ; PROCESS{$str | %{ [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($_)) }; } ; } ; }; 
        #endregion FB4 ; #*------^ END FB4 ^------
        # FOLLOWING CONSTANTS ARE USED FOR DEPENDANCY-LESS CONNECTIONS
        if(-not $o365_Toroco_SIDUpn){$o365_Toroco_SIDUpn = 'cy10b2RkLmthZHJpZUB0b3JvLmNvbQ==' | fb4 } ;
        $o365_SIDUpn = $o365_Toroco_SIDUpn ; 
        switch($env:Userdomain){
            'CMW'{
                if(-not $CMW_logon_SID){$CMW_logon_SID = 'Q01XXGQtdG9kZC5rYWRyaWU=' | fb4 } ; 
                $logon_SID = $CMW_logon_SID ; 
            }
            'TORO'{
                if(-not $TOR_logon_SID){$TOR_logon_SID = 'VE9ST1xrYWRyaXRzcw==' | fb4 } ; 
                $logon_SID = $TOR_logon_SID ; 
            }
            $env:COMPUTERNAME{
                $smsg = "%USERDOMAIN% -EQ %COMPUTERNAME%: $($env:computername) => non-domain-connected, likely edge role Ex server!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                if($WorkgroupName = (Get-WmiObject -Class Win32_ComputerSystem).Workgroup){
                    $smsg = "WorkgroupName:$($WorkgroupName)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                }
                if(($isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup')) -or (
                        $isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\Setup')) -or
                            $ByPassLocalExchangeServerTest){
                            $smsg = "We are on Exchange Server"
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            $IsEdgeTransport = $false
                            if((Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\EdgeTransportRole') -or (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\EdgeTransportRole')){
                                $smsg = "We are on Exchange Edge Transport Server"
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                $IsEdgeTransport = $true
                            } ; 
                } else {
                    $isLocalExchangeServer = $false 
                    $IsEdgeTransport = $false ;
                } ;
            } ; 
            default{
                $smsg = "$($env:userdomain):UNRECOGIZED/UNCONFIGURED USER DOMAIN STRING!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                THROW $SMSG 
                BREAK ; 
            }
        } ; 
        #endregion ENCODED_CONTANTS ; #*------^ END ENCODED_CONTANTS ^------
    
        #endregion CONSTANTS_AND_ENVIRO ; #*======^ CONSTANTS_AND_ENVIRO ^======
        
        # moved FUNCTIONS block up top of BEGIN
        #if($ticket){$pltSL.Tag = $ticket} ; 
        #region START_LOG_OPTIONS #*======v START_LOG_OPTIONS v======
        $useSLogHOl = $true ; # one or 
        $useTransPath = $false ; # TRANSCRIPTPATH
        $useTransRotate = $false ; # TRANSCRIPTPATHROTATE
        $useStartTrans = $false ; # STARTTRANS
        $useTransNoDep = $false ; # TRANSCRIPT_NODEP
        $useTransBasicScript = $false ; # BASIC_SCRIPT_TRANSCRIPT
        #region START_LOG_HOLISTIC #*------v START_LOG_HOLISTIC v------
        if($useSLogHOl){
            # Single log for script/function example that accomodates detect/redirect from AllUsers scope'd installed code, and hunts a series of drive letters to find an alternate logging dir (defers to profile variables)
            #${CmdletName} = $rPSCmdlet.MyInvocation.MyCommand.Name ;
            if(-not (get-variable LogPathDrives -ea 0)){$LogPathDrives = 'd','c' };
            foreach($budrv in $LogPathDrives){if(test-path -path "$($budrv):\scripts" -ea 0 ){break} } ;
            if(-not (get-variable rgxPSAllUsersScope -ea 0)){$rgxPSAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps(((d|m))*)1|dll)$" ;} ;
            if(-not (get-variable rgxPSCurrUserScope -ea 0)){$rgxPSCurrUserScope="^$([regex]::escape([Environment]::GetFolderPath('MyDocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps((d|m)*)1|dll)$" ;} ;
            $pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ;} ;
            if($whatif.ispresent){$pltSL.add('whatif',$($whatif))}
            elseif($WhatIfPreference.ispresent ){$pltSL.add('whatif',$WhatIfPreferenc)} ;         
            # if using [CmdletBinding(SupportsShouldProcess)] + -WhatIf:$($WhatIfPreference):
            #$pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($WhatIfPreference) ;} ;
            #$pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag="$($ticket)-$($TenOrg)-LASTPASS-" ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($WhatIfPreference) ;} ;
            #$pltSL.Tag = $((@($ticket,$usr) |?{$_}) -join '-')
            if($ticket){$pltSL.Tag = $ticket} ; ####
            #$pltSL.Tag = $env:COMPUTERNAME ; 
            #$pltSL.Tag = $((@($ticket,$usr) |?{$_}) -join '-')
            $tagfields = 'ticket','UserPrincipalName','folderscope' ; # DomainName TenOrg ModuleName 
            $tagfields | foreach-object{$fld = $_ ; if(get-variable $fld -ea 0 |?{$_.value} ){$pltSL.Tag += @($((get-variable $fld).value))} } ; 
            if($pltSL.Tag -is [array]){$pltSL.Tag = $pltSL.Tag -join '-' } ; 
            #$transcript = ".\logs\$($Ticket)-$($DomainName)-$(split-path $rMyInvocation.InvocationName -leaf)-$(get-date -format 'yyyyMMdd-HHmmtt')-trans-log.txt" ; 
            #$pltSL.Tag += "-$($DomainName)"
            #
            if($rPSBoundParameters.keys){ # alt: leverage $rPSBoundParameters hash
                $sTag = @() ; 
                #$pltSL.TAG = $((@($rPSBoundParameters.keys) |?{$_}) -join ','); # join all params
                if($rPSBoundParameters['Summary']){ $sTag+= @('Summary') } ; # build elements conditionally, string
                if($rPSBoundParameters['Number']){ $sTag+= @("Number$($rPSBoundParameters['Number'])") } ; # and keyname,value
                $pltSL.Tag += "-$($sTag -join ',')" ; # 4:46 PM 7/16/2025 flipped to append, not assign
            } ; 
            #
            if($rvEnv.isScript){
                write-host "`$script:PSCommandPath:$($script:PSCommandPath)" ;
                write-host "`$PSCommandPath:$($PSCommandPath)" ;
                if($rvEnv.PSCommandPathproxy){ $prxPath = $rvEnv.PSCommandPathproxy }
                elseif($script:PSCommandPath){$prxPath = $script:PSCommandPath}
                elseif($rPSCommandPath){$prxPath = $rPSCommandPath} ; 
            } ; 
            if($rvEnv.isFunc){
                if($rvEnv.FuncDir -AND $rvEnv.FuncName){
                       $prxPath = join-path -path $rvEnv.FuncDir -ChildPath $rvEnv.FuncName ; 
                } else {
                    write-warning "Missing either `$rvEnv.FuncDir -OR `$rvEnv.FuncName!" ; 
                } ; 
            } ; 
            if(-not $rvEnv.isFunc){
                # under funcs, this is the scriptblock of the func, not a path
                if($rvEnv.MyInvocationproxy.MyCommand.Definition){$prxPath2 = $rvEnv.MyInvocationproxy.MyCommand.Definition }
                elseif($rvEnv.MyInvocationproxy.MyCommand.Definition){$prxPath2 = $rvEnv.MyInvocationproxy.MyCommand.Definition } ; 
            } ; 
            if($prxPath){
                # 12/12/2025 new code to patch no-ext $prxPath
                if(-not [System.IO.Path]::GetExtension($prxPath)){
                    write-verbose "no-extension `$prxpath, asserting fake ext (.ps1|.psm1 as approp)" ;                         
                    switch($rvEnv.runSource){
                        'Function'{$prxPath = "$($prxPath).psm1" }
                        'ExternalScript'{$prxPath = "$($prxPath).ps1" }
                        default {
                            $smsg = "NO RECOGNIZED `$rvEnv.runSource: '$($rvEnv.runSource)'`nUNABLE TO SAFELY TEST FOR AllUsers or CU SCOPE!: ABORTING (Could log into module hosting dir!)" ; 
                            write-warning $smsg ; throw $smsg ; 
                            BREAK ; 
                        }
                    } ; 
                } ; 
                if(($prxPath -match $rgxPSAllUsersScope) -OR ($prxPath -match $rgxPSCurrUserScope)){
                    $bDivertLog = $true ; 
                    switch -regex ($prxPath){
                        $rgxPSAllUsersScope{$smsg = "AllUsers"} 
                        $rgxPSCurrUserScope{$smsg = "CurrentUser"}
                    } ;
                    $smsg += " context script/module, divert logging into [$budrv]:\scripts" 
                    write-verbose $smsg  ;
                    if($bDivertLog){
                        if((split-path $prxPath -leaf) -ne $rvEnv.CmdletName){
                            # function in a module/script installed to allusers|cu - defer name to Cmdlet/Function name
                            $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($rvEnv.CmdletName).ps1") ;
                        } else {
                            # installed allusers|CU script, use the hosting script name
                            $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $prxPath -leaf)) ;
                        }
                    } ;
                } else {
                    $pltSL.Path = $prxPath ;
                } ;
            }elseif($prxPath2){
                # 12/12/2025 new code to patch no-ext $prxPath2
                if(-not [System.IO.Path]::GetExtension($prxPath2)){
                    write-verbose "no-extension `$prxPath2, asserting fake ext (.ps1|.psm1 as approp)" ;                         
                    switch($rvEnv.runSource){
                        'Function'{$prxPath2 = "$($prxPath2).psm1" }
                        'ExternalScript'{$prxPath2 = "$($prxPath2).ps1" }
                        default {
                            $smsg = "NO RECOGNIZED `$rvEnv.runSource: '$($rvEnv.runSource)'`nUNABLE TO SAFELY TEST FOR AllUsers or CU SCOPE!: ABORTING (Could log into module hosting dir!)" ; 
                            write-warning $smsg ; throw $smsg ; 
                            BREAK ; 
                        }
                    } ; 
                } ; 
                if(($prxPath2 -match $rgxPSAllUsersScope) -OR ($prxPath2 -match $rgxPSCurrUserScope) ){
                        $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $prxPath2 -leaf)) ;
                } elseif(test-path $prxPath2) {
                    $pltSL.Path = $prxPath2 ;
                } elseif($rvEnv.CmdletName){
                    $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($rvEnv.CmdletName).ps1") ;
                } else {
                    $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$rvEnv.CmdletName, FROM WHICH TO BUILD A START-LOG.PATH!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    BREAK ;
                } ; 
            } else{
                $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$rvEnv.CmdletName, FROM WHICH TO BUILD A START-LOG.PATH!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                BREAK ;
            }  ;
            write-verbose "start-Log w`n$(($pltSL|out-string).trim())" ; 
            $logspec = start-Log @pltSL ;
            $error.clear() ;
            TRY {
                if($logspec){
                    $logging=$logspec.logging ;
                    $logfile=$logspec.logfile ;
                    $transcript=$logspec.transcript ;
                    $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                    if($stopResults){
                        $smsg = "Stop-transcript:$($stopResults)" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    } ; 
                    $startResults = start-Transcript -path $transcript -whatif:$false -confirm:$false;
                    if($startResults){
                        $smsg = "start-transcript:$($startResults)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ; 
                } else {throw "Unable to configure logging!" } ;
            } CATCH [System.Management.Automation.PSNotSupportedException]{
                if($host.name -eq 'Windows PowerShell ISE Host'){
                    $smsg = "This version of $($host.name):$($host.version) does *not* support native (start-)transcription" ; 
                } else { 
                    $smsg = "This host does *not* support native (start-)transcription" ; 
                } ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                #region SendMailAlert ; #*------v SendMailAlert v------
                $SmtpBody += "`n===FAIL Summary:" ;
                $SmtpBody += "`n$('-'*50)" ;
                $SmtpBody += "`n$('-'*50)" ;
                $smsg += "`n$(($smsg |out-string).trim())" ; 
                $sdEmail = @{
                    smtpFrom = $SMTPFrom ;
                    SMTPTo = $SMTPTo ;
                    SMTPSubj = $SMTPSubj ;
                    #SMTPServer = $SMTPServer ;
                    SmtpBody = $SmtpBody ;
                    SmtpAttachment = $SmtpAttachment ;
                    BodyAsHtml = $false ; # let the htmltag rgx in Send-EmailNotif flip on as needed
                    verbose = $($VerbosePreference -eq "Continue") ;
                } ;
                $smsg = "Send-EmailNotif w`n$(($sdEmail|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Send-EmailNotif @sdEmail ;

                #endregion SendMailAlert ; #*------^ END SendMailAlert ^------
            } ;
        } ; 
        #endregion START_LOG_HOLISTIC #*------^ END START_LOG_HOLISTIC ^------
        # ...
        #endregion START_LOG_OPTIONS #*======^ START_LOG_OPTIONS ^======

        #region NETWORK_INFO ; #*======v NETWORK_INFO v======
        $netsettings = resolve-NetworkLocalTDO ; 
        #endregion NETWORK_INFO ; #*======^ END NETWORK_INFO ^======
    
        <#
        $useO365 = $true ;
        $useEXO = $true ; 
        $UseOP=$true ; 
        $UseExOP=$true ;
        $useExopNoDep = $true ; # switch to use Connect-ExchangeServerTDO, vs connect-ex2010 (creds are assumed inherent to the account)
        $ExopVers = 'Ex2010' # 'Ex2019','Ex2016','Ex2013','Ex2010','Ex2007','Ex2003','Ex2000', Null for All versions
        if($Version){
            $ExopVers = $Version ; #defer to local script $version if set
        } ; 
        $useForestWide = $true ; # flag to trigger cross-domain/forest-wide code in AD & EXoP
        $UseOPAD = $false ; 
        $UseMSOL = $false ; # should be hard disabled now in o365
        $UseAAD = $true ; 
        #>

        #region SERVICE_CONNECTIONS #*======v END SERVICE_CONNECTIONS v======
    
        #region BROAD_SVC_CONTROL_VARIS ; #*======v BROAD_SVC_CONTROL_VARIS  v======   
        $useO365 = $true ; 
        $useOP = $true ;     
        # (config individual svcs in each block)
        #endregion BROAD_SVC_CONTROL_VARIS ; #*======^ END BROAD_SVC_CONTROL_VARIS ^======

        #region CALL_CONNECT_O365SERVICES ; #*======v CALL_CONNECT_O365SERVICES v======
        #$useO365 = $true ; 
        if($useO365){
            $pltCco365Svcs=[ordered]@{
                # environment parameters:
                EnvSummary = $rvEnv ; 
                NetSummary = $netsettings ; 
                # service choices
                useEXO = $true ;
                useSC = $false ; 
                UseMSOL = $false ;
                UseAAD = $false ; # M$ is actively blocking all AAD access now: Message: Access blocked to AAD Graph API for this application. https://aka.ms/AzureADGraphMigration.
                UseMG = $true ;
                # Service Connection parameters
                TenOrg = $TenOrg ; # $global:o365_TenOrgDefault ; 
                Credential = $Credential ;
                AdminAccount = $AdminAccount ; 
                #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
                UserRole = $UserRole ; # @('SID','CSVC') ;
                # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
                silent = $silent ;
                MGPermissionsScope = $MGPermissionsScope ;
                MGCmdlets = $MGCmdlets ;
            } ;
            write-verbose "(Purge no value keys from splat)" ; 
            $mts = $pltCco365Svcs.GetEnumerator() |?{$_.value -eq $null} ; $mts |%{$pltCco365Svcs.remove($_.Name)} ; rv mts -ea 0 ; 
            if((get-command connect-O365Services -EA STOP).parameters.ContainsKey('whatif')){
                $pltCco365SvcsnDSR.add('whatif',$($whatif))
            } ; 
            $smsg = "connect-O365Services w`n$(($pltCco365Svcs|out-string).trim())" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # add rertry on fail, up to $DoRetries
            $Exit = 0 ; # zero out $exit each new cmd try/retried
            # do loop until up to 4 retries...
            Do {
                $smsg = "connect-O365Services w`n$(($pltCco365Svcs|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $ret_ccSO365 = connect-O365Services @pltCco365Svcs ; 
                #region CONFIRM_CCEXORETURN ; #*------v CONFIRM_CCEXORETURN v------
                # matches each: $plt.useXXX:$true to matching returned $ret.hasXXX:$true 
                $vplt = $pltCco365Svcs ; $vret = 'ret_ccSO365' ; $ACtionCommand = 'connect-O365Services' ; $vtests = @() ; $vFailMsgs = @()  ; 
                $vplt.GetEnumerator() |?{$_.key -match '^use' -ANd $_.value -match $true} | foreach-object{
                    $pltkey = $_ ;
                    $smsg = "$(($pltkey | ft -HideTableHeaders name,value|out-string).trim())" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    $tprop = $pltkey.name -replace '^use','has';
                    if($rProp = (gv $vret).Value.psobject.properties | ?{$_.name -match $tprop}){
                        $smsg = "$(($rprop | ft -HideTableHeaders name,value |out-string).trim())" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        if($rprop.Value -eq $pltkey.value){
                            $vtests += $true ; 
                            $smsg = "Validated: $($pltKey.name):$($pltKey.value) => $($rprop.name):$($rprop.value)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        } else {
                            $smsg = "NOT VALIDATED: $($pltKey.name):$($pltKey.value) => $($rprop.name):$($rprop.value)" ;
                            $vtests += $false ; 
                            $vFailMsgs += "`n$($smsg)" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        };
                    } else{
                        $smsg = "Unable to locate: $($pltKey.name):$($pltKey.value) to any matching $($rprop.name)!)" ;
                        $smsg = "" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    } ; 
                } ; 
                if($vtests -notcontains $false){
                    $smsg = "==> $($ACtionCommand): confirmed specified connections *all* successful " ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    $Exit = $DoRetries ;
                } else {
                    $smsg = "==> $($ACtionCommand): FAILED SOME SPECIFIED CONNECTIONS" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $smsg = "MISSING SOME KEY CONNECTIONS. DO YOU WANT TO IGNORE, AND CONTINUE WITH CONNECTED SERVICES?" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $Exit ++ ;
                    $smsg = "Try #: $Exit" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    if($Exit -eq $DoRetries){
                        $smsg = "Unable to exec cmd!"; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        #-=-=-=-=-=-=-=-=
                        $sdEmail.SMTPSubj = "FAIL Rpt:$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"
                        $sdEmail.SmtpBody = "`n===Processing Summary:" ;
                        if($vFailMsgs){
                            $sdEmail.SmtpBody += "`n$(($vFailMsgs|out-string).trim())" ; 
                        } ; 
                        $sdEmail.SmtpBody += "`n" ;
                        if($SmtpAttachment){
                            $sdEmail.SmtpAttachment = $SmtpAttachment
                            $sdEmail.smtpBody +="`n(Logs Attached)" ;
                        };
                        $sdEmail.SmtpBody += "Pass Completed $([System.DateTime]::Now)" ;
                        $smsg = "Send-EmailNotif w`n$(($sdEmail|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Send-EmailNotif @sdEmail ;
                        $bRet=Read-Host "Enter YYY to continue. Anything else will exit"  ;
                        if ($bRet.ToUpper() -eq "YYY") {
                            $smsg = "(Moving on), WITH THE FOLLOW PARTIAL CONNECTION STATUS" ;
                            $smsg += "`n`n$(($ret_CcOPSvcs|out-string).trim())" ; 
                            write-host -foregroundcolor green $smsg  ;
                        } else {
                            throw $smsg ; 
                            break ; #exit 1
                        } ;  
                    } ;        
                } ; 
                #endregion CONFIRM_CCEXORETURN ; #*------^ END CONFIRM_CCEXORETURN ^------
            } Until ($Exit -eq $DoRetries) ; 
        } ; #  useO365-E
        #endregion CALL_CONNECT_O365SERVICES ; #*======^ END CALL_CONNECT_O365SERVICES ^======
    
        #region TEST_EXO_CONN ; #*------v TEST_EXO_CONN v------
        # ALT: simplified verify EXO conn: ALT to full CONNECT_O365SERVICES block - USE ONE OR THE OTHER!
        $useEXO = $true ; 
        $useSC = $false ; 
        if(-not $XOConnectionUri ){$XOConnectionUri = 'https://outlook.office365.com'} ;
        if(-not $SCConnectionUri){$SCConnectionUri = 'https://ps.compliance.protection.outlook.com'} ;
        $EXOtestCmdlet = 'Get-xoOrganizationConfig' ; 
        if(gcm $EXOtestCmdlet -ea 0){
            $conns = Get-ConnectionInformation -ea STOP  ; 
            $hasEXO = $hasSC = $false ; 
            #if($conns | %{$_ | ?{$_.ConnectionUri -eq 'https://outlook.office365.com' -AND $_.State -eq 'Connected' -AND $_.TokenStatus -eq 'Active'}}){
            $conns | %{
                if($_ | ?{$_.ConnectionUri -eq $XOConnectionUri}){$hasEXO = $true } ; 
                if($_ | ?{$_.ConnectionUri -eq $SCConnectionUri}){$hasSC = $true } ; 
            }
            if($useEXO -AND $hasEXO){
                write-verbose "EXO ConnectionURI present" ; 
            }elseif(-not $useEXO){}else{
                $smsg = "No Active EXO connection: Run - Connect-ExchangeOnline -Prefix xo -  before running this script!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                BREAK ; 
            } ; 
            if($useSC -AND $hasSC){
                write-verbose "SCI ConnectionURI present" ; 
            }elseif(-not $useSC){}else{
                $smsg = "No Active SC connection: Run - Connect-IPPSSession -Prefix SC -  before running this script!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                BREAK ; 
            } ; 
        }else {
            $smsg = "Missing gcm get-xoMailboxFolderStatistics: ExchangeOnlineManagement module *not* loaded!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            BREAK ; 
        } ;     
        #endregion TEST_EXO_CONN ; #*------^ END TEST_EXO_CONN ^------
    
        #region CALL_CONNECT_OPSERVICES ; #*======v CALL_CONNECT_OPSERVICES v======
        #$useOP = $false ; 
        if($useOP){
            $pltCcOPSvcs=[ordered]@{
                # environment parameters:
                EnvSummary = $rvEnv ;
                NetSummary = $netsettings ;
                XoPSummary = $lclExOP ;
                # service choices
                UseExOP = $true ;
                useForestWide = $true ;
                useExopNoDep = $false ;
                ExopVers = 'Ex2010' ;
                UseOPAD = $true ;
                useExOPVers = $useExOPVers; # 'Ex2010' ;
                # Service Connection parameters
                TenOrg = $TenOrg ; # $global:o365_TenOrgDefault ;
                Credential = $Credential ;
                #[ValidateSet("SID","ESVC","LSVC")]
                #UserRole = $UserRole ; # @('SID','ESVC') ;
                # if inheriting same $userrole param/default, that was already used for cloud conn, filter out the op unsupported CBA roles
                # exclude csvc as well, go with filter on the supported ValidateSet from get-HybridOPCredentials: ESVC|LSVC|SID
                UserRole = $UserRole |?{$_ -match '(ESVC|LSVC|SID)' -AND $_ -notmatch 'CBA'} ; 
                # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
                silent = $silent ;
            } ;

            write-verbose "(Purge no value keys from splat)" ;
            $mts = $pltCcOPSvcs.GetEnumerator() |?{$_.value -eq $null} ; $mts |%{$pltCcOPSvcs.remove($_.Name)} ; rv mts -ea 0 ;
            if((get-command connect-OPServices -EA STOP).parameters.ContainsKey('whatif')){
                $pltCcOPSvcsnDSR.add('whatif',$($whatif))
            } ;
            $smsg = "connect-OPServices w`n$(($pltCcOPSvcs|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $ret_CcOPSvcs = connect-OPServices @pltCcOPSvcs ; 

            # #region CONFIRM_CCOPRETURN ; #*------v CONFIRM_CCOPRETURN v------
            # matches each: $plt.useXXX:$true to matching returned $ret.hasXXX:$true
            $vplt = $pltCcOPSvcs ; $vret = 'ret_CcOPSvcs' ;  ; $ACtionCommand = 'connect-OPServices' ; 
            $vplt.GetEnumerator() |?{$_.key -match '^use' -ANd $_.value -match $true} | foreach-object{
                $pltkey = $_ ;
                $smsg = "$(($pltkey | ft -HideTableHeaders name,value|out-string).trim())" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $vtests = @() ;  $vFailMsgs = @()  ; 
                $tprop = $pltkey.name -replace '^use','has';
                if($rProp = (gv $vret).Value.psobject.properties | ?{$_.name -match $tprop}){
                    $smsg = "$(($rprop | ft -HideTableHeaders name,value |out-string).trim())" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    if($rprop.Value -eq $pltkey.value){
                        $vtests += $true ; 
                        $smsg = "Validated: $($pltKey.name):$($pltKey.value) => $($rprop.name):$($rprop.value)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    } else {
                        $smsg = "NOT VALIDATED: $($pltKey.name):$($pltKey.value) => $($rprop.name):$($rprop.value)" ;
                        $vtests += $false ; 
                        $vFailMsgs += "`n$($smsg)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    };
                } else{
                    $smsg = "Unable to locate: $($pltKey.name):$($pltKey.value) to any matching $($rprop.name)!)" ;
                    $smsg = "" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                } ; 
            } ; 
            if($useOP -AND $vtests -notcontains $false){
                $smsg = "==> $($ACtionCommand): confirmed specified connections *all* successful " ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            }elseif($vtests -contains $false -AND (get-variable ret_CcOPSvcs) -AND (gv -name "$($tenorg)meta").value.o365_opdomain.split('.')[0].toupper() -ne $env:userdomain){
                $smsg = "==> $($ACtionCommand): FAILED SOME SPECIFIED CONNECTIONS" ; 
                $smsg += "`nCROSS-ORG ONPREM CONNECTION: ATTEMPTING TO CONNECT TO ONPREM '$((gv -name "$($tenorg)meta").value.o365_Prefix)' $((gv -name "$($tenorg)meta").value.o365_opdomain.split('.')[0].toupper()) domain, FROM $($env:userdomain)!" ;
                $smsg += "`nEXPECTED ERROR, SKIPPING ONPREM ACCESS STEPS (force `$useOP:$false)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $useOP = $false ; 
            }elseif(-not $useOP -AND -not (get-variable ret_CcOPSvcs)){
                $smsg = "-useOP: $($useOP), skipped connect-OPServices" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else {
                $smsg = "==> $($ACtionCommand): FAILED SOME SPECIFIED CONNECTIONS" ; 
                $smsg += "`n`$ret_CcOPSvcs:`n$(($ret_CcOPSvcs|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $sdEmail.SMTPSubj = "FAIL Rpt:$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"
                $sdEmail.SmtpBody = "`n===Processing Summary:" ;
                if($vFailMsgs){
                    $sdEmail.SmtpBody += "`n$(($vFailMsgs|out-string).trim())" ; 
                } ; 
                $sdEmail.SmtpBody += "`n" ;
                if($SmtpAttachment){
                    $sdEmail.SmtpAttachment = $SmtpAttachment
                    $sdEmail.smtpBody +="`n(Logs Attached)" ;
                };
                $sdEmail.SmtpBody += "Pass Completed $([System.DateTime]::Now)" ;
                $smsg = "Send-EmailNotif w`n$(($sdEmail|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Send-EmailNotif @sdEmail ;
                throw $smsg ; 
                BREAK ; 
            } ; 
            #endregion CONFIRM_CCOPRETURN ; #*------^ END CONFIRM_CCOPRETURN ^------
            
            #region CONFIRM_OPFORESTWIDE ; #*------v CONFIRM_OPFORESTWIDE v------    
            if($useOP -AND $pltCcOPSvcs.useForestWide -AND $ret_CcOPSvcs.hasForestWide -AND $ret_CcOPSvcs.AdGcFwide){
                $smsg = "==> $($ACtionCommand): confirmed has BOTH .hasForestWide & .AdGcFwide ($($ret_CcOPSvcs.AdGcFwide))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success        
            }elseif($pltCcOPSvcs.useForestWide -AND (get-variable ret_CcOPSvcs) -AND (gv -name "$($tenorg)meta").value.o365_opdomain.split('.')[0].toupper() -ne $env:userdomain){
                $smsg = "`nCROSS-ORG ONPREM CONNECTION: ATTEMPTING TO CONNECT TO ONPREM '$((gv -name "$($tenorg)meta").value.o365_Prefix)' $((gv -name "$($tenorg)meta").value.o365_opdomain.split('.')[0].toupper()) domain, FROM $($env:userdomain)!" ;
                $smsg += "`nEXPECTED ERROR, SKIPPING ONPREM FORESTWIDE SPEC" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $useOP = $false ; 
            }elseif($useOP -AND $pltCcOPSvcs.useForestWide -AND -NOT $ret_CcOPSvcs.hasForestWide){
                $smsg = "==> $($ACtionCommand): MISSING CRITICAL FORESTWIDE SUPPORT COMPONENT:" ; 
                if(-not $ret_CcOPSvcs.hasForestWide){
                    $smsg += "`n----->$($ACtionCommand): MISSING .hasForestWide (Set-AdServerSettings -ViewEntireForest `$True) " ; 
                } ; 
                if(-not $ret_CcOPSvcs.AdGcFwide){
                    $smsg += "`n----->$($ACtionCommand): MISSING .AdGcFwide GC!:`n((Get-ADDomainController -Discover -Service GlobalCatalog).hostname):326) " ; 
                } ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $smsg = "MISSING SOME KEY CONNECTIONS. DO YOU WANT TO IGNORE, AND CONTINUE WITH CONNECTED SERVICES?" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $bRet=Read-Host "Enter YYY to continue. Anything else will exit"  ;
                if ($bRet.ToUpper() -eq "YYY") {
                    $smsg = "(Moving on), WITH THE FOLLOW PARTIAL CONNECTION STATUS" ;
                    $smsg += "`n`n$(($ret_CcOPSvcs|out-string).trim())" ; 
                    write-host -foregroundcolor green $smsg  ;
                } else {
                    throw $smsg ; 
                    break ; #exit 1
                } ;         
            }; 
            #endregion CONFIRM_OPFORESTWIDE ; #*------^ END CONFIRM_OPFORESTWIDE ^------
        } ; 
        #endregion CALL_CONNECT_OPSERVICES ; #*======^ END CALL_CONNECT_OPSERVICES ^======
    
        #endregion SERVICE_CONNECTIONS #*======^ END SERVICE_CONNECTIONS ^======

      
        # Configure the Get-xoMessageTrace splat 
        <# gxmt v1 params
        $pltGXMT=[ordered]@{
            Page= 1 ; # default it to 1 vs $null as we'll be purging empties further down
            ErrorAction = 'STOP' ;
            verbose = $($VerbosePreference -eq "Continue") ;
        } ;
        #>
        # 12:12 PM 10/21/2025 Get-xoMessageTraceV2 params - tossed out Page support and all native pagination
        #-ResultSize 5000 -StartDate $StartDate -EndDate $EndDate -WarningVariable MoreResultsAvailable 
        $pltGXMT=[ordered]@{
            #Page= 1 ; # default it to 1 vs $null as we'll be purging empties further down
            #ResultSize = 5000 ; 
            WarningVariable = "MoreResultsAvailable" ; 
            ErrorAction = 'STOP' ;
            verbose = $($VerbosePreference -eq "Continue") ;
        } ;
        if ($PSCmdlet.ParameterSetName -eq 'Dates') {
            if($EndDate -and -not $StartDate){
                $StartDate = (get-date $EndDate).addDays(-1 * $DaysLimit) ; 
            } ; 
            if($StartDate -and -not ($EndDate)){
                $smsg = "(StartDate w *NO* Enddate, asserting currenttime)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $EndDate=(get-date) ;
            } ;
        } else {
            if (-not $Days) {
                $StartDate = (get-date $EndDate).addDays(-1 * $DaysLimit) ; 
                $smsg = "No Days, StartDate or EndDate specified. Defaulting to $($DaysLimit)day Search window:$((get-date).adddays(-1 * $DaysLimit))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $EndDate = (get-date) ;
                $StartDate = (get-date $EndDate).addDays(-1 * $Days) ; 
                $smsg = "-Days:$($Days) specified: "
                #$smsg += "calculated StartDate:$((get-date $StartDate -format $sFulltimeStamp ))" ; 
                #$smsg += ", calculated EndDate:$((get-date $EndDate -format $sFulltimeStamp ))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #(get-date -format $sFiletimestamp);
            } ; 
        } ;

        $smsg = "(converting `$StartDate & `$EndDate to UTC, using input as `$StartLocal & `$EndLocal)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        # convert dates to GMT .ToUniversalTime(
        $StartDate = ([datetime]$StartDate).ToUniversalTime() ; 
        $EndDate = ([datetime]$EndDate).ToUniversalTime() ; 
        $StartLocal = ([datetime]$StartDate).ToLocalTime() ; 
        $EndLocal = ([datetime]$EndDate).ToLocalTime() ; 
        
        # sanity test the start/end dates, just in case (won't throw an error in gxmt)
        if($StartDate -gt $EndDate){
            $smsg = "`-StartDate:$($StartDate) is GREATER THAN -EndDate:($EndDate)!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            throw $smsg ; 
            break ; 
        } ; 

        $smsg = "`$StartDate:$(get-date -Date $StartLocal -format $sFulltimeStamp )" ;
        $smsg += "`n`$EndDate:$(get-date -Date $EndLocal -format $sFulltimeStamp )" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

        if((New-TimeSpan -Start $StartDate -End (get-date)).days -gt $DaysLimit){
            $smsg = "Search span (between -StartDate & -EndDate, or- Days in use) *exceeds* MS supported days history limit!`nReduce the window below a historical 10d, or use get-HistoricalSearch instead!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            Break ; 
        } ; 

        TRY{
            #$tendoms=Get-AzureADDomain ; 
            $tendoms = Get-MgDomain 
            #$Ten = ($tendoms |?{$_.name -like '*.mail.onmicrosoft.com'}).name.split('.')[0] ; #aad
            $Ten = ($tendoms |?{$_.id -like '*.mail.onmicrosoft.com'}).id.split('.')[0] ; # mg, why keep the same property, name == id? cuz fu!
            $Ten = "$($Ten.substring(0,1).toupper())$($Ten.substring(1,$Ten.length-1).toLower())"
        }CATCH{
            $smsg = "NOT MG CONNECTED! (dep: Get-MgDomain)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
          BREAK 
        } ;
       

    }  # BEG-E
    PROCESS {
        #region SPLAT_BUILD ; #*------v SPLAT_BUILD v------        
        if($SenderAddress){
            if($SenderAddress -match '\*'){
                # To do wildcards (*@DOMAIN.COM), SPEC THE ADDRESS LIKE: -SenderAddress @('*@DOMAIN.COM') (forces as array)
                $pltGXMT.add('SenderAddress',@(($SenderAddress -split ' *, *')) ) ;
            }else{
                $pltGXMT.add('SenderAddress',($SenderAddress -split ' *, *')) ;
            } ; 
        } ;
        if($RecipientAddress){
            if($RecipientAddress -match '\*'){
                # To do wildcards (*@DOMAIN.COM), SPEC THE ADDRESS LIKE: -RecipientAddress @('*@DOMAIN.COM') (forces as array)
                $pltGXMT.add('RecipientAddress',@(($RecipientAddress -split ' *, *')) ) ;
            }else{
                $pltGXMT.add('RecipientAddress',($RecipientAddress -split ' *, *')) ;
            } ; 
        } ;
        if($StartDate){
            $pltGXMT.add('StartDate',$StartDate) ; 
        } ;
        if($EndDate){
            $pltGXMT.add('EndDate',$EndDate) ; 
        } ;
        if($Status){
            $pltGXMT.add('Status',($Status -split ' *, *')) ; 
        } ;
        if($MessageId){
            $pltGXMT.add('MessageId',($MessageId -split ' *, *')) ; 
        } ;
        if($MessageTraceId){
            $pltGXMT.add('MessageTraceId',$MessageTraceId) ; 
        } ;
        if($FromIP){
            $pltGXMT.add('FromIP',$FromIP) ; 
        } ;
        if($ToIP){
            $pltGXMT.add('ToIP',$ToIP) ; 
        } ;
        # 4:01 PM 10/21/2025 add: $ResultSize,
        if($ResultSize){
            $pltGXMT.add('ResultSize',$ResultSize) ; 
        } else{
            # use default 5k msg limt, max allowed size by MS; given 100qrys/5min window throttling, pays to get max out of each qry.
            $pltGXMT.add('ResultSize',5000) ; 
        };
        # 12:28 PM 10/21/2025 new gxmtV2 -subject & SubjectFilterType params
        if($subject){
            $pltGXMT.add('Subject',$subject) ; 
        } ;
        <# You specify how the value is evaluated in the message subject by using the SubjectFilterType parameter.
            -SubjectFilterType
                The SubjectFilterType parameter specifies how the value of the Subject parameter is evaluated. Valid values are:
                    Contains
                    EndsWith
                    StartsWith
                We recommend using StartsWith or EndsWith instead of Contains whenever possible.
        #>
        if($SubjectFilterType){
            $pltGXMT.add('Subject',$SubjectFilterType) ; 
        } ;

        #endregion SPLAT_BUILD ; #*------^ END SPLAT_BUILD ^------

        # use the updated psOfile build:
        #-=-=-=-=-=-=-=-=
        #region MSGTRKFILENAME ; #*------v MSGTRKFILENAME v------
        write-verbose "Keys off of typical msgtrk inputsplat" ; 
        
        # default create a \logs\ dir below script dir
        $LogPath = split-path $logfile ; 
        $smsg = "Writing export files to discovered `$LogPath: $($LogPath)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        if (-not (test-path $LogPath )){mkdir $LogPath -verbose  }
        [string[]]$ofile=@() ; 
        write-verbose "Add comma-delimited elements" ; 
        #$ofile+=if($ticket -AND $Tag){@($ticket,$tag) -join '_'}else{$ticket} ;
        $ofile+= (@($ticket,$tag) | ?{$_}) -join '_' ; 
        $ofile+= (@($Ten,$Requestor,'EXOMsgTrc') | ?{$_} ) -join '-' ;
        $ofile+=if($SenderAddress){
            #"FROM_$((($SenderAddress | select -first 2) -join ',').replace('*','ANY'))"
            "FROM_$(( ($SenderAddress| select -first 2) -join ',').replace('*','ANY'))"
        }else{''} ;
        $ofile+=if($RecipientAddress){
            "TO_$(( ($RecipientAddress| select -first 2) -join ',').replace('*','ANY'))"
        }else{''} ;
        $ofile+=if($MessageId){
            #"MSGID_$($MessageId.replace('<','').replace('>',''))"
            if($MessageId -is [array]){
                "MSGID_$($MessageId[0] -replace '[\<\>]','')..."
            } else { 
                "MSGID_$($MessageId -replace '[\<\>]','')"
            } ; 
        }else{''} ;
        $ofile+=if($MessageTraceId){"MsgId_$($MessageTraceId)"}else{''} ;
        $ofile+=if($FromIP){"FIP_$($FromIP)"}else{''} ;
        $ofile+=if($MessageSubject){"SUBJ_$($MessageSubject.substring(0,[System.Math]::Min(10,$MessageSubject.Length)))..."}else{''} ;
        $ofile+=if($Status){
            "STATUS_$($Status -join ',')"
        }else{''} ;
        write-verbose "comma join the non-empty elements" ; 
        [string[]]$ofile=($ofile |  ?{$_} ) -join ',' ; 
        write-verbose "add the dash-delimited elements" ; 
        $ofile+=if($days){"$($days)d"}else{''} ;
        $ofile+=if($StartDate){"$(get-date $StartDate -format 'yyyyMMdd-HHmm')"}else{''} ;
        $ofile+=if($EndDate){$ofile+= "$(get-date $EndDate -format 'yyyyMMdd-HHmm')"}else{''} ;
        $ofile+=if($MessageSubject){"Subj_$($MessageSubject.replace("*"," ").replace("\"," "))"}else{''} ;
        $ofile+="run$(get-date -format 'yyyyMMdd-HHmm').csv" ;
        write-verbose "dash-join non-empty elems" ; 
        [string]$ofile=($ofile |  ?{$_} ) -join '-' ; 
        write-verbose "replace filesys illegal chars" ; 
        [string]$ofile=[RegEx]::Replace($ofile, "[{0}]" -f ([RegEx]::Escape(-join [System.IO.Path]::GetInvalidFileNameChars())), '') ;
        if($LogPath){
            write-verbose "add configured `LogPath" ; 
            $ofile = join-path $LogPath $ofile ; 
        } else { 
            write-verbose "add relative path" ; 
            $ofile=".\logs\$($ofile)" ;
        } ; 
        #$MSGSTRK | export-csv -noty $ofile -verbo ; 
        #write-host -foregroundcolor green "export-csv'd to:`n$((resolve-path $ofile).path)" ; 
        #endregion MSGTRKFILENAME ; #*------^ END MSGTRKFILENAME ^------
        #-=-=-=-=-=-=-=-=

        $statusLookupTbl = Initialize-exoStatusTable ;         

        #$ofile=[RegEx]::Replace($ofile, "[{0}]" -f ([RegEx]::Escape(-join [System.IO.Path]::GetInvalidFileNameChars())), '') ;
        # use the tested redirected $logfile path
        #$ofile = join-path -path (split-path $logfile) -ChildPath $ofile ; 
        $hReports = [ordered]@{} ; 
        #rxo ;
        $error.clear() ;
        $Exit = 0 ;
        # do retry the initial query
        Do {
            TRY {
                # prepurge empty hash value keys:
                #$pltGXMT=$pltGXMT.GetEnumerator()|? value ;
                # remove null keyed objects
                #$pltGXMT | Foreach {$p = $_ ;@($p.GetEnumerator()) | ?{ ($_.Value | Out-String).length -eq 0 } | Foreach-Object {$p.Remove($_.Key)} ;} ;
                # skip it, we're only adding populated items now
                #write-verbose "hashtype:$($pltGXMT.GetType().FullName)" ; 
                # and issue was first untested negative integer -Days; and 2nd GMT window for start/enddate, so the 'local' input needs to be converted to/from gmt to get the targeted content.

                <# as of 9:56 AM 10/21/2025: Microsoft is killing all requests to Get-xoMessageTrace, now returns:
                Write-ErrorMessage : ||Get-MessageTrace will start deprecating on September 1st, 2025. Please refer to: https://learn.microsoft.com/en-us/powershell/module/exchange/get-messagetracev2?view=exchange-ps to switch to 
                Get-MessageTraceV2.
                At C:\Users\kadriTSS\AppData\Local\Temp\2\tmpEXO_ah0pg1qz.hjm\tmpEXO_ah0pg1qz.hjm.psm1:1191 char:13
                +             Write-ErrorMessage $ErrorObject
                +             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    + CategoryInfo          : InvalidOperation: (:) [Get-MessageTrace], ValidationException
                    + FullyQualifiedErrorId : [Server=CY3PR04MB9691,RequestId=8c72957c-e95b-a089-8433-7f5e0e74f247,TimeStamp=Tue, 21 Oct 2025 14:40:45 GMT],Write-ErrorMessage
                [Announcing General Availability (GA) of the New Message Trace in Exchange Online | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/exchange/announcing-general-availability-ga-of-the-new-message-trace-in-exchange-online/4420243)

                [New Message trace in EAC in Exchange Online | Microsoft Learn](https://learn.microsoft.com/en-us/exchange/monitoring/trace-an-email-message/new-message-trace)

                [Using the Get-MessageTraceV2 cmdlet to generate mail traffic statistics by user - Blog](https://michev.info/blog/post/6572/using-the-get-messagetracev2-cmdlet-to-generate-mail-traffic-statistics-by-user)

                [PowerShell/Get-DetailedMessageStatsV2.ps1 at master · michevnew/PowerShell · GitHub](https://github.com/michevnew/PowerShell/blob/master/Get-DetailedMessageStatsV2.ps1)
                
                # Changes: throttling, torn out usefulness, from Michev:

                ### Positives:
                - Let's start with the good news. The new message trace ensures feature parity 
                    with the "old" experience, while bringing some nice improvements. The most 
                    significant of these is the support for querying data up to 90 days in the past 
                    in a synchronous manner, whereas we were previously limited to just a handful 
                    of days, and had to run async queries. Up to 10 days of data is available for a 
                    single query, but this should not be a problem as in any tenant of meaningful 
                    size, you will hit the "page" limit early on and will have to issue additional 
                    queries anyway. 
                -  larger set of filters supported for the Get-MessageTraceV2 cmdlet, most 
                    notably the ability to filter based on a message's subject, made possible 
                    thanks to the -Subject parameter. 
                ### Negatives:
                - Microsoft changed the way "pagination" works, and the new experience is mildly 
                    annoying at best. It could have been implemented better IMO, or at the very 
                    least align with the pagination experience in the Graph API. Speaking of which, 
                    the next negative is the lack of support for Graph API endpoints/methods. One 
                    can argue that we do have a suitable replacement on the Graph via the 
                    **analyzedEmails** endpoint, but as we discussed in [our 
                    article](https://www.michev.info/blog/post/6181/first-look-at-the-analyzedemails-graph-api-endpoint) 
                    on said endpoint, it's use case is different. 
                -  incoming deprecation of the old experience. Microsoft is giving customers 
                    until September 1st to move away from the 
                    Get-MessageTrace/Get-MessageTraceDetail cmdlets. The same deadline applies to 
                    the MessageTrace report in the good old reporting web service, which is the 
                    only supported RESTful interface to query the message trace data programmatically.
                    No alternative is provided at this point, thus any customers 
                    and ISVs that still rely on the reporting web service need to move to using 
                    PowerShell instead, which might be an issue. The same can be safe in regard to 
                    the new throttling guidance, namely 100 requests per 5 minutes. 

                > The biggest change in the script's logic is in how it handles pagination. 
                I've opted for an approach that relies on the presence of the "hint" returned 
                by the service, which unfortunately is implemented via the warning stream. In 
                effect, we suppress the warning while making sure its content is stored in a 
                variable and then processed to extract the "next page" cmdlet. I'm not a big 
                fan of this implementation, as you can see from [my 
                comments](https://techcommunity.microsoft.com/blog/exchange/announcing-public-preview-of-the-new-message-trace-in-exchange-online/4356561/replies/4392248) 
                under the original blog article. The alternative is to create the "next page" 
                syntax yourself, by copying the properties of the last returned entry, like 
                Tony does in his [sample 
                script](https://github.com/12Knocksinna/Office365itpros/blob/master/Analyze-MailTraffic.PS1)

                >
 
                > Another downside of the new "no pagination" approach is that we cannot have a 
                proper progress indicator, so instead I have added a "poor man's" variation of 
                it, just so you know whether the script is progressing. Once we fetch the 
                available message trace data, we largely follow the logic of the original 
                script and prepare a hashtable for each recipient, holding the count and size 
                of both inbound and outbound messages, per day. Lastly, we transform the output 
                and dump it into a CSV file in the working directory. And since HTML output 
                seems to be all the rage currently, I've asked Copilot to generate the 
                corresponding code. Can I play with the cool kids now? 🙂 

                TK: REQUIRES LATER REV
                10:18 AM 10/21/2025 jb running:
                #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                [PS]:D:\s\build $ Gcm Get-xoMessageTracev2

                CommandType     Name                                               Version    Source                                                                                                                                            
                -----------     ----                                               -------    ------                                                                                                                                            
                Function        Get-xoMessageTraceV2                               1.0        tmpEXO_ah0pg1qz.hjm

                [PS]:D:\s\build $ gmo exchangeonlinemanagement

                ModuleType Version    Name                                ExportedCommands                                                                                                                                                      
                ---------- -------    ----                                ----------------                                                                                                                                                      
                Script     3.6.0      ExchangeOnlineManagement            {Add-VivaModuleFeaturePolicy, Get-ConnectionInformation, Get-DefaultTenantBriefingConfig, Get-DefaultTenantMyAnalyticsFeatureConfig...}

                Curr Online rev:
                [PowerShell Gallery | ExchangeOnlineManagement 3.9.0](https://www.powershellgallery.com/packages/ExchangeOnlineManagement/3.9.0)

                    63,387,978 Downloads
                    12,868 Downloads of 3.9.1-Preview1
                    8/13/2025 Last Published

                Version                 | Downloads | Last updated
                ----------------------- | --------- | -------------
                3.9.1-Preview1          | 12,868    | a month ago
                3.9.0 (current version) | 1,424,135 | 2 months ago <=== 2 mos old!
                3.9.0-Preview1          | 9,617     | 3 months ago
                3.8.1-Preview1          | 48,821    | 5 months ago
                3.8.0                   | 2,050,555 | 5 months ago
                3.8.0-Preview2          | 14,309    | 6 months ago
                3.8.0-Preview1          | 10,600    | 7 months ago
                3.7.2                   | 1,234,251 | 7 months ago
                3.7.2-Preview1          | 6,924     | 8 months ago
                3.7.1                   | 3,181,614 | 9 months ago
                3.7.1-Preview1          | 9,542     | 10 months ago
                3.7.0                   | 2,950,466 | 12/2/2024
                3.7.0-Preview1          | 4,938     | 11/15/2024
                3.6.0                   | 3,537,886 | 9/25/2024

                #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

            #>
                <# my prior Get-xoMessageTrace code:
                $smsg = "Get-xoMessageTrace  w`n$(($pltGXMT|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $Page = 1  ;
                $Msgs=$null ;
                do {
                    $smsg = "Collecting - Page $($Page)..."  ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $pltGXMT.Page=$Page ;
                    $PageMsgs = Get-xoMessageTrace @pltGXMT |  ?{$_.SenderAddress -notlike '*micro*' -or $_.SenderAddress -notlike '*root*' }  ;
                    $Page++  ;
                    $Msgs += @($PageMsgs)  ;
                } until ($PageMsgs -eq $null) ;
                $Msgs=$Msgs| Sort Received ;
                $smsg = "Raw sender/recipient events:$(($Msgs|measure).Count)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                #>

                # michev's code:
                #$MailTraffic = @{} ; 
                # static 10d window
                #$StartDate = (Get-Date).AddDays(-10) #max period we can cover in a single query is 10 days, if needed rerun multiple times to cover up to 90
                #$EndDate = (Get-Date)
                #Get the first "page"
                $Msgs = $null # aggregator
                #$PageMsgs = Get-xoMessageTraceV2 -ResultSize 5000 -StartDate $StartDate -EndDate $EndDate -WarningVariable MoreResultsAvailable -Verbose:$false 3>$null
                #pltGXMT
                $smsg = "Get-xoMessageTrace  w`n$(($pltGXMT|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $PageMsgs = Get-xoMessageTraceV2 @pltGXMT 3>$null
                # The expression 3>$null in PowerShell redirects the Warning stream (stream number 3) to $null. required, because mich is using the warning to note restart points
                                                                                                <# Michev asked M$:
            [Announcing Public Preview of the New Message Trace in Exchange Online | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/exchange/announcing-public-preview-of-the-new-message-trace-in-exchange-online/4356561/replies/4392248)

            Thanks. I see a new warning being generated now, is this the supposed "hint"?

            PS> Get-MessageTracev2 -resultsize 1 ; 
            out:> WARNING: There are more results, use the following command to get more. Get-MessageTraceV2 -StartDate "xxx" -EndDate "xxx" -StartingRecipientAddress "vasil@michev.info" 

            If so, might I suggest using a format that does not require any additional 
            transformation, for example by returning a separate array element with just the 
            "next page" cmdlet syntax? Or by adding a "dummy" entry to the general output 
            stream instead of using the warning one? I.e. like this: 

            Or just do it the "Graph way" with @odata.nextpage and $count?

            [YunjieCao](https://techcommunity.microsoft.com/users/yunjiecao/2896050)
            to VasilMichev

            Mar 12, 2025

            Hi,

            Yes, that is the hint we provide. Thank you for your suggestions! We value this 
            feedback and will work on improvements after gathering input from all our customers.
            In the meantime, you can refer to the FAQ section **How could 
            pagination from V1 be achieved in V2?**. If you see a warning message, you can 
            use the scripts provided in the FAQ section to compose your queries without 
            depending on the warning message itself. 

            #>
                #$Msgs += $PageMsgs | Select Received,SenderAddress,RecipientAddress,Size,Status
                # splice over my postfilter system messages removal
                $Msgs += $PageMsgs | ?{$_.SenderAddress -notlike '*micro*' -or $_.SenderAddress -notlike '*root*' } ; 
                $Exit = $Retries ;
            } CATCH [System.Exception] {
                $ErrTrapd=$Error[0] ;
                if($ErrTrapd.Exception -match $rgxEXOThrottle){
                    $smsg = "MS 100-qry limit/5mins throttling detected, waiting $(RetryThrottle)s to retry..." ; 
                    $smsg += "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    #Start-Sleep -Milliseconds $ThrottleMs 
                    start-sleepcountdown -seconds $RetryThrottle -Rolling ; 
                    $Exit ++ ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $smsg= "Try #: $($Exit)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error }  #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    If ($Exit -eq $Retries) {
                        $smsg= "Unable to exec cmd!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error }  #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        BREAK ; 
                    } ;
                } else{
                    # different error, throw to the main catch
                    throw $ErrTrapd
                } ;     
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                # it's not outputting the underlying cmdlet error, try to force it :
                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #-=-record a STATUSWARN=-=-=-=-=-=-=
                $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                #-=-=-=-=-=-=-=-=
                $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
            } ; 
        } Until ($Exit -eq $Retries) ; 
        # another do/try on the more's
        #If more results are available, as indicated by the presence of the WarningVariable, we need to loop until we get all results
        if ($MoreResultsAvailable) {
            $Exit = 0 ;
            # moreresults loop
            Do {
                # exit retries loop
                $Exit = 0 ;
                Do {
                    TRY {
                        #As we don't have a clue how many pages we will get, proper progress indicator is not feasible.
                        Write-Host "." -NoNewline
                        #Handling this via Warning output is beyong annoying...
                        $NextPage = ($MoreResultsAvailable -join "").TrimStart("There are more results, use the following command to get more. ")
                        # note the above lacks the PREFIX!, patch it in
                        $NextPage = ($MoreResultsAvailable -join "").TrimStart("There are more results, use the following command to get more. ") -replace 'Get-MessageTraceV2','Get-xoMessageTraceV2' ; 
                        $ScriptBlock = [ScriptBlock]::Create($NextPage)
                        $smsg = "MORE:($($Msgs.count)):$(($ScriptBlock|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        $PageMsgs = Invoke-Command -ScriptBlock $ScriptBlock -WarningVariable MoreResultsAvailable -Verbose:$false 3>$null #MUST PASS WarningVariable HERE OR IT WILL NOT WORK
                        #$Msgs += $PageMsgs | Select Received,SenderAddress,RecipientAddress,Size,Status
                        # splice over my postfilter system messages removal 
                        #$Msgs += $PageMsgs | ?{$_.SenderAddress -notlike '*micro*' -or $_.SenderAddress -notlike '*root*' }
                        # Remove Exchange Online public folder hierarchy synchronization messages
                        # $Messages = $Messages | Where-Object {$_.Subject -NotLike "*HierarchySync*"}
                        $Msgs += $PageMsgs | ?{$_.SenderAddress -notlike '*micro*' -OR $_.SenderAddress -notlike '*root*' -AND ($_.Subject -NotLike "*HierarchySync*") }
                        if($MoreResultsAvailable.Count -eq 0){
                            # it didn't break on a repeat, could be the inner loop is preventing the outer until from triggering, so do it inside here.
                            Break ; 
                        } ; 
                    } CATCH [System.Exception] {
                        $ErrTrapd=$Error[0] ;
                        if($ErrTrapd.Exception -match $rgxEXOThrottle){
                            $smsg = "MS 100-qry limit/5mins throttling detected, waiting $(RetryThrottle)s to retry..." ; 
                            $smsg += "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            #Start-Sleep -Milliseconds $ThrottleMs 
                            start-sleepcountdown -seconds $RetryThrottle -Rolling ; 
                            $Exit ++ ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $smsg= "Try #: $($Exit)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error }  #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            If ($Exit -eq $Retries) {
                                $smsg= "Unable to exec cmd!" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error }  #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                BREAK ; 
                            } ;
                        } else{
                            # different error, throw to the main catch
                            throw $ErrTrapd
                        } ;     
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        # it's not outputting the underlying cmdlet error, try to force it :
                        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #-=-record a STATUSWARN=-=-=-=-=-=-=
                        $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                        if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                        if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                        #-=-=-=-=-=-=-=-=
                        $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                    } ; 
                } Until ($Exit -eq $Retries) ; 
            }until ($MoreResultsAvailable.Count -eq 0) #Arraylist
        }  # if-E More test
            
           
        #If no messages were found, exit
        if ($Msgs.Count -eq 0) {
            Write-Error "No messages found for the specified date range. Please check your permissions or update the date range above."
            return
        }
        # -----------
                                                                                                                            <# for comparison, here's how TonyRedmond handles the above
            [array]$Messages = $Null
            [int]$BatchSizeForMessages = 2000
                # original code [array]$MessagePage = Get-MessageTrace -StartDate $StartDate -EndDate $EndDate -PageSize 1000 -Page $i -Status "Delivered"
            Try {
                # The warning action is suppressed here because we don't want to see warnings when more data is available
                [array]$MessagePage = Get-MessageTraceV2 -StartDate $StartDate -EndDate $EndDate `
        	            -ResultSize $BatchSizeForMessages -Status "Delivered" -ErrorAction Stop -WarningAction SilentlyContinue
                $Messages += $MessagePage
            } Catch {
                Write-Host ("Error fetching message trace data: {0}" -f $_.Exception.Message)
                Break
            }
            If ($MessagePage.count -eq $BatchSizeForMessages) {
                Do {
                    Write-Host ("Fetched {0} messages so far" -f $Messages.count)
                    $LastMessageFetched = $MessagePage[-1]
                    $LastMessageFetchedDate = $LastMessageFetched.Received.ToString("O")
                    $LastMessageFetchedRecipient = $LastMessageFetched.RecipientAddress
                    # Fetch the next page of messages
                    [array]$MessagePage = Get-MessageTraceV2 -StartDate $StartDate -EndDate $LastMessageFetchedDate `
                        -StartingRecipientAddress $LastMessageFetchedRecipient -ResultSize $BatchSizeForMessages -Status "Delivered" -ErrorAction Stop -WarningAction SilentlyContinue
                    If ($MessagePage) {
                        $Messages += $MessagePage
                    }
                } While ($MessagePage.count -eq $BatchSizeForMessages)
            }
            # Remove Exchange Online public folder hierarchy synchronization messages
            $Messages = $Messages | Where-Object {$_.Subject -NotLike "*HierarchySync*"}
            #>
        # -----------
        # 12:25 PM 10/21/2025 as of Get-xoMessageTraceV2 -subject is a new [string] param, put it up in the splat - but it's not a regex, (removes my support below)
        <#
                if($subject){
                    $smsg = "Post-Filtering on Subject:$($subject)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    # detect whether to filter on -match (regex) or -like (asterisk, or default non-regex)
                    if(test-IsRegexPattern -string $subject -verbose:$($VerbosePreference -eq "Continue")){
                        $smsg = "(detected -subject as regex - using -match comparison)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $MsgsFltrd = $Msgs | ?{$_.Subject -match $subject} ;
                        if(-not $MsgsFltrd){
                            $smsg = "Subject: regex -match comparison *FAILED* to return matches`nretrying Subject filter as -Like..." ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $MsgsFltrd = $Msgs | ?{$_.Subject -like $subject} ;
                        } ; 
                    } else { 
                        $smsg = "(detected -subject as NON-regex - using -like comparison)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $MsgsFltrd = $Msgs | ?{$_.Subject -like $subject} ;
                        if(-not $MsgsFltrd){
                            $smsg = "Subject: -like comparison *FAILED* to return matches`nretrying Subject filter as -match..." ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $MsgsFltrd = $Msgs | ?{$_.Subject -match $subject} 
                        } ; 
                    } ; 
                    $smsg = "Post Subj filter matches:$(($MsgsFltrd|measure).Count)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $msgs = $MsgsFltrd ; 
                } ;
                #>
        
        # new try for balance of non-download work
        TRY {     
            if($Msgs){
                # reselect with local time variant
                $Msgs = $Msgs | select $propsMTAll ; 
                if($DoExports){
                    $smsg = "($(($Msgs|measure).count) events | export-csv $($ofile))" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    TRY{
                        $Msgs | select $propsMT | export-csv -notype -path $ofile -ea STOP  ;
                        $smsg = "export-csv'd to:`n$((resolve-path $ofile).path)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ; 
                    $smsg = "(adding `$hReports.MTMessages)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    
                    # add the csvfilename
                    $smsg = "(adding `$hReports.MTMessagesCSVFile:$($ofile))" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $hReports.add('MTMessagesCSVFile',$ofile) ; 
                } 

                $hReports.add('MTMessages',$msgs) ; 

                if($Msgs){
                    $smsg = "`n#*------v Status DISTRIB v------`n`n" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success

                    $hReports.add('StatusHisto',($Msgs | select -expand Status | group | sort count,count -desc | select count,name)) ;

                    $smsg = "`n$(($hReports.StatusHisto|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $smsg = "`n`n#*------^ Status DISTRIB ^------`n`n" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                    $smsg = "`n`n## Status Definitions:" ; 
                    $hReports.StatusHisto | select -expand Name | foreach-object{                   
                        $smsg += "`n$(($statusLookupTbl[$_] | ft -HideTableHeaders |out-string).trim())" ; 
                    } ; 
                    $smsg += "`n`n"
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success


                    $smsg = "`n`n#*------v MOST RECENT MATCH v------`n`n" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                    $hReports.add('MsgLast',($msgs[-1]| fl $propsMsgDump)) ;
                    $smsg = "`n$(($hReports.MsgLast |out-string).trim())";
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $smsg = "`n`n#*------^ MOST RECENT MATCH ^------`n`n" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                } ; 

                #region statFAIL ; #*------v statFAIL v------
                if($mFails = $msgs | ?{$_.status -eq 'Failed'} | select -last $MessageTraceDetailLimit){
                    $smsg = "Expanded analysis on last $($MessageTraceDetailLimit) Status:Failed messages..." ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                    if($mFails | ?{$_.Subject -notmatch '^Recall:\s' -AND $_.Subject -notmatch '^Automatic\sreply:\s'}){
                        $smsg = "Other Fails detected: Opening ExoP & ADMS connections (for get-recipient & get-aduser checks)..." ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        #region CXOP ; #*------v CXOP v------
                        $smsg = "Resolve ComputerSite..." ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        TRY{
                            $Site=[System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().Name
                        }CATCH{
                            $Site=$env:COMPUTERNAME ;
                            $smsg = "Non-AD-Connected system, setting `$Site:`$env:COMPUTERNAME" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ;
                        $smsg = "Resolved ComputerSite: $($Site)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $smsg = "Discovering and connecting to a local Exchange server in local AD Site"  ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $pltNPSS=[ordered]@{
                            siteName = $Site ;
                            RoleNames = @('HUB','CAS') ;
                            Verbose = ($PSBoundParameters['Verbose'] -eq $true) ;
                        } ;
                        $smsg = "Connect-ExchangeServerTDO w`n$(($pltNPSS|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $PSSession = Connect-ExchangeServerTDO @pltNPSS ;
                        #endregion CXOP ; #*------^ END CXOP ^------
                        #region loadADMS ; #*------v loadADMS v------
                        if(-not (get-command -name get-aduser -ea 0)){
                            $env:ADPS_LoadDefaultDrive = 0 ; $sName="ActiveDirectory"; if (!(Get-Module | where {$_.Name -eq $sName})) {Import-Module $sName -ea Stop}
                        } ; 
                        #endregion loadADMS ; #*------^ END loadADMS ^------
                    } ; 
                    
                    $FailAggr = @() ;                                         
                    foreach($failed in $mFails){
                        # 'RunspaceId',
                        # $propsMTAll = 'Organization','MessageId','Received', @{N='ReceivedLocal';E={[datetime]$_.Received.ToLocalTime()}},'SenderAddress','RecipientAddress','Subject','Status','ToIP','FromIP','Size','MessageTraceId','StartDate','EndDate','Index'

                        if($host.version.major -ge 3){$FailMsgSummary=[ordered]@{Dummy = $null ;} }
                        else {$FailMsgSummary=@{Dummy = $null ;} ;}
                        If($FailMsgSummary.Contains("Dummy")){$FailMsgSummary.remove("Dummy")} ;
                        $fieldsnull = 'Organization','MessageId','Received','ReceivedLocal','SenderAddress',
                            'RecipientAddress','Subject','Status','ToIP','FromIP','Size','MessageTraceId',
                            'StartDate','EndDate','Index','FailXoRecipientType','FailXopRecipientType',
                            'FailDetailEvent','FailDetailDetail','ADUserTermOU' ;  ; 
                        $fieldsnull | % { $FailMsgSummary.add($_,$null) } ;
                        $fieldsbool = 'isFailed','ADUserDisabled'
                            #,'isFailedOOO','isFailRecall','isFailOther','isFailOtherAcctsBlock',
                            #'isFailSecBlock','isFailMailLoop','isFailBrokenTerm','isFailNoMailbox', ; 
                        # 4:11 PM 11/22/2024 pulled the is*, do it by parsing the FailCode instead
                        $fieldsbool | % { $FailMsgSummary.add($_,$false) } ;


                        
                        $FailMsgSummary.Organization = $failed.Organization ; 
                        $FailMsgSummary.MessageId = $failed.MessageId ; 
                        $FailMsgSummary.Received = $failed.Received ; 
                        $FailMsgSummary.ReceivedLocal = $failed.ReceivedLocal ; 
                        $FailMsgSummary.SenderAddress = $failed.SenderAddress ; 
                        $FailMsgSummary.RecipientAddress = $failed.RecipientAddress ; 
                        $FailMsgSummary.Subject = $failed.Subject ; 
                        $FailMsgSummary.Status = $failed.Status ; 
                        $FailMsgSummary.ToIP = $failed.ToIP ; 
                        $FailMsgSummary.FromIP = $failed.FromIP ; 
                        $FailMsgSummary.Size = $failed.Size ; 
                        $FailMsgSummary.MessageTraceId = $failed.MessageTraceId ; 
                        $FailMsgSummary.StartDate = $failed.StartDate ; 
                        $FailMsgSummary.EndDate = $failed.EndDate ; 
                        $FailMsgSummary.Index = $failed.Index ;      
                        $FailMsgSummary.isFailed = $true ; 
                        
                        $FailMsgSummary.FailCode = $null ; 
                        $FailMsgSummary.FailXoRecipientType = $null ; 
                        $FailMsgSummary.FailXopRecipientType = $null ;
                        $FailMsgSummary.FailDetailEvent = $null ; 
                        $FailMsgSummary.FailDetailDetail = $null ; 
                        $FailMsgSummary.ADUserDisabled = $false ; 
                        $FailMsgSummary.ADUserTermOU = $null ;
                        #$rgxFailOOOSubj = '^Automatic\sreply:\s' ; 
                        if($failed | ?{$_.Subject -match $rgxFailOOOSubj}){
                            $FailMsgSummary.FailCode += @('FailOOO') ; 
                        } ; 
                        #$rgxFailRecallSubj = '^Recall:\s' ; 
                        if($failed | ?{$_.Subject -match $rgxFailRecallSubj}){
                            $FailMsgSummary.FailCode += @('FailRecall') ; 
                        } ; 
                        #$rgxFailOtherAcctBlock = 'OtherAccts-External-Mail-Rejection' ; 
                        #$FailOtherAcctBlockExemptionGroup = 'LYN-DL-OPExch-OtherAcctMbxs-ExternalMailOK@toro.com' ; 
                        if($failed | ?{$_.Subject -notmatch $rgxFailRecallSubj -AND $_.Subject -notmatch $rgxFailOOOSubj}){
                            #$FailMsgSummary.isFailOther = $true ; 
                            #$FODetail =  $failed | Get-xoMessageTraceDetail -ea STOP; 
                            # 9:48 AM 5/2/2025 Get-xoMessageTraceDetail pipe fails, blow out into a wait loop
                            $FODetail = pull-GetxoMessageTraceDetail -Messages $failed ;                            

                            $FailMsgSummary.FailDetailEvent = $FODetail.event ; 
                            $FailMsgSummary.FailDetailDetail = $FODetail.Detail ; 
                            if($FODetail | ?{$_.event -eq 'Transport rule' -AND $_.Detail -match $rgxFailOtherAcctBlock}){
                                $FailMsgSummary.FailCode += @('FailOtherAcctBlock') ; 
                            } ; 
                            #$rgxFailConfRmExtBlock = 'ConfRm-External-Mail-Rejection' ; 
                            if($FODetail | ?{$_.event -eq 'Transport rule' -AND $_.Detail -match $rgxFailConfRmExtBlock}){
                                $FailMsgSummary.FailCode += @('FailConfRmExtBlock') ; 
                            } ; 
                            #$rgxFailSecBlock = '^Security(\s-\s|-)' ; 
                            if($FODetail | ?{$_.event -eq 'Transport rule' -AND $_.Detail -match $rgxFailSecBlock}){
                                if(($FODetail.detail | select -unique ) -match "Transport\srule:\s'(.*)',"){
                                    $TRule = $matches[0] ; 
                                    $FailMsgSummary.FailCode += @("FailSecBlock:$($Trule)") ; 
                                }else{
                                    $FailMsgSummary.FailCode += @('FailSecBlock') ; 
                                } ; 
                            }
                            if($FODetail | ?{$_.event -eq 'FAIL' -AND $_.Detail -match 'Hop\scount\sexceeded\s-\spossible\smail\sloop'}){
                                $FailMsgSummary.FailCode += @('FailMailLoop') ; 
                                $xopRcp = $xoRCP = $adu = $null ; 
                                $xopRcp = get-recipient $failed.RecipientAddress -ea 0;
                                $xoRCP = get-xorecipient $failed.RecipientAddress -ea 0 ; 
                                $adu = get-aduser -id $xoRCP.alias -ea 0 ; 
                                $FailMsgSummary.FailXoRecipientType = $xoRCP.RecipientTypeDetails  ; 
                                $FailMsgSummary.FailXopRecipientType = $xopRcp.RecipientTypeDetails  ; 
                                if($FailMsgSummary.FailXoRecipientType -eq 'MailUser' -AND $FailMsgSummary.FailXopRecipientType -eq 'RemoteUserMailbox'){
                                    $FailMsgSummary.FailCode += @('FailBrokenTerm') ; 
                                    $FailMsgSummary.FailCode += @('FailNoMailbox') ; 
                                } ; 
                                if($adu.DistinguishedName -match 'OU=(Disabled|TERMedUsers|TERMedUserSharedEmail),'){
                                    $FailMsgSummary.ADUserTermOU = ($adu.DistinguishedName.split(',') | select -skip 1) -join ','  
                                    $FailMsgSummary.FailCode += @('FailBrokenTerm','FailADUserTermOU') ; 
                                } ;
                                if($adu.Enabled -eq $false){
                                    $FailMsgSummary.ADUserDisabled = $true  ; 
                                    $FailMsgSummary.FailCode += @('FailBrokenTerm','FailADUserDisabled') ; 
                                } ;
                            } ; 
                            if($FODetail | ?{$_.event -eq 'FAIL' -AND $_.Detail -match 'Reason:\s'}){
                                # there's a Reason:\s in the mix, try to echo it
                                $FailMsgSummary.FailCode += @('FailReason') ; 
                                $FailMsgSummary.FailDetailDetail = ($FODetail | ?{$_.event -eq 'FAIL' -AND $_.Detail -match 'Reason:\s'}).Detail
                            } ; 
                        } ; 
                        if($FailMsgSummary.FailCode){
                            # reduce to single instance of each code
                            $FailMsgSummary.FailCode = $FailMsgSummary.FailCode | select -unique ;
                        } ; 
                        $FailAggr +=  New-Object -TypeName PsObject -Property $FailMsgSummary
                        #[pscustomobject]$FailMsgSummary ; 
                    } ; 
                    #---

                    $smsg = "adding:`$hReports.MsgsFail" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $hReports.add('MsgsFail',$FailAggr) ; 
                    $ofileF = $ofile.replace('-EXOMsgTrc,','FAILMsgs,') ;
                    if($DoExports){
                        TRY{
                            $FailAggr | export-csv -notype -path $ofileF -ea STOP ;
                            $smsg = "export-csv'd to:`n$((resolve-path $ofileF).path)" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        } CATCH {
                            $ErrTrapd=$Error[0] ;
                            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ; 
                    } ; 


                    # divide up the results & report on the types
                    $FailsVariants = $hReports.MsgsFail | group failcode | select -expand name; 

                    $prpFailMsg = 'ReceivedLocal','SenderAddress','RecipientAddress','Subject','Status' ; 

                    # do the single fails
                    $SingleFails = $hReports.MsgsFail | ?{-not ($_.failcode -is [array])} ; 
                    $FailVariantsSingle = $SingleFails | group failcode | select -expand name; 
                    foreach($FV in $FailVariantsSingle){
                        $theseFails = $SingleFails |?{$_.failcode -eq $FV} ; 
                        #$pltWH=get-colorcombo -Rand ;
                        #$Host.UI.RawUI.BackgroundColor = $pltWH.BackgroundColor ;
                        #$Host.UI.RawUI.ForegroundColor = $pltWH.ForegroundColor ;
                        $hsFailRpt = @"

*------v Delivery Status:Failed of type: $($FV) v------

$(($theseFails|ft -a $prpFailMsg  | out-string).trim())

$(
    switch -regex ($FV){
        'FailOtherAcctBlock' {
            "`n$($FV): Blocked by Security-mandated Transport rule:$($rgxFailOtherAcctBlock)"
            "`n -To Exempt from Block: Request SvcDesk add the mailbox to $($FailOtherAcctBlockExemptionGroup) group"
            "`n -To suppress DDG Membership for converted SharedMailboxes (to UserMailbox, w logon): set CustomAttribute4: DL-Exclude"
        }
        'FailConfRmExtBlock'{
            "`n$($FV): Blocked by Security-mandated Transport rule:$($rgxFailConfRmExtBlock)`n(Firm mandate: No exemption permitted for ResourceMailboxes)`n"
        }
        'FailOOO'{
            "`n$($FV): Blocked by Security Policy: Blocked external delivery of Out-Of-Office messages`n(Global Security policy mandate: No exemption permitted)`n"
        }
        'FailRecall' {
            "`n$($FV): Expected fail: Sender issued Outlook Recall of message`n"
        }
        'FailSecBlock' {
            "`n$($FV): Blocked by Security-configured Transport rule`n"
        }
        'FailBrokenTerm|FailNoMailbox|FailMailLoop' {
            "`n$($FV): No valid recipient found: Broken offboarded user: Email looped between environments until hop count exceeded, and Non-Delivery Notice (NDR) was issued`n"
        }
        'FailADUserTermOU' {
            "`n$($FV): No valid recipient found: Broken offboarded user:ADUser is in Term OU: Email looped between environments until hop count exceeded, and Non-Delivery Notice (NDR) was issued`n"
        }
        'FailADUserDisabled' {
            "`n$($FV): No valid recipient found: Broken offboarded user: ADUser is disabled: Email looped between environments until hop count exceeded, and Non-Delivery Notice (NDR) was issued`n"
        }  
        'FailReason' {
            "`n$($FV): Other error, with a 'Reason' specification`n"
            $theseFails.FailDetailDetail |%{"`n$($_)"}
        }
        default{
            "`n$($FV): Undefined error (not configured as a response in this script)`n"
            $theseFails.FailDetailDetail |%{"`n$($_)"}
        }   
    }
)

*------^ END Delivery Status:Failed of type: $($FV) ^------

"@ ; 
                        #write-host @pltWH $hsFailRpt ; 
                        $smsg = $hsFailRpt ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    } ;  # loop-E

                    $ArrayFails = $hReports.MsgsFail | ?{$_.failcode -is [array]} ; 
                    $FailVariantsArray = $ArrayFails | group failcode | select -expand name; 
                    $BadTermFailCodes = 'FailBrokenTerm','FailNoMailbox','FailADUserTermOU','FailADUserDisabled' ; 
                    [regex]$rgxBadTerm = ('(' + (($BadTermFailCodes  |%{[regex]::escape($_)}) -join '|') + ')') ;
                    #$pltWH=get-colorcombo -Rand ;
                    #foreach($FV in $FailVariantsArray){
                    foreach($Fail in $ArrayFails){
                        # do the BadTermFails
                        #$BadTermFails = $hReports.MsgsFail | ?{$_.failcode -match $rgxbadterm}
                        #$OtherArrayFails = $hReports.MsgsFail | ?{$_.failcode -notmatch $rgxbadterm}

                        #$(($theseFails|ft -a $prpGXMTfta | out-string).trim())       
                        # MessageID: $($Fail.MessageID)                  
                        $hsFailRpt = @"

*------v Delivery Status:Failed : $($Fail.MessageID) v------


$(($Fail |ft -a $prpFailMsg  | out-string).trim())

$(
    
    if($Fail.FailDetailEvent){
        "`nFailDetailEvent: $(($Fail.FailDetailEvent) -join ',')`n"
    }
    if($Fail.FailDetailDetail){
        "`nFailDetailDetail:`n$(($Fail.FailDetailDetail | out-string).trim())`n"
    }
    if($Fail.FailXoRecipientType){
        "`nCloud Recipient"
        "`nFailXoRecipientType: $(($Fail.FailXoRecipientType | out-string).trim())"
        switch ($Fail.FailXoRecipientType){
            "UserMailbox" {
                "`nis a standard functional MAILBOX: UserMailbox" ; 
            }
            "SharedMailbox" {
                "`nis a standard functional MAILBOX: SharedMailbox" ; 
            }
            "EquipmentMailbox" {
                "`nis a standard functional MAILBOX: EquipmentMailbox" ; 
            }
            "RoomMailbox" {
                "`nis a standard functional MAILBOX: RoomMailbox" ; 
            }
            "MailUser" {
                "`nMAILUSER: Generally reflects a removed license: => MS immediately deletes mailbox"
                "`nis a NON-MAILBOX: MailUser *forwards* to matching OnPrem/external UserMailbox object" ; 
            } ;
            default {
                write-warning "$((get-date).ToString('HH:mm:ss')):Unsupported RecipientType:($Fail.recipienttype). EXITING!" ;
                Break ;
            }
        }
        
    }
    if($fail.FailXopRecipientType){
        "`n`nOnPrem Recipient"
        "`nFailXopRecipientType: $(($fail.FailXopRecipientType | out-string).trim())"
        switch ($fail.FailXopRecipientType){
            'RemoteUserMailbox' {
                "`nis a NON-MAILBOX: RemoteUserMailbox *forwards* to matching cloud UserMailbox object" ; 
            }
            'RemoteSharedMailbox' {
                "`nis a NON-MAILBOX: RemoteSharedMailbox *forwards* to matching cloud SharedMailbox object" ; 
            }
            'RemoteRoomMailbox' {
                "`nis a NON-MAILBOX: RemoteRoomMailbox *forwards* to matching cloud RoomMailbox object" ; 
            }
            'RemoteEquipmentMailbox' {
                "`nis a NON-MAILBOX: RemoteEquipmentMailbox *forwards* to matching cloud EquipmentMailbox object" ; 
            }
            'UserMailbox' {
                "`nis a MISCONFIGURED MAILBOX: UserMailbox objects should no longer remain OnPrem (longer than it takes to migrate them to cloud during onboarding)" ; 
            }
            'SharedMailbox' {
                "`nis a MISCONFIGURED MAILBOX: SharedMailbox objects should no longer remain OnPrem (longer than it takes to migrate them to cloud during onboarding)" ; 
            }
            'MailUser' {
                "`nMAILUSER WO RMBX DETECTED! - POSSIBLE NOBRAIN?"
                "`nis a NON-MAILBOX: MailUser forwards to matching cloud UserMailbox object" ; 
            }
            'MailUniversalDistributionGroup' {
                "`nis a NON-MAILBOX: MailUniversalDistributionGroup are DistrubutionGroup objects that distribute mail to a membership" ; 
            }
            'DynamicDistributionGroup'  {
                "`nis a NON-MAILBOX: DynamicDistributionGroup are Dynamic DistrubutionGroup objects that distribute mail to an on-demand query-populated membership" ; 
            }
            'MailContact' {
                "`nis a NON-MAILBOX: MailContact is a non-SecurityPrincipal, that forwards mail to an exteral email address" ; 
            }
            default{
                "`nUnable to resolve `$fail.FailXopRecipientType: $($fail.FailXopRecipientType)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ;
                break ;
            }
        }
    }
    if($Fail.ADUserDisabled){
        "`nADUserDisabled: $(($Fail.ADUserDisabled | out-string).trim())"
    }
    if($Fail.ADUserTermOU){
        "`nADUserTermOU: $(($Fail.ADUserTermOU | out-string).trim())"
    }
    if($fail.FailXopRecipientType -notmatch '^(Mailbox|SharedMailbox|RoomMailbox|EquipmentMailbox)' -AND $Fail.FailXoRecipientType -notmatch '^(Mailbox|SharedMailbox|RoomMailbox|EquipmentMailbox)'){
        "`n`n==> EXPECTED LOOP FAILURE: BOTH CLOUD AND ONPREM RECIPIENT OBJECTS ARE _NON-MAILBOXES_ `n=> THERE IS NO WHERE TO DELIVER ANY MESSAGES TO THE ADDRESS!`n" ; 
    } 
)

*------^ END  Delivery Status:Failed : $($Fail.MessageID)  ^------

"@ ; 
                        #write-host @pltWH $hsFailRpt ; 
                        $smsg = $hsFailRpt ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    } ;  # loop-E

                } ;
                #endregion statFAIL ; #*------^ END statFAIL ^------

                #region statQUAR ; #*------v statQUAR v------
                if(-not $NoQuarCheck -AND ($mQuars = $msgs | ?{$_.status -eq 'Quarantined'})){
                    $hReports.add('MsgsQuar',$mQuars) ;
                    $ofileQ = $ofile.replace('-EXOMsgTrc,','QUARMsgs,') ;
                    #set-variable -name "$($vn)_QUAR" -Value ($mQuars) -ea STOP;
                    if($DoExports){
                        TRY{
                            $mQuars | export-csv -notype -path $ofileQ -ea STOP ;
                            $smsg = "export-csv'd to:`n$((resolve-path $ofileQ).path)" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        } CATCH {
                            $ErrTrapd=$Error[0] ;
                            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ; 
                    } ; 
                    # 8:57 AM 12/6/2024 it's taking *5mins* to Get-xoQuarantineMessage; there's no point in running that 15 times, for the same sender, w same header & senderID specs
                    # we need to down group the SenderAddress, and just process the last most-recent 'x', $QuarExpandLimitPerSender
                    $QuarSendersGrouped  = $mQuars | group SenderAddress | select Count,Name ; 
                    $smsg = "Status:Quarantined SenderAddress distribution:`n$(($QuarSendersGrouped |  ft -a count,name|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $smsg = "EXPANDING QUARANTINES: (most recent $($QuarExpandLimitPerSender) Qurantine(s) per SenderAddress)`n$" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                    else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    $procQuars = @() ; 
                    foreach($QSName in $QuarSendersGrouped.name){
                        $procQuars += @($mQuars | ?{$_.SenderAddress -eq $QSName} | sort Received | select -last $QuarExpandLimitPerSender) ; 
                    } ; 
                    #$ttl = $mQuars |  measure | select -expand count ;
                    $ttl = $procQuars |  measure | select -expand count ;
                    $prcd=0 ;
                    #$mQuars |foreach-object{
                    $procQuars |foreach-object{
                        $tmsg = $_ ;
                        $prcd++ ;
                        $smsg = $sBnrS="`n`n#*------v PROCESSING QUAR:($($prcd)/$($ttl)): $($tmsg.MessageID) v------" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $qmsg = Get-xoQuarantineMessage -MessageId $tmsg.MessageID ;
                        $qmsg |foreach-object{
                            $qid = $_.identity ;
                            $smsg = "`n$(($qmsg|ft -a $prpGXQMfta | out-string).trim())`n" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $hdr = Get-xoQuarantineMessageHeader -Identity $qid | select -expand header;
                            #$rgxReturnPath = "Return-Path:((\n|\r|\s)*)([0-9a-zA-Z]+[-._+&='])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}" ;
                            if($hdr -match $rgxReturnPath){
                                $smsg = "$(( (($matches[0] -split ':' |foreach-object{$_.trim()} ) -join ': ') |out-string).trim())" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                                else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } ;
                            $hdrsp = $hdr.Split([Environment]::NewLine) ;
                            write-host  "$(($hdrsp | ?{$_ -match $rgxHdrSenderIDKeys}|out-string).trim())" ;
                            start-sleep -Milliseconds 500 ;
                        } ;
                        $smsg = "$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                } ;
                #endregion statQUAR ; #*------^ END statQUAR ^------

                #region statGETSTAT ; #*------v statGETSTAT  v------
                if( $mGetStat = $msgs|?{$_.Status -eq 'GettingStatus'}){
                    $smsg = "Status:GettingStatus returned on some traces - INDETERMINANT STATUS THOSE ITEMS (PENDING TRACKABLE LOGGING), RERUN IN A FEW MINS TO GET FUNCTIONAL DATA! (EXO-SIDE ISSUE)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                    $smsg = "`n`n#*------v GettingStatus's Attempt to Re-Resolve via Get-xoMessageTraceDetail (up to last $($MessageTraceDetailLimit) messages) v------`n`n" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    $midn = 20 ; $namn = 15 ; 
                    $gsmprcd = 0 ; 
                    $gsmAggr = @() ;
                    $prpgMsg = 'Received','SenderAddress','RecipientAddress','Subject' ; 
                    foreach($gsmsg in ($mGetStat | select -last $MessageTraceDetailLimit)){
                        $gsmprcd++ ; 
                        # just dump a quick summary for now
                        $smsg = "`n`n===#$($gsmprcd): MsgId: $($gsmsg.MessageId) : Status:$($gsmsg.Status)" ; 
                        $smsg += "`n$(($gsmsg | ft -a $prpgMsg|out-string).trim())" ;
                        # pop all the values but status, from the getstat event, (use the detail return'd updated)
                        $pxyEvent = [ordered]@{
                            Organization        = $gsmsg.Organization ; #$evtd.Organization ;#  toroco.onmicrosoft.com
                            MessageId           = $gsmsg.MessageId ; #$evtd.MessageId ;#  <ADR50000009071697200005056AEB0091FD089AFCAED106AF4B8@GRAINGER.COM>
                            Received            = $gsmsg.Received ; #$evtd.Date ;#  4/30/2025 4:48:27 AM
                            ReceivedLocal       = $gsmsg.ReceivedLocal ;#  4/29/2025 11:48:27 PM
                            SenderAddress       = $gsmsg.SenderAddress ; #$evtd.SenderAddress ;#  S_BTCEMAIL@GRAINGER.COM
                            RecipientAddress    = $gsmsg.RecipientAddress ; #$evtd.RecipientAddress ;#  ap@charlesmachineworks.com
                            Subject             = $gsmsg.Subject ;#  Grainger Inv # 9489372020 PO# 4501043337
                            Status              = $null ; #$evtd.Event ;#  GettingStatus
                            ToIP                = $gsmsg.ToIP ;#
                            FromIP              = $gsmsg.FromIP ;
                            Size                = $gsmsg.Size ;#  105464
                            MessageTraceId      = $gsmsg.MessageTraceId ; #$evtd.MessageTraceId ;#  f915afcc-f5ea-4f2a-3e0a-08dd87a23f8e
                            StartDate           = $gsmsg.StartDate ;#  4/29/2025 3:52:37 PM
                            EndDate             = $gsmsg.EndDate ;#  5/1/2025 3:52:37 PM
                            Index               = $gsmsg.Index ;#  9
                        } ; 

                        #if($gsmd = Get-xoMessageTrace -MessageId $gsmsg.MessageId | Get-xoMessageTraceDetail){
                        # 9:42 AM 5/2/2025 having issues with pipe into Get-xoMessageTraceDetail, expand it out, with a wait
                        # 11:18 AM 5/2/2025 shift to function
                        $gsmd = pull-GetxoMessageTraceDetail -Messages (Get-xoMessageTrace -MessageId $gsmsg.MessageId -ea STOP) ; 

                        if($gsmd){
                            # just dump a quick summary
                            $smsg += "`nDetailDisposition:`n$(($gsmd | ft -a|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            $cndx = $gsmsg.Index ; 
                            foreach($evtd in $gsmd){
                                # build a proxy event to add to the msgs table
                                # will have multiple events - receive & Deliver etc - need to loop below
                                #$pxyEvent = [ordered]@{
                                    $pxyEvent.Organization        = if($evtd.Organization){$evtd.Organization} ; 
                                    $pxyEvent.MessageId           = if($evtd.MessageId){$evtd.MessageId} ;#  <ADR50000009071697200005056AEB0091FD089AFCAED106AF4B8@GRAINGER.COM>
                                    $pxyEvent.Received            = if($evtd.Date){$evtd.Date} ;#  4/30/2025 4:48:27 AM
                                    #ReceivedLocal       = if($gsmsg.ReceivedLocal){$gsmsg.ReceivedLocal} ;#  4/29/2025 11:48:27 PM
                                    $pxyEvent.SenderAddress       = if($evtd.SenderAddress){$evtd.SenderAddress} ;#  S_BTCEMAIL@GRAINGER.COM
                                    $pxyEvent.RecipientAddress    = if($evtd.RecipientAddress){$evtd.RecipientAddress} ;#  ap@charlesmachineworks.com
                                    #Subject             = if($gsmsg.Subject){$gsmsg.Subject} ;#  Grainger Inv # 9489372020 PO# 4501043337
                                    $pxyEvent.Status              = if($evtd.Event){$evtd.Event} ;#  GettingStatus
                                    $pxyEvent.ToIP                = if((([xml]$evtd.data).root.mep |?{$_.name -match 'MailboxServer|ServerHostName'}).string){
                                                                          (([xml]$evtd.data).root.mep |?{$_.name -match 'MailboxServer|ServerHostName'}).string ; 
                                                                    }
                                    # looked at resolving fqdn's at ms, to ips: there's no external dns support to ptr them
                                    $pxyEvent.FromIP              = if((([xml]$evtd.data).root.mep |?{$_.name -match 'ClientIP|ClientName'}).string ){
                                                                          (([xml]$evtd.data).root.mep |?{$_.name -match 'ClientIP|ClientName'}).string 
                                                                    } ;  
                                    #Size                = if($gsmsg.Size){} ;#  105464
                                    $pxyEvent.MessageTraceId      = if($evtd.MessageTraceId){$evtd.MessageTraceId} ;#  f915afcc-f5ea-4f2a-3e0a-08dd87a23f8e
                                    $pxyEvent.StartDate           = if($evtd.StartDate){$evtd.StartDate} ;#  4/29/2025 3:52:37 PM
                                    $pxyEvent.EndDate             = if($evtd.EndDate){$evtd.EndDate} ;#  5/1/2025 3:52:37 PM
                                    $pxyEvent.Index               = $cndx++ ;#  9
                                #} ; 
                                
                                $gsmAggr += [pscustomobject]$pxyEvent ;
                            } ; 


                        }else{
                            $smsg = "UNABLE TO Get-xoMessageTraceDetail on $($gsmsg.MessageId)!" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        } ; 

                        #$smsg = "$($sBnr3.replace('~v','~^').replace('v~','^~'))`n" ;
                        #if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H3 } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;   
                    } ; 

                    $smsg = "`n`n#*------^  GettingStatus's Attempt to Re-Resolve via Get-xoMessageTraceDetail (up to last $($MessageTraceDetailLimit) messages)  ^------`n`n" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                } ;
                $hReports.add('MsgsGetStatusDetail',$gsmAggr) ;
                #endregion statGETSTAT  ; #*------^ END statGETSTAT  ^------

                if(test-path -path $ofile){
                    $smsg = "(log file confirmed)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    Resolve-Path -Path $ofile | select -expand Path | out-clipboard ;
                    $smsg = "$($Msgs.count) matches output to:`n'$($ofile)'`n(copied to CB)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                } else { "MISSING MsgTrc LOG FILE!" } ;
                
                if($Detailed){
                    if($msgs.count -gt $MessageTraceDetailLimit){
                        $smsg = "$($msgs.count) EXCEEDS `$MessageTraceDetailLimit:$($MessageTraceDetailLimit)!.`nget-MTD'ing only most recent $($MessageTraceDetailLimit) msgs...!"
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        #$mtdmsgs = $msgs | select -last $MessageTraceDetailLimit ; 
                        # should downgroup mtd senders,recipients just like quar senders
                        if($RecipientAddress -OR $SenderAddress){
                            if($RecipientAddress -AND -not $SenderAddress){
                                $smsg = "-RecipientAddress: $($RecipientAddress) with -Detail: limited SenderAddress gxmtd expansion to lastest $($QuarExpandLimitPerSender)/Sender" ; 
                                $smsg += "`n(condensing traffic...)" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                $DtlSendersGrouped  = $msgs | group SenderAddress | select Count,Name ;
                                $mtdmsgs = @() ; 
                                foreach($QSName in $DtlSendersGrouped.name){
                                    $mtdmsgs += @($msgs | ?{$_.SenderAddress -eq $QSName} | sort Received | select -last $QuarExpandLimitPerSender) ; 
                                } ; 
                            }elseif($SenderAddress -AND -not $RecipientAddress){
                                $smsg = "-SenderAddress: $($SenderAddress) with -Detail: limited RecipientAddress gxmtd expansion to latest $($QuarExpandLimitPerSender)/RecipientAddress" ; 
                                $smsg += "`n(condensing traffic...)" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                $DtlRecipientsGrouped  = $msgs | group recipientaddress | select Count,Name ;
                                foreach($QSName in $DtlRecipientsGrouped.name){
                                    $mtdmsgs += @($msgs | ?{$_.recipientaddress -eq $QSName} | sort Received | select -last $QuarExpandLimitPerSender) ; 
                                } ; 
                            }else{
                                # both, just do base limit                           
                                $mtdmsgs = $msgs | select -last $MessageTraceDetailLimit ; 
                            } ;
                            $smsg = "Reducing net Get-xoMessageTraceDetail lookups to last $($MessageTraceDetailLimit) messages " ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            $mtdmsgs = $mtdmsgs | select -last $MessageTraceDetailLimit ; 
                        }else{
                            # just do the last of whole set
                            $smsg = "Reducing net Get-xoMessageTraceDetail lookups to last $($MessageTraceDetailLimit) messages " ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            $mtdmsgs = $msgs | select -last $MessageTraceDetailLimit ; 
                        } ; 
                    } else { $mtdmsgs = $msgs }  ; 
                    $smsg = "`n[$(($msgs|measure).count)msgs]|=>Get-xoMessageTraceDetail:" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                    #$mtds = $mtdmsgs | Get-xoMessageTraceDetail ;
                    # 9:22 AM 5/2/2025 above isn't returning Get-xoMessageTraceDetail results, loop/throttle it
                    $mtds = pull-GetxoMessageTraceDetail -Messages $mtdmsgs ; 

                    $mtdRpt = @() ; 
                    if($DetailedReportRuleHits){
                        $TRules = Get-xotransportrule  ; 
                        $smsg = "Checking for `$mtds|`?{$_.Event -eq 'Transport rule'}:" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    } ; 
                    $prpMTDSUM = 'DateLocal','Event','Action','Detail','TRuleName','MessageId','SenderAddress','RecipientAddress' ; 

                    foreach($mtd in $mtds){
                        $mtdsummary = [ordered]@{
                            Date = $mtd.Date ; 
                            DateLocal = ([datetime]$mtd.Date).ToLocalTime() ; 
                            Event = $mtd.Event ;
                            Action = $mtd.Action ;
                            Detail = $mtd.Detail ;
                            TRuleName = $null ; 
                            TRuleDetails = $null ; 
                            MessageId = $mtd.MessageId ; 
                            SenderAddress = if($mtd.SenderAddress){
                                                $mtd.SenderAddress ; 
                                            }else{
                                                $mtdm.SenderAddress ; 
                                            }
                            RecipientAddress =  if($mtd.RecipientAddress){
                                                $mtd.RecipientAddress
                                            }else{
                                                $mtdm.RecipientAddress ; 
                                            } 
                        } ; 
                        if($DetailedReportRuleHits){
                            if ($mtd| ?{$_.Event -eq 'Transport rule'}){
                                # $smsg = "`n$(($mtd | fl Date,Event,Action,Detail |out-string).trim())" ; 
                                if($mtd.detail -match "Transport\srule:\s'',\sID:\s\('(\w{8}-\w{4}-\w{4}-\w{4}-\w{12})'\)"){
                                    #$smsg = "$(($trules|?{$_.guid -eq $matches[1]}  | format-list Name,State,Priority|out-string).trim())" ; 
                                    $ruledetail = $trules|?{$_.guid -eq $matches[1]}  | select Name,Guid,State,Priority ; 
                                    $mtdsummary.TRuleName = $ruledetail.Name ; 
                                    $mtdsummary.TRuleDetails = $ruledetail ; 
                                } ; 
                                #$smsg = "`n$(($mtdsummary| fl Date,Event,Action,Detail,TRuleName |out-string).trim())" ; 
                                # blank above
                                $smsg = "`n$(($mtdsummary | select $prpMTDSUM  | fl |out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            } else {
                                $smsg = "(no Event -eq 'Transport rule' matches in details run)" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            }; 
                        } else {
                            $smsg = "`n$(($mtdsummary| fl Date,Event,Action,Detail|out-string).trim())" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        }  ;
   
                        $mtdRpt += New-Object PSObject -Property $mtdsummary;
                        #[pscustomobject]$mtdsummary ; 
                    } ; 
                
                    if($mtds){
                        if($DoExports){
                            $ofileMTD = $ofile.replace('-MsgTrc','-MTD') ;
                            $smsg = "($(($mtds|measure).count) mtds | export-csv $($ofileMTD))" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            TRY{
                                $mtds | select $propsMTD | export-csv -notype -path $ofileMTD -ea Stop ;
                                $smsg = "export-csv'd to:`n$((resolve-path $ofileMTD).path)" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            } CATCH {
                                $ErrTrapd=$Error[0] ;
                                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } ; 
                            if(test-path -path $ofileMTD){
                                $smsg = "(log file confirmed)" ;
                                $smsg += "`n$($mtds.count) MTD matches output to:`n'$($ofileMTD)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                            } else { 
                                $smsg = "MISSING MTD LOG FILE!" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            } ;

                        } ; 

                        $hReports.add('MTDetails',$mtds) ; 

                        if($DoExports){
                            # add the csvfilename
                            $smsg = "(adding `$hReports.MTDCSVFile:$($ofileMTD))" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            $hReports.add('MTDCSVFile',$MTDCSVFile) ; 
                        } ; 

                        #$hReports.add('MTDReport',$ofileMTD) ; 
                        # mtdreport
                        $hReports.add('MTDReport', $mtdRpt) ; 

                        if($DoExports){
                            $ofileMTDRpt = $ofile.replace('-MsgTrc','-MTDRpt') ;
                            TRY{
                                $mtdRpt | export-csv -notype -path $ofileMTDRpt -ea Stop ;
                            } CATCH {
                                $ErrTrapd=$Error[0] ;
                                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } ; 
                            if(test-path -path $ofileMTD){
                                $smsg = "(log file confirmed)" ;
                                $smsg += "`n$($mtdRpt.count) MTDReport matches output to:`n'$($ofileMTDRpt)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                # add the csvfilename
                                $smsg = "(adding `$hReports.MTDRptCSVFile:$($ofileMTDRpt))" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                $hReports.add('MTDRptCSVFile',$ofileMTDRpt) ; 

                            } else { 
                                $smsg = "MISSING MTD LOG FILE!" 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            } ;
                        } ; 
                   } ;
                } ;
            } else {
                $smsg = "NO MATCHES RETURNED from MT Query" ;
                $smsg += "`n$(($pltGXMT|out-string).trim())" ; 
                $smsg += "`n(net of any relevant ConnectorId or other postfilters)"  ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            } ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # it's not outputting the underlying cmdlet error, try to force it :
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ; 

        
    } ;  # PROC-E
    END {
        if($SimpleTrack -AND ($hReports.Keys.Count -gt 0)){
            $smsg = "-SimpleTrack specified: Only returning net message tracking set to pipeline" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            $msgs | write-output ; 
        } else { 
            $smsg = "(no -SimpleTrack: returning full summary object to pipeline)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            if($hReports.Keys.Count -gt 0){
                # convert the hashtable to object for output to pipeline
                #$Rpt += New-Object PSObject -Property $hReports ;
                $smsg = "(Returning summary object to pipeline)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                
                TRY{
                    New-Object -TypeName PsObject -Property $hReports | write-output ; 
                    # export the entire return object into xml
                    $smsg = "(exporting `$hReports summary object to xml:$($ofile.replace('.csv','.xml')))" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    New-Object -TypeName PsObject -Property $hReports | export-clixml -path $ofile.replace('.csv','.xml') -ea STOP
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ; 
            } else { 
                $smsg = "Unpopulated `$hReports, skipping output to pipeline" ; 
                # 9:36 AM 10/21/2025 typo fix, WARNING->WARN
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                $false | write-output ; 
            } ;  
        } ; 
    } ; 
}

#*------^ Get-EXOMessageTraceExportedTDO.ps1 ^------


#*------v get-ExoMessageTraceSourceType.ps1 v------
function get-ExoMessageTraceSourceType {
<#
    .SYNOPSIS
    get-ExoMessageTraceSourceType - Provides a prefab array indexed hash of Exchange-Online Get-xoMessageTrace Source Types Note: This is a static non-query-based list of sourcess. The function must be manually updated to accomodate MS MessageTrace sources types changes over time.
    .PARAMETER Mailboxes
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2024-05-17
    FileName    : get-ExoMessageTraceSourceType.ps1
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-ex2010
    Tags        : Powershell,ExchangeOnline,MessageTrace,Reporting
    REVISIONS
    * 3:54 PM 5/17/2024 adapted from vxo\get-ExoMessageTraceEventType(); ; added array support on the EventID & Type
    .DESCRIPTION
    get-ExoMessageTraceSourceType - Provides a prefab array indexed hash of Exchange-Online Get-xoMessageTrace Source Types Note: This is a static non-query-based list of Sources. The function must be manually updated to accomodate MS MessageTrace Source types changes over time.
    Run it without a -Source and it returns the entire indexed hash to the pipeline

    
    .PARAMETER Source
    MessageTrace Sourceid to be resolved to details[-Source 'AGENTINFO']
    .PARAMETER Type
    Optional type classification subset to be returned from the entire Source set[-Type 'Problem']
    .EXAMPLE
    PS> $SourceInfo = get-ExoMessageTraceSourceType -Source AGENTINFO -verbose ; 
    PS> $SourceInfo | out-string ; 

        SourceValue Description                                                                                    Type     
        ----------- -----------                                                                                    ----     
        SMTP        The message was submitted by the SMTP send or SMTP receive component of the transport service. transport

    Retrieve Resolve 'SMTP' to it's stock MS description & type, and output to console
    .EXAMPLE
    PS> write-verbose 'Retrive the entire indexed hash of Source details, and output the results to console' ; 
    PS> $SourcesDetail = get-ExoMessageTraceSourceType ; 
    PS> $SourcesDetail | out-string ; 

        Name                           Value                                                                                                                                                                                                                             
        ----                           -----                                                                                                                                                                                                                             
        AGENTINFO                      @{EventName=AGENTINFO; Description=This event is used by transport agents to log custom data.; Type=info}                   
        ...[TRIMMED]...
        TRANSFER                       @{EventName=TRANSFER; Description=Recipients were moved to a forked message because of content conversion, message recipient limits, or agents. Sources include ROUTING or QUEUE.; Type=info}                                     

    Retrive the entire indexed hash of EventID details, and output the results to console. 
    PS> $SourcesDetail['SMTP'] | out-string ; 

        SourceValue Description                                                                                    Type     
        ----------- -----------                                                                                    ----     
        SMTP        The message was submitted by the SMTP send or SMTP receive component of the transport service. transport

    PS> $SourcesDetail.values | group type |  ft -a count,name 

        Count Name     
        ----- ----     
            6 problem  
           12 info     
            2 transport

    PS> $rgxSrcProblem = ('(' + (($SourcesDetail.values | ?{$_.type -eq 'problem'} | select -expand SourceValue |%{[regex]::escape($_)}) -join '|') + ')') ;
    PS> $rgxSrcTransp = ('(' + (($SourcesDetail.values | ?{$_.type -eq 'transport'} | select -expand SourceValue|%{[regex]::escape($_)}) -join '|') + ')') ;
    PS> $rgxSrcInfo =  ('(' + (($SourcesDetail.values | ?{$_.type -eq 'info'} | select -expand SourceValue|%{[regex]::escape($_)}) -join '|') + ')') ;
    PS> $rgxSrcProblem

        (ADMIN|APPROVAL|BOOTLOADER|DSN|PICKUP|POISONMESSAGE)

    PS> $rgxSrcInfo

        (AGENT|DNS|GATEWAY|MAILBOXRULE|MEETINGMESSAGEPROCESSOR|ORAR|PUBLICFOLDER|QUEUE|REDUNDANCY|RESOLVER|ROUTING|SAFETYNET)

    PS> $rgxSrcTransp 

        (SMTP|STOREDRIVER)

    Retrieve the entire set of defined event-id's returned as an indexed hash. Output the hash to console; lookup and return the AGENTINFO event-id details; group the assigned types; Build & output regexes for the Problem, Transport & Info types.
    .EXAMPLE
    PS> $SrcInfo = get-ExoMessageTraceSourceType -type 'problem','transport' ; 
    PS> $SrcInfo | write-output ;

        SourceValue   Description                                                                                                                                                          Type     
        -----------   -----------                                                                                                                                                          ----     
        ADMIN         The event source was human intervention. For example, an administrator used Queue Viewer to delete a message, or submitted message files using the Replay directory. problem  
        APPROVAL      The event source was the approval framework that's used with moderated recipients. For more information, see Manage message approval.                                problem  
        BOOTLOADER    The event source was unprocessed messages that exist on the server at boot time. This is related to the LOAD event type.                                             problem  
        DSN           The event source was a delivery status notification (also known as a DSN, bounce message, non-delivery report, or NDR).                                              problem  
        PICKUP        The event source was the Pickup directory. For more information, see Pickup Directory and Replay Directory.                                                          problem  
        POISONMESSAGE The event source was the poison message identifier. For more information about poison messages and the poison message queue, see Queues and messages in queues       problem  
        SMTP          The message was submitted by the SMTP send or SMTP receive component of the transport service.                                                                       transport
    
    PS> write-verbose 'Create a regex from the Source names returned' ;
    PS> $rgxEvtIDTransProb = ('(' + (($SrcInfo.SourceValue |%{[regex]::escape($_)}) -join '|') + ')') ;
    PS> $rgxEvtIDTransProb

        (ADMIN|APPROVAL|BOOTLOADER|DSN|PICKUP|POISONMESSAGE|SMTP|STOREDRIVER)

    Retrieve the Type:Problem & Transport EventIDs and build a regex out of the combonation
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    #Requires -Modules verb-IO, verb-logging, verb-Text
    [OutputType('System.Collections.Hashtable')]
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory=$FALSE,HelpMessage="Optional MessageTrace Source Value to be resolved to details[-Source 'AGENTINFO']")]
            [ValidateNotNullOrEmpty()]
            [string[]]$Source,
        [Parameter(Mandatory=$FALSE,HelpMessage="Optional type classification subset to be returned from the entire Source set[-Type 'Problem']")]
            [ValidateSet('transport','problem','info')]
            [string[]]$Type
    ) ;
    if($Source -AND $Type){
        $smsg = "Both -Source & -Type specified: Please specify one or the other (or none, to return all defined Sources)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    } ; 
    ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
    $verbose = ($VerbosePreference -eq "Continue") ;
    
    # check if using Pipeline input or explicit params:
    if ($PSCmdlet.MyInvocation.ExpectingInput) {
        write-verbose "Data received from pipeline input: '$($InputObject)'" ;
    } else {
        # doesn't actually return an obj in the echo
        #write-verbose "Data received from parameter input: '$($InputObject)'" ;
    } ;
    

    # input table of Exchange Online assignable licenses that include a UserMailbox:
    $ExoSourcesTbl = @"
|SourceValue |Description|Type|
|---|---|---|
|ADMIN |The event source was human intervention. For example, an administrator used Queue Viewer to delete a message, or submitted message files using the Replay directory.|problem|
|AGENT |The event source was a transport agent.|info|
|APPROVAL |The event source was the approval framework that's used with moderated recipients. For more information, see Manage message approval.|problem|
|BOOTLOADER |The event source was unprocessed messages that exist on the server at boot time. This is related to the LOAD event type.|problem|
|DNS |The event source was DNS.|info|
|DSN |The event source was a delivery status notification (also known as a DSN, bounce message, non-delivery report, or NDR).|problem|
|GATEWAY |The event source was a Foreign connector. For more information, see Foreign Connectors.|info|
|MAILBOXRULE |The event source was an Inbox rule. For more information, see Inbox rules.|info|
|MEETINGMESSAGEPROCESSOR |The event source was the meeting message processor, which updates calendars based on meeting updates.|info|
|ORAR |The event source was an Originator Requested Alternate Recipient (ORAR). You can enable or disable support for ORAR on Receive connectors using the OrarEnabled parameter on the New-ReceiveConnector or Set-ReceiveConnector cmdlets.|info|
|PICKUP |The event source was the Pickup directory. For more information, see Pickup Directory and Replay Directory.|problem|
|POISONMESSAGE |The event source was the poison message identifier. For more information about poison messages and the poison message queue, see Queues and messages in queues|problem|
|PUBLICFOLDER |The event source was a mail-enabled public folder.|info|
|QUEUE |The event source was a queue.|info|
|REDUNDANCY |The event source was Shadow Redundancy. For more information, see Shadow redundancy in Exchange Server.|info|
|RESOLVER |The event source was the recipient resolution component of the categorizer in the Transport service. For more information, see Recipient resolution in Exchange Server.|info|
|ROUTING |The event source was the routing resolution component of the categorizer in the Transport service.|info|
|SAFETYNET |The event source was Safety Net. For more information, see Safety Net in Exchange Server.|info|
|SMTP |The message was submitted by the SMTP send or SMTP receive component of the transport service.|transport|
|STOREDRIVER |The event source was a MAPI submission from a mailbox on the local server.|transport|
"@ ;
    $ExoSources = $ExoSourcesTbl | convertfrom-markdowntable ;

    # building a CustObj (actually an indexed hash) with the SourceValue|Descriptions. The 'index' for each event, is the SourceValue 
    $smsg = "(converting $(($ExoSources|measure).count) Get-xoMessageTrace-supported Source Value types, to indexed hash)" ;     
    if($verbose){
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    } ; 
    if($host.version.major -gt 2){$hExoSources = [ordered]@{} } 
    else { $hExoSources = @{} } ;
    
    $ttl = ($ExoSources|measure).count ; $Procd = 0 ; 
    foreach ($EID in $ExoSources){
        $Procd ++ ; 
        $sBnrS="`n#*------v PROCESSING : ($($Procd)/$($ttl)) $($EID.SourceValue) v------" ; 
        $smsg = $sBnrS ; 
        if($verbose){
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
        
        $name =$EID.SourceValue ; 
        $hExoSources[$name] = $EID ; 
        if($EID.Description -match '<br/>'){
            $hExoSources[$name].Description = $hExoSources[$name].Description -replace '<br/>','\n'
        } ;

        $smsg = "$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
        if($verbose){
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
    } ;  # loop-E

    if($hExoSources){
        if($Source){
            foreach($Src in $Source){
                if($hexoSources[$Src]){
                    $smsg = "(Returning matched Source:$($Src) details to pipeline)" ; 
                    if($verbose){
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ; 
                    $hexoSources[$Src] | Write-Output ; 
                }else {
                    $smsg = "Unable to resolve Source: $($Src) to a matching documented Source Value string!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    throw $smsg ; 
                } ; 
            } ; 
        }elseif($Type){
            foreach($Typ in $Type){
                $smsg = "(Returning matched Type:$($Typ) event details to pipeline)" ; 
                if($verbose){
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ; 
                $hexoSources.values | ?{$_.type -eq $typ} | write-output 
            } ; 
        }else{
            $smsg = "(Returning full set of summary objects to pipeline)" ; 
            if($verbose){
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
            $hexoSources | Write-Output ;
        } ; 
    } else {
        $smsg = "NO RETURNABLE `$hExoSources OBJECT!" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        THROW $smsg ;
    } ; 
}

#*------^ get-ExoMessageTraceSourceType.ps1 ^------


#*------v get-EXOMsgTraceDetailed.ps1 v------
function get-EXOMsgTraceDetailed {
    <#
    .SYNOPSIS
    get-EXOMsgTraceDetailed - Run a MessageTrace with output summarizing, export to csv, and optional followup with MessageTraceDetail, summarize (expand TransportRules opt), and export to csv
    .NOTES
    Version     : 2.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-11-05
    FileName    : get-EXOMsgTraceDetailed.ps1
    License     : MIT License
    Copyright   : (c) 2024 Todd Kadrie
    Github      : https://github.com/tostka/verb-EXO
    Tags        : Powershell,Exchange,ExchangeOnline,Tracking,Delivery
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 12:54 PM 10/14/2024 added fully enumerated splat demo    
    * 2:00 PM 10/7/2024 
    * 3:22 PM 9/27/2024 substantial retool, to make it a single goto middleware func for msgtracks, appears working; added params to better approx both Get-xoMessageTrace and existing 7psmsgtrkexo BP calls;
        Added aliases for all Get-MessageTrackingLog & new-xoHistoricalSearch equiv params as well (to cut down on confusion, it takes any synonym for the field)
    * 4:38 PM 1/24/2022 retooled start/enddateto convert 'local tz' inputs, to t 
        GMT/UTC; and track/convert content back to local time ; added testing of 
        msgtrace splat params, only when populated ;  updated CBH & Examples (covering 
        variant formats of booking response msgs); converted hash summary output to 
        psobject ; ren -doMTD -> -Detailed ; validate $days is a positive integer;
        swapped strings with new central constants: $sFulltimeStamp, $sFiletimestamp
    * 4:04 PM 11/19/2021 flipped wh,wv,ww to wlt - added -days ; updated logic testing for dates/days against MS 10d limit (stored as new constant) ; checks out functional; needs 7pswlt rplcments of write-*
    * 12:40 PM 11/15/2021 - expanded subject -match/-like to post test and use the opposing option where the detected failed to yield filtered msgs. 
    * 3:46 pm 11/12/2021 - added -Subject test-IsRegexPattern() and autoflip tween -match & -like post filtering. 
    * 2:37 PM 11/5/2021 init
    .DESCRIPTION
    get-EXOMsgTraceDetailed - Run a MessageTrace with output summarizing, export to csv, and optional followup with MessageTraceDetail, summarize (expand TransportRules opt), and export to csv
    This function wraps the EXO get-MessageTrace & get-MessageTraceDetail, to run structured message traces with export to CSV, optional follow-on Get-MessageTraceDetail, post-filtering on specified Subject, and outputs a summary hashtable object with the following:

        Returns summary object to pipeline, with following properties:
        [obj].MTMessages: MessageTracking messages matched
        [obj].MTMessagesCSVFile full path to exported MTMessages as csv file
        [obj].MTDetails: MessageTrackingDetail refactored summary of MTD as transactions
        [obj].MTDCSVFile: full path to exported MTDs as csv file 
        [obj].MTDReport: expanded Detail summary output
        [obj].MTDRptCSVFile: full path to exported MTDReport as csv file 
        > Note: As of 4/2021, MS wrecked utility of get-MessageTrace, dropping range from 30 days to 10 days, with silent failure to return -gt 10d (not even a range error). 
        > So there's not a lot of utility to supporting -Enddate (date) -Days 11, to pull historical 11day windows: If it's more than 10d old, you've got to use HistSearch regardless. 

    .PARAMETER ticket
    Ticket [-ticket 999999]
    .PARAMETER Requestor
    Ticket Customer email identifier. [-Requestor 'fname.lname@domain.com']
    .PARAMETER Tag
    Tag string (Variable Name compatible: no spaces A-Za-z0-9_ only) that is used for Variables and export file name construction. [-Tag 'LastDDGSend']
    .PARAMETER SenderAddress
    SenderAddress (an array runs search on each)[-SenderAddress addr@domain.com]
    .PARAMETER RecipientAddress
    RecipientAddress (an array runs search on each)[-RecipientAddress addr@domain.com]
    .PARAMETER StartDate
    Start of range to be searched[-StartDate '11/5/2021 2:16 PM']
    .PARAMETER EndDate
    End of range to be searched (defaults to current time if unspecified)[-EndDate '11/5/2021 5:16 PM']
    .PARAMETER Days
    Days to be searched, back from current time(Alt to use of StartDate & EndDate; Note:MS won't search -gt 10 days)[-Days 7]
    .PARAMETER Subject
    Subject of target message (emulated via post filtering, not supported param of Get-xoMessageTrace) [-Subject 'Some subject']
    .PARAMETER Status
    The Status parameter filters the results by the delivery status of the message (None|GettingStatus|Failed|Pending|Delivered|Expanded|Quarantined|FilteredAsSpam),an array runs search on each). [-Status 'Failed']
    .PARAMETER MessageId
    MessageId of target message(s) (include any <> and enclose in quotes; an array runs search on each)[-MessageId '<nnnn-nn.xxx....outlook.com>']
    .PARAMETER MessageTraceId
    The MessageTraceId parameter can be used with the recipient address to uniquely identify a message trace and obtain more details. A message trace ID is generated for every message that's processed by the system. [-MessageTraceId 'nnnneacn-ccnn-ndnb-annn-nednfncnnnna']
    .PARAMETER FromIP
    The FromIP parameter filters the results by the source IP address. For incoming messages, the value of FromIP is the public IP address of the SMTP email server that sent the message. For outgoing messages from Exchange Online, the value is blank. [-FromIP '123.456.789.012']
    .PARAMETER ToIP
    The ToIP parameter filters the results by the destination IP address. For outgoing messages, the value of ToIP is the public IP address in the resolved MX record for the destination domain. For incoming messages to Exchange Online, the value is blank. [-ToIP '123.456.789.012']
    .PARAMETER SimpleTrack
    switch to just return the net messages on the initial track (no Fail/Quarantine, MTDetail or other post-processing summaries) [-simpletrack]
    .PARAMETER DetailedReportRuleHits
    switch to do Summarize & Expansion of any MTD TransportRule events (defaults true) [-DetailedReportRuleHits]
    .PARAMETER MessageTraceDetailLimit
    Integer number of maximum messages to be follow-up MessageTraceDetail'd [-MessageTraceDetailLimit 20]
    .PARAMETER NoQuarCheck
    switch to do Summarize & Expansion of any MTD TransportRule events (defaults true) [-NoQuarCheck]
    .PARAMETER DoExports
    switch to perform configured csv exports of results (defaults true) [-DoExports]
    .PARAMETER Detailed
    switch to perform MessageTrackingDetail pass, after intial MessageTrace (up to limit specified in -MessageTraceDetailLimit (defaults true) [-Detailed]
    .PARAMETER TenOrg
    Tenant Tag (3-letter abbrebiation)[-TenOrg 'XYZ']
    .PARAMETER Credential
    Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]
    .PARAMETER UserRole
    Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER Silent
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    None. Returns no objects or output (.NET types)
    System.Boolean
    [| get-member the output to see what .NET obj TypeName is returned, to use here]
    .EXAMPLE
        PS> $results = get-EXOMsgTraceDetailed -ticket 651268 -SenderAddress='SENDER@DOMAIN.COM' -RecipientAddress='RECIPIENT@DOMAIN.COM' -StartDate='11/1/2021  4:35:39 PM' -Subject 'Accepted: Exmark/RLC Bring Up' -verbose ;
        # dump messages table and group Status
        $results.MTMessages | ft -a ReceivedLocal,Sender*,Recipient*,subject,*status,*ip ;
        $results.MTMessages | group status | ft -auto count,name ;
        # dump MessageTraceDetail table
        $results.MTDetails | sort Date | ft -a date,event,action,detail,sender*,recipient* ;
        # dump MessageTraceDetail Summary Report as table
        $results.MTDReport| sort date | ft -a DateLocal,Event,Action,Detail ;
        # echo csv output files
        $results.MTMessagesCSVFile ;
        $results.MTDRptCSVFile ;
        Run a typical MessageTrace on sender & recipient, specified start/end dates, and subject, with default 100-message MessageTraceDetail report, with verbose output.
        And then demo of working with the data returned
        .EXAMPLE
        PS> $results = get-EXOMsgTraceDetailed -ticket 651268 -SenderAddress='ATTENDEE@DOMAIN.COM' -RecipientAddress='ORGANIZER@DOMAIN.COM' -StartDate='11/1/2021  4:35:39 PM' -Subject 'Accepted: [MEETINGSUBJ]' -verbose ;
        Run a Meeting ACCEPTED MessageTrace - 
            no booking conflict, 
            From: Attendee To: Originator
            Subject: 'Accepted: [MEETINGSUBJ]'
        - with default 100-message MessageTraceDetail report, with verbose output.
        .EXAMPLE
        PS> $results = get-EXOMsgTraceDetailed -ticket 651268 -SenderAddress='ROOM@DOMAIN.COM' -RecipientAddress='ORGANIZER@DOMAIN.COM' -StartDate='11/1/2021  4:35:39 PM' -Subject 'Declined: [MEETINGSUBJ]' -verbose ;
        Run a Meeting DECLINED MessageTrace - 
             Booking conflict, 
             From: Room, To: Originator (and copy to any SendOnBehalf delegate that actually created the meeting)
             Subject is: 'Declined: [MEETINGSUBJ]'
        - with default 100-message MessageTraceDetail report, with verbose output.
        .EXAMPLE
        PS> $results = get-EXOMsgTraceDetailed -ticket 651268 -SenderAddress='ROOM@DOMAIN.COM' -RecipientAddress='ORGANIZER@DOMAIN.COM' -StartDate='11/1/2021  4:35:39 PM' -Subject 'Tentative: [MEETINGSUBJ]' -verbose ;
        Run a Meeting TENTATIVE response (Moderated resource), MessageTrace, - 
            reflects a AllRequestinPolicy:`$true resource ;
            w ResourceDelegates; 
            no booking conflict;
            but pending ResDelegate approval
            From: Room, To: Originator (and copy to any SendOnBehalf delegate that actually created the meeting)
            Subject is: 'Tentative: [MEETINGSUBJ]'
         -  with default 100-message MessageTraceDetail report, with verbose output. 
        .EXAMPLE
        PS> $results = get-EXOMsgTraceDetailed -ticket 651268 -SenderAddress='ORGANIZER@DOMAIN.COM' -RecipientAddress='RESDELEGATE@DOMAIN.COM' -StartDate='11/1/2021  4:35:39 PM' -Subject 'FW: [MEETINGSUBJ]' -verbose ;
        Run a Meeting 'FW: [MEETINGSUBJ]' MODERATION REQUEST MessageTrace - 
            TO: ResourceDelegates (redirected Forward) FROM: ORGANIZER
            reflects a Resource with: AllRequestinPolicy:`$true; 
            ResourceDelegates configured; 
            no booking conflict, but pending ResDelegate approval 
        - MessageTrace (which will come from Meeting Originator email address), to the ResDelegate addresses, with default 100-message MessageTraceDetail report, with verbose output.
        .EXAMPLE
        PS> $pltGEXOMT=[ordered]@{
        PS>     Ticket = '999999' ; 
        PS>     Requestor = 'fname.lname@domain.tld' ; 
        PS>     Tag = 'TestGxmtD' ;
        PS>     senderaddress = 'fname.lname@domain.tld','fname.lname@domain2.TLD' ;
        PS>     StartDate = (get-date ).AddDays(-1) ;
        PS>     EndDate = (get-date ) ;
        PS>     erroraction = 'STOP' ;
        PS>     verbose = $true ; 
        PS> } ;
        PS> $smsg = "get-EXOMsgTraceDetailed w`n$(($pltGEXOMT|out-string).trim())" ;
        PS> if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        PS> $results = get-EXOMsgTraceDetailed @pltGEXOMT ; 
        PS> $results.MTMessages | ft -a ReceivedLocal,Sender*,Recipient*,subject,*status,*ip ;
        Splatted demo
        .EXAMPLE
        PS> $pltGEXOMT=[ordered]@{
        PS>     Ticket = '99999' ;
        PS>     Requestor = 'fname.lname@domain.tld' ; 
        PS>     Tag = 'AnyTraffic' ;
        PS>     senderaddress = '*@DOMAIN.COM' ;
        PS>     StartDate = (get-date ).AddDays(-10) ;
        PS>     EndDate = (get-date ) ;
        PS>     erroraction = 'STOP' ;
        PS>     verbose = $true ;
        PS> } ;
        PS> $smsg = "get-EXOMsgTraceDetailed w`n$(($pltGEXOMT|out-string).trim())" ;
        PS> if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        PS> $results = get-EXOMsgTraceDetailed @pltGEXOMT ; 
        Demo search on wildcard sender address (using * wildcard character)
        .EXAMPLE
        PS> $pltGEXOMT=[ordered]@{
        PS>     Ticket = '999999' ; 
        PS>     Requestor = 'fname.lname@domain.tld' ; 
        PS>     Tag = 'SEARCHTAG' ;
        PS>     senderaddress = 'fname.lname@domain.tld','fname.lname@domain2.TLD' ;
        PS>     StartDate = (get-date ).AddDays(-1) ;
        PS>     EndDate = (get-date ) ;
        PS>     RecipientAddress = 'fname.lname@domain.tld'  ; 
        PS>     Days = 10 ; 
        PS>     subject = 'MSGSUBJECT' ; 
        PS>     Status = $null ; # 'None|GettingStatus|Failed|Pending|Delivered|Expanded|Quarantined|FilteredAsSpam'
        PS>     MessageId = '<NNNN.NA.NNNNNNNNNNNN@SUB.DOMAIN.TLD>'; 
        PS>     MessageTraceId = 'nnnnccdn-nnen-nfnn-nnan-nnnendnebnce' ; 
        PS>     FromIP = $null ; 
        PS>     ToIP = $null ; 
        PS>     SimpleTrack = $false ;
        PS>     DetailedReportRuleHits= $true ; 
        PS>     NoQuarCheck = $false ; 
        PS>     DoExports=$TRUE ; 
        PS>     Detailed = $false ; 
        PS>     #TenOrg = global:o365_TenOrgDefault ; 
        PS>     #Credential = $null ;
        PS>     #UserRole = @('SIDCBA','SID','CSVC') ; 
        PS>     #useEXOv2 = $true
        PS>     #silent = $false ;
        PS>     verbose = $true ; 
        PS> } ;
        PS> $smsg = "get-EXOMsgTraceDetailed w`n$(($pltGEXOMT|out-string).trim())" ;
        PS> if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        PS> $results = get-EXOMsgTraceDetailed @pltGEXOMT ; 
        Fully eunmerated splat parameters demo
        .LINK
        https://docs.microsoft.com/en-us/powershell/module/exchange/get-messagetrace
        .LINK
        https://docs.microsoft.com/en-us/powershell/module/exchange/get-messagetracedetail
        .LINK
        https://github.com/tostka/verb-exo
    #>
    #Requires -Modules AzureAD, ExchangeOnlineManagement 
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\sregex\sexpr")][ValidateSet("US","GB","AU")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)]#positiveInt:[ValidateRange(0,[int]::MaxValue)]#negativeInt:[ValidateRange([int]::MinValue,0)][ValidateCount(1,3)]
    [CmdletBinding(DefaultParameterSetName='Days')]
    PARAM(
        [Parameter(Mandatory=$false,HelpMessage="Ticket [-ticket 999999]")]
            [ValidateNotNullOrEmpty()]    
            [string]$ticket,
         [Parameter(HelpMessage="Ticket Customer email identifier. [-Requestor 'fname.lname@domain.com']")] 
            [Alias('UID')]
            [string]$Requestor,
        [Parameter(HelpMessage="Tag string (Variable Name compatible: no spaces A-Za-z0-9_ only) that is used for Variables and export file name construction. [-Tag 'LastDDGSend']")] 
            [ValidatePattern('^[A-Za-z0-9_]*$')]
            [string]$Tag,
        [Parameter(HelpMessage="SenderAddress (an array runs search on each)[-SenderAddress addr@domain.com]")]
            [Alias('Sender')]
            [string[]]$SenderAddress, # MultiValuedProperty
        [Parameter(HelpMessage="RecipientAddress (an array runs search on each)[-RecipientAddress addr@domain.com]")]
            [Alias('Recipients')]
            [string[]]$RecipientAddress, # MultiValuedProperty
        [Parameter(ParameterSetName='Dates',HelpMessage="Start of range to be searched[-StartDate '11/5/2021 2:16 PM']")]
            [Alias('Start')]
            [DateTime]$StartDate,
        [Parameter(ParameterSetName='Dates',HelpMessage="End of range to be searched (defaults to current time if unspecified)[-EndDate '11/5/2021 5:16 PM']")]
            [Alias('End')]
            [DateTime]$EndDate=(get-date),
        [Parameter(ParameterSetName='Days',HelpMessage="Days to be searched, back from current time(Alt to use of StartDate & EndDate; Note:MS won't search -gt 10 days)[-Days 7]")]
            #[ValidateRange(0,[int]::MaxValue)]
            [ValidateRange(0,10)] # MS won't search beyond 10, and silently returns incomplete results
            [int]$Days,
        [Parameter(HelpMessage="Subject of target message (emulated via post filtering, not supported param of Get-xoMessageTrace) [-Subject 'Some subject']")]
            [Alias('MessageSubject')]
            [string]$subject,
        [Parameter(HelpMessage="The Status parameter filters the results by the delivery status of the message (None|GettingStatus|Failed|Pending|Delivered|Expanded|Quarantined|FilteredAsSpam),an array runs search on each). [-Status 'Failed']")]
            [Alias('DeliveryStatus','EventId')]
            [ValidateSet('None','GettingStatus','Failed','Pending','Delivered','Expanded','Quarantined','FilteredAsSpam')]
            [string[]]$Status, # MultiValuedProperty
        [Parameter(HelpMessage="MessageId of target message(s) (include any <> and enclose in quotes; an array runs search on each)[-MessageId '<nnnn-nn.xxx....outlook.com>']")]
            # Get-xoMessageTrace specs <MultiValuedProperty>: "just means that you can provide multiple values (i.e. an array) as the argument to the parameter. If your users input something like alice@example.com,bob@example.com,charlie@example.com, you need to split the delims"
            [string[]]$MessageId, # MultiValuedProperty
        [Parameter(HelpMessage="The MessageTraceId parameter can be used with the recipient address to uniquely identify a message trace and obtain more details. A message trace ID is generated for every message that's processed by the system. [-MessageTraceId 'nnnneacn-ccnn-ndnb-annn-nednfncnnnna']")] 
            [Guid]$MessageTraceId,
        [Parameter(HelpMessage="The FromIP parameter filters the results by the source IP address. For incoming messages, the value of FromIP is the public IP address of the SMTP email server that sent the message. For outgoing messages from Exchange Online, the value is blank. [-FromIP '123.456.789.012']")] 
            [string]$FromIP, 
        [Parameter(HelpMessage="The ToIP parameter filters the results by the destination IP address. For outgoing messages, the value of ToIP is the public IP address in the resolved MX record for the destination domain. For incoming messages to Exchange Online, the value is blank. [-ToIP '123.456.789.012']")] 
            [string]$ToIP,
        [Parameter(HelpMessage="switch to just return the net messages on the initial track (no Fail/Quarantine, MTDetail or other post-processing summaries) [-simpletrack]")]
            [switch]$SimpleTrack,
        [Parameter(HelpMessage="switch to do Summarize & Expansion of any MTD TransportRule events (defaults true) [-DetailedReportRuleHits]")]
            [switch]$DetailedReportRuleHits= $true,
        [Parameter(HelpMessage="Integer number of maximum messages to be follow-up MessageTraceDetail'd [-MessageTraceDetailLimit 20]")]
            [int]$MessageTraceDetailLimit = 100,
        [Parameter(HelpMessage="switch to do Summarize & Expansion of any MTD TransportRule events (defaults true) [-NoQuarCheck]")]
            [switch]$NoQuarCheck,
        [Parameter(HelpMessage="switch to perform configured csv exports of results (defaults true) [-DoExports]")]
            [switch]$DoExports=$TRUE,
        [Parameter(HelpMessage="switch to perform MessageTrackingDetail pass, after intial MessageTrace (up to limit specified in -MessageTraceDetailLimit (defaults true) [-Detailed]")]
            [switch]$Detailed,
        # Service Connection Supporting Varis (AAD, EXO, EXOP)
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
            [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ;
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ;
                return $true ;
            })]
            [string[]]$UserRole = @('SIDCBA','SID','CSVC'),
            #@('SID','CSVC'),
            # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
            [switch] $useEXOv2=$true,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent
    ) ;
    <# emulate aliases on the ExoP params: Get-MessageTrackingLog -Start -End -EventId -MessageSubject -MessageId
    And HistSearch: Start-HistoricalSearch -EndDate <DateTime> -ReportTitle 
        <String> -ReportType <MessageTrace | MessageTraceDetail | DLP | TransportRule | 
        SPAM | Malware> -StartDate <DateTime> [-DeliveryStatus <String>] [-Direction 
        <All | Sent | Received>] [-DLPPolicy <MultiValuedProperty>] [-Locale 
        <CultureInfo>] [-MessageID <MultiValuedProperty>] [-NotifyAddress 
        <MultiValuedProperty>] [-OriginalClientIP <String>] [-RecipientAddress 
        <MultiValuedProperty>] [-SenderAddress <MultiValuedProperty>] [-TransportRule 
        <MultiValuedProperty>] 
    fully emulate whats in psmsgtrkexo:
    $pltI=@{     ticket="TICKETNO" ;
       uid="USERID"; # used for ofile, leave ofile to external process, picking name etc and vn to outside concrete process of getting stock email trace
       days=10 ;
       StartDate='' ;
       EndDate='' ;
       Sender="" ;
       Recipients="" ;
       MessageSubject="" ;
       Status='' ;
       MessageTraceId='' ;
       MessageId='' ;
       FromIP='' ;
       NoQuarCheck='';
       Tag='' ;
    }   ;
    #>
    <# #-=-=-=MUTUALLY EXCLUSIVE PARAMS OPTIONS:-=-=-=-=-=
    # designate a default paramset, up in cmdletbinding line
    [CmdletBinding(DefaultParameterSetName='SETNAME')]
      # * set blank, if none of the sets are to be forced (eg optional mut-excl params)
      # * force exclusion by setting ParameterSetName to a diff value per exclusive param

    # example:single $Computername param with *multiple* ParameterSetName's, and varying Mandatory status per set
        [Parameter(ParameterSetName='LocalOnly', Mandatory=$false)]
        $LocalAction,
        [Parameter(ParameterSetName='Credential', Mandatory=$true)]
        [Parameter(ParameterSetName='NonCredential', Mandatory=$false)]
        $ComputerName,
        # $Credential as tied exclusive parameter
        [Parameter(ParameterSetName='Credential', Mandatory=$false)]
        $Credential ;    
        # effect: 
        -computername is mandetory when credential is in use
        -when $localAction param (w localOnly set) is in use, neither $Computername or $Credential is permitted
        write-verbose -verbose:$verbose "ParameterSetName:$($PSCmdlet.ParameterSetName)"
        Can also steer processing around which ParameterSetName is in force:
        if ($PSCmdlet.ParameterSetName -eq 'LocalOnly') {
            return "some localonly stuff" ; 
        } ;     
    #-=-=-=-=-=-=-=-=
    #>
    BEGIN{
        #region CONSTANTS_AND_ENVIRO #*======v CONSTANTS_AND_ENVIRO v======
        # Debugger:proxy automatic variables that aren't directly accessible when debugging (must be assigned and read back from another vari) ; 
        $rPSCmdlet = $PSCmdlet ; 
        $rPSScriptRoot = $PSScriptRoot ; 
        $rPSCommandPath = $PSCommandPath ; 
        $rMyInvocation = $MyInvocation ; 
        $rPSBoundParameters = $PSBoundParameters ; 
        [array]$score = @() ; 
        if($rPSCmdlet.MyInvocation.InvocationName){
            if($rPSCmdlet.MyInvocation.InvocationName -match '\.ps1$'){
                $score+= 'ExternalScript' 
            }elseif($rPSCmdlet.MyInvocation.InvocationName  -match '^\.'){
                write-warning "dot-sourced invocation detected!:$($rPSCmdlet.MyInvocation.InvocationName)`n(will be unable to leverage script path etc from MyInvocation objects)" ; 
                # dot sourcing is implicit scripot exec
                $score+= 'ExternalScript' ; 
            } else {$score+= 'Function' };
        } ; 
        if($rPSCmdlet.CommandRuntime){
            if($rPSCmdlet.CommandRuntime.tostring() -match '\.ps1$'){$score+= 'ExternalScript' } else {$score+= 'Function' }
        } ; 
        $score+= $rMyInvocation.MyCommand.commandtype.tostring() ; 
        $grpSrc = $score | group-object -NoElement | sort count ;
        if( ($grpSrc |  measure | select -expand count) -gt 1){
            write-warning  "$score mixed results:$(($grpSrc| ft -a count,name | out-string).trim())" ;
            if($grpSrc[-1].count -eq $grpSrc[-2].count){
                write-warning "Deadlocked non-majority results!" ;
            } else {
                $runSource = $grpSrc | select -last 1 | select -expand name ;
            } ;
        } else {
            write-verbose "consistent results" ;
            $runSource = $grpSrc | select -last 1 | select -expand name ;
        };
        write-host "Calculated `$runSource:$($runSource)" ;
        'score','grpSrc' | get-variable | remove-variable ; # cleanup temp varis

        # function self-name (equiv to script's: $MyInvocation.MyCommand.Path) ;
        ${CmdletName} = $rPSCmdlet.MyInvocation.MyCommand.Name ;
        $PSParameters = New-Object -TypeName PSObject -Property $rPSBoundParameters ;
        write-verbose "`$rPSBoundParameters:`n$(($rPSBoundParameters|out-string).trim())" ;
        $Verbose = ($VerbosePreference -eq 'Continue') ; 
        # pre psv2, no $rPSBoundParameters autovari to check, so back them out:
        if($rPSCmdlet.MyInvocation.InvocationName){
            if($rPSCmdlet.MyInvocation.InvocationName  -match '^\.'){
                $smsg = "detected dot-sourced invocation: Skipping `$PSCmdlet.MyInvocation.InvocationName-tied cmds..." ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            } else { 
                write-verbose 'Collect all non-default Params (works back to psv2 w CmdletBinding)'
                $ParamsNonDefault = (Get-Command $rPSCmdlet.MyInvocation.InvocationName).parameters | Select-Object -expand keys | Where-Object{$_ -notmatch '(Verbose|Debug|ErrorAction|WarningAction|ErrorVariable|WarningVariable|OutVariable|OutBuffer)'} ;
            } ; 
        } else { 
            $smsg = "(blank `$rPSCmdlet.MyInvocation.InvocationName, skipping Parameters collection)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; 
        #region ENVIRO_DISCOVER ; #*------v ENVIRO_DISCOVER v------
        <#
        # Debugger:proxy automatic variables that aren't directly accessible when debugging ; 
        $rPSScriptRoot = $PSScriptRoot ; 
        $rPSCommandPath = $PSCommandPath ; 
        $rMyInvocation = $MyInvocation ; 
        $rPSBoundParameters = $PSBoundParameters ; 
        #>
        $ScriptDir = $scriptName = '' ;     
        if($ScriptDir -eq '' -AND ( (get-variable -name rPSScriptRoot -ea 0) -AND (get-variable -name rPSScriptRoot).value.length)){
            $ScriptDir = $rPSScriptRoot
        } ; # populated rPSScriptRoot
        if( (get-variable -name rPSCommandPath -ea 0) -AND (get-variable -name rPSCommandPath).value.length){
            $ScriptName = $rPSCommandPath
        } ; # populated rPSCommandPath
        if($ScriptDir -eq '' -AND $runSource -eq 'ExternalScript'){$ScriptDir = (Split-Path -Path $rMyInvocation.MyCommand.Source -Parent)} # Running from File
        # when $runSource:'Function', $rMyInvocation.MyCommand.Source is empty,but on functions also tends to pre-hit from the rPSCommandPath entFile.FullPath ;
        if( $scriptname -match '\.psm1$' -AND $runSource -eq 'Function'){
            write-host "MODULE-HOMED FUNCTION:Use `$CmdletName to reference the running function name for transcripts etc (under a .psm1 `$ScriptName will reflect the .psm1 file  fullname)"
            if(-not $CmdletName){write-warning "MODULE-HOMED FUNCTION with BLANK `$CmdletNam:$($CmdletNam)" } ;
        } # Running from .psm1 module
        if($ScriptDir -eq '' -AND (Test-Path variable:psEditor)) {
            write-verbose "Running from VSCode|VS" ; 
            $ScriptDir = (Split-Path -Path $psEditor.GetEditorContext().CurrentFile.Path -Parent) ; 
                if($ScriptName -eq ''){$ScriptName = $psEditor.GetEditorContext().CurrentFile.Path }; 
        } ;
        if ($ScriptDir -eq '' -AND $host.version.major -lt 3 -AND $rMyInvocation.MyCommand.Path.length -gt 0){
            $ScriptDir = $rMyInvocation.MyCommand.Path ; 
            write-verbose "(backrev emulating `$rPSScriptRoot, `$rPSCommandPath)"
            $ScriptName = split-path $rMyInvocation.MyCommand.Path -leaf ;
            $rPSScriptRoot = Split-Path $ScriptName -Parent ;
            $rPSCommandPath = $ScriptName ;
        } ;
        if ($ScriptDir -eq '' -AND $rMyInvocation.MyCommand.Path.length){
            if($ScriptName -eq ''){$ScriptName = $rMyInvocation.MyCommand.Path} ;
            $ScriptDir = $rPSScriptRoot = Split-Path $rMyInvocation.MyCommand.Path -Parent ;
        }
        if ($ScriptDir -eq ''){throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$rMyInvocation IS BLANK!" } ;
        if($ScriptName){
            if(-not $ScriptDir ){$ScriptDir = Split-Path -Parent $ScriptName} ; 
            $ScriptBaseName = split-path -leaf $ScriptName ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($ScriptName) ;
        } ; 
        # blank $cmdlet name comming through, patch it for Scripts:
        if(-not $CmdletName -AND $ScriptBaseName){
            $CmdletName = $ScriptBaseName
        }
        # last ditch patch the values in if you've got a $ScriptName
        if($rPSScriptRoot.Length -ne 0){}else{ 
            if($ScriptName){$rPSScriptRoot = Split-Path $ScriptName -Parent }
            else{ throw "Unpopulated, `$rPSScriptRoot, and no populated `$ScriptName from which to emulate the value!" } ; 
        } ; 
        if($rPSCommandPath.Length -ne 0){}else{ 
            if($ScriptName){$rPSCommandPath = $ScriptName }
            else{ throw "Unpopulated, `$rPSCommandPath, and no populated `$ScriptName from which to emulate the value!" } ; 
        } ; 
        if(-not ($ScriptDir -AND $ScriptBaseName -AND $ScriptNameNoExt  -AND $rPSScriptRoot  -AND $rPSCommandPath )){ 
            throw "Invalid Invocation. Blank `$ScriptDir/`$ScriptBaseName/`ScriptNameNoExt" ; 
            BREAK ; 
        } ; 
        # echo results dyn aligned:
        $tv = 'runSource','CmdletName','ScriptName','ScriptBaseName','ScriptNameNoExt','ScriptDir','PSScriptRoot','PSCommandPath','rPSScriptRoot','rPSCommandPath' ; 
        $tvmx = ($tv| Measure-Object -Maximum -Property Length).Maximum * -1 ; 
        #$tv | get-variable | %{  write-host -fore yellow ("`${0,$tvmx} : {1}" -f $_.name,$_.value) } ; # w-h
        $tv | get-variable | %{  write-verbose ("`${0,$tvmx} : {1}" -f $_.name,$_.value) } ; # w-v
        'tv','tvmx'|get-variable | remove-variable ; # cleanup temp varis        

        # get-EXOMsgTraceDetailed -ticket 651268 -SenderAddress='SENDER@exmark.com' -RecipientAddress='RECIPIENT@domain.com' -StartDate='11/1/2021  4:35:39 PM' -Subject 'Accepted: [MTGSUBJECT]';
        <#$ticket = '651268' ;
        $subject = 'Accepted: Exmark/RLC Bring Up' ;
        $MessageId=$null ; 
        $MessageTraceId=$null ; 
        $Detailed=$true ;
        $MessageTraceDetailLimit = 100 ; 
        $DetailedReportRuleHits= $true ;
        #>
        if(-not (gcm Remove-InvalidVariableNameChars -ea 0)){
            Function Remove-InvalidVariableNameChars ([string]$Name) {
                ($Name.tochararray() -match '[A-Za-z0-9_]') -join '' | write-output ;
            };
        } ;

        #$prpGXMTfta = 'ReceivedLocal','Status','SenderAddress','RecipientAddress','Subject','MessageId' ;
        #$prpGXQMfta = 'ReceivedTime','Type','Direction','SenderAddress','RecipientAddress','Subject','MessageId','Size','ReleaseStatus','Expires','ReleasedBy' ;
        [regex]$rgxHdrSenderIDKeys = ('(?i:' + (('spf','dkim','dmarc','d=','smtp.mailfrom','smtp.rcpttodomain','header.from=','helo','Return-Path:','From:','Subject:','Sender:','Submitter:','Reply-To:','To:','Message-ID:','client-ip','X-Mailer:','X-Received:','Received: from','ARC-Authentication-Results:','arc=','oda=','compauth=','reason=' |%{[regex]::escape($_)}) -join '|') + ')') ;
        [regex]$rgxReturnPath = "Return-Path:((\n|\r|\s)*)([0-9a-zA-Z]+[-._+&='])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}" ;

        $propsMT = 'Received',@{N='ReceivedLocal';E={[datetime]$_.Received.ToLocalTime()}},'SenderAddress','RecipientAddress','Subject','Status','ToIP','FromIP','Size','MessageId','MessageTraceId','Index' ;
        # setup a refactor of Receivedlocal on Received, but return *all* properties
        $propsMTAll = 'RunspaceId','Organization','MessageId','Received', @{N='ReceivedLocal';E={[datetime]$_.Received.ToLocalTime()}},'SenderAddress','RecipientAddress','Subject','Status','ToIP','FromIP','Size','MessageTraceId','StartDate','EndDate','Index'
        #$propsMTD = 'Date','Event','Action','Detail','Data' ;
        # add a locatltime variant
        $propsMTD = @{N='DateLocal';E={$_.Date.ToLocalTime()}},'Date','Event','Action','Detail','Data' ;

        $propsMsgDump = @{N='ReceivedLocal';E={$_.Received.ToLocalTime()}},'Status','SenderAddress','RecipientAddress','Subject' ;
        $DaysLimit = 10 # reflect the current MS get-messagetrace window limit
        #$sFulltimeStamp = 'MM/dd/yyyy-HH:mm:ss.fff' ;
        #$sFiletimestamp = 'yyyyMMdd-HHmm' ;
        $s24HTimestamp = 'yyyyMMdd-HHmm'
        $sFiletimestamp =  $s24HTimestamp

        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        # Get parameters this function was invoked with
        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
        $Verbose = ($VerbosePreference -eq 'Continue') ; 
        
        #region START-LOG-HOLISTIC #*------v START-LOG-HOLISTIC v------
        # Single log for script/function example that accomodates detect/redirect from AllUsers scope'd installed code, and hunts a series of drive letters to find an alternate logging dir (defers to profile variables)
        #${CmdletName} = $rPSCmdlet.MyInvocation.MyCommand.Name ;
        if(!(get-variable LogPathDrives -ea 0)){$LogPathDrives = 'd','c' };
        foreach($budrv in $LogPathDrives){if(test-path -path "$($budrv):\scripts" -ea 0 ){break} } ;
        if(!(get-variable rgxPSAllUsersScope -ea 0)){
            $rgxPSAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps(((d|m))*)1|dll)$" ;
        } ;
        if(!(get-variable rgxPSCurrUserScope -ea 0)){
            $rgxPSCurrUserScope="^$([regex]::escape([Environment]::GetFolderPath('MyDocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps((d|m)*)1|dll)$" ;
        } ;
        $pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($whatif) ;} ;
        # if using [CmdletBinding(SupportsShouldProcess)] + -WhatIf:$($WhatIfPreference):
        #$pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($WhatIfPreference) ;} ;
        #$pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag="$($ticket)-$($TenOrg)-LASTPASS-" ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($WhatIfPreference) ;} ;
        #$pltSL.Tag = $ModuleName ; 
        if($script:rPSCommandPath){ $prxPath = $script:rPSCommandPath }
        elseif($script:PSCommandPath){$prxPath = $script:PSCommandPath}
        if($rMyInvocation.MyCommand.Definition){$prxPath2 = $rMyInvocation.MyCommand.Definition }
        elseif($MyInvocation.MyCommand.Definition){$prxPath2 = $MyInvocation.MyCommand.Definition } ; 
        if($prxPath){
            if(($prxPath -match $rgxPSAllUsersScope) -OR ($prxPath -match $rgxPSCurrUserScope)){
                $bDivertLog = $true ; 
                switch -regex ($prxPath){
                    $rgxPSAllUsersScope{$smsg = "AllUsers"} 
                    $rgxPSCurrUserScope{$smsg = "CurrentUser"}
                } ;
                $smsg += " context script/module, divert logging into [$budrv]:\scripts" 
                write-verbose $smsg  ;
                if($bDivertLog){
                    if((split-path $prxPath -leaf) -ne $cmdletname){
                        # function in a module/script installed to allusers|cu - defer name to Cmdlet/Function name
                        $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
                    } else {
                        # installed allusers|CU script, use the hosting script name
                        $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $prxPath -leaf)) ;
                    }
                } ;
            } else {
                $pltSL.Path = $prxPath ;
            } ;
       }elseif($prxPath2){
            if(($prxPath2 -match $rgxPSAllUsersScope) -OR ($prxPath2 -match $rgxPSCurrUserScope) ){
                 $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $prxPath2 -leaf)) ;
            } elseif(test-path $prxPath2) {
                $pltSL.Path = $prxPath2 ;
            } elseif($cmdletname){
                $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
            } else {
                $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$CMDLETNAME, FROM WHICH TO BUILD A START-LOG.PATH!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                BREAK ;
            } ; 
        } else{
            $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$CMDLETNAME, FROM WHICH TO BUILD A START-LOG.PATH!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            BREAK ;
        }  ;
        write-verbose "start-Log w`n$(($pltSL|out-string).trim())" ; 
        $logspec = start-Log @pltSL ;
        $error.clear() ;
        TRY {
            if($logspec){
                #$logging=$logspec.logging ;
                $logging= $false ; # explicitly turned logfile writing off, just want to use it's path for exports
                $logfile=$logspec.logfile ;
                $transcript=$logspec.transcript ;
                <# 2:30 PM 9/27/2024 no transcript, just want solid logging path discovery
                $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                if($stopResults){
                    $smsg = "Stop-transcript:$($stopResults)" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                } ; 
                $startResults = start-Transcript -path $transcript ;
                if($startResults){
                    $smsg = "start-transcript:$($startResults)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ; 
                #>
            } else {throw "Unable to configure logging!" } ;
        } CATCH [System.Management.Automation.PSNotSupportedException]{
            if($host.name -eq 'Windows PowerShell ISE Host'){
                $smsg = "This version of $($host.name):$($host.version) does *not* support native (start-)transcription" ; 
            } else { 
                $smsg = "This host does *not* support native (start-)transcription" ; 
            } ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ;
        #endregion START-LOG-HOLISTIC #*------^ END START-LOG-HOLISTIC ^------


        #region SERVICE_CONNECTIONS #*======v SERVICE_CONNECTIONS v======
        # PRETUNE STEERING separately *before* pasting in balance of region
        #*------v STEERING VARIS v------
        $useO365 = $true ;
        $useEXO = $true ; 
        $UseOP=$false ; 
        $UseExOP=$false ;
        $useForestWide = $true ; # flag to trigger cross-domain/forest-wide code in AD & EXoP
        $UseOPAD = $false ; 
        $UseMSOL = $false ; # should be hard disabled now in o365
        $UseAAD = $true  ; 
        $useO365 = [boolean]($useO365 -OR $useEXO -OR $UseMSOL -OR $UseAAD)
        $UseOP = [boolean]($UseOP -OR $UseExOP -OR $UseOPAD) ;
        #*------^ END STEERING VARIS ^------
        #*------v EXO V2/3 steering constants v------
        $EOMModName =  'ExchangeOnlineManagement' ;
        $EOMMinNoWinRMVersion = $MinNoWinRMVersion = '3.0.0' ; # support both names
        #*------^ END EXO V2/3 steering constants ^------
        # assert Org from Credential specs (if not param'd)
        # 1:36 PM 7/7/2023 and revised again -  revised the -AND, for both, logic wasn't working
        if($TenOrg){    
            $smsg = "Confirmed populated `$TenOrg" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } elseif(-not($tenOrg) -and $Credential){
            $smsg = "(unconfigured `$TenOrg: asserting from credential)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $TenOrg = get-TenantTag -Credential $Credential ;
        } else { 
            # if not using Credentials or a TargetTenants/TenOrg loop, default the $TenOrg on the $env:USERDOMAIN
            $smsg = "(unconfigured `$TenOrg & *NO* `$Credential: fallback asserting from `$env:USERDOMAIN)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            switch -regex ($env:USERDOMAIN){
                ([regex]('(' + (( @($TORMeta.legacyDomain,$CMWMeta.legacyDomain)  |foreach-object{[regex]::escape($_)}) -join '|') + ')')).tostring() {$TenOrg = $env:USERDOMAIN.substring(0,3).toupper() } ;
                $TOLMeta.legacyDomain {$TenOrg = 'TOL' }
                default {throw "UNRECOGNIZED `$env:USERDOMAIN!:$($env:USERDOMAIN)" ; exit ; } ;
            } ; 
        } ; 
        #region useO365 ; #*------v useO365 v------
        #$useO365 = $false ; # non-dyn setting, drives variant EXO reconnect & query code
        #if($CloudFirst){ $useO365 = $true } ; # expl: steering on a parameter
        if($useO365){
            #region GENERIC_EXO_CREDS_&_SVC_CONN #*------v GENERIC EXO CREDS & SVC CONN BP v------
            # o365/EXO creds
            <### Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile*
            $o365Cred = get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
            Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred = get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
            Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred = get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
            Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            ###>
            $o365Cred = $null ;
            if($Credential){
                $smsg = "`Credential:Explicit credentials specified, deferring to use..." ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                # get-TenantCredentials() return format: (emulating)
                $o365Cred = [ordered]@{
                    Cred=$Credential ; 
                    credType=$null ; 
                } ; 
                $uRoleReturn = resolve-UserNameToUserRole -UserName $Credential.username -verbose:$($VerbosePreference -eq "Continue") ; # Username
                #$uRoleReturn = resolve-UserNameToUserRole -Credential $Credential -verbose = $($VerbosePreference -eq "Continue") ;   # full Credential support
                if($uRoleReturn.UserRole){
                    $o365Cred.credType = $uRoleReturn.UserRole ; 
                } else { 
                    $smsg = "Unable to resolve `$credential.username ($($credential.username))"
                    $smsg += "`nto a usable 'UserRole' spec!" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    throw $smsg ;
                    Break ;
                } ; 
            } else { 
                $pltGTCred=@{TenOrg=$TenOrg ; UserRole=$null; verbose=$($verbose)} ;
                if($UserRole){
                    $smsg = "(`$UserRole specified:$($UserRole -join ','))" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $pltGTCred.UserRole = $UserRole; 
                } else { 
                    $smsg = "(No `$UserRole found, defaulting to:'CSVC','SID' " ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    $pltGTCred.UserRole = 'CSVC','SID' ; 
                } ; 
                $smsg = "get-TenantCredentials w`n$(($pltGTCred|out-string).trim())" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $o365Cred = get-TenantCredentials @pltGTCred
            } ; 
            if($o365Cred.credType -AND $o365Cred.Cred -AND $o365Cred.Cred.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                $smsg = "(validated `$o365Cred contains .credType:$($o365Cred.credType) & `$o365Cred.Cred.username:$($o365Cred.Cred.username)" ;
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                # 9:58 AM 6/13/2024 populate $credential with return, if not populated (may be required for follow-on calls that pass common $Credentials through)
                if((gv Credential) -AND $Credential -eq $null){
                    $credential = $o365Cred.Cred ;
                }elseif($credential.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                    $smsg = "(`$Credential is properly populated; explicit -Credential was in initial call)" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                } else {
                    $smsg = "`$Credential is `$NULL, AND $o365Cred.Cred is unusable to populate!" ;
                    $smsg = "downstream commands will *not* properly pass through usable credentials!" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    throw $smsg ;
                    break ;
                } ;
            } else {
                $smsg = "UNABLE TO RESOLVE FUNCTIONAL CredType/UserRole from specified explicit -Credential:$($Credential.username)!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                break ;
            } ; 
            if($o365Cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                if(get-Variable -Name cred$($tenorg) -scope Script -ea 0 ){ remove-Variable -Name cred$($tenorg) -scope Script } ;
                New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
                $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $statusdelta = ";ERROR"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatettus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                Break ;
            } ;
            # if we get here, wo a $Credential, w resolved $o365Cred, assign it 
            if(-not $Credential -AND $o365Cred){$Credential = $o365Cred.cred } ; 
            # configure splat for connections: (see above useage)
            # downstream commands
            $pltRXO = [ordered]@{
                Credential = $Credential ;
                verbose = $($VerbosePreference -eq "Continue")  ;
            } ;
            if((get-command Reconnect-EXO).Parameters.keys -contains 'silent'){
                $pltRxo.add('Silent',$silent) ;
            } ;
            # default connectivity cmds - force silent false
            $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$true) ; 
            if((get-command Reconnect-EXO).Parameters.keys -notcontains 'silent'){
                $pltRxo.remove('Silent') ;
            } ; 
            #region EOMREV ; #*------v EOMREV Check v------
            #$EOMmodname = 'ExchangeOnlineManagement' ;
            $pltIMod = @{Name = $EOMmodname ; ErrorAction = 'Stop' ; verbose=$false} ;
            # do a gmo first, faster than gmo -list
            if([version]$EOMMv = (Get-Module @pltIMod).version){}
            elseif([version]$EOMMv = (Get-Module -ListAvailable @pltIMod).version){}
            else {
                $smsg = "$($EOMmodname) PowerShell v$($MinNoWinRMVersion) module is required, do you want to install it?" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                else{ $smsg = "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $bRet = Read-Host "Enter YYY to continue. Anything else will exit"  ;
                if ($bRet.ToUpper() -eq "YYY") {
                    $smsg = "Installing $($EOMmodname) module..." ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Install-Module $EOMmodname -Repository PSGallery -AllowClobber -Force ;
                } else {
                    $smsg = "Please install $($EOMmodname) PowerShell v$($MinNoWinRMVersion)  module." ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #exit 1
                    break ;
                }  ;
            } ;
            $smsg = "(Checking for WinRM support in this EOM rev...)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            if([version]$EOMMv -ge [version]$MinNoWinRMVersion){
                $MinNoWinRMVersion = $EOMMv.tostring() ;
                $IsNoWinRM = $true ;
            }elseif([version]$EOMMv -lt [version]$MinimumVersion){
                $smsg = "Installed $($EOMmodname) is v$($MinNoWinRMVersion): This module is obsolete!" ;
                $smsg += "`nAnd unsupported by this function!" ;
                $smsg += "`nPlease install $($EOMmodname) PowerShell v$($MinNoWinRMVersion)  module!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Break ;
            } else {
                $IsNoWinRM = $false ;
            } ;
            [boolean]$UseConnEXO = [boolean]([version]$EOMMv -ge [version]$MinNoWinRMVersion) ;
            #endregion EOMREV ; #*------^ END EOMREV Check  ^------
            #-=-=-=-=-=-=-=-=
            <### CALLS ARE IN FORM: (cred$($tenorg))
            # downstream commands
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; 
            } ;
            if((get-command Reconnect-EXO).Parameters.keys -contains 'silent'){
                $pltRxo.add('Silent',$false) ;
            } ; 
            # default connectivity cmds - force silent false
            $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$true) ;
            if((get-command Reconnect-EXO).Parameters.keys -notcontains 'silent'){
                $pltRxo.remove('Silent') ;
            } ; 
            #$pltRXO creds & .username can also be used for AzureAD connections:
            #Connect-AAD @pltRXOC ;
            ###>
            #endregion GENERIC_EXO_CREDS_&_SVC_CONN #*------^ END GENERIC EXO CREDS & SVC CONN BP ^------

        } else {
            $smsg = "(`$useO365:$($useO365))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; # if-E if($useO365 ){
        #endregion useO365 ; #*------^ END useO365 ^------

        #region useEXO ; #*------v useEXO v------
        # 1:29 PM 9/15/2022 as of MFA & v205, have to load EXO *before* any EXOP, or gen get-steppablepipeline suffix conflict error
        if($useEXO){
            if ($script:useEXOv2 -OR $useEXOv2) { reconnect-eXO2 @pltRXOC }
            else { reconnect-EXO @pltRXOC } ;
        } else {
            $smsg = "(`$useEXO:$($useEXO))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; # if-E 
        #endregion  ; #*------^ END useEXO ^------
      
        #region GENERIC_EXOP_CREDS_&_SRVR_CONN #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
        # steer all onprem code on $XXXMeta.ExOPAccessFromToro & Ex10Server values
        #$UseOP=$true ; 
        #$UseExOP=$true ;
        #$useForestWide = $true ; # flag to trigger cross-domain/forest-wide code in AD & EXoP
        <# no onprem dep
        if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
            $UseOP = $UseExOP = $true ;
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ;
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        } else {
            $UseOP = $UseExOP = $false ;
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ;
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        } ;
        #>
        if($UseOP){
            #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
            # do the OP creds too
            $OPCred=$null ;
            # default to the onprem svc acct
            # userrole='ESVC','SID'
            #$pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC','SID'; verbose=$($verbose)} ;
            # userrole='SID','ESVC'
            $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='SID','ESVC'; verbose=$($verbose)} ;
            $smsg = "get-HybridOPCredentials w`n$(($pltGHOpCred|out-string).trim())" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                if(get-Variable -Name "cred$($tenorg)OP" -scope Script -ea 0 ){ remove-Variable -Name "cred$($tenorg)OP" -scope Script } ;
                New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $statusdelta = ";ERROR"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                Break ;
            } ;
            $smsg= "Using OnPrem/EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            <### CALLS ARE IN FORM: (cred$($tenorg))
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; 
            } ;
            $1stConn = $false ; # below uses silent suppr for both x10 & xo!
            if($1stConn){
                $pltRX10.silent = $pltRXO.silent = $false ;
            } else {
                $pltRX10.silent = $pltRXO.silent =$true ;
            } ;
            if($pltRX10){ReConnect-Ex2010 @pltRX10 }
            else {ReConnect-Ex2010 }
            #$pltRx10 creds & .username can also be used for local ADMS connections
            ###>
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; 
            } ;
            if((get-command Reconnect-Ex2010).Parameters.keys -contains 'silent'){
                $pltRX10.add('Silent',$false) ;
            } ;

            # defer cx10/rx10, until just before get-recipients qry
            #endregion GENERIC_EXOP_CREDS_&_SRVR_CONN #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
            # connect to ExOP X10
            if($useEXOP){
                if($pltRX10){
                    #ReConnect-Ex2010XO @pltRX10 ;
                    ReConnect-Ex2010 @pltRX10 ;
                } else { Reconnect-Ex2010 ; } ;
                #Add-PSSnapin -Name 'Microsoft.Exchange.Management.PowerShell.SnapIn'
                #TK: add: test Exch & AD functional connections
                TRY{
                    if(get-command -module (get-module |?{$_.name -like 'tmp_*'}).name -name 'get-OrganizationConfig'){} else {
                        $smsg = "(mangled Ex10 conn: dx10,rx10...)" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        disconnect-ex2010 ; reconnect-ex2010 ; 
                    } ; 
                    if(-not ($OrgName = ((get-OrganizationConfig).DistinguishedName.split(',') |?{$_ -like 'DC=*'}) -join '.' -replace 'DC=','')){
                        $smsg = "Missing Exchange Connection! (no (Get-OrganizationConfig).name returned)" ; 
                        throw $smsg ; 
                        $smsg | write-warning  ; 
                    } ; 
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = $ErrTrapd ;
                    $smsg += "`n";
                    $smsg += $ErrTrapd.Exception.Message ;
                    if ($logging) { _write-log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    CONTINUE ;
                } ;
            } else { 
          
            } ; 
            if($useForestWide){
                #region  ; #*------v OPTIONAL CODE TO ENABLE FOREST-WIDE NATIVE EXCHANGE SUPPORT v------
                $smsg = "(`$useForestWide:$($useForestWide)):Enabling EXoP Forestwide)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $smsg = 'Set-AdServerSettings -ViewEntireForest `$True' ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Set-AdServerSettings -ViewEntireForest $True ;
                #endregion  ; #*------^ END OPTIONAL CODE TO ENABLE FOREST-WIDE NATIVE EXCHANGE SUPPORT ^------
            } ;
        } else {
            $smsg = "(`$useOP:$($UseOP))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        }  ;  # if-E $UseOP

        #region UseOPAD #*------v UseOPAD v------
        if($UseOP -OR $UseOPAD){
            #region GENERIC_ADMS_CONN_&_XO #*------v GENERIC ADMS CONN & XO  v------
            $smsg = "(loading ADMS...)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # always capture load-adms return, it outputs a $true to pipeline on success
            $ADMTLoaded = load-ADMS -Verbose:$FALSE ;
            # 9:32 AM 4/20/2023 trimmed disabled/fw-borked cross-org code
            TRY {
                if(-not(Get-ADDomain  -ea STOP).DNSRoot){
                    $smsg = "Missing AD Connection! (no (Get-ADDomain).DNSRoot returned)" ; 
                    throw $smsg ; 
                    $smsg | write-warning  ; 
                } ; 
                $objforest = get-adforest -ea STOP ; 
                # Default new UPNSuffix to the UPNSuffix that matches last 2 elements of the forestname.
                $forestdom = $UPNSuffixDefault = $objforest.UPNSuffixes | ?{$_ -eq (($objforest.name.split('.'))[-2..-1] -join '.')} ; 
                if($useForestWide){
                    #region  ; #*------v OPTIONAL CODE TO ENABLE FOREST-WIDE AD GC QRY SUPPORT v------
                    $smsg = "(`$useForestWide:$($useForestWide)):Enabling AD Forestwide)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $smsg = 'Set-AdServerSettings -ViewEntireForest `$True' ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #TK 9:44 AM 10/6/2022 need org wide for rolegrps in parent dom (only for onprem RBAC, not EXO)
                    $GcFwide = "$((Get-ADDomainController -Discover -Service GlobalCatalog).hostname):3268" ;        
                    #endregion  ; #*------^ END  OPTIONAL CODE TO ENABLE FOREST-WIDE AD GC QRY SUPPORT  ^------
                } ;    
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = $ErrTrapd ;
                $smsg += "`n";
                $smsg += $ErrTrapd.Exception.Message ;
                if ($logging) { _write-log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                CONTINUE ;
            } ;        
            #endregion GENERIC_ADMS_CONN_&_XO #*------^ END GENERIC ADMS CONN & XO ^------
        } else {
            $smsg = "(`$UseOP:$($UseOP))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        }  ;
        #if (!$domaincontroller) { $domaincontroller = get-gcfast } ;
        #if(!$domaincontroller){ if(test-path function:get-gcfast){$domaincontroller = get-gcfast} else { throw "no get-gcfast()!" } ;} else {"(existing `$domaincontroller:$($domaincontroller))"} ;
        # use new get-GCFastXO cross-org dc finde
        # default to Op_ExADRoot forest from $TenOrg Meta
        #if($UseOP -AND -not $domaincontroller){
        if($UseOP -AND -not (get-variable domaincontroller -ea 0)){
            #$domaincontroller = get-GCFastXO -TenOrg $TenOrg -subdomain ((get-variable -name "$($TenOrg)Meta").value['OP_ExADRoot']) -verbose:$($verbose) |?{$_.length};
            # need to debug the above, credential issue?
            # just get it done
            $domaincontroller = get-GCFast
        }  else { 
            # have to defer to get-azuread, or use EXO's native cmds to poll grp members
            # TODO 1/15/2021
            $useEXOforGroups = $true ; 
            $smsg = "$($TenOrg):HAS NO ON-PREM ACTIVEDIRECTORY, DEFERRING ALL GROUP ACCESS & MGMT TO NATIVE EXO CMDS!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
        if($useForestWide -AND -not $GcFwide){
            #region  ; #*------v OPTIONAL CODE TO ENABLE FOREST-WIDE ACTIVEDIRECTORY SUPPORT: v------
            $smsg = "`$GcFwide = Get-ADDomainController -Discover -Service GlobalCatalog" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $GcFwide = "$((Get-ADDomainController -Discover -Service GlobalCatalog).hostname):3268" ;
            $smsg = "Discovered `$GcFwide:$($GcFwide)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #endregion  ; #*------^ END OPTIONAL CODE TO ENABLE FOREST-WIDE ACTIVEDIRECTORY SUPPORT ^------
        } ;
        #endregion UseOPAD #*------^ END UseOPAD ^------

        #region MSOL_CONNECTION ; #*------v  MSOL CONNECTION v------
        #$UseMSOL = $false 
        if($UseMSOL){
            #$reqMods += "connect-msol".split(";") ;
            #if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
            $smsg = "(loading MSOL...)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #connect-msol ;
            connect-msol @pltRXOC ;
        } else {
            $smsg = "(`$UseMSOL:$($UseMSOL))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ;
        #endregion MSOL_CONNECTION ; #*------^  MSOL CONNECTION ^------

        #region AZUREAD_CONNECTION ; #*------v AZUREAD CONNECTION v------
        #$UseAAD = $false 
        if($UseAAD){
            #$reqMods += "Connect-AAD".split(";") ;
            #if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
            $smsg = "(loading AAD...)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Connect-AAD @pltRXOC ;
        } else {
            $smsg = "(`$UseAAD:$($UseAAD))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ;
        #endregion AZUREAD_CONNECTION ; #*------^ AZUREAD CONNECTION ^------
      
        <# defined above
        # EXO connection
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            verbose = $($verbose) ; } ;
        #>
        <#
        if($VerbosePreference = "Continue"){
            $VerbosePrefPrior = $VerbosePreference ;
            $VerbosePreference = "SilentlyContinue" ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        disconnect-exo ;
        if ($script:useEXOv2) { reconnect-eXO2 @pltRXOC }
        else { reconnect-EXO @pltRXOC } ;
        # reenable VerbosePreference:Continue, if set, during mod loads
        if($VerbosePrefPrior -eq "Continue"){
            $VerbosePreference = $VerbosePrefPrior ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        #>
        #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        #endregion SERVICE_CONNECTIONS #*======^ END SERVICE_CONNECTIONS ^======

        # Configure the Get-xoMessageTrace splat 
        $pltGXMT=[ordered]@{
            #SenderAddress=$SenderAddress;
            #RecipientAddress=$RecipientAddress;
            #StartDate=(get-date $StartDate);
            #StartDate= $StartDate;
            #EndDate=(get-date $EndDate);
            #EndDate=$EndDate;
            Page= 1 ; # default it to 1 vs $null as we'll be purging empties further down
            ErrorAction = 'STOP' ;
            verbose = $($VerbosePreference -eq "Continue") ;
        } ;
        if ($PSCmdlet.ParameterSetName -eq 'Dates') {
            if($EndDate -and -not $StartDate){
                $StartDate = (get-date $EndDate).addDays(-1 * $DaysLimit) ; 
            } ; 
            if($StartDate -and -not ($EndDate)){
                $smsg = "(StartDate w *NO* Enddate, asserting currenttime)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $EndDate=(get-date) ;
            } ;
        } else {
            if (-not $Days) {
                $StartDate = (get-date $EndDate).addDays(-1 * $DaysLimit) ; 
                $smsg = "No Days, StartDate or EndDate specified. Defaulting to $($DaysLimit)day Search window:$((get-date).adddays(-1 * $DaysLimit))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $EndDate = (get-date) ;
                $StartDate = (get-date $EndDate).addDays(-1 * $Days) ; 
                $smsg = "-Days:$($Days) specified: "
                #$smsg += "calculated StartDate:$((get-date $StartDate -format $sFulltimeStamp ))" ; 
                #$smsg += ", calculated EndDate:$((get-date $EndDate -format $sFulltimeStamp ))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #(get-date -format $sFiletimestamp);
            } ; 
        } ;

        $smsg = "(converting `$StartDate & `$EndDate to UTC, using input as `$StartLocal & `$EndLocal)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        # convert dates to GMT .ToUniversalTime(
        $StartDate = ([datetime]$StartDate).ToUniversalTime() ; 
        $EndDate = ([datetime]$EndDate).ToUniversalTime() ; 
        $StartLocal = ([datetime]$StartDate).ToLocalTime() ; 
        $EndLocal = ([datetime]$EndDate).ToLocalTime() ; 
        
        # sanity test the start/end dates, just in case (won't throw an error in gxmt)
        if($StartDate -gt $EndDate){
            $smsg = "`-StartDate:$($StartDate) is GREATER THAN -EndDate:($EndDate)!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            throw $smsg ; 
            break ; 
        } ; 

        $smsg = "`$StartDate:$(get-date -Date $StartLocal -format $sFulltimeStamp )" ;
        $smsg += "`n`$EndDate:$(get-date -Date $EndLocal -format $sFulltimeStamp )" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

        if((New-TimeSpan -Start $StartDate -End (get-date)).days -gt $DaysLimit){
            $smsg = "Search span (between -StartDate & -EndDate, or- Days in use) *exceeds* MS supported days history limit!`nReduce the window below a historical 10d, or use get-HistoricalSearch instead!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            Break ; 
        } ; 

        TRY{
            $tendoms=Get-AzureADDomain ; 
            $Ten = ($tendoms |?{$_.name -like '*.mail.onmicrosoft.com'}).name.split('.')[0] ;
            $Ten = "$($Ten.substring(0,1).toupper())$($Ten.substring(1,$Ten.length-1).toLower())"
        }CATCH{
            $smsg = "NOT AAD CONNECTED!" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
          BREAK 
        } ;
       

    }  # BEG-E
    PROCESS {

        <#
        # default StartDate to -10 can't do more
        $pltGXMT=[ordered]@{
          #SenderAddress=$SenderAddress;
          #RecipientAddress=$RecipientAddress;
          #StartDate=(get-date $StartDate);
          #StartDate= $StartDate;
          #EndDate=(get-date $EndDate);
          #EndDate=$EndDate;
          Page= 1 ; # default it to 1 vs $null as we'll be purging empties further down
          ErrorAction = 'STOP' ;
          verbose = $($VerbosePreference -eq "Continue") ;
        } ;
        # throwing errors using unpopulated, so add them conditionally 
        #>

        <# #-=-=-=-=-=-=-=-=
        [Parameter(Mandatory=$false,HelpMessage="Ticket [-ticket 999999]")]
            [ValidateNotNullOrEmpty()]
            [string]$ticket,
        [Parameter(HelpMessage="Tag string that is used for Variables name construction. [-Tag 'LastDDGSend']")]
            [string]$Tag,
        [Parameter(HelpMessage="SenderAddress (an array runs search on each)[-SenderAddress addr@domain.com]")]
            [Alias('Sender')]
            [string[]]$SenderAddress, # MultiValuedProperty
        [Parameter(HelpMessage="RecipientAddress (an array runs search on each)[-RecipientAddress addr@domain.com]")]
            [Alias('Recipients')]
            [string[]]$RecipientAddress, # MultiValuedProperty
        [Parameter(ParameterSetName='Dates',HelpMessage="Start of range to be searched[-StartDate '11/5/2021 2:16 PM']")]
            [Alias('Start')]
            [DateTime]$StartDate,
        [Parameter(ParameterSetName='Dates',HelpMessage="End of range to be searched (defaults to current time if unspecified)[-EndDate '11/5/2021 5:16 PM']")]
            [Alias('End')]
            [DateTime]$EndDate=(get-date),
        [Parameter(ParameterSetName='Days',HelpMessage="Days to be searched, back from current time(Alt to use of StartDate & EndDate; Note:MS won't search -gt 10 days)[-Days 7]")]
            #[ValidateRange(0,[int]::MaxValue)]
            [ValidateRange(0,10)] # MS won't search beyond 10, and silently returns incomplete results
            [int]$Days,
        [Parameter(HelpMessage="Subject of target message (emulated via post filtering, not supported param of Get-xoMessageTrace) [-Subject 'Some subject']")]
            [Alias('MessageSubject')]
            [string]$subject,
        [Parameter(HelpMessage="Subject of target message [-Subject 'Some subject']")]
            [Alias('DeliveryStatus','EventId')]
            [ValidateSet('None','GettingStatus','Failed','Pending','Delivered','Expanded','Quarantined','FilteredAsSpam')]
            [string[]]$Status, # MultiValuedProperty
        [Parameter(HelpMessage="MessageId of target message(s) (include any <> and enclose in quotes; an array runs search on each)[-MessageId '<nnnn-nn.xxx....outlook.com>']")]
            # Get-xoMessageTrace specs <MultiValuedProperty>: "just means that you can provide multiple values (i.e. an array) as the argument to the parameter. If your users input something like alice@example.com,bob@example.com,charlie@example.com, you need to split the delims"
            [string[]]$MessageId, # MultiValuedProperty
        [Parameter(HelpMessage="MessageTraceId of target message [-MessageTraceId '[MessageTraceId string]']")]
            [Guid]$MessageTraceId,
        [Parameter(HelpMessage="The FromIP parameter filters the results by the source IP address. For incoming messages, the value of FromIP is the public IP address of the SMTP email server that sent the message. For outgoing messages from Exchange Online, the value is blank. [-FromIP '123.456.789.012']")]
            [string]$FromIP,
        [Parameter(HelpMessage="The ToIP parameter filters the results by the destination IP address. For outgoing messages, the value of ToIP is the public IP address in the resolved MX record for the destination domain. For incoming messages to Exchange Online, the value is blank. [-ToIP '123.456.789.012']")]
            [string]$ToIP,
        [Parameter(HelpMessage="switch to do Summarize & Expansion of any MTD TransportRule events (defaults true) [-DetailedReportRuleHits]")]
            [switch]$DetailedReportRuleHits= $true,
        [Parameter(HelpMessage="Integer number of maximum messages to be follow-up MessageTraceDetail'd [-MessageTraceDetailLimit 20]")]
            [int]$MessageTraceDetailLimit = 100,
        [Parameter(HelpMessage="switch to do Summarize & Expansion of any MTD TransportRule events (defaults true) [-DetailedReportRuleHits]")]
            [switch]$NoQuarCheck,
        [Parameter(HelpMessage="switch to perform MessageTrackingDetail pass, after intial MessageTrace (up to limti specified in -MessageTraceDetailLimit (defaults true) [-Detailed]")]
            [switch]$Detailed=$true
        #-=-=-=-=-=-=-=-=
        #>
        $ofile ="$($ticket)-MsgTrc" ;
        if($SenderAddress){
            if($SenderAddress -match '\*'){
                # To do wildcards (*@DOMAIN.COM), SPEC THE ADDRESS LIKE: -SenderAddress @('*@DOMAIN.COM') (forces as array)
                $pltGXMT.add('SenderAddress',@(($SenderAddress -split ' *, *')) ) ;
            }else{
                $pltGXMT.add('SenderAddress',($SenderAddress -split ' *, *')) ;
            } ; 
            $ofile+=",From-$($pltGXMT.SenderAddress.replace("*","ANY"))" 
        } ;
        if($RecipientAddress){
            if($RecipientAddress -match '\*'){
                # To do wildcards (*@DOMAIN.COM), SPEC THE ADDRESS LIKE: -RecipientAddress @('*@DOMAIN.COM') (forces as array)
                $pltGXMT.add('RecipientAddress',@(($RecipientAddress -split ' *, *')) ) ;
            }else{
                $pltGXMT.add('RecipientAddress',($RecipientAddress -split ' *, *')) ;
            } ; 
            $ofile+=",To-$($pltGXMT.RecipientAddress.replace("*","ANY"))" ;
        } ;
        if($StartDate){
            $pltGXMT.add('StartDate',$StartDate) ; 
            $ofile+= "-$(get-date $pltGXMT.StartDate -format $sFiletimestamp)-"  ;
        } ;
        if($EndDate){
            $pltGXMT.add('EndDate',$EndDate) ; 
            $ofile+= "$(get-date $pltGXMT.EndDate -format $sFiletimestamp)" ;
        } ;
        if($Status){
            $pltGXMT.add('Status',($Status -split ' *, *')) ; 
            $ofile+= "$(get-date $pltGXMT.EndDate -format $sFiletimestamp)" ;
        } ;
        if($MessageId){
            $pltGXMT.add('MessageId',($MessageId -split ' *, *')) ; 
            $ofile+=",MsgId-$($pltGXMT.MessageId.replace('<','').replace('>',''))" ;
        } ;
        if($MessageTraceId){
            $pltGXMT.add('MessageTraceId',$MessageTraceId) ; 
            $ofile+=",MsgId-$($pltGXMT.MessageTraceId)"  ;
        } ;
        if($FromIP){
            $pltGXMT.add('FromIP',$FromIP) ; 
            $ofile+=",MsgId-$($pltGXMT.FromIP.replace('<','').replace('>',''))"  ;
        } ;
        if($ToIP){
            $pltGXMT.add('ToIP',$ToIP) ; 
            $ofile+=",MsgId-$($pltGXMT.ToIP.replace('<','').replace('>',''))"  ;
        } ;

        if($subject){
            $ofile+=",Subj-$($subject.substring(0,[System.Math]::Min(15,$subject.Length)))..." 
        } ;
        
        # use the updated psOfile build:
        #-=-=-=-=-=-=-=-=
        #region MSGTRKFILENAME ; #*------v MSGTRKFILENAME v------
        write-verbose "Keys off of typical msgtrk inputsplat" ; 
        <#
        $pltI=@{   ticket=$ticket ;
           Requestor=$requestor ;
           days=0 ;
           StartDate=$TargetMsg.Received.Adddays(-1) ;
           EndDate=$TargetMsg.Received.Adddays(+1) ;
           Sender="" ;
           Recipients=$TargetMsg.RecipientAddress ;
           Status='' ;
           MessageSubject="" ;
           MessageTraceId='' ;
           MessageId=$TargetMsg.MessageId ;
           FromIP='' ;
           NoQuarCheck='';
           Tag='LatestDDG' ;
         }   ;
          #>
        # default create a \logs\ dir below script dir
        $LogPath = split-path $logfile ; 
        $smsg = "Writing export files to discovered `$LogPath: $($LogPath)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        if (-not (test-path $LogPath )){mkdir $LogPath -verbose  }
        [string[]]$ofile=@() ; 
        write-verbose "Add comma-delimited elements" ; 
        #$ofile+=if($ticket -AND $Tag){@($ticket,$tag) -join '_'}else{$ticket} ;
        $ofile+= (@($ticket,$tag) | ?{$_}) -join '_' ; 
        $ofile+= (@($Ten,$Requestor,'EXOMsgTrc') | ?{$_} ) -join '-' ;
        $ofile+=if($SenderAddress){
            "FROM_$((($SenderAddress | select -first 2) -join ',').replace('*','ANY'))"
        }else{''} ;
        $ofile+=if($RecipientAddress){
            "TO_$( ($RecipientAddress| select -first 2) -join ',').replace('*','ANY'))"
        }else{''} ;
        $ofile+=if($MessageId){
            #"MSGID_$($MessageId.replace('<','').replace('>',''))"
            if($MessageId -is [array]){
                "MSGID_$($MessageId[0] -replace '[\<\>]','')..."
            } else { 
                "MSGID_$($MessageId -replace '[\<\>]','')"
            } ; 
        }else{''} ;
        $ofile+=if($MessageTraceId){"MsgId_$($MessageTraceId)"}else{''} ;
        $ofile+=if($FromIP){"FIP_$($FromIP)"}else{''} ;
        $ofile+=if($MessageSubject){"SUBJ_$($MessageSubject.substring(0,[System.Math]::Min(10,$MessageSubject.Length)))..."}else{''} ;
        $ofile+=if($Status){
            "STATUS_$($Status -join ',')"
        }else{''} ;
        write-verbose "comma join the non-empty elements" ; 
        [string[]]$ofile=($ofile |  ?{$_} ) -join ',' ; 
        write-verbose "add the dash-delimited elements" ; 
        $ofile+=if($days){"$($days)d"}else{''} ;
        $ofile+=if($StartDate){"$(get-date $StartDate -format 'yyyyMMdd-HHmm')"}else{''} ;
        $ofile+=if($EndDate){$ofile+= "$(get-date $EndDate -format 'yyyyMMdd-HHmm')"}else{''} ;
        $ofile+=if($MessageSubject){"Subj_$($MessageSubject.replace("*"," ").replace("\"," "))"}else{''} ;
        $ofile+="run$(get-date -format 'yyyyMMdd-HHmm').csv" ;
        write-verbose "dash-join non-empty elems" ; 
        [string]$ofile=($ofile |  ?{$_} ) -join '-' ; 
        write-verbose "replace filesys illegal chars" ; 
        [string]$ofile=[RegEx]::Replace($ofile, "[{0}]" -f ([RegEx]::Escape(-join [System.IO.Path]::GetInvalidFileNameChars())), '') ;
        if($LogPath){
            write-verbose "add configured `LogPath" ; 
            $ofile = join-path $LogPath $ofile ; 
        } else { 
            write-verbose "add relative path" ; 
            $ofile=".\logs\$($ofile)" ;
        } ; 
        #$MSGSTRK | export-csv -noty $ofile -verbo ; 
        #write-host -foregroundcolor green "export-csv'd to:`n$((resolve-path $ofile).path)" ; 
        #endregion MSGTRKFILENAME ; #*------^ END MSGTRKFILENAME ^------
        #-=-=-=-=-=-=-=-=


        #$ofile=[RegEx]::Replace($ofile, "[{0}]" -f ([RegEx]::Escape(-join [System.IO.Path]::GetInvalidFileNameChars())), '') ;
        # use the tested redirected $logfile path
        #$ofile = join-path -path (split-path $logfile) -ChildPath $ofile ; 
        $hReports = [ordered]@{} ; 
        #rxo ;
        $error.clear() ;
        TRY {
            # prepurge empty hash value keys:
            #$pltGXMT=$pltGXMT.GetEnumerator()|? value ;
            # remove null keyed objects
            #$pltGXMT | Foreach {$p = $_ ;@($p.GetEnumerator()) | ?{ ($_.Value | Out-String).length -eq 0 } | Foreach-Object {$p.Remove($_.Key)} ;} ;
            # skip it, we're only adding populated items now
            #write-verbose "hashtype:$($pltGXMT.GetType().FullName)" ; 
            # and issue was first untested negative integer -Days; and 2nd GMT window for start/enddate, so the 'local' input needs to be converted to/from gmt to get the targeted content.

            $smsg = "Get-xoMessageTrace  w`n$(($pltGXMT|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            $Page = 1  ;
            $Msgs=$null ;
            do {
                $smsg = "Collecting - Page $($Page)..."  ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $pltGXMT.Page=$Page ;
                $PageMsgs = Get-xoMessageTrace @pltGXMT |  ?{$_.SenderAddress -notlike '*micro*' -or $_.SenderAddress -notlike '*root*' }  ;
                $Page++  ;
                $Msgs += @($PageMsgs)  ;
            } until ($PageMsgs -eq $null) ;
            $Msgs=$Msgs| Sort Received ;
            $smsg = "Raw sender/recipient Msgs:$(($Msgs|measure).Count)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

            if($subject){
                $smsg = "Post-Filtering on Subject:$($subject)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                # detect whether to filter on -match (regex) or -like (asterisk, or default non-regex)
                if(test-IsRegexPattern -string $subject -verbose:$($VerbosePreference -eq "Continue")){
                    $smsg = "(detected -subject as regex - using -match comparison)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $MsgsFltrd = $Msgs | ?{$_.Subject -match $subject} ;
                    if(-not $MsgsFltrd){
                        $smsg = "Subject: regex -match comparison *FAILED* to return matches`nretrying Subject filter as -Like..." ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $MsgsFltrd = $Msgs | ?{$_.Subject -like $subject} ;
                    } ; 
                } else { 
                    $smsg = "(detected -subject as NON-regex - using -like comparison)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $MsgsFltrd = $Msgs | ?{$_.Subject -like $subject} ;
                    if(-not $MsgsFltrd){
                        $smsg = "Subject: -like comparison *FAILED* to return matches`nretrying Subject filter as -match..." ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $MsgsFltrd = $Msgs | ?{$_.Subject -match $subject} 
                    } ; 
                } ; 
                $smsg = "Post Subj filter matches:$(($MsgsFltrd|measure).Count)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $msgs = $MsgsFltrd ; 
            } ;
            $ofile+= "-r$(get-date -format $sFiletimestamp).csv" ;
            $ofile = (split-path $ofile -leaf) # can't fix a full path, just the leaf name, then re-path
            $ofile=[RegEx]::Replace($ofile, "[{0}]" -f ([RegEx]::Escape(-join [System.IO.Path]::GetInvalidFileNameChars())), '') ;
            #$ofile=".\logs\$($ofile)" ;
            #$ofile=(join-path -path (split-path $logfile) -childpath "logs\$($ofile)") ;
            $ofile=(join-path -path (split-path $logfile) -childpath $ofile) ;
            if($Msgs){
                # reselect with local time variant
                $Msgs = $Msgs | select $propsMTAll ; 
                if($DoExports){
                    $smsg = "($(($Msgs|measure).count)msgs | export-csv $($ofile))" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                
                    $Msgs | select $propsMT | export-csv -notype -path $ofile  ;
                    $smsg = "export-csv'd to:`n$((resolve-path $ofile).path)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $smsg = "(adding `$hReports.MTMessages)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    
                    # add the csvfilename
                    $smsg = "(adding `$hReports.MTMessagesCSVFile:$($ofile))" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $hReports.add('MTMessagesCSVFile',$ofile) ; 
                } 

                $hReports.add('MTMessages',$msgs) ; 

                $smsg = "Status Distrib:" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $smsg = "`n#*------v Status DISTRIB v------" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $smsg = "$(($Msgs | select -expand Status | group | sort count,count -desc | select count,name|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $smsg = "`n#*------^ Status DISTRIB ^------" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $smsg = "`n#*------v MOST RECENT MATCH v------" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $smsg = "$(($msgs[-1]| fl $propsMsgDump |out-string).trim())";
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $smsg = "`n#*------^ MOST RECENT MATCH ^------" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 



                if($mFails = $msgs | ?{$_.status -eq 'Failed'}){
                    $ofileF = $ofile.replace('-EXOMsgTrc,','FAILMsgs,') ;
                    if($DoExports){
                        $mFails | export-csv -notype -path $ofileF -ea STOP ;
                        $smsg = "export-csv'd to:`n$((resolve-path $ofileF).path)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    } ; 
                    if($mOOO = $mFails | ?{$_.Subject -match '^Automatic\sreply:\s'}){
                        $smsg = $sBnr3="`n#*~~~~~~v Status FAILED: Expected Policy Blocked External OutOfOffice v~~~~~~" ;
                        $smsg += "`n$($mOOO| measure | select -expand count) msgs:Expected Out-of-Office Policy:(attempt to send externally)`n$(($mOOO| ft -a $prpGXMTfta |out-string).trim())" ;
                        $smsg += "`n$($sBnr3.replace('~v','~^').replace('v~','^~'))`n"  ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    } ;
                    if($mRecl = $mFails | ?{$_.Subject -match '^Recall:\s'}){                 $smsg = $sBnr3="`n#*~~~~~~v Status FAILED: Expected: Recalled message v~~~~~~" ;
                        $smsg += "`n$($mRecl| measure | select -expand count) msgs:Expected Sender Recalled Message `n$(($mRecl| ft -a $prpGXMTfta |out-string).trim())" ;
                        $smsg += "`n$($sBnr3.replace('~v','~^').replace('v~','^~'))`n"  ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    } ;
                    if($mFails = $mFails | ?{$_.Subject -notmatch '^Recall:\s' -AND $_.Subject -notmatch '^Automatic\sreply:\s'}){                 $smsg = $sBnr3="`n#*~~~~~~v Status FAILED: Other Failure message v~~~~~~" ;
                        $smsg += "`n$(($mFails | ft -a |out-string).trim())" ;
                        $smsg += "`n$($sBnr3.replace('~v','~^').replace('v~','^~'))`n"  ;
                        write-host -foregroundcolor yellow $smsg ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    } ;
                } ;
                if(-not $NoQuarCheck -AND ($mQuars = $msgs | ?{$_.status -eq 'Quarantined'})){
                    $ofileQ = $ofile.replace('-EXOMsgTrc,','QUARMsgs,') ;
                    #set-variable -name "$($vn)_QUAR" -Value ($mQuars) -ea STOP;
                    if($DoExports){
                        $mQuars | export-csv -notype -path $ofileQ -ea STOP ;
                        $smsg = "export-csv'd to:`n$((resolve-path $ofileQ).path)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    } ; 
                    $smsg = "EXPANDING QUARANTINES:`n$" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                    else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $ttl = $mQuars |  measure | select -expand count ;
                    $prcd=0 ;
                    $mQuars |foreach-object{
                        $tmsg = $_ ;
                        $prcd++ ;
                        $smsg = $sBnrS="`n`n#*------v PROCESSING QUAR:($($prcd)/$($ttl)): $($tmsg.MessageID) v------" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $qmsg = Get-xoQuarantineMessage -MessageId $tmsg.MessageID ;
                        $qmsg |foreach-object{
                            $qid = $_.identity ;
                            $smsg = "`n$(($qmsg|ft -a $prpGXQMfta | out-string).trim())`n" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $hdr = Get-xoQuarantineMessageHeader -Identity $qid | select -expand header;
                            #$rgxReturnPath = "Return-Path:((\n|\r|\s)*)([0-9a-zA-Z]+[-._+&='])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}" ;
                            if($hdr -match $rgxReturnPath){
                                $smsg = "$(( (($matches[0] -split ':' |foreach-object{$_.trim()} ) -join ': ') |out-string).trim())" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                                else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } ;
                            $hdrsp = $hdr.Split([Environment]::NewLine) ;
                            write-host  "$(($hdrsp | ?{$_ -match $rgxHdrSenderIDKeys}|out-string).trim())" ;
                            start-sleep -Milliseconds 500 ;
                        } ;
                        $smsg = "$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                } ;

                if( $msgs | ?{$_.status -eq 'GettingStatus'}){
                    $smsg = "Status:GettingStatus returned on some traces - INDETERMINANT STATUS THOSE ITEMS (PENDING TRACKABLE LOGGING), RERUN IN A FEW MINS TO GET FUNCTIONAL DATA! (EXO-SIDE ISSUE)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                } ;

                if(test-path -path $ofile){
                    $smsg = "(log file confirmed)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    Resolve-Path -Path $ofile | select -expand Path | out-clipboard ;
                    $smsg = "$($Msgs.count) matches output to:`n'$($ofile)'`n(copied to CB)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                } else { "MISSING MsgTrc LOG FILE!" } ;
                
                if($Detailed){
                    if($msgs.count -gt $MessageTraceDetailLimit){
                        $smsg = "$($msgs.count) EXCEEDS `$MessageTraceDetailLimit:$($MessageTraceDetailLimit)!.`nget-MTD'ing only most recent $($MessageTraceDetailLimit) msgs...!"
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        $mtdmsgs = $msgs | select -last $MessageTraceDetailLimit ; 
                    } else { $mtdmsgs = $msgs }  ; 
                    $smsg = "`n[$(($msgs|measure).count)msgs]|=>Get-xoMessageTraceDetail:" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                    $mtds = $mtdmsgs | Get-xoMessageTraceDetail ;

                    $mtdRpt = @() ; 
                    if($DetailedReportRuleHits){
                        $TRules = Get-xotransportrule  ; 
                        $smsg = "Checking for `$mtds|`?{$_.Event -eq 'Transport rule'}:" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    } ; 
                    foreach($mtd in $mtds){
                        $mtdsummary = [ordered]@{
                            Date = $mtd.Date ; 
                            DateLocal = ([datetime]$mtd.Date).ToLocalTime() ; 
                            Event = $mtd.Event ;
                            Action = $mtd.Action ;
                            Detail = $mtd.Detail ;
                            TRuleName = $null ; 
                            TRuleDetails = $null ; 
                        } ; 
                        if($DetailedReportRuleHits){
                            if ($mtd| ?{$_.Event -eq 'Transport rule'}){
                                # $smsg = "`n$(($mtd | fl Date,Event,Action,Detail |out-string).trim())" ; 
                                if($mtd.detail -match "Transport\srule:\s'',\sID:\s\('(\w{8}-\w{4}-\w{4}-\w{4}-\w{12})'\)"){
                                    #$smsg = "$(($trules|?{$_.guid -eq $matches[1]}  | format-list Name,State,Priority|out-string).trim())" ; 
                                    $ruledetail = $trules|?{$_.guid -eq $matches[1]}  | select Name,Guid,State,Priority ; 
                                    $mtdsummary.TRuleName = $ruledetail.Name ; 
                                    $mtdsummary.TRuleDetails = $ruledetail ; 
                                } ; 
                                $smsg = "`n$(($mtdsummary| fl Date,Event,Action,Detail,TRuleName |out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            } ; 
                        } else {
                            $smsg = "`n$(($mtdsummary| fl Date,Event,Action,Detail|out-string).trim())" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        }  ;
   
                        $mtdRpt += [pscustomobject]$mtdsummary ; 
                    } ; 
                
                    if($mtds){
                        if($DoExports){
                            $ofileMTD = $ofile.replace('-MsgTrc','-MTD') ;
                            $smsg = "($(($mtds|measure).count)mtds | export-csv $($ofileMTD))" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            
                            $mtds | select $propsMTD | export-csv -notype -path $ofileMTD  ;
                            $smsg = "export-csv'd to:`n$((resolve-path $ofileMTD).path)" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                            if(test-path -path $ofileMTD){
                                $smsg = "(log file confirmed)" ;
                                $smsg += "`n$($mtds.count) MTD matches output to:`n'$($ofileMTD)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                            } else { 
                                $smsg = "MISSING MTD LOG FILE!" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            } ;

                        } ; 

                        $hReports.add('MTDetails',$mtds) ; 

                        if($DoExports){
                            # add the csvfilename
                            $smsg = "(adding `$hReports.MTDCSVFile:$($ofileMTD))" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            $hReports.add('MTDCSVFile',$MTDCSVFile) ; 
                        } ; 

                        #$hReports.add('MTDReport',$ofileMTD) ; 
                        # mtdreport
                        $hReports.add('MTDReport', $mtdRpt) ; 

                        if($DoExports){
                            $ofileMTDRpt = $ofile.replace('-MsgTrc','-MTDRpt') ;
                            $mtdRpt | export-csv -notype -path $ofileMTDRpt  ;
                            if(test-path -path $ofileMTD){
                                $smsg = "(log file confirmed)" ;
                                $smsg += "`n$($mtdRpt.count) MTDReport matches output to:`n'$($ofileMTDRpt)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                # add the csvfilename
                                $smsg = "(adding `$hReports.MTDRptCSVFile:$($ofileMTDRpt))" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                $hReports.add('MTDRptCSVFile',$ofileMTDRpt) ; 

                            } else { 
                                $smsg = "MISSING MTD LOG FILE!" 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            } ;
                        } ; 
                   } ;
                } ;
            } else {
                $smsg = "NO MATCHES RETURNED from MT Query" ;
                $smsg += "`n$(($pltGXMT|out-string).trim())" ; 
                $smsg += "`n(net of any relevant ConnectorId or other postfilters)"  ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            } ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ; 

        
    } ;  # PROC-E
    END {
        if($SimpleTrack -AND ($hReports.Keys.Count -gt 0)){
            $smsg = "-SimpleTrack specified: Only returning net message tracking set to pipeline" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            $msgs | write-output ; 
        } else { 
            $smsg = "(no -SimpleTrack: returning full summary object to pipeline)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            if($hReports.Keys.Count -gt 0){
                # convert the hashtable to object for output to pipeline
                #$Rpt += New-Object PSObject -Property $hReports ;
                $smsg = "(Returning summary object to pipeline)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                New-Object -TypeName PsObject -Property $hReports | write-output ; 
            } else { 
                $smsg = "Unpopulated `$hReports, skipping output to pipeline" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARNING } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                $false | write-output ; 
            } ;  
        } ; 
    } ; 
}

#*------^ get-EXOMsgTraceDetailed.ps1 ^------


#*------v get-MailboxFolderStats.ps1 v------
function get-MailboxFolderStats {
    <#
    .SYNOPSIS
    get-MailboxFolderStats.ps1 - Perform smart get-mailboxfolderstatistics command, as appropriate to target location -Mailbox, on either Exchange on-premesis or Exchange Online.
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-03-12
    FileName    : get-MailboxFolderStats
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Mailbox,Statistics,Reporting
    REVISIONS
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    # 12:17 PM 5/14/2021 updated passstatus code to curr, and added -ea to the gv's (suppress errors when not present)
    * 11:54 AM 4/2/2021 updated wlt & recstat support, updated catch blocks
    * 3:28 PM 3/16/2021 added multi-tenant support
    * 1:12 PM 3/15/2021 init work was done 3/12, removed recursive-err generating #Require on the hosting verb-EXO module
    .DESCRIPTION
    get-MailboxFolderStats.ps1 - Perform smart get-mailboxfolderstatistics command, as appropriate to target location -Mailbox, on either Exchange on-premesis or Exchange Online.
    Dependancy on my verb-ex2010 Exchange onprem (and is within verb-exo EXO mod, which adds dependant EXO connection support).
    .PARAMETER TenOrg
    TenantTag values, indicating Tenant to Create DDG WITHIN[-TenOrg 'TOL']    
    .PARAMETER  Mailbox
    Mailbox identifier [samaccountname,name,emailaddr,alias]
    .PARAMETER Ticket
    Ticket # [-Ticket nnnnn]
    .PARAMETER IncludeAge
    Switch to include Oldest/Newest message per folder information[-IncludeAge]
    .PARAMETER IncludeSize
    Switch to include aggregate size of each folder [-IncludeSize]
    .PARAMETER NonEmptyOnly
    Switch to display infor for only non-zero content folders (defaults `$true)[-NonEmptyOnly]
    .INPUTS
    Accepts piped input.
    .OUTPUTS
    Outputs csv & console summary of mailbox folders content
    .EXAMPLE
    get-MailboxFolderStats -Mailbox quotes@domain.com -Ticket 99999 -includeage -verbose ;
    Perform a mailbox stats summary report query, on the specified mailbox, and include specified ticket# in output csv (which is output below .\logs\ dir of current directory at runtime).
    .EXAMPLE
    $report = get-MailboxFolderStats -Mailbox quotes@domain.com -Ticket 99999 -includeage -asobject ;
    Return an object for the summary report, rather than console dump (in addition to csv export)
    .EXAMPLE
    get-MailboxFolderStats -Mailbox quotes@domain.com -Ticket 347298 -includeage -includesize ;
    Perform a mailbox stats, and include size per folder (in KB) in output report
    .LINK
    https://github.com/tostka/verb-exo
    .LINK
    https://github.com/tostka/verb-ex2010
    #>
    #Requires -Version 3
    ##Requires -Modules verb-ex2010
    # 2:49 PM 3/8/2022 pull verb-ex2010 ref - I think it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag values, indicating Tenant to Create DDG WITHIN[-TenOrg 'TOL']")]
        [ValidateNotNullOrEmpty()]
        [string]$TenOrg = ('TOR'),
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Mailbox identifier [samaccountname,name,emailaddr,alias]")]
        [ValidateNotNullOrEmpty()][string]$Mailbox,    
        [Parameter(Mandatory=$false,HelpMessage="Ticket # [-Ticket nnnnn]")]
        #[ValidateLength(5)] # non-mandatory
        [int]$Ticket,
        [Parameter(HelpMessage="Switch to include Oldest/Newest message per folder information[-IncludeAge]")]
        [switch] $IncludeAge,
        [Parameter(HelpMessage="Switch to include aggregate size of each folder [-IncludeSize]")]
        [switch] $IncludeSize,
        [Parameter(HelpMessage="Switch to display info for only non-zero content folders (defaults `$true)[-NonEmptyOnly]")]
        [switch] $NonEmptyOnly=$true,
        [Parameter(HelpMessage="Switch to return raw object rather than formated console report(defaults `$true)[-NonEmptyOnly]")]
        [switch] $asObject
    ) ;
    BEGIN {
        $Verbose=($VerbosePreference -eq 'Continue') ;  
        # Get parameters this function was invoked with
        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;  
        $pltGMFS=@{identity= $Mailbox ;} ; 
        $propsFldr = @{Name='Folder';Expression={$_.Identity.tostring()}},@{Name="Items";Expression={$_.ItemsInFolder}} ;
        $rgxSysFldrs = '.*\\(Versions|SubstrateHolds|DiscoveryHolds|Yammer.*|Social\sActivity\sNotifications|Suggested\sContacts|Recipient\sCache|PersonMetadata|Audits|Calendar\sLogging|Purges)$' ; 
        if($IncludeAge){ 
            $pltGMFS.add('IncludeOldestAndNewestItems',$true) ; 
            $propsFldr += @{Name="OldestItem";Expression={get-date $_.OldestItemReceivedDate}},@{Name="NewestItem";Expression={$_.NewestItemReceivedDate}} ; 
        } ;
        if($IncludeSize){ 
            $pltGMFS.add('IncludeAnalysis',$true) ; 
            # w dehydrated, raw parsing is: $mbxstats.TotalItemSize.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB ;
            $propsFldr += @{Name="SizeMB";Expression={[math]::round($_.FolderSize.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}} ; 
        } ;

        $Retries = 4 ;
        $RetrySleep = 5 ;
        if(!$ThrottleMs){$ThrottleMs = 50 ;}
        $CredRole = 'CSVC' ; # role of svc to be dyn pulled from metaXXX if no -Credential spec'd, 
        if(!$rgxDriveBanChars){$rgxDriveBanChars = '[;~/\\\.:]' ; } ; # ;~/\.:, 

        $UseOP=$false ; 
        if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
            $UseOP = $true ; 
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ; 
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } else { 
            $UseOP = $false ; 
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ; 
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; 

        # o365/EXO creds
        $o365Cred=$null ;
        <# Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile* 
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
        Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
        .EXAMPLE
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
        Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
        .EXAMPLE
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
        Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
        #>
        #if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -verbose:$($verbose))){
        # force it to use the csvc mapping from $xxxmeta.o365_CSvcUpn, failthrough to SID spec 
        if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -UserRole 'CSVC','SID' -verbose:$($verbose))){
            # make it script scope, so we don't have to predetect & purge before using new-variable
            New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
            $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } else {
            #-=-record a STATUS=-=-=-=-=-=-=
            $statusdelta = ";ERROR";
            if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
            #-=-=-=-=-=-=-=-=
            $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
            exit ;
        } ;
        <# CALLS ARE IN FORM: (cred$($tenorg))
        $pltRXO = @{Credential = $Credential ; verbose = $($verbose) ; }
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            verbose = $($verbose) ; } ; 
        if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
        else { reconnect-EXO @pltRXO } ;
        # or with Tenant-specific cred($Tenorg) lookup
        #>

        if($UseOP){
            # do the OP creds too
            $OPCred=$null ;
            # default to the onprem svc acct
            $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC' ;verbose=$($verbose)} ;
            if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                #-=-record a STATUS=-=-=-=-=-=-=
                $statusdelta = ";ERROR";
                if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                #-=-=-=-=-=-=-=-=
                $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                exit ;
            } ;

            # === Exchange LEMS/REMS detect & connect code

            $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;  
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ; 

    } ;  # BEGIN-E
    PROCESS {
        $ofile=".\$($ticket)-$($Mailbox)-folder-sizes-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
        $error.clear() ;
        TRY {
            if(!(gcm get-recipient -ea 0)){rx10} ;
            $OpRcp=get-recipient $Mailbox ;
            switch ($OpRcp.recipienttype){
                "MailUser" {
                    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($tmbx) IS AN EXO MBOX" ;
                    
                    if($VerbosePreference = "Continue"){
                        $VerbosePrefPrior = $VerbosePreference ;
                        $VerbosePreference = "SilentlyContinue" ;
                        $verbose = ($VerbosePreference -eq "Continue") ;
                    } ; 
                    disconnect-exo ; # pre-disconnect    
                    $pltRXO = @{
                        Credential = (Get-Variable -name cred$($tenorg) ).value ;
                        verbose = $($verbose) ; }
                    if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
                    else { reconnect-EXO @pltRXO } ;
                    if($VerbosePrefPrior -eq "Continue"){
                        $VerbosePreference = $VerbosePrefPrior ;
                        $verbose = ($VerbosePreference -eq "Continue") ;
                    } ;

                    set-alias ps1GetMbxFldrStat Get-exoMailboxFolderStatistics ; 
                } ;
                "UserMailbox" {
                    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($tmbx) IS AN EX2010 MBOX" ;
                    
                    if($VerbosePreference = "Continue"){
                        $VerbosePrefPrior = $VerbosePreference ;
                        $VerbosePreference = "SilentlyContinue" ;
                        $verbose = ($VerbosePreference -eq "Continue") ;
                    } ; 
                    # connect OP
                    $pltRX10 = @{
                        Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                        verbose = $($verbose) ; } ;     
                    if($pltRX10){
                        Connect-Ex2010 @pltRX10 ;
                    } else { connect-Ex2010 ; } ;
                    # reenable VerbosePreference:Continue, if set, during mod loads 
                    if($VerbosePrefPrior -eq "Continue"){
                        $VerbosePreference = $VerbosePrefPrior ;
                        $verbose = ($VerbosePreference -eq "Continue") ;
                    } ;

                    set-alias ps1GetMbxFldrStat Get-MailboxFolderStatistics ; 
                } ;
                default {
                    throw "UNRECOGNIZED ONPREM RECIPIENTTYPE:$($OpRcp.recipienttype)" ; exit ; 
                } ; 
            } ;
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$((get-alias ps1GetMbxFldrStat).definition) w`n$(($pltGMFS|out-string).trim())" ; 
            $fldrs = ps1GetMbxFldrStat @pltGMFS ;
            if($NonEmptyOnly){
                write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):(REPORTING NON-ZERO FOLDERS ONLY)" ; $fldrs = $fldrs | ?{$_.ItemsInFolder -gt 0}
            } ; 
            $fldrs | ?{$_.identity -notmatch $rgxSysFldrs } | select $propsFldr | export-csv  -path $ofile -notype ;
            if(!$asObject){
                import-csv $ofile | ft -auto | out-default ; 
            } else { 
                write-verbose "-asObject specified, returning object to pipeline (rather than console dump)" ; 
                import-csv $ofile | write-output ; 
            } ; 
            write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):`n===>`$ofile:$($ofile)`n" ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ; 
    } ;  # PROC-E
    END {
        remove-alias ps1GetMbxFldrStat ;
    } ; 
    
}

#*------^ get-MailboxFolderStats.ps1 ^------


#*------v get-MsgTrace.ps1 v------
function get-MsgTrace {
    <#
    .SYNOPSIS
    get-MsgTrace.ps1 - Perform smart get-exoMessageTrace/MessageTrackingLog command, as appropriate to target location -Mailbox, on either Exchange on-premesis or Exchange Online.
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-03-12
    FileName    : get-MsgTrace.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Mailbox,Statistics,Reporting
    REVISIONS
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 2:40 PM 12/10/2021 more cleanup 
     * 12:17 PM 5/14/2021 updated passstatus code to curr, and added -ea to the gv's (suppress errors when not present)
    * 2:23 PM 3/16/2021 added multi-tenant support ; debugged both exOP & exo, added -ReportFail & -ReportRowsLimit params. At this point Exclusive params are only partially configured
    * 1:12 PM 3/15/2021 init work was done 3/12, removed recursive-err generating #Require on the hosting verb-EXO module
    .DESCRIPTION
    get-MsgTrace - Perform smart get-exoMessageTrace/MessageTrackingLog command, as appropriate to target location -Mailbox, on either Exchange on-premesis or Exchange Online.
    Dependancy on my verb-ex2010 Exchange onprem (and is within verb-exo EXO mod, which adds dependant EXO connection support).
    .PARAMETER TenOrg
    TenantTag values, indicating Tenant to Create DDG WITHIN[-TenOrg 'TOL']    
    .PARAMETER Recipients
    Recipient email addresses identifiers (comma-delimited)[-Recipients xxx@domain.com]
    .PARAMETER Sender
    Sender email address identifiers (EXO supports comma-delimited) [-Sender xxx@domain.com]
    .PARAMETER Subject
    "Message Subject string to be matched (post-filtered from broad query)[-Subject 'subject phrase']
    .PARAMETER Logon
    User Logon tag to be applied to output file[-Logon samaccountname]
    .PARAMETER Status
    Transport Status (EventID on-Prem)(RECEIVE|DELIVER|FAIL|SEND|RESOLVE|EXPAND|TRANSFER|DEFER) [-EventID SEND
    .PARAMETER Connectorid
    Connector identifier[-Connectorid SendConnX]
    .PARAMETER Source
    Source keyword to be used for filtering (STOREDRIVER|SMTP|DNS|ROUTING)[-Source SMTP]
    .PARAMETER MessageId
    "Target MessageId for search[-MessageId xxxxxxx]
    .PARAMETER MessageTraceId
    Target MessageId for search[-MessageTraceId xxxxxxx]
    .PARAMETER StartDate
    Start of time span to be searched[-StartDate 1/1/2021]
    .PARAMETER EndDate
    End of time span to be searched[-EndDate 1/7/2021]
    .PARAMETER Ticket
    Ticket # [-Ticket nnnnn]
    .PARAMETER useEXOP
    Switch to specify ONPREM Exch get-MessageTrackingLog trace (defaults `$false == EXO Message Search)[-useEXOP]
    .PARAMETER ReportRowsLimit
    Max number of rows to output to console when a -ReportXXX param is specified (defaults 100)[-ReportRowsLimit]
    .PARAMETER asObject
    Switch to return raw object rather than formated console report(defaults `$true)[-NonEmptyOnly]
    .INPUTS
    Accepts piped input.
    .OUTPUTS
    Outputs csv & console summary of mailbox folders content
    .EXAMPLE
    get-MsgTrace -Sender SENDER@DOMAIN.com -Ticket 99999 -days 7 -verbose ;
    Perform a default EXO trace last 7 days of traffic on specified sender, use specified Ticket number in csv file name, with verbose output
    .EXAMPLE
    $msgs = get-MsgTrace -Sender quotes@bossplow.com -Ticket 347298 -days 7 -asobject -verbose ;
    Above EXO MessageTrace returning an object for further postfiltering.
    .EXAMPLE
    get-msgtrace -sender ACCOUNT@COMPANY.com -useEXOP -ticket 99999 -d 1 -verbose ; 
    Run an ONPREM get-MessageTrackingLog search
    .EXAMPLE 
    $msgs = get-msgtrace -sender ACCOUNT@COMPANY.com -useEXOP -ticket 99999 -start (get-date).addhours(-1) -verbose -ReportFail; 
    Run an ONPREM get-MessageTrackingLog search, with specific -Start time (End will be asserted), with detailed dump of (first 100) EventID 'Fail' items
    .LINK
    https://github.com/tostka/verb-exo
    .LINK
    https://github.com/tostka/verb-ex2010
    #>
    #Requires -Version 3
    ##Requires -Modules verb-ex2010
    # 2:49 PM 3/8/2022 pull verb-ex2010 ref - I think it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("(lyn|bcc|spb|adl)ms6(4|5)(0|1).(china|global)\.ad\.COMPANY\.com")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    [CmdletBinding(DefaultParameterSetName='SendRec')]
    <# $isplt=@{  ticket="347298" ;  uid="wilinaj";  days=7 ;  Sender="quotes@bossplow.com" ;  Recipients="" ;  MessageSubject="" ;  EventID='' ;  Connectorid="" ;  Source="" ;} ; 
    #>
    Param(
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag values, indicating Tenant to Create DDG WITHIN[-TenOrg 'TOL']")]
        [ValidateNotNullOrEmpty()]
        [string]$TenOrg = ('TOR'),
        [Parameter(ParameterSetName='SendRec',HelpMessage="Recipient email addresses identifiers (comma-delimited)[-Recipients xxx@domain.com]")]
        [string]$Recipients,    
        [Parameter(ParameterSetName='SendRec',HelpMessage="Sender email address identifier (EXO supports comma-delimited)")]
        [string]$Sender, 
        [Parameter(HelpMessage="Message Subject string to be matched (post-filtered from broad query)[-Subject 'subject phrase']")]
        [string]$Subject,
        [Parameter(HelpMessage="User Logon tag to be applied to output file[-Logon samaccountname]")]
        [string]$Logon,
        [Parameter(HelpMessage="Transport Status (EventID on-Prem)(RECEIVE|DELIVER|FAIL|SEND|RESOLVE|EXPAND|TRANSFER|DEFER) [-EventID SEND")]
        [ValidateSet("RECEIVE","DELIVER","FAIL","SEND","RESOLVE","EXPAND","TRANSFER","DEFER")]
        [string]$Status,
        [Parameter(HelpMessage="Connector identifier[-Connectorid SendConnX]")]
        [string]$Connectorid,
        [Parameter(HelpMessage="Source keyword to be used for filtering (STOREDRIVER|SMTP|DNS|ROUTING)[-Source SMTP]")]
        [ValidateSet("STOREDRIVER","SMTP","DNS","ROUTING")]
        [string]$Source,
        [Parameter(ParameterSetName='MsgID',HelpMessage="Target MessageId for search[-MessageId xxxxxxx]")]
        [string]$MessageId, 
        [Parameter(ParameterSetName='MsgTrcID',HelpMessage="Target MessageId for search[-MessageTraceId xxxxxxx]")]
        [string]$MessageTraceId,
        [Parameter(HelpMessage="Start of time span to be searched[-StartDate 1/1/2021]")]
        [string]$StartDate,
        [Parameter(HelpMessage="End of time span to be searched[-EndDate 1/7/2021]")]
        [string]$EndDate,
        [Parameter(HelpMessage="Days back to search[-Days 7]")]
        [int]$Days,
        [Parameter(Mandatory=$false,HelpMessage="Ticket # [-Ticket nnnnn]")]
        #[ValidateLength(5)] # non-mandatory
        [int]$Ticket,
        [Parameter(HelpMessage="Switch to specify ONPREM Exch get-MessageTrackingLog trace (defaults `$false == EXO Message Search)[-useEXOP]")]
        [switch] $useEXOP=$false,
        [Parameter(HelpMessage="Switch to return raw object rather than formated console report(defaults `$true)[-NonEmptyOnly]")]
        [switch] $asObject,
        [Parameter(HelpMessage="Switch to return detailed analysis of FAIL items[-ReportFail]")]
        [switch] $ReportFail,
        [Parameter(HelpMessage="Max number of rows to output to console when a -ReportXXX param is specified (defaults 100)[-ReportRowsLimit]")]
        [int]$ReportRowsLimit = 100  
    ) ;
    BEGIN {
        $Verbose=($VerbosePreference -eq 'Continue') ;  
        # Get parameters this function was invoked with
        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
        $propsFldr = @{Name='Folder';Expression={$_.Identity.tostring()}},@{Name="Items";Expression={$_.ItemsInFolder}} ;
        $propsMsgEx10 = 'Timestamp',@{N='TimestampLocal';E={$_.Timestamp.ToLocalTime()}},'Source','EventId','RelatedRecipientAddress','Sender',@{N='Recipients';E={$_.Recipients}},"RecipientCount",@{N='RecipientStatus';E={$_.RecipientStatus}},"MessageSubject","TotalBytes",@{N='Reference';E={$_.Reference}},'MessageLatency','MessageLatencyType','InternalMessageId','MessageId','ReturnPath','ClientIp','ClientHostname','ServerIp','ServerHostname','ConnectorId','SourceContext','MessageInfo',@{N='EventData';E={$_.EventData}} ;
        $propsMsgEXO = @{N='ReceivedLocal';E={$_.Received.ToLocalTime()}},'SenderAddress','RecipientAddress','Subject','Status','ToIP','FromIP','Size','MessageId','MessageTraceId','Index' ;
        
        # pull settings per Tenant fr Meta
        $Meta = gv -name "$($TenOrg)Meta" ; 
        <# pull value fr meta
        if($Meta -is [system.array]){ throw "Unable to resolve unique `$xxxMeta! from `$TenOrg:$($TenOrg)" ; break} ; 
        if(!$Meta.value.DefaultObjectOwner){throw "Unable to resolve $($Meta.Name).value.DefaultObjectOwner from `$TenOrg:$($TenOrg)" ; break} 
        else { $ManagedBy=$Meta.value.DefaultObjectOwner} ;  ;
        #>

        $Retries = 4 ;
        $RetrySleep = 5 ;
        if(!$ThrottleMs){$ThrottleMs = 50 ;}
        $CredRole = 'CSVC' ; # role of svc to be dyn pulled from metaXXX if no -Credential spec'd, 
        if(!$rgxDriveBanChars){$rgxDriveBanChars = '[;~/\\\.:]' ; } ; # ;~/\.:, 
        
        if($useEXOP){
            $UseOP=$false ; 
            if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
                $UseOP = $true ; 
                $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ; 
                if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else { 
                $UseOP = $false ; 
                $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ; 
                if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } ; 
        } else { 
            # o365/EXO creds
            $o365Cred=$null ;
            <# Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile* 
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
            Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
            Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
            Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            #>
            #if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -verbose:$($verbose))){
            # force it to use the csvc mapping from $xxxmeta.o365_CSvcUpn, failthrough to SID spec 
            if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -UserRole 'CSVC','SID' -verbose:$($verbose))){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
                $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                #-=-record a STATUS=-=-=-=-=-=-=
                $statusdelta = ";ERROR";
                if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                #-=-=-=-=-=-=-=-=
                $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                exit ;
            } ;
            <# CALLS ARE IN FORM: (cred$($tenorg))
            $pltRXO = @{Credential = $Credential ; verbose = $($verbose) ; }
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                verbose = $($verbose) ; } ; 
            if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
            else { reconnect-EXO @pltRXO } ;
            # or with Tenant-specific cred($Tenorg) lookup
            #>
        } ; 

        if($UseOP){
            # do the OP creds too
            $OPCred=$null ;
            # default to the onprem svc acct
            $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC' ;verbose=$($verbose)} ;
            if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                #-=-record a STATUS=-=-=-=-=-=-=
                $statusdelta = ";ERROR";
                if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                #-=-=-=-=-=-=-=-=
                $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                exit ;
            } ;

            # === Exchange LEMS/REMS detect & connect code

            $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;  
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ; 
        
    } ;  # BEGIN-E
    PROCESS {
        #$ofile=".\$($ticket)-$($Mailbox)-folder-sizes-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
        $error.clear() ;
    
        switch ($useEXOP){
            $false {

                write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):PERFORMING AN EXO MSGTRACE" ;
                if($VerbosePreference = "Continue"){
                    $VerbosePrefPrior = $VerbosePreference ;
                    $VerbosePreference = "SilentlyContinue" ;
                    $verbose = ($VerbosePreference -eq "Continue") ;
                } ; 
                disconnect-exo ; # pre-disconnect    
                $pltRXO = @{
                    Credential = (Get-Variable -name cred$($tenorg) ).value ;
                    verbose = $($verbose) ; }
                if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
                else { reconnect-EXO @pltRXO } ;
                if($VerbosePrefPrior -eq "Continue"){
                    $VerbosePreference = $VerbosePrefPrior ;
                    $verbose = ($VerbosePreference -eq "Continue") ;
                } ;

                # recycle $pltRXO for the AAD connection
                connect-AAD @pltRXO ;

                set-alias ps1GetMsgTrace Get-exoMessageTrace  ; 
                $props = $propsMsgEXO ; 
                $msgtrk=[ordered]@{
                    PageSize=1000 ;
                    Page=$null ;
                    StartDate=$null ;
                    EndDate=$null ;
                } ;
                if($Days -AND -not($StartDate -AND $EndDate)){
                    $msgtrk.StartDate=(get-date ([datetime]::Now)).adddays(-1*$days);
                    $msgtrk.EndDate=(get-date) ;
                } ;
                if($StartDate -and !($days)){
                    $msgtrk.StartDate=$(get-date $StartDate)
                } ;
                if($EndDate -and !($days)){
                    $msgtrk.EndDate=$(get-date $EndDate)
                } elseif($StartDate -and !($EndDate)){
                    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):
    (StartDate w *NO* Enddate, asserting currenttime)" ;
                    $msgtrk.EndDate=(get-date) ;
                } ;
                
                $error.clear() ;
                TRY {
                    #Connect-AAD ;
                    $tendoms=Get-AzureADDomain ;
                } CATCH {
                    $ErrTrapt=$Error[0] ;
                    Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
                    $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrpd.Exception.GetType().FullName)]{" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Exit #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                } ; 
            
                $Ten = ($tendoms |?{$_.name -like '*.mail.onmicrosoft.com'}).name.split('.')[0] ;
                $ofile ="$($ticket)-$($Ten)-$($Logon)-EXOMsgTrk" ;
                if($Sender){
                    if($Sender -match '\*'){
                        "(wild-card Sender detected)" ;
                        $msgtrk.add("SenderAddress",$Sender) ;
                    } else {
                        $msgtrk.add("SenderAddress",$Sender) ;
                    } ;
                    $ofile+=",From-$($Sender.replace("*","ANY"))" ;
                } ;
                if($Recipients){
                    if($Recipients -match '\*'){        "(wild-card Recipient detected)" ;
                        $msgtrk.add("RecipientAddress",$Recipients) ;
                    } else {
                            $msgtrk.add("RecipientAddress",$Recipients) ;
                    } ;
                    $ofile+=",To-$($Recipients.replace("*","ANY"))" ;
                } ;
                if($MessageId){
                    $msgtrk.add("MessageId",$MessageId) ;
                    $ofile+=",MsgId-$($MessageId.replace('<','').replace('>',''))" ;
                } ;
                if($MessageTraceId){
                    $msgtrk.add("MessageTraceId",$MessageTraceId) ;
                    $ofile+=",MsgId-$($MessageTraceId.replace('<','').replace('>',''))" ;
                } ;
                if($Subject){    $ofile+=",Subj-$($Subject.substring(0,[System.Math]::Min(10,$Subject.Length)))..." ;
                } ;
                if($Status){
                    $msgtrk.add("Status",$Status)  ;
                    $ofile+=",Status-$($Status)" ;
                } ;
                if($days){$ofile+= "-$($days)d-" } ;
                if($StartDate){$ofile+= "-$(get-date $StartDate -format 'yyyyMMdd-HHmmtt')-" } ;
                if($EndDate){$ofile+= "$(get-date $EndDate -format 'yyyyMMdd-HHmmtt')" } ;
                
                write-verbose -verbose:$true  "$((get-date).ToString('HH:mm:ss')):Running MsgTrk:$($Ten)" ;
    $(($msgtrk|out-string).trim()|out-default) ;
  
                TRY {
                    $Page = 1  ;
                    $Msgs=$null ;
                    do {
                        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):Collecting - Page $($Page)..."  ;
                        $msgtrk.Page=$Page ;
                        $PageMsgs = ps1GetMsgTrace @msgtrk |  ?{$_.SenderAddress -notlike '*micro*' -or $_.SenderAddress -notlike '*root*' }  ;
                        $Page++  ;
                        $Msgs += @($PageMsgs)  ;
                    } until ($PageMsgs -eq $null) ;
                } CATCH {
                    Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
                    Exit ;
                } ; 
                $Msgs=$Msgs| Sort Received ;
                write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):==Msgs Returned:$(($Msgs|measure).count)" ;
                write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):Raw matches:$(($Msgs|measure).Count)" ;
                if($Subject){
                    write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):Post-Filtering on Subject:$($Subject)" ;
                    $Msgs = $Msgs | ?{$_.Subject -like $Subject} ;
                    $ofile+="-Subj-$($Subject.replace("*"," ").replace("\"," "))" ;
                    write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):Post Subj filter matches:$(($Msgs|measure).Count)" ;
                } ;
                $ofile+= "-run$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
                $ofile=[RegEx]::Replace($ofile, "[{0}]" -f ([RegEx]::Escape(-join [System.IO.Path]::GetInvalidFileNameChars())), '') ;
                $ofile=".\logs\$($ofile)" ;
                if($Msgs){
                    $Msgs | select $props | export-csv -notype -path $ofile  ;
                    write-host -foregroundcolor yellow "Status Distrib:" ;
                    write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):`n#*------v MOST RECENT MATCH v------" ;
                    write-host -foregroundcolor white "$(($msgs[-1]| format-list ReceivedLocal,StatusSenderAddress,RecipientAddress,Subject|out-string).trim())";
                    write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):`n#*------^ MOST RECENT MATCH ^------" ;
                    write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):`n#*------v Status DISTRIB v------" ;
                    "$(($Msgs | select -expand Status | group | sort count,count -desc | select count,name |out-string).trim())";
                    write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):`n#*------^ Status DISTRIB ^------" ;
                    if(test-path -path $ofile){
                            write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):(log file confirmed)" ;
                            Resolve-Path -Path $ofile | select -expand Path | out-clipboard ;
                            write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($Msgs.count) matches output to:`n'$($ofile)'`n(copied to CB)" ;
                    } else { "MISSING LOG FILE!" } ;

                    if($ReportFail){
                        $sBnr3="`n#*------v Status:FAIL Traffic (up to 1st $($ReportRowsLimit)) v------" ; 
                        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3)" ;
                        write-host -foregroundcolor cyan "$(($MSGS|?{$_.Status -eq 'FAIL'} | select -first $($ReportRowsLimit) | fl recipients,recipientstatus,ServerHostname|out-string).trim())" ; 
                        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3.replace('~v','~^').replace('v~','^~'))`n" ;
                    } ; 
                    
                    if($asObject){
                        $Msgs | write-output ; 
                    } ; 
                } else {
                    write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):NO MATCHES FOUND from::`n$(($msgtrk|out-string).trim()|out-default)`n(with any relevant ConnectorId postfilter)" ;
                } ;
            } ; # end EXO switchblock

            $true {
                write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):PERFORMING AN ONPREM MSGTRACK" ;
                if($VerbosePreference = "Continue"){
                    $VerbosePrefPrior = $VerbosePreference ;
                    $VerbosePreference = "SilentlyContinue" ;
                    $verbose = ($VerbosePreference -eq "Continue") ;
                } ; 
                # connect OP
                $pltRX10 = @{
                    Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                    verbose = $($verbose) ; } ;     
                if($pltRX10){
                    Connect-Ex2010 @pltRX10 ;
                } else { connect-Ex2010 ; } ;

                # reenable VerbosePreference:Continue, if set, during mod loads 
                if($VerbosePrefPrior -eq "Continue"){
                    $VerbosePreference = $VerbosePrefPrior ;
                    $verbose = ($VerbosePreference -eq "Continue") ;
                } ;

                set-alias ps1GetMsgTrace get-messagetrackinglog  ; 
                $props = $propsMsgEx10 ; 
                $msgtrk=@{
                    Start=(get-date ([datetime]::Now)).adddays(-1*$days) ;
                    End=(get-date) ;
                    resultsize="UNLIMITED" ;
                } ;
                # Page=$null ;
                $msgtrk=[ordered]@{
                    resultsize="UNLIMITED" ;
                    Start=$null ;
                    End=$null ;
                } ;
                if($Days -AND -not($StartDate -AND $EndDate)){
                    $msgtrk.Start=(get-date ([datetime]::Now)).adddays(-1*$days);
                    $msgtrk.End=(get-date) ;
                } ;
                if($StartDate -and !($days)){
                    $msgtrk.Start=$(get-date $StartDate)
                } ;
                if($EndDate -and !($days)){
                    $msgtrk.End=$(get-date $EndDate)
                } elseif($StartDate -and !($EndDate)){
                    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):
    (StartDate w *NO* End, asserting currenttime)" ;
                    $msgtrk.End=(get-date) ;
                } ;
                TRY {
                    $Site=[System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().Name ;
                    # "$($ticket)-$($uid)-$($Site.substring(0,3))-MsgTrk" ;
                    $ofile ="$($ticket)-$($Site.substring(0,3))-OPMsgTrk" ;
                    if($Sender){$msgtrk.add("Sender",$Sender) ;
                        $ofile+=",From-$($Sender)" ;
                        } ;
                    if($Recipients){$msgtrk.add("Recipients",$Recipients) ;
                        $ofile+=",To-$($Recipients)" ;
                    } ;
                    if($Subject){$msgtrk.add("MessageSubject",$Subject)  ;
                        $ofile+=",Subj-$($Subject.substring(0,[System.Math]::Min(10,$Subject.Length)))..." ;
                    } ;
                    if($EventID){$msgtrk.add("EventID",$Status)  ;
                        $ofile+=",Evt-$($Status)" ;
                    } ;
                    
                    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$((get-alias ps1GetMsgTrace).ResolvedCommandName) w`n$(($msgtrk|out-string).trim())" ; 
                    $Srvrs=(Get-ExchangeServer | where { $_.isHubTransportServer -eq $true -and $_.Site -match ".*\/$($Site)$"} | select -expand Name) ;
                    #$Msgs=($Srvrs| get-messagetrackinglog @msgtrk) | sort Timestamp ;
                    $Msgs =@() ; # 
                    # loop the servers, to provide a status output
                    foreach($Srvr in $Srvrs){
                        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):Tracking $($Srvr) server..." ; 
                        $sMsgs = ($Srvr| get-messagetrackinglog @msgtrk) ;
                        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):(($Srvr):$(($sMsgs|measure).count) matched msgs)" ; 
                        $Msgs+=$sMsgs ; 
                        $sMsgs = $null ; 
                    } ; 
                    #$Msgs = $Msgs |  sort Timestamp ;
                    $Msgs=$Msgs| Sort Timestamp ;
                    write-verbose -verbose:$true  "$((get-date).ToString('HH:mm:ss')):Raw matches:$(($Msgs|measure).Count)" ;
                    if($Connectorid){
                        write-verbose -verbose:$true  "$((get-date).ToString('HH:mm:ss')):Filtering on Conn:$($Connectorid)" ;
                        $Msgs = $Msgs | ?{$_.connectorid -like $Connectorid} ;
                        $ofile+="-conn-$($Connectorid.replace("*"," ").replace("\"," "))" ;
                        write-verbose -verbose:$true  "$((get-date).ToString('HH:mm:ss')):Post Conn filter matches:$(($Msgs|measure).Count)" ;
                    } ;
                    if($Source){
                        write-verbose -verbose:$true  "$((get-date).ToString('HH:mm:ss')):Filtering on Source:$($Source)" ;
                        $Msgs = $Msgs | ?{$_.Source -like $Source} ;
                        write-verbose -verbose:$true  "$((get-date).ToString('HH:mm:ss')):Post Src filter matches:$(($Msgs|measure).Count)" ;
                        $ofile+="-src-$($Source)" ;
                    } ;
                    if($Days){$ofile+= "-$($days)d-run$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;} 
                    else {
                        $ofile+= "-$(get-date $msgtrk.Start -format 'yyyyMMdd-HHmmtt')-$(get-date $msgtrk.End -format 'yyyyMMdd-HHmmtt')-run$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
                    } ;  
                    $ofile=[RegEx]::Replace($ofile, "[{0}]" -f ([RegEx]::Escape(-join [System.IO.Path]::GetInvalidFileNameChars())), '') ;
                    $ofile=".\logs\$($ofile)" ;
                    
                    if($Msgs){
                        $Msgs | SELECT $props| EXPORT-CSV -notype -path $ofile ;
                        write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):`n#*------v MOST RECENT MATCH v------" ;
                        write-host -foregroundcolor cyan "$(((($msgs[-1]| format-list Timestamp,EventId,Sender,Recipients,MessageSubject|out-string).trim())|out-string).trim())" ; 
                        write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):`n#*------^ MOST RECENT MATCH ^------" ;
                        write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):`n#*------v EVENTID DISTRIB v------" ;
                        write-host -foregroundcolor cyan "$(($Msgs | select -expand EventId | group | sort count,count -desc | select count,name |out-string).trim())" ; 
                        write-host -fore gray "(SEND=SMTP SEND,TRANSFER=Routing,RESOLVE=Recipient conversion)" ;
                        write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):`n#*------^ EVENTID DISTRIB ^------" ;
                        if(test-path -path $ofile){
                            write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):(log file confirmed)" ;
                            Resolve-Path -Path $ofile | select -expand Path | out-clipboard ;
                            write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($Msgs.count) matches output to:`n'$($ofile)'`n(copied to CB)" ;
                        } else { "MISSING LOG FILE!" } ;
                        
                        if($ReportFail){
                            $sBnr3="`n#*~~~~~~v -ReportFail specified: Status:FAIL Traffic (up to 1st $($ReportRowsLimit)): v~~~~~~" ; 
                            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3)" ;
                            write-host -foregroundcolor cyan "$(((($MSGS|?{$_.eventid -eq 'fail'} | select -first $($ReportRowsLimit) | fl recipients,recipientstatus,ServerHostname|out-string).trim())|out-string).trim())" ; 
                            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3.replace('~v','~^').replace('v~','^~'))`n" ;
                        } ; 

                        if($asObject){
                            $Msgs | SELECT $props | write-output ; 
                        } ; 
                    } else {    write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):NO MATCHES FOUND from::`n$(($msgtrk|out-string).trim()|out-default)`n(with any relevant ConnectorId postfilter)" ;
                    } ;
                } CATCH {
                    Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
                    Exit ;
                } ; 
            } ;
            default {
                throw "UNRECOGNIZED useEXOP value)" ; exit ; 
            } ; 
        } ; # SWITCH-E
        
    } ;  # PROC-E
    END {
        remove-alias ps1GetMsgTrace ;
    } ; 
}

#*------^ get-MsgTrace.ps1 ^------


#*------v Get-OrgNameFromUPN.ps1 v------
function Get-OrgNameFromUPN{
    <#
    .SYNOPSIS
    Get-OrgNameFromUPN.ps1 - Extract organization name from UserPrincipalName ; localized verb-EXO vers of non-'$global:' helper funct from ExchangeOnlineManagement. The globals export fine, these don't and appear to need to be loaded manually
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 20201109-0833AM
    FileName    : Get-OrgNameFromUPN.ps1
    License     : [none specified]
    Copyright   : [none specified]
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell
    AddedCredit : Microsoft (edited version of published commands in the module)
    AddedWebsite:	https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
    REVISIONS
    * 8:34 AM 11/9/2020 init
    .DESCRIPTION
    Get-OrgNameFromUPN.ps1 - Extract organization name from UserPrincipalName ; localized verb-EXO vers of non-'$global:' helper funct from ExchangeOnlineManagement. The globals export fine, these don't and appear to need to be loaded manually

    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    Get-OrgNameFromUPN
    Stock call
    .LINK
    https://github.com/tostka/verb-EXO
    .LINK
    https://docs.microsoft.com/en-us/powershell/exchange/exchange-online-powershell-v2
    #>
    [CmdletBinding()]
    param([string] $UPN)
    $fields = $UPN -split '@'
    return $fields[-1]
}

#*------^ Get-OrgNameFromUPN.ps1 ^------


#*------v get-xoHistSearch.ps1 v------
function get-xoHistSearch {
    <#
    .SYNOPSIS
    get-xoHistSearch.ps1 - wrapper/automation for EXO's get-HistoricalSearch cmdlet, Assembles ReportTitle & models an export-csv filename, around recipient, sender, reportType etc params specified for get-historicalsearch, also dawdle loops monitoring & alerting the progress of the associated PSJob created by the search submission.
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-07-13
    FileName    : get-xoHistSearch.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 2:16 PM 6/24/2024: rem'd out #Requires -RunasAdministrator; sec chgs in last x mos wrecked RAA detection 
    * 1:44 PM 1/6/2022 updated example2 to have start/end rather than days; added region tags for bracketed blocks of code
    * 2:40 PM 12/10/2021 more cleanup 
    * 12:49 PM 9/28/2021 init; added MsgID support; added MsgID example
    .DESCRIPTION
    get-xoHistSearch.ps1 - wrapper/automation for EXO's get-HistoricalSearch cmdlet, Assembles ReportTitle & models an export-csv filename, around recipient, sender, reportType etc params specified for get-historicalsearch, also dawdle loops monitoring & alerting the progress of the associated PSJob created by the search submission.
    .PARAMETER Requester
    Requester identifier[-Requester user@domain.com]
    .PARAMETER Ticket
    Ticket # [-Ticket nnnnn]
    .PARAMETER Days
    Days of History to retrieve (from current time, defaults to 30) # [-Days nnnnn]
    .PARAMETER StartDate
    Optional StartDate (use of -Days will autocalc from current datetime)[-StartDate mm/dd/yyyy]
    .PARAMETER EndDate
    Optional EndDate (use of -Days will autocalc from current datetime) [-EndDate mm/dd/yyyy]
    .PARAMETER Recipients
    RecipientAddresses [-Recipients 'recip1@domain.com','recip2@domain.com']
    .PARAMETER Sender
    SenderAddress [-Sender 'sender@domain.com']
    .PARAMETER MessageID
    MessageID to be traced [-MessageID '<XXXXX@XXXXX.namprd04.prod.outlook.com>']
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    Returns report to pipeline
    .EXAMPLE
    PS> $pltHS = [ordered]@{ 
            Ticket = TICKET;
            Requester = 'REQUESTOR' ;
            Days = 30 ;
            Recipient = $null ;
            Sender = 'SENDER@DOMAIN.COM' ;
            NotifyAddress = 'NOTIFY@DOMAIN.COM' ;
            verbose = $true ;
            showdebug = $true ;
         } ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):get-xoHistSearch w`n$(($pltHS|out-string).trim())" ;
    get-xoHistSearch @pltHS ;
    Demo splatted-params search against Days and Sender
    .EXAMPLE
    PS> $pltHS = [ordered]@{ 
        Ticket = 'TICKET';
        Requester = 'REQUESTOR' ;;
        StartDate = (get-date 'TIMESTAMP').AddMinutes(-5) ;
        EndDate = (get-date 'TIMESTAMP').AddMinutes(60) ; ; 
        Recipient = $null ;
        Sender = 'SENDER' ;
        NotifyAddress = 'todd.kadrie@toro.com' ;
        MessageId = '<CH2PR04MB6886105FBBEB2C3FB2DD9D0DF4759@CH2PR04MB6886.namprd04.prod.outlook.com>' ;
        verbose = $true ;
        showdebug = $true ;
    } ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):get-xoHistSearch w`n$(($pltHS|out-string).trim())" ;
    get-xoHistSearch @pltHS ;
    Demo splatted-params -MessageID HistoricalSearch with Start & EndDates bracketing timestamp (from problem message)
    .LINK
    https://docs.microsoft.com/en-us/powershell/module/exchange/get-historicalsearch
    .LINK
    https://github.com/tostka/verb-exo
    #>
    ###Requires -Version 5
    #Requires -Modules ExchangeOnlineManagement,verb-Auth, verb-IO, verb-logging, verb-Text
    ###Requires -Modules ActiveDirectory, AzureAD, MSOnline, ExchangeOnlineManagement, verb-ADMS, verb-Auth, verb-Ex2010, verb-EXO, verb-IO, verb-logging, verb-Text
    ##Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("(lyn|bcc|spb|adl)ms6(4|5)(0|1).(china|global)\.ad\.COMPANY\.com")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding(DefaultParameterSetName='Days')]
    #[CmdletBinding()]
    #[Alias('gxhs')]
    PARAM(
        [Parameter(Mandatory=$False,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
        $TenOrg = 'TOR',
        [Parameter(Mandatory=$False,HelpMessage="Requester identifier[-Requester user@domain.com]")]
        $Requester,
        [Parameter(Mandatory=$False,HelpMessage="Ticket # [-Ticket nnnnn]")]
        $Ticket,
        [Parameter(ParameterSetName='Days',Mandatory=$False,HelpMessage="Days of History to retrieve (from current time, defaults to 30) # [-Days nnnnn]")]
        [int]$Days=30,
        [Parameter(ParameterSetName='Date',Mandatory=$False,HelpMessage="Optional StartDate (use of -Days will autocalc from current datetime)[-StartDate mm/dd/yyyy]")]
        [DateTime]$StartDate,
        [Parameter(ParameterSetName='Date',Mandatory=$False,HelpMessage="Optional EndDate (use of -Days will autocalc from current datetime) [-EndDate mm/dd/yyyy]")]
        [DateTime]$EndDate,
        [Parameter(Mandatory=$False,HelpMessage="RecipientAddresses [-Recipients 'recip1@domain.com','recip2@domain.com']")]
        [string]$Recipients,
        [Parameter(Mandatory=$False,HelpMessage="SenderAddress [-Sender 'sender@domain.com']")]
        [string]$Sender,
        [Parameter(Mandatory=$False,HelpMessage="MessageID to be traced [-MessageID '<XXXXX@XXXXX.namprd04.prod.outlook.com>']")]
        [string]$MessageID,
        [Parameter(Mandatory=$False,HelpMessage="Result status Notification Address [-NotifyAddress 'recipx@domain.com']")]
        [string]$NotifyAddress,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2,
        [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
        [switch] $showDebug
    ) ;
    BEGIN{
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        #$rgxEmailAddr = "^([0-9a-zA-Z]+[-f._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ;
        #$rgxDName = "^([a-zA-Z]{2,}\s[a-zA-Z]{1,}'?-?[a-zA-Z]{2,}\s?([a-zA-Z]{1,})?)" ;
        #$rgxSamAcctNameTOR = "^\w{2,20}$" ; # up to 20k, the limit prior to win2k
        #$rgxSamAcctName = "^[^\/\\\[\]:;|=,+?<>@?]+$" # no char limit ;

        $propsJob = "Status",@{name="Stat"; expression={$_.ReportStatusDescription}},@{name="From"; expression={$_.SenderAddress}},@{name="To"; expression={$_.RecipientAddress}},@{name="Prog"; expression={$_.JobProgress}},@{name="ETA"; expression={(get-date ($_.EstimatedCompletionTime.ToLocalTime()) -f 'MM/dd HH:mmtt')}} ;
        $propsJobResults = 'JobId','FileRows','ErrorCode','ErrorDescription','Status','ReportStatusDescription','SenderAddress','RecipientAddress','MessageID','CompletionDate','JobProgress','EstimatedCompletionTime','FileUrl' ;

        <#
        $progInterval= 500 ; # write-progress wait interval in ms
        $DoRetries = 4 ;
        $RetrySleep = 5 ;
        [int]$retryLimit=1; # just one retry to patch lineuri duped users and retry 1x
        [int]$retryDelay=20;    # secs wait time after failure
        #>

        #$ComputerName = $env:COMPUTERNAME ;
        #$sQot = [char]34 ; $sQotS = [char]39 ;

        if ($psISE){
            $ScriptDir = Split-Path -Path $psISE.CurrentFile.FullPath ;
            $ScriptBaseName = split-path -leaf $psise.currentfile.fullpath ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($psise.currentfile.fullpath) ;
                    $PSScriptRoot = $ScriptDir ;
            if($PSScriptRoot -ne $ScriptDir){ write-warning "UNABLE TO UPDATE BLANK `$PSScriptRoot TO CURRENT `$ScriptDir!"} ;
            $PSCommandPath = $psise.currentfile.fullpath ;
            if($PSCommandPath -ne $psise.currentfile.fullpath){ write-warning "UNABLE TO UPDATE BLANK `$PSCommandPath TO CURRENT `$psise.currentfile.fullpath!"} ;
        } else {
            if($host.version.major -lt 3){
                $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                $PSCommandPath = $myInvocation.ScriptName ;
                $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
            } elseif($PSScriptRoot) {
                $ScriptDir = $PSScriptRoot ;
                if($PSCommandPath){
                    $ScriptBaseName = split-path -leaf $PSCommandPath ;
                    $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($PSCommandPath) ;
                } else {
                    $PSCommandPath = $myInvocation.ScriptName ;
                    $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                    $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
                } ;
            } else {
                if($MyInvocation.MyCommand.Path) {
                    $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                    $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                    $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
                } else {
                    throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" ;
                } ;
            } ;
        } ;
        if($showDebug){
            write-host -foregroundcolor green "`SHOWDEBUG: `$ScriptDir:$($ScriptDir)`n`$ScriptBaseName:$($ScriptBaseName)`n`$ScriptNameNoExt:$($ScriptNameNoExt)`n`$PSScriptRoot:$($PSScriptRoot)`n`$PSCommandPath:$($PSCommandPath)" ;
        } ;
        #region EMAIL_HANDLING_BOILERPLATE ; #====== v EMAIL HANDLING BOILERPLATE (USE IN SUB MAIN) v==================================
        $bodyAsHtml=$true ;
        $smtpPriority="Normal";
        # SMTP port (default is 25)
        $smtpPort = 25 ;
        $smtpToFailThru="dG9kZC5rYWRyaWVAdG9yby5jb20="| convertfrom-Base64String
        # pull the notifc smtpto from the xxxMeta.NotificationDlUs value
        if(!$showdebug){
            if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs){
                $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs ;
            }elseif((Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1){
                $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1 ;
            } else {$smtpTo=$smtpToFailThru} ;
        } else {
            # debug pass, don't send to main dl, use NotificationAddr1    if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs){
            if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1){
                #set-variable -Name $meta.name -Value ((get-variable -name $meta.name).value  += @{'o365_AcceptedDomains' = (Get-exoAcceptedDomain).domainname} )
                $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1 ;
            } else {$smtpTo=$smtpToFailThru } ;
        } ;
        $smtpFrom = (($scriptBaseName.replace(".","-")) + "@$( (Get-Variable  -name "$($TenOrg)Meta").value.o365_OPDomain )") ;
        $smtpSubj= "Proc Rpt:"
        if($whatif) {$smtpSubj+="WHATIF:" }
        else {$smtpSubj+="PROD:" } ;
        $smtpSubj+= "$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"   ;
        if(!($bodyAsHtml)){
            # if not inline attachment in body, need to load report as attachment
            $smtpAttachment=$rptfile ;
        } else {
            #9:49 AM 3/26/2015 just blank the attachment if we're not mailing it
            $smtpAttachment=$null;
        };
        # setup body as a hash
        $smtpBody = @() ;
        # (`n = CrLf in body)
        #endregion EMAIL_HANDLING_BOILERPLATE ; #====== ^ EMAIL HANDLING BOILERPLATE (USE IN SUB MAIN) ^ ==================================

        #*======v FUNCTIONS v======

        #-------v Function _cleanup v-------
        function _cleanup {
            <#
            .SYNOPSIS
            _cleanup.ps1 - clear all objects, prep close transcript, email report and exit
            .NOTES
            Version     : 1.0.0
            Author      : Todd Kadrie
            Website     :	http://www.toddomation.com
            Twitter     :	@tostka / http://twitter.com/tostka
            CreatedDate : 2020-
            FileName    :
            License     : MIT License
            Copyright   : (c) 2020 Todd Kadrie
            Github      : https://github.com/tostka/verb-XXX
            Tags        : Powershell
            AddedCredit : REFERENCE
            AddedWebsite:	URL
            AddedTwitter:	URL
            REVISIONS
            # 10:32 AM 9/14/2021: _cleanup(): # only mail on PassStatus
            # 8:47 AM 11/24/2020 cloned over intact from maintain-exousrmbxretentionpolicies
            # 3:15 PM 10/13/2020 added CBH, added params: summarizeStatus,
                NoTranscriptStop, TranscriptItemsLimit, each exempts certain blocks of process
                - trying to genericize for reuse on other scripts ; added html body support
                (using <pre../pre> to preserve text layout, even in outlook display
            # 12:40 PM 10/23/2018 added write-log trainling bnr
            # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
            # 8:45 AM 10/13/2015 reset $DebugPreference to default SilentlyContinue, if on
            # # 8:46 AM 3/11/2015 at some time from then to 1:06 PM 3/26/2015 added ISE Transcript
            # 8:39 AM 12/10/2014 shifted to stop-transcriptLog function
            # 7:43 AM 1/24/2014 always stop the running transcript before exiting
            .DESCRIPTION
            _cleanup.ps1 - clear all objects, prep close transcript, email report and exit
            .PARAMETER  LogPath
            Alt transcript/logfile path for mailing (rather than `$transcript/`$logfile)[-LogPath c:\path-to\log.txt]
            .PARAMETER TranscriptItemsLimit
            Number of transactions to determine Transcript inclusion[-TranscriptItemsLimit]
            .PARAMETER summarizeStatus
            Switch to output a summary of the `$script:PassStatus delimted string[-summarizeStatus]
            .PARAMETER NoTranscriptStop
            Switch to skip transcript stop & exit [-NoTranscriptStop]
            .PARAMETER ShowDebug
            Parameter to display Debugging messages [-ShowDebug switch]
            .PARAMETER Whatif
            Parameter to run a Test no-change pass [-Whatif switch]
            .EXAMPLE
            _cleanup
            Default Call
            .EXAMPLE
            $pltCleanup=@{LogPath=$tmpcopy summarizeStatus=$true ;  NoTranscriptStop=$true ; showDebug=$($showDebug) ;  whatif=$($whatif) ; } ;
            _cleanup @pltCleanup ;
            Splatted parameter'd call
            #>
            [CmdletBinding()]
            PARAM(
                [Parameter(HelpMessage="Alt transcript/logfile path for mailing (rather than `$transcript/`$logfile)[-LogPath c:\path-to\log.txt]")]
                [ValidateScript({Test-Path $_})]
                $LogPath,
                [Parameter(HelpMessage="Number of transactions to determine Transcript inclusion[-TranscriptItemsLimit]")]
                [int] $TranscriptItemsLimit = 10,
                [Parameter(HelpMessage="Switch to output a summary of the `$script:PassStatus delimted string[-summarizeStatus]")]
                [switch] $summarizeStatus,
                [Parameter(HelpMessage="Switch to skip transcript stop & exit [-NoTranscriptStop]")]
                [switch] $NoTranscriptStop,
                [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
                [switch] $showDebug,
                [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
                [switch] $whatIf
            ) ;
            # clear all objects, prep close transcript, email report and exit
            # REVISIONS
            $smsg = "_cleanup" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            if(!$NoTranscriptStop){
                # handle transcript closure in the main script (Tenant loop)
                stop-transcript
                if(($host.Name -eq "Windows PowerShell ISE Host") -AND ($host.version.Major -lt 5)){
                    # 8:46 AM 3/11/2015 shift the logfilename gen out here, so that we can arch it
                    #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -uformat "%Y%m%d-%H%M" ) + "-ISEtrans.log")) ;
                    # 2:16 PM 4/27/2015 shift to static timestamp $timeStampNow
                    #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + $timeStampNow + "-ISEtrans.log")) ;
                    # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
                    $Logname=(join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -format 'yyyyMMdd-HHmmtt') + "-ISEtrans.log")) ;
                    $smsg = "`$Logname: $($Logname)";
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Start-iseTranscript -logname $Logname -Verbose:($VerbosePreference -eq 'Continue') ;
                    #Archive-Log $Logname -Verbose:($VerbosePreference -eq 'Continue');
                    # 1:23 PM 4/23/2015 standardize processing file so that we can send a link to open the transcript for review
                    $transcript = $Logname
                } else {
                    $smsg = "Stop Transcript" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Stop-TranscriptLog -Verbose:($VerbosePreference -eq 'Continue') ;
                    #if($showdebug){ $smsg = "Archive Transcript" };
                    #Archive-Log $transcript -Verbose:($VerbosePreference -eq 'Continue') ;
                } # if-E
            } else {
                $smsg = "(_cleanup(): deferring transcript stop to main script)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; # !$NoTranscriptStop
            # add trailing notifc
            $smsg = "Mailing Report" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # variant options:
            #$smtpSubj= "Proc Rpt:$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"   ;
            #Load as an attachment into the body text:
            #$body = (Get-Content "path-to-file\file.html" ) | converto-html ;
            #$SmtpBody += ("Pass Completed "+ [System.DateTime]::Now + "`nResults Attached: " +$transcript) ;
            # 4:07 PM 10/11/2018 giant transcript, no send
            #$SmtpBody += "Pass Completed $([System.DateTime]::Now)`nResults Attached:($transcript)" ;
            #$SmtpBody += "Pass Completed $([System.DateTime]::Now)`nTranscript:($transcript)" ;
            # group out the PassStatus_$($tenorg) strings into a report for eml body
            if($script:PassStatus){
                if($summarizeStatus){
                    if($script:TargetTenants){
                        # loop the TargetTenants/TenOrgs and summarize each processed
                        foreach($TenOrg in $TargetTenants){
                            $SmtpBody += "`n===Processing Summary: $($TenOrg):" ;
                            # can't split an empty string
                            if((get-Variable -Name PassStatus_$($tenorg)).value){
                                if((get-Variable -Name PassStatus_$($tenorg)).value.split(';') |Where-Object{$_ -ne ''}){
                                    $SmtpBody += (summarize-PassStatus -PassStatus (get-Variable -Name PassStatus_$($tenorg)).value -verbose:$($VerbosePreference -eq 'Continue') );
                                } ;
                            } else {
                                $SmtpBody += "(no processing of mailboxes in $($TenOrg), this pass)" ;
                            } ;
                            $SmtpBody += "`n" ;

                        } ;
                    } ;

                    if($PassStatus){
                        if($PassStatus.split(';') |Where-Object{$_ -ne ''}){
                            $SmtpBody += (summarize-PassStatus -PassStatus $PassStatus -verbose:$($VerbosePreference -eq 'Continue') );
                        } ;
                    } else {
                        $SmtpBody += "(no `$PassStatus updates, this pass)" ;
                    } ;

                } else {
                    # dump PassStatus right into the email
                    $SmtpBody += "`n`$script:PassStatus: $($script:PassStatus):" ;
                } ;
                if($SmtpAttachment){
                    $smtpBody +="(Logs Attached)"
                };
                $SmtpBody += "`n$('-'*50)" ;
                # include transcript in body, where fewer than limit of processed items logged in PassStatus
                # no, there're 3 transcripts, stored in $Alltranscripts, but skip it#
        #        if( ($script:PassStatus.split(';') |?{$_ -ne ''}|measure).count -lt $TranscriptItemsLimit){
        #            # add full transcript if less than 10 entries processed
        #            $SmtpBody += "`nTranscript:$(gc $transcript)`n" ;
        #        } else {
                    if(!$ArchPath ){ $ArchPath = get-ArchivePath } ;
                    if($Alltranscripts){
                        $Alltranscripts |ForEach-Object{
                            #$archedTrans = join-path -path $ArchPath -childpath (split-path $transcript -leaf) ;
                            $archedTrans = join-path -path $ArchPath -childpath (split-path $_ -leaf) ;
                            $smtpBody += "`nTranscript accessible at:`n$($archedTrans)`n" ;
                        } ;
                    } ;
                #};
            }
            $SmtpBody += "Pass Completed $([System.DateTime]::Now)" ;
            $SmtpBody += "`n" + $MailBody
            # body rendered in OL loses all wordrwraps
            # force strip out the html
            #$smtpBody = [regex]::Replace($smtpBody, "\<[^\>]*\>", '') ;
            $styleCSS = "<style>BODY{font-family: Arial; font-size: 10pt;}" ;
            $styleCSS += "TABLE{border: 1px solid black; border-collapse: collapse;}" ;
            $styleCSS += "TH{border: 1px solid black; background: #dddddd; padding: 5px; }" ;
            $styleCSS += "TD{border: 1px solid black; padding: 5px; }" ;
            $styleCSS += "</style>" ;
            <#
            $html = @"
<html>
<head><title>$title</title></head>
<body>
<pre>$smtpBody</pre>
</body>
</html>
"@ ;
#>
            # one with style support (goees in the <head../head> block)
            $html = @"
<html>
<head>
$($styleCSS)
<title>$title</title></head>
<body>
<pre>
$($smtpBody)
</pre>
</body>
</html>
"@ ;
            # convertto-html doesn't do raw txt, just objects
            #$smtpBody = $smtpBody | ConvertTo-Html -Head $styleCSS ;
            # use the bp html <pre../pre> version
            $smtpBody = $html ;
            # name $attachment for the actual $SmtpAttachment expected by Send-EmailNotif
            #$SmtpAttachment=$transcript ;
            # test for ERROR|CHANGE - actually non-blank, only gets appended to with one or the other
            # to test for one, (but not a regex)
            # # always force
            #if($script:passstatus.split(';') -contains 'ERROR'){
            # only mail on PassStatus
            if([string]::IsNullOrEmpty($script:PassStatus)){
                $smsg = "No Email Report: `$script:PassStatus isNullOrEmpty" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {

                $Email = @{
                    smtpFrom = $SMTPFrom ;
                    SMTPTo = $SMTPTo ;
                    SMTPSubj = $SMTPSubj ;
                    #SMTPServer = $SMTPServer ;
                    SmtpBody = $SmtpBody ;
                    SmtpAttachment = $SmtpAttachment ;
                    BodyAsHtml = $false ; # let the htmltag rgx in Send-EmailNotif flip on as needed
                    verbose = $($VerbosePreference -eq "Continue") ;
                } ;
                $smsg = "Send-EmailNotif w`n$(($Email|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Send-EmailNotif @Email ;
            } ;
            #add an exit comment
            $smsg = "END $BARSD4 $scriptBaseName $BARSD4"
            $smsg += "`n$BARSD40"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # finally restore the DebugPref if set
            if ($ShowDebug -OR ($DebugPreference = "Continue")) {
                $smsg = "Resetting `$DebugPreference from 'Continue' back to default 'SilentlyContinue'" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $showdebug=$false
                # 8:41 AM 10/13/2015 also need to enable write-debug output (and turn this off at end of script, it's a global, normally SilentlyContinue)
                $DebugPreference = "SilentlyContinue" ;
            } # if-E
            $smsg= "#*======^ END PASS:$($ScriptBaseName) ^======" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            if(!$NoTranscriptStop){
                EXIT # trailing tempfile cleanup in the sub main
            } ;
        } #*------^ END Function _cleanup ^------

        #*======^ END FUNCTIONS ^======

        #*======v SUB MAIN  v====== (not really, but it's a landmark for post-functions exec)

        #rx10 -Verbose:$false ;
        #rxo  -Verbose:$false ; cmsol  -Verbose:$false ;

        $sBnr="`n#*======v $(${CmdletName}) : v======" ;
        $smsg = $sBnr ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        # email trigger vari, and email body aggretating log
        $PassStatus = $MailBody = $null ;

        # add try catch as well - this may be making it zero-tolerance and catching all minor errors, disable it
        #Set-StrictMode -Version 2.0 ;

        #region SERVICE_CONNECTIONS #*------v SERVICE CONNECTIONS v------
        #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        # steer all onprem code on $XXXMeta.ExOPAccessFromToro & Ex10Server values
        $UseOP=$false ;
        <#
        if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
            $UseOP = $true ;
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ;
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        } else {
            $UseOP = $false ;
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ;
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        } ;
        #>
        $UseOP=$false ;

        $useEXO = $true ; # non-dyn setting, drives variant EXO reconnect & query code
        if($useEXO){
            #region GENERIC_EXO_CREDS_&_SVC_CONN #*------v GENERIC EXO CREDS & SVC CONN BP v------
            # o365/EXO creds
            <### Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile*
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
            Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
            Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
            Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            ###>
            $o365Cred=$null ;
            if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -UserRole 'CSVC','SID' -verbose:$($verbose))){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                if(get-Variable -Name cred$($tenorg) -scope Script){
                    Remove-Variable -Name cred$($tenorg) -scope Script
                } ;
                New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
                $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                Break ;
            } ;
            <### CALLS ARE IN FORM: (cred$($tenorg))
            $pltRXO = @{Credential = $Credential ; verbose = $($verbose) ; }
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; Silent = $true ;} ;
            if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
            else { reconnect-EXO @pltRXO } ;
            # or with Tenant-specific cred($Tenorg) lookup
            #$pltRXO creds & .username can also be used for AzureAD connections
            Connect-AAD @pltRXO ;
            ###>
            # configure splat for connections: (see above useage)
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; Silent = $true ;} ;
            #endregion GENERIC_EXO_CREDS_&_SVC_CONN #*------^ END GENERIC EXO CREDS & SVC CONN BP ^------
        } # if-E $useEXO

        if($UseOP){
            #region GENERIC_EXOP_CREDS_&_SRVR_CONN #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
            # do the OP creds too
            $OPCred=$null ;
            # default to the onprem svc acct
            $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC','SID'; verbose=$($verbose)} ;
            if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                if(get-Variable -Variable -Name "cred$($tenorg)OP" -scope Script){
                    Remove-Variable -Name "cred$($tenorg)OP" -scope Script ;
                } ;
                New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                Break ;
            } ;
            $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            <# CALLS ARE IN FORM: (cred$($tenorg))
             $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; Silent = $true ; } ;
            Reconnect-Ex2010 @pltRX10 ; # local org conns
            #$pltRx10 creds & .username can also be used for local ADMS connections
            #>
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; Silent = $true ; } ;

            # defer cx10/rx10, until just before get-recipients qry
            #endregion GENERIC_EXOP_CREDS_&_SRVR_CONN #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
            # connect to ExOP X10
            if($pltRX10){
                #ReConnect-Ex2010XO @pltRX10 ;
                ReConnect-Ex2010 @pltRX10 ;
            } else { Reconnect-Ex2010 ; } ;
        } ;  # if-E $useOP

        
        if($UseOP){
            #region GENERIC_ADMS_CONN_&_XO #*------v GENERIC ADMS CONN & XO  v------
            <# already confirmed in modloads
            # load ADMS
            $reqMods += "load-ADMS".split(";") ;
            if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
            #>
            write-host -foregroundcolor gray  "(loading ADMS...)" ;
            #write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):MSG" ;

            load-ADMS -Verbose:$FALSE ;

            # resolve $domaincontroller dynamic, cross-org
            # setup ADMS PSDrives per tenant
            if(!$global:ADPsDriveNames){
                $smsg = "(connecting X-Org AD PSDrives)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $global:ADPsDriveNames = mount-ADForestDrives -verbose:$($verbose) ;
            } ;
            if(($global:ADPsDriveNames|Measure-Object).count){
                $useEXOforGroups = $false ;
                $smsg = "Confirming ADMS PSDrives:`n$(($global:ADPsDriveNames.Name|%{get-psdrive -Name $_ -PSProvider ActiveDirectory} | ft -auto Name,Root,Provider|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                # returned object
                #         $ADPsDriveNames
                #         UserName                Status Name
                #         --------                ------ ----
                #         DOM\Samacctname   True  [forestname wo punc]
                #         DOM\Samacctname   True  [forestname wo punc]
                #         DOM\Samacctname   True  [forestname wo punc]

            } else {
                #-=-record a STATUS=-=-=-=-=-=-=
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                #-=-=-=-=-=-=-=-=
                $smsg = "Unable to detect POPULATED `$global:ADPsDriveNames!`n(should have multiple values, resolved to $()"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                Break ;
            } ;
        } ;
        #if (!$domaincontroller) { $domaincontroller = get-gcfast } ;
        #if(!$domaincontroller){ if(test-path function:get-gcfast){$domaincontroller=get-gcfast} else { throw "no get-gcfast()!" } ;} else {"(existing `$domaincontroller:$($domaincontroller))"} ;
        # use new get-GCFastXO cross-org dc finde
        # default to Op_ExADRoot forest from $TenOrg Meta
        #$domaincontroller = get-GCFastXO -TenOrg $TenOrg -subdomain ((Get-Variable -name "$($TenOrg)Meta").value['OP_ExADRoot']) -verbose:$($verbose) |Where-Object{$_.length};
        #endregion GENERIC_ADMS_CONN_&_XO #*------^ END GENERIC ADMS CONN & XO ^------

        <# 
        #region MSOL_CONNECTION ; #*------v  MSOL CONNECTION v------ 
        $reqMods += "connect-msol".split(";") ;
        if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
        write-host -foregroundcolor gray  "(loading AAD...)" ;
        #connect-msol ;
        connect-msol @pltRXO ;
        #endregion MSOL_CONNECTION ; #*------^  MSOL CONNECTION ^------ 
        #>

        <#
        #region AZUREAD_CONNECTION ; #*------v AZUREAD CONNECTION v------ 
        $reqMods += "Connect-AAD".split(";") ;
        if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
        write-host -foregroundcolor gray  "(loading AAD...)" ;
        #connect-msol ;
        Connect-AAD @pltRXO ;
        #region AZUREAD_CONNECTION ; #*------^ AZUREAD CONNECTION ^------ 
        #>


        <# defined above
        # EXO connection
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            verbose = $($verbose) ; } ;
        #>
        if($VerbosePreference = "Continue"){
            $VerbosePrefPrior = $VerbosePreference ;
            $VerbosePreference = "SilentlyContinue" ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        disconnect-exo ;
        if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
        else { reconnect-EXO @pltRXO } ;
        # reenable VerbosePreference:Continue, if set, during mod loads
        if($VerbosePrefPrior -eq "Continue"){
            $VerbosePreference = $VerbosePrefPrior ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        #endregion SERVICE_CONNECTIONS #*------^ END SERVICE CONNECTIONS ^------


        $error.clear() ;
        TRY {
            # 11:56 AM 4/24/2015 moved below func defs, in sub main
            $archPath = get-ArchivePath ;

            # 12:44 PM 4/24/2015 fine squash any array coming out (till we get it sorted)
            if($archPath -is [system.array]){
                if($bDebug) {Write-Verbose "Flattening `$archpath array" -verbose:$verbose}
                $archPath = $archPath[0] ;
            }  # if-E;

        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(Get-Variable passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(Get-Variable -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ;
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$($smsg)" } ;

            #set-AdServerSettings -ViewEntireForest $false ;

            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ;

        #region CONFIGURE_DEFAULT_LOGGING_FROM_PARENT_SCRIPT_NAME #*======V CONFIGURE DEFAULT LOGGING FROM PARENT SCRIPT NAME v======
        if(!(get-variable LogPathDrives -ea 0)){$LogPathDrives = 'd','c' };
        foreach($budrv in $LogPathDrives){if(test-path -path "$($budrv):\scripts" -ea 0 ){break} } ;
        if(!(get-variable rgxPSAllUsersScope -ea 0)){
            $rgxPSAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps(((d|m))*)1|dll)$" ;
        } ;
        if(!(get-variable rgxPSCurrUserScope -ea 0)){
            $rgxPSCurrUserScope="^$([regex]::escape([Environment]::GetFolderPath('MyDocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps((d|m)*)1|dll)$" ;
        } ;
        $pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($whatif) ;} ;
        $pltSL.Tag = $ticket -join ',' ;
        if($script:PSCommandPath){
            if(($script:PSCommandPath -match $rgxPSAllUsersScope) -OR ($script:PSCommandPath -match $rgxPSCurrUserScope)){
                $bDivertLog = $true ;
                switch -regex ($script:PSCommandPath){
                    $rgxPSAllUsersScope{$smsg = "AllUsers"}
                    $rgxPSCurrUserScope{$smsg = "CurrentUser"}
                } ;
                $smsg += " context script/module, divert logging into [$budrv]:\scripts"
                write-verbose $smsg  ;
                if($bDivertLog){
                    if((split-path $script:PSCommandPath -leaf) -ne $cmdletname){
                        # function in a module/script installed to allusers|cu - defer name to Cmdlet/Function name
                        $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
                    } else {
                        # installed allusers|CU script, use the hosting script name
                        $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $script:PSCommandPath -leaf)) ;
                    }
                } ;
            } else {
                $pltSL.Path = $script:PSCommandPath ;
            } ;
        } else {
            if(($MyInvocation.MyCommand.Definition -match $rgxPSAllUsersScope) -OR ($MyInvocation.MyCommand.Definition -match $rgxPSCurrUserScope) ){
                 $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $script:PSCommandPath -leaf)) ;
            } elseif(test-path $MyInvocation.MyCommand.Definition) {
                $pltSL.Path = $MyInvocation.MyCommand.Definition ;
            } elseif($cmdletname){
                $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
            } else {
                $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$CMDLETNAME, FROM WHICH TO BUILD A START-LOG.PATH!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                BREAK ;
            } ;
        } ;
        write-verbose "start-Log w`n$(($pltSL|out-string).trim())" ;
        $logspec = start-Log @pltSL ;
        $error.clear() ;
        TRY {
            if($logspec){
                $logging=$logspec.logging ;
                $logfile=$logspec.logfile ;
                $transcript=$logspec.transcript ;
                $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                start-Transcript -path $transcript ;
            } else {throw "Unable to configure logging!" } ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ;
        #endregion CONFIGURE_DEFAULT_LOGGING_FROM_PARENT_SCRIPT_NAME #*======^ CONFIGURE DEFAULT LOGGING FROM PARENT SCRIPT NAME ^======



    } # BEGIN-E
    PROCESS{

        $pltHS=@{
            ReportTitle=$null ;
            StartDate=(get-date ([datetime]::Today)).adddays($days * -1) ;
            EndDate=(get-date) ;
            ReportType="MessageTrace" ;
            NotifyAddress=$NotifyAddress ;
        } ;
        if($StartDate){
          $smsg = "(setting `$pltHS.StartDate to `$StartDate)" ;
          if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
          else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
          $pltHS.StartDate = $StartDate
        } ;
        if($EndDate){
            $smsg = "(setting `$pltHS.EndDate to `$EndDate)" ;
          if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
          else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $pltHS.EndDate = $EndDate
        } ;
        if($MessageID){
            $pltHs.add('MessageID',$MessageID) ;
        } ;
        if($ticket){$pltHS.ReportTitle = "$($ticket)-" };
        if($Requester){$pltHS.ReportTitle += "$($Requester) " } ;
        $pltHS.ReportTitle = "$($pltHS.ReportType) " ;
        if($Recipients){
            $pltHS.add("RecipientAddress","$($Recipients)" ) ;
            $pltHS.ReportTitle = "TO-$($recip) " ;
        } ;
        if($Sender){
          $pltHS.add("SenderAddress","$($Sender)" ) ;
          $pltHS.ReportTitle += "FROM-$($Sender) " ;
        } ;
        if($days){
            $pltHS.ReportTitle += "$($days)D-History"    } else {        $pltHS.ReportTitle += "$(get-date $pltHS.StartDate -format 'yyyyMMdd-HHmmtt')" ;
            $pltHS.ReportTitle += "-$(get-date $pltHS.EndDate -format 'yyyyMMdd-HHmmtt')" ;
        } ;

        $smsg = "===Start-ExoHistoricalSearch w `$pltHS:$($pltHS|out-string)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        TRY {
            $HSo=Start-ExoHistoricalSearch @pltHS ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(Get-Variable passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(Get-Variable -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ;
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ;

        $smsg = "===Confirming new HS Job:$($Hso.JobID)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        $error.clear() ;
        TRY {
            $oHSJob = Get-ExoHistoricalSearch -JobID $hSO.jobID ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(Get-Variable passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(Get-Variable -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ;
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ;

        $1F=$false ;
        Do {
            if($1F){Start-Sleep -s 60} ;
            write-host "." -NoNewLine ;
            $1F=$true ;
            $oHSJob = Get-ExoHistoricalSearch -JobID $hSO.jobID ;

            $smsg = "`n$(($oHSJob | ft -auto $propsJob|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        } Until ($oHSJob.status -eq 'Done') ;

        $ofile ="$($ticket)-$($Requester)-EXOHistSrch" ;
        #$ofile+=",$($pltHS.ReportTitle)" ;
        $ofile+=",$(create-AcronymFromCaps $pltHS.ReportType)" ;
        if($pltHS.SenderAddress){$ofile+=",From-$($pltHS.SenderAddress.replace("*","ANY"))" } ;
        if($pltHS.RecipientAddress){$ofile+=",To-$($pltHS.RecipientAddress.replace("*","ANY"))" } ;
        if($pltHS.MessageID){$ofile+=",MsgID-$($pltHS.replace('<','').replace('>','').substring(0,8))" } ;
        $ofile+=",$(get-date $pltHS.StartDate -format 'yyyyMMdd-HHmm')-$(get-date $pltHS.EndDate -format 'yyyyMMdd-HHmm')" ;
        #$ofile+= ",run-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
        $ofile+= ".csv" ;
        $ofile=[RegEx]::Replace($ofile, "[{0}]" -f ([RegEx]::Escape(-join [System.IO.Path]::GetInvalidFileNameChars())), '') ;

        if($env:computername -match $rgxMyWorkstationsW){
            $ofile="c:\usr\work\incid\$($ofile)"
        } else {
            $drvhunt = 'd','c' ;
            foreach($dh in $drvhunt){
                $dhpath = "$($dh):\scripts\logs" ;
                if(test-path $dhpath ){ break } else {$dhpath = $null} ;
            } ;
            if($dhpath){$ofile="$($dhpath)\$($ofile)"}
        } ;

        write-host "`a" ;
        write-host "`a" ;
        write-host "`a" ;
        if($oHSJob.CompletionDate){
            $ts = New-TimeSpan -Start $oHSJob.SubmitDate -End $oHSJob.CompletionDate
        } else {
            $ts = New-TimeSpan -Start $oHSJob.SubmitDate -End (get-date) ;
        } ;
        $msg = "DONE!`n(Report gen took: {0:g} (h:m:s:ms)`n" -f $ts ;
        $msg += "`n$(($oHSJob |fl $propsJobResults |out-string).trim())`n`nUse CSV filename:`n$($ofile)`n" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        $smsg = "(also avail at https://admin.exchange.microsoft.com/#/messagetrace under 'Downloadable reports')" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        $msg = "Post-download, to convert the download .csv to [name]-expanded.csv (MessageTrace csv equivelent) `nconvert-HistoricalSearchCSV.ps1 -ToCSV -Files $($ofile)"  ;
        $smsg += "`nNOTE:MS ENCODING BREAK: Force the encoding when direct import-csv'ing the raw HistSearch .csv! `nimport-csv -encoding unicode -path '$($ofile)'" ;
        #write-host $msg ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;


    }
    END{
        _Cleanup

    } ;
}

#*------^ get-xoHistSearch.ps1 ^------


#*------v get-XOMailboxFolderList.ps1 v------
function get-XOMailboxFolderList {
    <#
	.SYNOPSIS
	get-XOMailboxFolderList - Enumerates all user-accessible folders for the specified Exchange Online mailbox
	.NOTES
	Version     : 1.0.0
	Author      : Vasil Michev
	Website     : https://www.michev.info/blog/post/2500/how-to-reset-mailbox-folder-permissions
	Twitter     :	
	CreatedDate : 2022-06-15
	FileName    : get-XOMailboxFolderList.ps1
	License     : Not Asserted
	Copyright   : Not Asserted
	Github      : https://github.com/michevnew/PowerShell/blob/master/reset-XOMailboxAllFolderPerms.ps1
	Tags        : Powershell,ExchangeOnline,Mailbox,Delegate
	AddedCredit : Todd Kadrie
	AddedWebsite: http://www.toddomation.com
	AddedTwitter: @tostka / http://twitter.com/tostka
	REVISIONS
	* 12:48 PM 9/22/2023 revised (to shift into my verb-exo module for generic use): add/expand CBH; renam ReturnFolderList -> get-XOMailboxFolderList (alias orig name)
	* 6/15/22 vm posted version
	.DESCRIPTION
	get-XOMailboxFolderList - Enumerates all user-accessible folders for the specified Exchange Online mailbox
	PARAMETER SMTPAddress
	Smtp Address of mailbx to be processed
	.INPUTS
    SMTP address of the mailbox.
    .OUTPUTS
    Array with information about the mailbox folders.
	.EXAMPLE
	PS> $folders = get-XOMailboxFolderList -SMTPAddress email@domain.com ; 
	This command will return a list of all user-accessible folders for the specified email address
	.LINK
	https://github.com/tostka/verb-EXO
	#>
    [CmdletBinding()]
    [Alias('ReturnFolderList')]
    PARAM(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true, HelpMessage="Smtp Address of mailbx to be processed")]
            $SMTPAddress
    ) ; 
    #$MBfolders = Invoke-Command -Session $session -ScriptBlock { Get-MailboxFolderStatistics $using:SMTPAddress | Select-Object Name,FolderType,Identity } -HideComputerName -ErrorAction Stop ; 
    # EOM3+ direct, no pssession support
    #$MBfolders = Get-xoMailboxFolderStatistics $SMTPAddress | Select-Object Name,FolderType,Identity -ErrorAction Stop ; 
    #*======v BP Wrapper for running EXO dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp) v======
    # define the splat of all params:
    $pltGMFS = [ordered]@{Identity = $SMTPAddress ; erroraction = 'STOP'; verbose = $($VerbosePreference -eq "Continue") ;} ;
    $cmdlet = 'Get-MailboxFolderStatistics' ; $verb,$noun = $cmdlet.split('-') ;  #Spec cmdletname (VERB-NOUN), & split v/n
    TRY{$xoS = Get-ConnectionInformation -ErrorAction STOP }CATCH{reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP }
    TRY{
        if((-not $xos) -OR ($xoS | ?{$_.tokenstatus -notmatch 'Active|Expired' -AND $_.State -ne 'Connected'} )){reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP } ; 
        if($xos){
            $xcmd = "$verb-$($xoS.ModulePrefix)$noun `@pltGMFS" ; # build cmdline w splat, then echo:
            $smsg = "$($([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value)) w`n$(($pltGMFS|out-string).trim())" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            $MBfolders = invoke-expression $xcmd  | Select-Object Name,FolderType,Identity -ErrorAction Stop ; 
            if($MBfolders){write-verbose "(confirmed valid $([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value) output)" ; }
        } else { 
            $smsg = "Missing `$xos EXO connection!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            throw $smsg ; BREAK ; 
        } 
    } CATCH {
        $ErrTrapd=$Error[0] ;
        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    } ; 
    <# version 12:43 PM 9/21/2023 moved cixo up to 1st, won't have prefix if not populated, also needs to fail/retry to ensure conn;  
    11:48 AM 9/20/2023 minor tweaks ; 3:01 PM 9/19/2023 initial 
    ## this runs: 1) connection status check, w rxo on demand; 2) splat wrapper with integrated prefix support; 3) try/catch on exec; 
    useful alias: cixo => get-connectioninformation;
    #>
    #*======^ END BP wrapper for running dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp)  ^======
    $MBfolders = $MBfolders | ? {($_.FolderType -eq "User created" -or $_.FolderType -in $includedfolders) -and ($_.Name -notin $excludedfolders)} ; 
    if (-not $MBfolders) { return } 
    else { return ($MBfolders | select Name,FolderType,Identity) } ; 
}

#*------^ get-XOMailboxFolderList.ps1 ^------


#*------v Get-xoMailboxFolderPermissionsRecursive.ps1 v------
function Get-xoMailboxFolderPermissionsRecursive {
        <#
        .SYNOPSIS
        Gets the current permissions for all user-accessible folders for a given mailbox.
        .NOTES
        Version     : 0.0.
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 2023-
        FileName    : Get-xoMailboxFolderPermissionsRecursive.ps1
        License     : MIT License
        Copyright   : (c) 2023 Todd Kadrie
        Github      : https://github.com/tostka/verb-XXX
        Tags        : Powershell
        AddedCredit : REFERENCE
        AddedWebsite: URL
        AddedTwitter: URL
        REVISIONS
        * 1:45 PM 9/22/2023 ren Get-MailboxFolderPermissionsRecursive -> Get-xoMailboxFolderPermissionsRecursive (alias orig)
        * 10:47 AM 9/19/2023 rejigger to simply echo what it finds
        .DESCRIPTION
        The Get-xoMailboxFolderPermissionsRecursive cmdlet echoes permissions for all user-accessible folders for the given mailbox(es), specified via the -Mailbox parameter. The list of folders is generated via the get-XOMailboxFolderList function. Configure the $includedfolders and $excludedfolders variables to granularly control the folder list.
        .PARAMETER Mailbox
        Use the -Mailbox parameter to designate the mailbox. Any valid Exchange mailbox identifier can be specified. Multiple mailboxes can be specified in a comma-separated list or array, see examples below.
		.PARAMETER Quiet
		Switch to suppress outputs
        .EXAMPLE
        PS> $mbperms =  Get-xoMailboxFolderPermissionsRecursive -Ticket 999999 -Mailbox user@domain.com.com -OutVariable global:varFolderPermissionsFound ; 
        This command returns all permissions on all user-accessible folders in the user@domain.com mailbox, and tags the output .csv file with the specified ticket number.
        .EXAMPLE
        PS> $return = Get-xoMailboxFolderPermissionsRecursive -Mailbox @('emailaddress@domain.com','emailaddres2s@domain.com') -ResetDefaultLevel -verbose -whatif:$true
        Typical two-user pass as array, using specifying to include reset of all Default levels, with Whatif & verbose, assign output to $return
        .EXAMPLE
        PS> $return = Get-xoMailboxFolderPermissionsRecursive -Mailbox brad.stensrud@toro.com -ticket 760151 ; 
        PS> write-host "`n==Returned permission entries:" ; 
        PS> $return | ft -a ; 
        PS> write-host "==usertype distribution:" ; 
        PS> $return | group usertype |  ft -a count,name ; 
        PS> write-host "==output the subset of UNKNOWN usertype grants:" ; 
        PS> $return |?{$_.usertype -eq 'UNKNOWN'} | ft -a ; 
        PS> write-host "==username distribution:" ; 
        PS> $return |group user |  ft -a count,name ; 
        PS> write-host "==review UserType:Internal & username <> to mailbox owner:" ; 
        PS> write-verbose "derive 'owner' name:Should be the usertype:Internal w AccessRights:OWNER and highest frequency" ; 
        PS> $owner = $return | ?{$_.accessrights -like '*owner*' -AND $_.UserType -eq 'Internal'} | select -expand user | group | sort -desc | select -first 1 name | select -expand name ;
        PS> $return |?{$_.UserType -eq 'Internal' -AND $_.user -ne $owner} | ft -a ; 
        PS> write-host "==Non-Owner Grants:" ; 
        PS> $return |?{$_.user -ne $owner} | ft -a ; 
        PS> write-host "(count:$(($return |?{$_.user -ne $owner} |  measure | select -expand count|out-string).trim()))`n" ; 
        Typical single-user pass with ticket specified, assign output to $return, with range of post analysis examination of returned perm entries
        .EXAMPLE
        PS> write-verbose "Gather folder permissions from target mailbox" ; 
        PS> $mbfp = Get-xoMailboxFolderPermissionsRecursive -Ticket 999999 -Mailbox todd.kadrie@toro.com ; 
        PS> write-host "Echo returned folderperms to console, tabular" ; 
        PS> $mbfp | ft -a ; 
        PS> write-host "echo postfiltered broken-SID perms" ; 
        PS> $mbfp | ?{$_.user -match 'NT:S-1-5-21-'} | ft -a ; 
        PS> write-verbose "Run a removal of each of the broken-SID permissions" ; 
        PS> $mbfp | ?{$_.user -match 'NT:S-1-5-21-'} | %{ remove-xomailboxfolderpermission -id $_.foldername -user $_.user -whatif } ;
        Demo collecting all grants in target mailbox; reviewing return; post-filtering for broken SID entries; and then removing those entries with remove-xoMailboxFolderPermission, whatif pass is specified
        .INPUTS
        A mailbox identifier.
        .OUTPUTS
        Array of Mailbox address, Folder name and User.
        #>
        #Requires -Modules ActiveDirectory, ExchangeOnlineManagement, verb-Auth
        [cmdletbinding()]
        [Alias('Get-MailboxFolderPermissionsRecursive')]
        Param(
            [Parameter(Mandatory=$False,HelpMessage="Ticket Number [-Ticket '999999']")]
                [string]$Ticket,
            [Parameter(Mandatory=$true,ValueFromPipeline=$false,HelpMessage="Use the -Mailbox parameter to designate the mailbox. Any valid Exchange mailbox identifier can be specified. Multiple mailboxes can be specified in a comma-separated list or array, see examples below.")]
                [ValidateNotNullOrEmpty()]
                [Alias("Identity")]
                [String[]]$Mailbox,
            [Parameter(HelpMessage="Switch to suppress outputs")]
                [switch]$Quiet        
        ) ; 
        BEGIN{
            $includedfolders = @("Root","Inbox","Calendar", "Contacts", "DeletedItems", "Drafts", "JunkEmail", "Journal", 
                "Notes", "Outbox", "SentItems", "Tasks", "CommunicatorHistory", "Clutter", "Archive") ; 
            $Defaultfolders = @("Root","Inbox","Calendar", "Contacts", "DeletedItems", "SentItems", "Tasks") #Trimmed down list of default folders
            #Exclude additional Non-default folders created by Outlook or other mail programs. Folder NAMES, not types! So make sure to include translations too!
            #Exclude SearchDiscoveryHoldsFolder and SearchDiscoveryHoldsUnindexedItemFolder as they're not marked as default folders #Exclude "Calendar Logging" on older Exchange versions
            $excludedfolders = @("News Feed","Quick Step Settings","Social Activity Notifications","Suggested Contacts", 
                "SearchDiscoveryHoldsUnindexedItemFolder", "SearchDiscoveryHoldsFolder","Calendar Logging") ; 

            $prpADU = 'DistinguishedName','enabled','samaccountname','sid','UserPrincipalName' ; 
            $DefaultRoleUserNames = @("Default","Anonymous","Owner@local","Member@local") ; 
            if(!$ThrottleMs){$ThrottleMs = 500} ; 
            if( -not (get-variable -name PSScriptRoot -ea 0) -OR ($PSScriptRoot -eq '') -OR ($PSScriptRoot -eq $null)){
            if ($psISE) { $ScriptName = $psISE.CurrentFile.FullPath } 
            elseif($psEditor){
                if ($context = $psEditor.GetEditorContext()) {$ScriptName = $context.CurrentFile.Path } 
            } elseif ($host.version.major -lt 3) {
                $ScriptName = $MyInvocation.MyCommand.Path ;
                $PSScriptRoot = Split-Path $ScriptName -Parent ;
                $PSCommandPath = $ScriptName ;
            } else {
                if ($MyInvocation.MyCommand.Path) {
                    $ScriptName = $MyInvocation.MyCommand.Path ;
                    $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                } else {throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" } ;
            };
            if($ScriptName){
                $ScriptDir = Split-Path -Parent $ScriptName ;
                $ScriptBaseName = split-path -leaf $ScriptName ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($ScriptName) ;
            } ; 
        } else {
            if($PSScriptRoot){$ScriptDir = $PSScriptRoot ;}
            else{
                write-warning "Unpopulated `$PSScriptRoot!" ; 
                $ScriptDir=(Split-Path -parent $MyInvocation.MyCommand.Definition) + "\" ;
            }
            if ($PSCommandPath) {$ScriptName = $PSCommandPath } 
            else {
                $ScriptName = $myInvocation.ScriptName
                $PSCommandPath = $ScriptName ;
            } ;
            $ScriptBaseName = (Split-Path -Leaf ((& { $myInvocation }).ScriptName))  ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
        } ;
        if(-not $ScriptDir){
            write-host "Failed `$ScriptDir resolution on PSv$($host.version.major): Falling back to $MyInvocation parsing..." ; 
            $ScriptDir=(Split-Path -parent $MyInvocation.MyCommand.Definition) + "\" ;
            $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ; 
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;     
        } else {
            if(-not $PSCommandPath ){
                $PSCommandPath  = $ScriptName ; 
                if($PSCommandPath){ write-host "(Derived missing `$PSCommandPath from `$ScriptName)" ; } ;
            } ; 
            if(-not $PSScriptRoot  ){
                $PSScriptRoot   = $ScriptDir ; 
                if($PSScriptRoot){ write-host "(Derived missing `$PSScriptRoot from `$ScriptDir)" ; } ;
            } ; 
        } ; 
        if(-not ($ScriptDir -AND $ScriptBaseName -AND $ScriptNameNoExt)){ 
            throw "Invalid Invocation. Blank `$ScriptDir/`$ScriptBaseName/`ScriptNameNoExt" ; 
            BREAK ; 
        } ; 

        $smsg = "`$ScriptDir:$($ScriptDir)" ;
        $smsg += "`n`$ScriptBaseName:$($ScriptBaseName)" ;
        $smsg += "`n`$ScriptNameNoExt:$($ScriptNameNoExt)" ;
        $smsg += "`n`$PSScriptRoot:$($PSScriptRoot)" ;
        $smsg += "`n`$PSCommandPath:$($PSCommandPath)" ;  ;
        write-verbose $smsg ; 
        #endregion ENVIRO_DISCOVER ; #*------^ END ENVIRO_DISCOVER ^------

            Write-Verbose "Parsing the Mailbox parameter..."
            $SMTPAddresses = @{}
            foreach ($mb in $Mailbox) {
                Start-Sleep -Milliseconds 80 #Add some delay to avoid throttling...
                #*======v BP Wrapper for running EXO dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp) v======
                # define the splat of all params:
                $pltGMbx = [ordered]@{identity =  $mb ; erroraction = 'STOP'; verbose = $($VerbosePreference -eq "Continue") ;} ;
                $cmdlet = 'get-Mailbox' ; $verb,$noun = $cmdlet.split('-') ;  #Spec cmdletname (VERB-NOUN), & split v/n
                TRY{$xoS = Get-ConnectionInformation -ErrorAction STOP }CATCH{reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP }
                TRY{
                    if((-not $xos) -OR ($xoS | ?{$_.tokenstatus -notmatch 'Active|Expired' -AND $_.State -ne 'Connected'} )){reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP } ; 
                    if($xos){
                        $xcmd = "$verb-$($xoS.ModulePrefix)$noun `@pltGMbx" ; # build cmdline w splat, then echo:
                        $smsg = "$($([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value)) w`n$(($pltGMbx|out-string).trim())" ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        $SMTPAddress  = invoke-expression $xcmd  | 
                            Select-Object -ExpandProperty PrimarySmtpAddress -ErrorAction SilentlyContinue;
                        if($SMTPAddress){write-verbose "(confirmed valid $([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value) output)" ; }
                    } else { 
                        $smsg = "Missing `$xos EXO connection!" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        throw $smsg ; BREAK ; 
                    } 
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                    write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                } ; 
                <# version 12:43 PM 9/21/2023 moved cixo up to 1st, won't have prefix if not populated, also needs to fail/retry to ensure conn;  
                11:48 AM 9/20/2023 minor tweaks ; 3:01 PM 9/19/2023 initial 
                ## this runs: 1) connection status check, w rxo on demand; 2) splat wrapper with integrated prefix support; 3) try/catch on exec; 
                useful alias: cixo => get-connectioninformation;
                #>
                #*======^ END BP wrapper for running dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp)  ^======
                if (-not $SMTPAddress) { if (-not $Quiet) { 
                    $smsg = "Mailbox with identifier $mb not found, skipping..." }; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    continue 
                } elseif (($SMTPAddress.count -gt 1) -or ($SMTPAddresses[$mb]) -or ($SMTPAddresses.ContainsValue($SMTPAddress))) { 
                    $smsg = "Multiple mailboxes matching the identifier $mb found, skipping..."; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    continue 
                }else { $SMTPAddresses[$mb] = $SMTPAddress } ; 
            }
            if (-not $SMTPAddresses -or ($SMTPAddresses.Count -eq 0)) { 
                Throw "No matching mailboxes found, check the parameter values." 
            } ; 
            $smsg = "The following list of mailboxes will be used:$($SMTPAddresses.values  -join ", ")" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $smsg = "List of default folder TYPES that will be used:$($includedfolders  -join ", ")" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $smsg = "List of folder NAMES that will be excluded:$($excludedfolders  -join ", ")" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        } ; # BEG-E
        PROCESS {
            $out = @() ; 
            foreach ($smtp in $SMTPAddresses.Values) {
                $sBnrS = $smsg ="`n#*------v PROCESSING Mailbox: $($smtp)... v------" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                Start-Sleep -Milliseconds $ThrottleMs  ; #Add some delay to avoid throttling...
                Write-Verbose "Obtaining folder list for mailbox ""$smtp""..." ; 
                $folders = get-XOMailboxFolderList $smtp ; 
                Write-Verbose "A total of $($folders.count) folders found for $($smtp)." ; 
                if (-not $folders) { 
                    $smsg ="No matching folders found for $($smtp), skipping..." ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    continue 
                } ; 
                #Cycle over each folder we are interested in
                foreach ($folder in $folders) {
                    $smsg = "`n==PROCESSING:$($folder.name)`n" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    #"Fix" for folders with "/" characters, treat the Root folder separately
                    if ($folder.FolderType -eq "Root") { $foldername = $smtp }
                    else { $foldername = $folder.Identity.ToString().Replace([char]63743,"/").Replace($smtp,$smtp + ":") } ; 
                    
                    $fPermissions = get-XOMailboxFolderPermissionsSummary $foldername
                    if (-not $ResetDefaultLevel) { $fPermissions = $fPermissions | ? {$_.UserName -notin @("Default","Anonymous","Owner@local","Member@local")}}  ; #filter out default permissions
                    if (-not $fPermissions) { Write-Verbose "No permission entries found for $($foldername), skipping..." ; continue } ; 
                    #echo the folder permissions for each delegate
                    foreach ($u in $fPermissions) {
                        write-host "`n" ; 
                        if ($u.UserType -eq "Default") {
                            #UserType enumeration https://docs.microsoft.com/en-us/previous-versions/office/developer/exchange-server-2010/ff319704(v%3Dexchg.140)
                            #if ($ResetDefaultLevel) {
                                <# https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes?view=powershell-7.3#the-using-scope-modifier
                                    scope $using: - Used to access variables defined in another scope while running scripts via cmdlets like Start-Job and Invoke-Command.

                                #>
                                TRY {
                                    #write-host -foregroundcolor yellow "Resetting permissions on ""$foldername"" for principal ""Default""." ;
                                    if ($folder.FolderType -eq "Calendar") {
                                        $smsg = "'Default:Calendar entry':" ;
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        #if (($u.AccessRights -join ",") -ne "AvailabilityOnly") {
                                        # TTC customizes the view as LimitedDetails: $CalPermsDefault
                                        if (($u.AccessRights -join ",") -ne $CalPermsDefault) {
                                            #Invoke-Command -Session $session -ScriptBlock { Set-MailboxFolderPermission -Identity $Using:foldername -User Default -AccessRights AvailabilityOnly -WhatIf:$using:WhatIfPreference -Confirm:$false } -ErrorAction Stop -HideComputerName ;
                                            # can't use -session $session with EOM3+, try direct calls; should work
                                            #Set-xoMailboxFolderPermission -Identity $foldername -User Default -AccessRights $CalPermsDefault -WhatIf:$WhatIfPreference -Confirm:$false -ErrorAction Stop ;
                                        } else { continue } ; 
                                        #$outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $folder.name;"User" = $u.UserName;"AccessRights" = "AvailabilityOnly"}) ; 
                                        $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $u.identity;"User" = $u.UserName ; 
                                            UserType = $u.UserType ; 
                                            AccessRights = $u.AccessRights ; 
                                            SharingPermissionFlags = $u.SharingPermissionFlags ; 
                                        }) ;
                                        $out += $outtemp; 
                                        if (-not $Quiet ) { 
                                            #$outtemp | ft -a 
                                            $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        }  ;
                                    } else {
                                        if (($u.AccessRights -join ",") -ne "None") {
                                            $smsg = "'Default:non-NONE entry':" ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                            #Invoke-Command -Session $session -ScriptBlock { Set-MailboxFolderPermission -Identity $Using:foldername -User Default -AccessRights None -WhatIf:$using:WhatIfPreference -Confirm:$false } -ErrorAction Stop -HideComputerName 
                                            # eom3+ no pss
                                            #Set-xoMailboxFolderPermission -Identity $Using:foldername -User Default -AccessRights None -WhatIf:$using:WhatIfPreference -Confirm:$false -ErrorAction Stop ;
                                            # dump these
                                            $smsg = "'non-NONE entry':" ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                        } else { continue } ; 
                                        $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $u.identity;"User" = $u.UserName ; 
                                            UserType = $u.UserType ; 
                                            AccessRights = $u.AccessRights ; 
                                            SharingPermissionFlags = $u.SharingPermissionFlags ; 
                                        }) ;
                                        # echo, don't dump, the END is emitting a full obj stack
                                        $out += $outtemp; 
                                        if (-not $Quiet ) { 
                                            #$outtemp | ft -a 
                                            $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        }  ;
                                    } ; 
                                    #$out += $outtemp; if (-not $Quiet -and -not $WhatIfPreference) { $outtemp }  ; #Write output to the console unless the -Quiet parameter is used
                                } CATCH {$_ | fl * -Force; continue}  ; #catch-all for any unhandled errors
                            #} else { continue } ; 
                        } elseif ($u.UserType -eq "Anonymous") { 
                            # continue #Maybe set them all to none when $resetdefault is used?
                            $smsg = "'Anonymous entry':" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $u.identity;"User" = $u.UserName ; 
                                UserType = $u.UserType ; 
                                AccessRights = $u.AccessRights ; 
                                SharingPermissionFlags = $u.SharingPermissionFlags ; 
                            }) ;
                            $out += $outtemp; 
                            if (-not $Quiet ) { 
                                #$outtemp | ft -a 
                                $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            }  ;
                        } elseif ($u.UserType -eq "Unknown") { 
                            #write-host -foregroundcolor yellow "Skipping orphaned permissions entry: $($u.UserName)"; continue 
                            # actually on reviews, we *want* to see and dump the orphan/corrupt entries:
                            $smsg = "'UNKNOWN entry':" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            # may as well attempt a gadu resolve on the SID
                            if($u.UserName -match '^NT:S-'){
                                $smsg = "(entry UserName appears to be a BROKEN SID (SECURITY IDENTIFYER == DELETED USER OBJECT)" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                write-verbose "(attempting: get-aduser -id $($u.UserName.replace('NT:','')) )" ; 
                                TRY{
                                   if($ADU =  get-aduser -id ($u.UserName.replace('NT:','')) -ErrorAction STOP){
                                        $smsg = "Resolved`n $($u.UserName.replace('NT:',''))`n to an existing ADUser object:`n$(($adu | fl $prpADU |out-string).trim())" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                   }else {
                                        write-warning "Unable to resolve $($u.UserName.replace('NT:','')) to an existing ADUser object (likely deleted TERM)"
                                   } ; 
                           
                                }CATCH{ write-warning "Unable to resolve $($u.UserName.replace('NT:','')) to an existing ADUser object (likely deleted TERM)" }
                            }
                            $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $u.identity;"User" = $u.UserName ; 
                                UserType = $u.UserType ; 
                                AccessRights = $u.AccessRights ; 
                                SharingPermissionFlags = $u.SharingPermissionFlags ; 
                            }) ;
                            #$out += $outtemp; if (-not $Quiet ) { $outtemp | ft -a }  ;
                            # echo, don't dump, the END is emitting a full obj stack
                            $out += $outtemp; 
                            if (-not $Quiet ) { 
                                #$outtemp | ft -a 
                                $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            }  ;
                        } elseif ($u.UserType -eq "Internal") { 
                            #write-host -foregroundcolor yellow "Skipping orphaned permissions entry: $($u.UserName)"; continue 
                            # actually on reviews, we *want* to see and dump the entries:
                            $smsg = "'Internal entry':" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $u.identity;"User" = $u.UserName ; 
                                UserType = $u.UserType ; 
                                AccessRights = $u.AccessRights ; 
                                SharingPermissionFlags = $u.SharingPermissionFlags ; 
                            }) ;
                            $out += $outtemp; 
                            if (-not $Quiet ) { 
                                #$outtemp | ft -a 
                                $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            }  ;
                        } else {
                            if ($u.UserType -eq "External") { $u.User = $u.UserName }
                            TRY {
                                #if (-not $u.User) { continue } ; 
                                #Invoke-Command -Session $session -ScriptBlock { Remove-MailboxFolderPermission -Identity $Using:foldername -User $Using:u.User -WhatIf:$using:WhatIfPreference -Confirm:$false } -ErrorAction Stop -HideComputerName ;
                                # eom3+ no pss
                                #Remove-xoMailboxFolderPermission -Identity $foldername -User $u.User -WhatIf:$WhatIfPreference -Confirm:$false -ErrorAction Stop ;
                                $smsg = "'non-NONE entry':" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $u.identity;"User" = $u.UserName ; 
                                    UserType = $u.UserType ; 
                                    AccessRights = $u.AccessRights ; 
                                    SharingPermissionFlags = $u.SharingPermissionFlags ; 
                                }) ;
                                $out += $outtemp; 
                                if (-not $Quiet ) { 
                                    #$outtemp | ft -a 
                                    $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                }  ;
                            } CATCH [System.Management.Automation.RemoteException] {
                                if (-not $Quiet) {
                                    if ($_.CategoryInfo.Reason -eq "UserNotFoundInPermissionEntryException") { Write-Host "WARNING: No existing permissions entry found on ""$foldername"" for principal ""$($u.UserName)""" -ForegroundColor Yellow }
                                    elseif ($_.CategoryInfo.Reason -eq "CannotChangePermissionsOnFolderException") { Write-Host "ERROR: Folder permissions for ""$foldername"" CANNOT be changed!" -ForegroundColor Red }
                                    elseif ($_.CategoryInfo.Reason -eq "CannotRemoveSpecialUserException") { Write-Host "ERROR: Folder permissions for ""$($u.UserName)"" CANNOT be changed!" -ForegroundColor Red }
                                    elseif ($_.CategoryInfo.Reason -eq "ManagementObjectNotFoundException") { Write-Host "ERROR: Folder ""$foldername"" not found, this should not happen..." -ForegroundColor Red }
                                    elseif ($_.CategoryInfo.Reason -eq "InvalidInternalUserIdException") { Write-Host "ERROR: ""$($u.UserName)"" is not a valid security principal for folder-level permissions..." -ForegroundColor Red }
                                    else {$_ | fl * -Force; continue}  ; #catch-all for any unhandled errors
                                } ;  # if-E !quiet
                            } catch {$_ | fl * -Force; continue} ;#catch-all for any unhandled errors
                        } # if-E
                    }  ; # ACE loop-E
                } ;  # FOLDERS loop-E
                $smsg = $sBnrS.replace('-v','-^').replace('v-','^-') ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            }  # MBX loop-E
        } ;  # PROC-E
        END{
            if ($out) {
                #$out | Export-Csv -Path "$((Get-Date).ToString('yyyy-MM-dd_HH-mm-ss'))_MailboxFolderPermissionsRemoved.csv" -NoTypeInformation -Encoding UTF8 -UseCulture ;
                #$opath = "$((Get-Date).ToString('yyyy-MM-dd_HH-mm-ss'))_MailboxFolderPermissionsRemoved.csv" ; 
                #write-host "Exporting results to the CSV file...`n$($opath)" ;
                #$out | Export-Csv -Path $opath -NoTypeInformation -Encoding UTF8 -UseCulture ;
                [string]$opath = $null ; 
                if($ticket){$opath += "$($TICKET)-" }
                # $opath += "$($item)_MailboxFolderPermissionsRemoved-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ; 
                if(($SMTPAddresses.Values |  measure | select -expand count ) -gt 3){
                    $opath += "$($SMTPAddresses.Values[0]),xxx_MailboxFolderPermissionsRemoved-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ; 
                } else { 
                    $opath += "$($SMTPAddresses.Values -join ',')_MailboxFolderPermissionsRemoved-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ; 
                } ; 
                $oPath = join-path -path (join-path -path $ScriptDir -childpath "logs") -ChildPath $opath ; 
                write-host "Exporting results to the CSV file...`n$($opath)" ;
                $out | Export-Csv -Path $opath -NoTypeInformation -Encoding UTF8 -UseCulture ;
                #Write output to the console unless the -Quiet parameter is used
                #if (-not $Quiet -and -not $WhatIfPreference) { return $out | Out-Default }  ; 
                if (-not $Quiet -and -not $WhatIfPreference) { return $out  }  ; # above is returning as an array of text with no fields; output the object and aggregate it
            } else { write-host -foregroundcolor yellow "Output is empty, skipping the export to CSV file..." } ;
            Write-Verbose "Finish..." ;
        } ; 
    }

#*------^ Get-xoMailboxFolderPermissionsRecursive.ps1 ^------


#*------v get-XOMailboxFolderPermissionsSummary.ps1 v------
function get-XOMailboxFolderPermissionsSummary {
    <#
	.SYNOPSIS
	get-XOMailboxFolderPermissionsSummary - Enumerates all permissions for the given  Exchange Online mailbox folder
	.NOTES
	Version     : 1.0.0
	Author      : Vasil Michev
	Website     : https://www.michev.info/blog/post/2500/how-to-reset-mailbox-folder-permissions
	Twitter     :	
	CreatedDate : 2022-06-15
	FileName    : get-XOMailboxFolderPermissionsSummary.ps1
	License     : Not Asserted
	Copyright   : Not Asserted
	Github      : https://github.com/michevnew/PowerShell/blob/master/reset-XOMailboxAllFolderPerms.ps1
	Tags        : Powershell,ExchangeOnline,Mailbox,Delegate
	AddedCredit : Todd Kadrie
	AddedWebsite: http://www.toddomation.com
	AddedTwitter: @tostka / http://twitter.com/tostka
	REVISIONS
	* 12:48 PM 9/22/2023 revised (to shift into my verb-exo module for generic use): add/expand CBH; renam GetFolderPermissions -> get-XOMailboxFolderPermissionsSummary (alias orig name)
	* 6/15/22 vm posted version
	.DESCRIPTION
	Enumerates all permissions for the given  Exchange Online mailbox folder
	.PARAMETER foldername
	Identifier of the target folder, expressed in 'email@domain.com:\folderpath' format
	..INPUTS
    Identifier for the folder.
    .OUTPUTS
    Array with information about the mailbox folder permissions.
	.EXAMPLE
	PS> $perms = get-XOMailboxFolderPermissionsSummary user@domain.com:\Calendar ; 
	This command will return a list of all user-accessible folders for the specified email address
	.LINK
	https://github.com/tostka/verb-EXO
	#>
	[CmdletBinding()]
	[Alias('GetFolderPermissions')]
    PARAM(
        [Parameter(Mandatory=$true, ValueFromPipeline=$true, HelpMessage="Identifier of the target folder, expressed in 'email@domain.com:\folderpath' format")]
        $foldername
    ) ; 
    <#if (-not $session -or ($session.State -ne "Opened")) { Write-Error "No active Exchange Remote PowerShell session detected, please connect first. To connect to ExO: https://technet.microsoft.com/en-us/library/jj984289(v=exchg.160).aspx" -ErrorAction Stop }
    $FolderPerm = Invoke-Command -Session $session -ScriptBlock { Get-MailboxFolderPermission $using:foldername | Select-Object Identity,User,AccessRights,SharingPermissionFlags } -HideComputerName -ErrorAction Stop |
            select Identity,@{n="User";e={$_.User.RecipientPrincipal.Guid.Guid}},@{n="UserType";e={$_.User.UserType.ToString()}},@{n="UserName";e={$_.User.DisplayName}},AccessRights,SharingPermissionFlags ; 
    #>
    $prpFldrPerm = 'Identity','User','AccessRights','SharingPermissionFlags' ; 
    $prpFldrPermLeaf = 'Identity',
        @{n="User";e={$_.User.RecipientPrincipal.Guid.Guid}},
        @{n="UserType";e={$_.User.UserType.ToString()}},
        @{n="UserName";e={$_.User.DisplayName}},
        'AccessRights','SharingPermissionFlags' ; 
    # looked at adding:.user.RecipientPrincipal.value to above: but User is actually proxying RecipientPrincipal nested guid - wo it, it indicates there's no resolved recipient

    # eom3+ no pssession supp
    #$FolderPerm = Get-xoMailboxFolderPermission $foldername | Select-Object Identity,User,AccessRights,SharingPermissionFlags -ErrorAction Stop |
    #     select Identity,@{n="User";e={$_.User.RecipientPrincipal.Guid.Guid}},@{n="UserType";e={$_.User.UserType.ToString()}},@{n="UserName";e={$_.User.DisplayName}},AccessRights,SharingPermissionFlags ; 
    #*======v BP Wrapper for running EXO dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp) v======
    # define the splat of all params:
    $pltGMFP = [ordered]@{identity = $foldername ;erroraction = 'STOP'; verbose = $($VerbosePreference -eq "Continue") ;} ;
    $cmdlet = 'Get-MailboxFolderPermission' ; $verb,$noun = $cmdlet.split('-') ;  #Spec cmdletname (VERB-NOUN), & split v/n
    TRY{$xoS = Get-ConnectionInformation -ErrorAction STOP }CATCH{reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP }
    TRY{
        if((-not $xos) -OR ($xoS | ?{$_.tokenstatus -notmatch 'Active|Expired' -AND $_.State -ne 'Connected'} )){reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP } ; 
        if($xos){
            $xcmd = "$verb-$($xoS.ModulePrefix)$noun `@pltGMFP" ; # build cmdline w splat, then echo:
            $smsg =  "$($([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value)) w`n$(($pltGMFP|out-string).trim())" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            $FolderPerm = invoke-expression $xcmd  | Select-Object $prpFldrPerm -ErrorAction Stop | 
                Select-Object $prpFldrPermLeaf ; 
            if($FolderPerm){write-verbose "(confirmed valid $([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value) output)" ; }
        } else { 
            $smsg = "Missing `$xos EXO connection!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            throw $smsg ; BREAK ; 
        } 
    } CATCH {
        $ErrTrapd=$Error[0] ;
        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    } ; 
    <# version 12:43 PM 9/21/2023 moved cixo up to 1st, won't have prefix if not populated, also needs to fail/retry to ensure conn;  
    11:48 AM 9/20/2023 minor tweaks ; 3:01 PM 9/19/2023 initial 
    ## this runs: 1) connection status check, w rxo on demand; 2) splat wrapper with integrated prefix support; 3) try/catch on exec; 
    useful alias: cixo => get-connectioninformation;
    #>
    #*======^ END BP wrapper for running dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp)  ^======
    if (-not $FolderPerm) { return }
    else { return $FolderPerm }
}

#*------^ get-XOMailboxFolderPermissionsSummary.ps1 ^------


#*------v move-MailboxToXo.ps1 v------
function move-MailboxToXo{
    <#
    .SYNOPSIS
    move-MailboxToXo.ps1 - EX Hybrid Onprem-> EXO mailbox move
    .NOTES
    Version: 1.1.13
    Author: Todd Kadrie
    Website:	http://www.toddomation.com
    Twitter:	@tostka, http://twitter.com/tostka
    REVISIONS   :
    * 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
    # 11:44 AM 6/23/2023 sync over again fr 👇🏼 ; completely untested, just pasted in updated params, funcs, and submain block, above trailing write-output .
    # 12:41 PM 3/14/2022 sync'd to latest mods of move-EXOmailboxNow, largely rem'ing the xo AD material, long-broken by undocumented fw chgs.
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 2:40 PM 12/10/2021 more cleanup 
    * 11:24 AM 9/16/2021 encoded eml
    # 10:46 AM 6/2/2021 sub'd verb-logging for v-trans
    * 1:54 PM 5/19/2021 expanded get-hybridcred to use both esvc & sid userroles
    * 11:40 AM 5/14/2021 added -ea 0 to the gv tests (suppresses not-found error when called without logging config)
    # 11:11 AM 5/7/2021 replaced verbose & bdebugs ; fixed missing logging function & added trailing echo of path.
    * 3:55 PM 5/6/2021 update logging, with move to module, it's logging into the ALlusers profile dir
    * 11:05 AM 5/5/2021 refactor into a function, add to verb-exo; ren move-ExoMailboxNow -> move-MailboxToXo
    * 9:54 AM 5/5/2021 removed comment dates; rem'd spurious -domainc param on get-exorecipient
    * 3:15 PM 5/4/2021 v1.1.10 added trailing |?{$_.length} bug workaround for get-gcfastxo.ps1
    * 1:36 PM 3/31/2021 updated rgx to incl jumpboxes; repairs to new cross-org material (subseq to maint-RetPol changes/breaks) ; For some reason nowe requires ; rewrote all connect-reconn's to use central def'd splats AcceptLargeDataLoss in the movereq (wasn't there prev, but worked) ; had shifted out of domaincontroller use (due to new use of get-addomainctontroller returning array's instead of single entries, worked around the issue, put dc's back into queries, to cut down on retry/dawdle. ; updated the re-publish script under description, now echo's requiredvers
    * 9:41 AM 3/30/2021 publishing
    * 9:23 AM 11/17/2020 lots of minor revs, made sure all
    (re)connect-(ex2010|exo)'s had creds, and supported Exov2 switch, replaced
    approp write-verbose -> pswlt blocks ; updated catches to full cred & pswlt
    support ; dbg'd whatif succeessfully. Successfully moved TestNewGenericTodd
    * 9:07 AM 10/26/2020 added EXOv2 support (param, and if/then calls) ;
    * 3:17 PM 10/23/2020 exported xo dc code to new verb-adms:get-gcfastXO() ; now
    fully XO-supporting, determins MigEndPt by cycling $xxxMeta.MepArry
    (semi-colon-delimited string of MEP name;fqdn;regex - regex matches regional
    server DB names and steers the mbx MEP to match).
    * 4:13 PM 10/21/2020 midway through multi-tenant update, left off with:still needs ADMS mount-ADForestDrives() and set-location code @ 395 (had to recode mount-admforestdrives and debug cred production code & infra-string inputs before it would work; will need to dupe to suspend variant on final completion
    * 11:48 AM 4/27/2020 updated for jumpbox/published/installed script, genericized
    * 1:46 PM 2/4/2020 #920 Remove-exoMoveRequest: doesn't like $true on force
    * 12:35 PM 11/26/2019 debugged through issues created by genericizing the domain lookups - still dependant on hard MEP choice mappings on db names - added a default mep chooser that just takes index-0 on the list. Better'n nothing but if CMW has multi-meps, it could pick the wrong one.
    * 12:23 PM 11/22/2019 partial port for x-tenant use, need to get the OPCred spec pulled out of globals too...
    * 7:30 AM 8/14/2019 `$BatchName:revise & add SID
    * 9:38 AM 5/8/2019 added -NoTEST param, to skip MEP tests (no point running 2x, after initial whatif pass)
    * 9:39 AM 1/21/2019 final form used to migrate forwarded mbxs to EXO - RetentPolicy code disabled until we have DL's stocked with population of each target policy, for exempting if they turn up Default DRM Retention Policy again.
    * 8:27 PM 1/18/2019 added -BatchName param, to append later items to an existing Batch, without auto-gening the batchname
    * 7:24 PM 1/18/2019 a LOT of updates, used for forarded mbx moves, 97 - would have used MigrationBatch, but needed to use monitor-exoxxx.ps1 to catch moverequest completion and migrate fowd on the fly
    * 3:59 PM 1/18/2019 spliced in the functions & modloads from convert-OPUserGenerics2Shared.ps1 and the write-log() from check-exolicense.ps1.
    * 10:58 AM 11/27/2018 updated the trailing batch status echo
    * 2:07 PM 11/16/2018 fix typo and incomplete Test-exoMigrationServerAvailability  code, now failure causes it to retsta all MEPs, also removed duped credential prompts
    * 2:19 PM 10/9/2018 correct help text for TargetMailboxes - it's an array, not a comma-delim list
    * 2:49 PM 9/19/2018 added -CompleteEveningOf support and self-determining 6pm/5:30($ADSiteCodeAU) Cutover targets by region/MEP
    * 2:50 PM 9/5/2018 added existingmove pre-removal validated
    * 1:57 PM 9/5/2018 added echo'd replicated-monitoring cmd to the mix, updated move test to check that EXOrecipient has the $TORMeta['o365_TenantDomainMail'] address, or abort move
    * 1:12 PM 8/29/2018 added @$TORMeta['o365_TenantDom'] email addr test and auto-fix, echo of monitoring command to console
    * 1:36 PM 8/27/2018 Added UPN identify (was throwing error: The operation couldn't be performed because 'servicedesk' matches multiple entries.). Also looking up explicit $tmbx obj to pull values from, pretest, supporess prompt for predefined $OPcred ;
    * ident code both move-EXOmailboxNow.ps1 move-EXOmailboxSuspend.ps1 & , only diff is Suspend uses: SuspendWhenReadyToComplete=$TRUE in following;
    $MvSplat=@{
        Identity=$tmbx.userprincipalname ;
        remote=$true;
        RemoteHostName="MEPFQDN.DOMAIN.com" ;
        TargetDeliveryDomain="$TORMeta['o365_TenantDomainMail']" ;
        RemoteCredential=$OPcred ;
        BadItemLimit=1000 ;
        Suspend=$false ;
        SuspendWhenReadyToComplete=$false ;
        BatchName=$Batchname ;
        whatif=$($whatif) ;
    } ;
    .DESCRIPTION
    move-MailboxToXo.ps1 - Non-Suspend Onprem-> EXO mailbox move
    .PARAMETER TargetMailboxes
    Mailbox identifiers(array)[-Targetmailboxes]
    .PARAMETER BatchFile
    CSV file of mailbox descriptors, including at least PrimarySMTPAddress field [-BatchFile c:\path-to\file.csv]
    .PARAMETER BatchName
    Hard-code MoveRequest BatchName
    .PARAMETER Suspend
    Suspend move on creation Flag [-Suspend]
    .PARAMETER NoTEST
    NoTest Flag [-NoTEST]
    .PARAMETER Credential
    Credential to use for this connection [-credential [credential obj variable]")][System.Management.Automation.PSCredential]
    .PARAMETER UserRole
    Role of account (SID|CSID|UID|B2BI|CSVC|ESvc|LSvc)[-UserRole SID]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER silent
    Switch to specify suppression of all but warn/error echos.(unimplemented, here for cross-compat)
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .PARAMETER whatif
    Whatif Flag (DEFAULTED TRUE!) [-whatIf]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    move-MailboxToXo.ps1 -TargetMailboxes ACCOUNT@COMPANY.com -showDebug  -whatIf ;
    Perform immediate move of specified mailbox, with debug output & whtif pass
    .EXAMPLE
    move-MailboxToXo.ps1 -TargetMailboxes ACCOUNT@COMPANY.com -showDebug -notest -whatIf ;
    Perform immediate move of specified mailbox, suppress MEP tests (-NoTest), showdebug output & whatif pass
    .LINK
    https://bitbucket.org/tostka/powershell/
    #>
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
            [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(Position=0,Mandatory=$False,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Mailbox identifiers(array)[-Targetmailboxes]")]
            [ValidateNotNullOrEmpty()]$TargetMailboxes,
        [Parameter(Mandatory=$false,HelpMessage="CSV file of mailbox descriptors, including at least PrimarySMTPAddress field [-BatchFile c:\path-to\file.csv]")]
            [ValidateScript({Test-Path $_})][string]$BatchFile,
        [Parameter(Position=0,HelpMessage="Hard-code MoveRequest BatchName")]
            [string]$BatchName,
        [Parameter(HelpMessage="Suspend move on creation Flag [-Suspend]")]
            [switch] $Suspend,
        [Parameter(HelpMessage="NoTest Flag [-NoTEST]")]
            [switch] $NoTEST,
        [Parameter(HelpMessage="Credential to use for cloud actions [-credential [credential obj variable]")]
            [System.Management.Automation.PSCredential]$Credential,
        # = $global:$credO365TORSID,
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ; 
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ; 
                return $true ; 
            })]
            [string[]]$UserRole = @('SID','CSVC'),
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
            [switch] $useEXOv2=$true,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
                [switch] $silent,
        [Parameter(HelpMessage="Unpromtped run Flag [-showDebug]")]
            [switch] $NoPrompt,
        [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
            [switch] $showDebug,
        [Parameter(HelpMessage="Whatif Flag (DEFAULTED TRUE!) [-whatIf]")]
            [switch] $whatIf=$true
    ) # PARAM BLOCK END

    $verbose = ($VerbosePreference -eq "Continue") ;


    #region INIT; # ------
    #*======v SCRIPT/DOMAIN/MACHINE/INITIALIZATION-DECLARE-BOILERPLATE v======
    # SCRIPT-CONFIG MATERIAL TO SET THE UNDERLYING $DBGPREF:
    if ($Whatif){Write-Verbose -Verbose:$true "`$Whatif is TRUE (`$whatif:$($whatif))" ; };
    # If using WMI calls, push any cred into WMI:
    #if ($Credential -ne $Null) {$WmiParameters.Credential = $Credential }  ;

    # scriptname with extension
    $ScriptDir=(Split-Path -parent $MyInvocation.MyCommand.Definition) + "\" ;
    $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
    $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
    $ComputerName = $env:COMPUTERNAME ;

    # build smtpfrom & to fr Meta
    $smtpFrom = (($scriptBaseName.replace(".","-")) + "@$((Get-Variable  -name "$($TenOrg)Meta").value.o365_OPDomain)") ;
    #$smtpSubj= ("Daily Rpt: "+ (Split-Path $transcript -Leaf) + " " + [System.DateTime]::Now) ;
    $smtpSubj= "Proc Rpt:"   ;
    if($whatif) {
        $smtpSubj+="WHATIF:" ;
    } else {
        $smtpSubj+="PROD:" ;
    } ;
    $smtpSubj+= "$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"   ;
    #$smtpTo=$TORMeta['NotificationAddr1'] ;
    #$smtpTo=$TORMeta['NotificationDlUs'] ;
    $smtpToFailThru="todd.kadrie@toro.com"
    # one bene of looping: no module dependancy, works before modloads occur
    # pull the notifc smtpto from the xxxMeta.NotificationDlUs value
    # non-looping - $TenOrg is an input param, does't need modules to work yet
    if(!$showdebug){
        if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs){
            $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs ;
        }elseif((Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1){
            $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1 ;
        } else {
            $smtpTo=$smtpToFailThru;
        } ;
    } else {
        # debug pass, don't send to main dl, use NotificationAddr1    if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs){
        if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1){
            #set-variable -Name $meta.name -Value ((get-variable -name $meta.name).value  += @{'o365_AcceptedDomains' = (Get-exoAcceptedDomain).domainname} )
            $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1 ;
        } else {
            $smtpTo=$smtpToFailThru ;
        } ;
    }

    $sQot = [char]34 ; $sQotS = [char]39 ;
    $NoProf=[bool]([Environment]::GetCommandLineArgs() -like '-noprofile'); # if($NoProf){# do this};

    #$ProgInterval= 500 ; # write-progress wait interval in ms
    # add gui vb prompt support
    #[System.Reflection.Assembly]::LoadWithPartialName('Microsoft.VisualBasic') | Out-Null ;
    # should use Windows.Forms where possible, more stable

    switch -regex ($env:COMPUTERNAME) {
        ($rgxMyBox) { $LocalInclDir = "c:\usr\work\exch\scripts" ; }
        ($rgxProdEx2010Servers) { $LocalInclDir = "c:\scripts" ; }
        ($rgxLabEx2010Servers) { $LocalInclDir = "c:\scripts" ; }
        #($rgxProdL13Servers) { $LocalInclDir = "c:\scripts" ; }
        # ($rgxLabL13Servers) { $LocalInclDir = "c:\scripts" ; }
        ($rgxAdminJumpBoxes) {
            $LocalInclDir = (split-path $profile) ;
        }
    } ;

    #configure EXO EMS aliases to cover useEXOv2 requirements
    switch ($script:useEXOv2){
        $true {
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):using ExoV2 cmdlets" ;
            #reconnect-eXO2 @pltRXO ;
            set-alias ps1GetXRcp get-xorecipient ;
            set-alias ps1GetXMbx get-xomailbox ;
            set-alias ps1SetXMbx Set-xoMailbox ;
            set-alias ps1GetxUser get-xoUser ;
            set-alias ps1GetXCalProc get-xoCalendarprocessing ;
            set-alias ps1GetXMbxFldrPerm get-xoMailboxfolderpermission ;
            set-alias ps1GetXAccDom Get-xoAcceptedDomain ;
            set-alias ps1GGetXRetPol Get-xoRetentionPolicy ;
            set-alias ps1GetXDistGrp get-xoDistributionGroup ;
            set-alias ps1GetXDistGrpMbr get-xoDistributionGroupmember ;
            set-alias ps1TestXMigrSrvrAvail Test-xoMigrationServerAvailability ;
            set-alias ps1GetXMovReq get-xomoverequest ;
            set-alias ps1RmvXMovReq  Remove-xoMoveRequest ;
            set-alias ps1NewXMovReq  New-xoMoveRequest ;
            set-alias ps1GetXMovReqStats Get-xoMoveRequestStatistics
        }
        $false {
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):using EXO cmdlets" ;
            #reconnect-exo @pltRXO
            set-alias ps1GetXRcp get-exorecipient ;
            set-alias ps1GetXMbx get-exomailbox ;
            set-alias ps1SetXMbx Set-exoMailbox ;
            set-alias ps1GetxUser get-exoUser ;
            set-alias ps1GetXCalProc get-exoCalendarprocessing  ;
            set-alias ps1GetXMbxFldrPerm get-exoMailboxfolderpermission  ;
            set-alias ps1GetXAccDom Get-exoAcceptedDomain ;
            set-alias ps1GGetXRetPol Get-exoRetentionPolicy
            set-alias ps1GetXDistGrp get-exoDistributionGroup  ;
            set-alias ps1GetXDistGrpMbr get-exoDistributionGroupmember ;
            set-alias ps1TestXMigrSrvrAvail Test-exoMigrationServerAvailability ;
            set-alias ps1GetXMovReq get-exomoverequest ;
            set-alias ps1RmvXMovReq  Remove-exoMoveRequest ;
            set-alias ps1NewXMovReq  New-exoMoveRequest ;
            set-alias ps1GetXMovReqStats Get-exoMoveRequestStatistics
        } ;
    } ;  # SWTCH-E useEXOv2

    $Retries = 4 ;
    $RetrySleep = 5 ;
    $DawdleWait = 30 ; # wait time (secs) between dawdle checks
    $DirSyncInterval = 30 ; # AADConnect dirsync interval
    if(!$ThrottleMs){$ThrottleMs = 50 ;} ;
    $CredRole = 'CSVC' ; # role of svc to be dyn pulled from metaXXX if no -Credential spec'd,

    #$LastDays = -3 ;
    #if($LastDays -gt 0){$LastDays = $LastDays * -1 } ; # flip non-negative to negative integer, updated *-1 in the usage line

    if(!$rgxDriveBanChars){$rgxDriveBanChars = '[;~/\\\.:]' ; } ; # ;~/\.:,

    #*======v FUNCTIONS v======

    #-=-=TEMP SUPPRESS VERBOSE-=-=-=-=-=-=
    # suppress VerbosePreference:Continue, if set, during mod loads (VERY NOISEY)
    if($VerbosePreference = "Continue"){
        $VerbosePrefPrior = $VerbosePreference ;
        $VerbosePreference = "SilentlyContinue" ;
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ;
    #*------v  MOD LOADS  v------
    # strings are: "[tModName];[tModFile];tModCmdlet"
    $tMods = @() ;
    $tMods+="verb-Auth;C:\sc\verb-Auth\verb-Auth\verb-Auth.psm1;get-password" ;
    $tMods+="verb-logging;C:\sc\verb-logging\verb-logging\verb-logging.psm1;write-log";
    $tMods+="verb-IO;C:\sc\verb-IO\verb-IO\verb-IO.psm1;Add-PSTitleBar" ;
    $tMods+="verb-Mods;C:\sc\verb-Mods\verb-Mods\verb-Mods.psm1;check-ReqMods" ;
    $tMods+="verb-Text;C:\sc\verb-Text\verb-Text\verb-Text.psm1;Remove-StringDiacritic" ;
    #$tMods+="verb-Desktop;C:\sc\verb-Desktop\verb-Desktop\verb-Desktop.psm1;Speak-words" ;
    $tMods+="verb-dev;C:\sc\verb-dev\verb-dev\verb-dev.psm1;Get-CommentBlocks" ;
    $tMods+="verb-Network;C:\sc\verb-Network\verb-Network\verb-Network.psm1;Send-EmailNotif" ;
    $tMods+="verb-Automation.ps1;C:\sc\verb-Automation.ps1\verb-Automation.ps1\verb-Automation.ps1.psm1;Retry-Command" ;
    #$tMods+="verb-AAD;C:\sc\verb-AAD\verb-AAD\verb-AAD.psm1;Build-AADSignErrorsHash";
    $tMods+="verb-ADMS;C:\sc\verb-ADMS\verb-ADMS\verb-ADMS.psm1;load-ADMS";
    $tMods+="verb-Ex2010;C:\sc\verb-Ex2010\verb-Ex2010\verb-Ex2010.psm1;Connect-Ex2010";
    $tMods+="verb-EXO;C:\sc\verb-EXO\verb-EXO\verb-EXO.psm1;Connect-Exo";
    #$tMods+="verb-L13;C:\sc\verb-L13\verb-L13\verb-L13.psm1;Connect-L13";
    #$tMods+="verb-Teams;C:\sc\verb-Teams\verb-Teams\verb-Teams.psm1;Connect-Teams";
    #$tMods+="verb-SOL;C:\sc\verb-SOL\verb-SOL\verb-SOL.psm1;Connect-SOL" ;
    #$tMods+="verb-Azure;C:\sc\verb-Azure\verb-Azure\verb-Azure.psm1;get-AADBearToken" ;
    foreach($tMod in $tMods){
      $tModName = $tMod.split(';')[0] ; $tModFile = $tMod.split(';')[1] ; $tModCmdlet = $tMod.split(';')[2] ;
      $smsg = "( processing `$tModName:$($tModName)`t`$tModFile:$($tModFile)`t`$tModCmdlet:$($tModCmdlet) )" ;
      if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
      else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
      if($tModName -eq 'verb-Network' -OR $tModName -eq 'verb-Azure'){
          #write-host "GOTCHA!" ;
      } ;
      $lVers = get-module -name $tModName -ListAvailable -ea 0 | sort version | select -last 1 ;
      if($lVers){   $lVers=($lVers | sort version)[-1];   try {     import-module -name $tModName -RequiredVersion $lVers.Version.tostring() -force -DisableNameChecking -Verbose:$false  } catch {     write-warning "*BROKEN INSTALLED MODULE*:$($tModName)`nBACK-LOADING DCOPY@ $($tModDFile)" ;import-module -name $tModDFile -force -DisableNameChecking -verbose:$false  } ;
      } elseif (test-path $tModFile) {
        write-warning "*NO* INSTALLED MODULE*:$($tModName)`nBACK-LOADING DCOPY@ $($tModDFile)" ;
        try {import-module -name $tModDFile -force -DisableNameChecking -Verbose:$false} # force non-verbose, suppress spam
        catch {   write-error "*FAILED* TO LOAD MODULE*:$($tModName) VIA $(tModFile) !" ;   $tModFile = "$($tModName).ps1" ;   $sLoad = (join-path -path $LocalInclDir -childpath $tModFile) ;   if (Test-Path $sLoad) {       Write-Verbose -verbose ((Get-Date).ToString("HH:mm:ss") + "LOADING:" + $sLoad) ;       . $sLoad ;       if ($showdebug) { Write-Verbose -verbose "Post $sLoad" };   } else {       $sLoad = (join-path -path $backInclDir -childpath $tModFile) ;       if (Test-Path $sLoad) {           Write-Verbose -verbose ((Get-Date).ToString("HH:mm:ss") + "LOADING:" + $sLoad) ;           . $sLoad ;           if ($showdebug) { Write-Verbose -verbose "Post $sLoad" };       } else {           Write-Warning ((Get-Date).ToString("HH:mm:ss") + ":MISSING:" + $sLoad + " EXITING...") ;           exit;       } ;   } ; } ;
      } ;
      if(!(test-path function:$tModCmdlet)){
          write-warning -verbose:$true  "UNABLE TO VALIDATE PRESENCE OF $tModCmdlet`nfailing through to `$backInclDir .ps1 version" ;
          $sLoad = (join-path -path $backInclDir -childpath "$($tModName).ps1") ;
          if (Test-Path $sLoad) {     Write-Verbose -verbose:$true ((Get-Date).ToString("HH:mm:ss") + "LOADING:" + $sLoad) ;     . $sLoad ;     if ($showdebug) { Write-Verbose -verbose "Post $sLoad" };     if(!(test-path function:$tModCmdlet)){         write-warning "$((get-date).ToString('HH:mm:ss')):FAILED TO CONFIRM `$tModCmdlet:$($tModCmdlet) FOR $($tModName)" ;     } else {          write-verbose -verbose:$true  "(confirmed $tModName loaded: $tModCmdlet present)"     }
          } else {     Write-Warning ((Get-Date).ToString("HH:mm:ss") + ":MISSING:" + $sLoad + " EXITING...") ;     exit; } ;
      } else {     write-verbose -verbose:$true  "(confirmed $tModName loaded: $tModCmdlet present)" } ;
      if($tModName -eq 'verb-logging'){

            <#
            if($PSCommandPath){   $logspec = start-Log -Path $PSCommandPath -NoTimeStamp -Tag LASTPASS -showdebug:$($showdebug) -whatif:$($whatif) ;
            } else {    $logspec = start-Log -Path ($MyInvocation.MyCommand.Definition) -showdebug:$($showdebug) -whatif:$($whatif) ; } ;
            if($logspec){
                $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                $logging=$logspec.logging ;
                $logfile=$logspec.logfile ;
                $transcript=$logspec.transcript ;
                #Configure default logging from parent script name
                #start-transcript -Path $transcript ;
            } else {throw "Unable to configure logging!" } ;
            #>

      } ;
    } ;  # loop-E
    #*------^ END MOD LOADS ^------
    #-=-=-=-=RE-ENABLE PRIOR VERBOSE-=-=-=-=
    # reenable VerbosePreference:Continue, if set, during mod loads
    if($VerbosePrefPrior -eq "Continue"){
        $VerbosePreference = $VerbosePrefPrior ;
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ;
    #-=-=-=-=-=-=-=-=

    #*------v Function check-ReqMods  v------
    function check-ReqMods ($reqMods){    $bValidMods=$true ;    $reqMods | foreach-object {        if( !(test-path function:$_ ) ) {          write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing $($_) function." ;          $bValidMods=$false ;        }    } ;    write-output $bValidMods ;} ;
    #*------^ END Function check-ReqMods  ^------

    #*======^ END FUNCTIONS ^======

    #*======v SUB MAIN v======

    # email trigger vari, it will be semi-delimd list of mail-triggering events
    $script:PassStatus = $null ;

    # check for $TenOrg & credential alignment
    # with credential un-defaulted, no need to compare $TenOrg & credential
    $tvari = "PassStatus_$($tenorg)" ; if(get-Variable -Name $tvari -scope Script -ea 0){Remove-Variable -Name $tvari -scope Script}
    New-Variable -Name PassStatus_$($tenorg) -scope Script -Value $null ;

    $reqMods+="Add-PSTitleBar;Remove-PSTitleBar".split(";") ;
    #Disconnect-EMSR (variant name in some ps1's for Disconnect-Ex2010)
    #$reqMods+="Reconnect-CCMS;Connect-CCMS;Disconnect-CCMS".split(";") ;
    #$reqMods+="Reconnect-SOL;Connect-SOL;Disconnect-SOL".split(";") ;
    $reqMods+="Test-TranscriptionSupported;Test-Transcribing;Stop-TranscriptLog;Start-IseTranscript;Start-TranscriptLog;get-ArchivePath;Archive-Log;Start-TranscriptLog".split(";") ;
    # add verb-automation content
    $reqMods+="retry-command".split(";") ;
    # lab, fails wo
    $reqMods+="Load-EMSSnap" ;
    # remove dupes
    $reqMods=$reqMods| select -Unique ;
    <#
    $dPref = 'd','c' ; foreach($budrv in $dpref){ if(test-path -path "$($budrv):\scripts" -ea 0 ){ break ;  } ;  } ;
    [regex]$rgxScriptsAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\Scripts" ;
    if($PSCommandPath){
        if($PSCommandPath -match $rgxScriptsAllUsersScope){
            # AllUsers installed script, divert into [$budrv]:\scripts (don't write logs into allusers context folder)
            $logspec = start-Log -Path (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $PSCommandPath -leaf)) -NoTimeStamp -Tag "($TenOrg)-LASTPASS" -showdebug:$($showdebug) -whatif:$($whatif) ;
        }else {
            $logspec = start-Log -Path $PSCommandPath -NoTimeStamp -Tag "($TenOrg)-LASTPASS" -showdebug:$($showdebug) -whatif:$($whatif) ;
        } ;
    } else {
        if($MyInvocation.MyCommand.Definition -match $rgxScriptsAllUsersScope){
            $logspec = start-Log -Path (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $PSCommandPath -leaf)) -NoTimeStamp -Tag "($TenOrg)-LASTPASS" -showdebug:$($showdebug) -whatif:$($whatif) ;
        } else {
            $logspec = start-Log -Path $MyInvocation.MyCommand.Definition -NoTimeStamp -Tag "($TenOrg)-LASTPASS" -showdebug:$($showdebug) -whatif:$($whatif) ;
        } ;
    } ;
    #>
    # 10:29 AM 5/19/2021 splice in curr start-log bloc
    # detect profile installs (installed mod or script), and redir to stock location
    $dPref = 'd','c' ; foreach($budrv in $dpref){ if(test-path -path "$($budrv):\scripts" -ea 0 ){ break ;  } ;  } ;
    [regex]$rgxScriptsModsAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)" ;
    [regex]$rgxScriptsModsCurrUserScope="^$([regex]::escape([environment]::getfolderpath('Mydocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)" ;
    # -Tag "($TenOrg)-LASTPASS" 
    $lTag = @($TargetMailboxes)[0].tostring().substring(0,[System.Math]::Min(12,@($TargetMailboxes)[0].length))
    $pltSLog = [ordered]@{ NoTimeStamp=$false ; Tag=$lTag  ; showdebug=$($showdebug) ;whatif=$($whatif) ;} ;
    if($PSCommandPath){
        if(($PSCommandPath -match $rgxScriptsModsAllUsersScope) -OR ($PSCommandPath -match $rgxScriptsModsCurrUserScope) ){
            # AllUsers or CU installed script, divert into [$budrv]:\scripts (don't write logs into allusers context folder)
            if($PSCommandPath -match '\.ps(d|m)1$'){
                # module function: use the ${CmdletName} for childpath
                $pltSLog.Path= (join-path -Path "$($budrv):\scripts" -ChildPath "$(${CmdletName}).ps1" )  ;
            } else { 
                $pltSLog.Path=(join-path -Path "$($budrv):\scripts" -ChildPath (split-path $PSCommandPath -leaf)) ;
            } ; 
        }else {
            $pltSLog.Path=$PSCommandPath ;
        } ;
    } else {
        if( ($MyInvocation.MyCommand.Definition -match $rgxScriptsModsAllUsersScope) -OR ($MyInvocation.MyCommand.Definition -match $rgxScriptsModsCurrUserScope) ){
            $pltSLog.Path=(join-path -Path "$($budrv):\scripts" -ChildPath (split-path $PSCommandPath -leaf)) ;
        } else {
            $pltSLog.Path=$MyInvocation.MyCommand.Definition ;
        } ;
    } ;
    $smsg = "start-Log w`n$(($pltSLog|out-string).trim())" ;
    if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
    $logspec = start-Log @pltSLog ;
    <#
    if($logspec){
        $logging=$logspec.logging ;
        $logfile=$logspec.logfile ;
        $transcript=$logspec.transcript ;

        if($whatif){
            $logfile=$logfile.replace("-BATCH","-BATCH-WHATIF") ;
            $transcript=$transcript.replace("-BATCH","-BATCH-WHATIF") ;
        } else {
            $logfile=$logfile.replace("-BATCH","-BATCH-EXEC") ;
            $transcript=$transcript.replace("-BATCH","-BATCH-EXEC") ;
        } ;
        if($Ticket){
            $logfile=$logfile.replace("-BATCH","-$($Ticket)") ;
            $transcript=$transcript.replace("-BATCH","-$($Ticket)") ;
        } else {
            $logfile=$logfile.replace("-BATCH","-nnnnnn") ;
            $transcript=$transcript.replace("-BATCH","-nnnnnn") ;
        } ;

        if(Test-TranscriptionSupported){
            $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
            start-transcript -Path $transcript ;
        } ;
    } else {throw "Unable to configure logging!" } ;
    #>
    # reloc batch calc, to include the substring in the log/transcript
    if(!$BatchName){
        $BatchName = "ExoMoves-$($env:USERNAME)" ;
        # include the 1st TargetMailbox fr the param, use first 12 chars (or less)
        $BatchName += '-' + @($TargetMailboxes)[0].tostring().substring(0,[System.Math]::Min(12,@($TargetMailboxes)[0].length)) ;
        if( (@($TargetMailboxes)|measure).count -gt 1 ){
            # append an ellipses to indicate multiple mbxs moved
            $BatchName += '...' ;
        } ;
        $BatchName += "-$(get-date -format 'yyyyMMdd-HHmmtt')" ;
        $smsg= "Using Dynamic BatchName:$($BatchName)" ;
    } else {
        $smsg= "Using -BatchName:$($BatchName)" ;
    } ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    if($logspec){
        $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
        $logging=$logspec.logging ;
        $logfile=$logspec.logfile ;
        $transcript=$logspec.transcript ;
        #Configure default logging from parent script name
        # logfile                        C:\usr\work\o365\scripts\logs\move-EXOmailboxNow-(TOR)-LASTPASS-LOG-BATCH-WHATIF-log.txt
        # transcript                     C:\usr\work\o365\scripts\logs\move-EXOmailboxNow-(TOR)-LASTPASS-Transcript-BATCH-WHATIF-trans-log.txt
        if($Ticket){
            $logfile=$logfile.replace("-BATCH","-$($Ticket)-BATCH") ;
            $transcript=$transcript.replace("-BATCH","-$($Ticket)-BATCH") ;
        } else {
            $logfile=$logfile.replace("-BATCH","-nnnnnn") ;
            $transcript=$transcript.replace("-BATCH","-nnnnnn") ;
        } ;
        $logfile = $logfile.replace('-LASTPASS','').replace('BATCH',(Remove-InvalidFileNameChars -name $BatchName )) ;
        $transcript = $transcript.replace('-LASTPASS','').replace('BATCH',(Remove-InvalidFileNameChars -name $BatchName )) ;
        if(Test-TranscriptionSupported){start-transcript -Path $transcript }
        else { write-warning "$($host.name) v$($host.version.major) does *not* support Transcription!" } ;
    } else {throw "Unable to configure logging!" } ;

    $smsg= "#*======v START PASS:$($ScriptBaseName) v======" ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    <# disable cross-org handling, post tenant migr, no need
    # seeing Curly & Cheech turn up in EX10 queries, pre-purge *any* AD psdrive
    if($existingADPSDrives = get-psdrive -PSProvider ActiveDirectory -ea 0){
        $smsg = "Purging *existing* AD PSDrives found:$(($existingADPSDrives| ft -auto name,provider,root,globalcatalog|out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $error.clear() ;
        TRY {
            $existingADPSDrives | remove-psdrive -Verbose:$($verbose) # -WhatIf:$($whatif) ;
        } CATCH {
            Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($Error[0].Exception.GetType().FullName)]{" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            BREAK ;
        } ;

    } ;

    # also purge the $global:ADPsDriveNames or $script:ADPsDriveNames
    if(gv -name ADPsDriveNames -scope global -ea 0){
        $error.clear() ;
        TRY {
            Remove-Variable -name ADPsDriveNames -Scope Global ;
        } CATCH {
            Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($Error[0].Exception.GetType().FullName)]{" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            BREAK ;
        } ;
    } ;
    if(gv -name ADPsDriveNames -scope script -ea 0){
        $error.clear() ;
        TRY {
            Remove-Variable -name ADPsDriveNames -Scope script ;
        } CATCH {
            Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($Error[0].Exception.GetType().FullName)]{" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            BREAK ;
        } ;
    } ;
    #>
    # $XXXMeta.ExOPAccessFromToro & Ex10Server
    # steer all onprem code
    $UseOP=$false ;
    if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
        $UseOP = $true ;
        $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ;
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
    } else {
        $UseOP = $false ;
        $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ;
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
    } ;

    # TEST
    if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;

    $useEXO = $true ; # non-dyn setting, drives variant EXO reconnect & query code
    if($useEXO){
        #*------v GENERIC EXO CREDS & SVC CONN BP v------
        # o365/EXO creds
        <### Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile*
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
        Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
        .EXAMPLE
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
        Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
        .EXAMPLE
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
        Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
        ###>
        $o365Cred=$null ;
        <# $TenOrg is a mandetory param in this script, skip dyn resolution
        switch -regex ($env:USERDOMAIN){
            "(TORO|CMW)" {$TenOrg = $env:USERDOMAIN.substring(0,3).toupper() } ;
            "TORO-LAB" {$TenOrg = 'TOL' }
            default {
                throw "UNRECOGNIZED `$env:USERDOMAIN!:$($env:USERDOMAIN)" ;
                exit ;
            } ;
        } ;
        #>
        if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -UserRole 'CSVC','ESVC','SID' -verbose:$($verbose))){
            # make it script scope, so we don't have to predetect & purge before using new-variable - except now it does [headcratch]
            $tvari = "cred$($tenorg)" ; if(get-Variable -Name $tvari -scope Script -ea 0){Remove-Variable -Name $tvari -scope Script}
            New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
            $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } else {
            $statusdelta = ";ERROR";
            $script:PassStatus += $statusdelta ;
            set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
            $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
            exit ;
        } ;
        <### CALLS ARE IN FORM: (cred$($tenorg))
        $pltRXO = @{Credential = $Credential ; verbose = $($verbose) ; }
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            verbose = $($verbose) ; } ;
        if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
        else { reconnect-EXO @pltRXO } ;
        # or with Tenant-specific cred($Tenorg) lookup
        #$pltRXO creds & .username can also be used for AzureAD connections
        Connect-AAD @pltRXO ;
        ###>
        # configure splat for connections: (see above useage)
        # downstream commands
        $pltRXO = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
        } ;
        if((gcm Reconnect-EXO).Parameters.keys -contains 'silent'){
            $pltRxo.add('Silent',$silent) ;
        } ;
        # default connectivity cmds - force silent false
        $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$true) ;
        if((gcm Reconnect-EXO).Parameters.keys -notcontains 'silent'){ $pltRxo.remove('Silent') } ; 
        #*------^ END GENERIC EXO CREDS & SVC CONN BP ^------
    } # if-E $useEXO

    if($UseOP){
        #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
        # do the OP creds too
        $OPCred=$null ;
        # default to the onprem svc acct
        $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC','SID'; verbose=$($verbose)} ;
        if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
            # make it script scope, so we don't have to predetect & purge before using new-variable
            $tvari = "cred$($tenorg)OP" ; if(get-Variable -Name $tvari -scope Script -ea 0){Remove-Variable -Name $tvari -scope Script} ; 
            New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
            $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } else {
            $statusdelta = ";ERROR";
            $script:PassStatus += $statusdelta ;
            set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
            $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole $($userrole -join '|') value!"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
            exit ;
        } ;
        $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        <# CALLS ARE IN FORM: (cred$($tenorg))
        $pltRX10 = @{
            Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
            verbose = $($verbose) ; }
        Reconnect-Ex2010 @pltRX10 ; # local org conns
        #$pltRx10 creds & .username can also be used for local ADMS connections
        #>
        $pltRX10 = @{
            Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
            verbose = $($verbose) ; } ;
        # TEST
        if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
        # defer cx10/rx10, until just before get-recipients qry
        #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
        # connect to ExOP X10
        <#
        if($pltRX10){
            ReConnect-Ex2010 @pltRX10 ;
        } else { Reconnect-Ex2010 ; } ;
        #>
    } ;  # if-E $useEXOP


    $smsg= "Using EXOP cred:$($pltRXO.Credential.username)" ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    $smsg= "Using OPCred cred:$($pltRX10.Credential.username)" ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    <# 4:42 PM 6/21/2022 with exo2 hybrid bug, have to move rx10 AFTER rxo
    if($VerbosePreference = "Continue"){
        $VerbosePrefPrior = $VerbosePreference ;
        $VerbosePreference = "SilentlyContinue" ;
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ;
    if($pltRX10){ReConnect-Ex2010 @pltRX10 }
    else { Reconnect-Ex2010 ; } ;
    if($VerbosePrefPrior -eq "Continue"){
        $VerbosePreference = $VerbosePrefPrior ;
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ;
    # which also includes loadadms (old ad/ex bug), must be done after rx10


    # load ADMS
    $reqMods+="load-ADMS".split(";") ;
    if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
    $smsg = "(loading ADMS...)" ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    load-ADMS ;

    # multi-org AD
    #still needs ADMS mount-ADForestDrives() and set-location code @ 395 (had to recode mount-admforestdrives and debug cred production code & infra-string inputs before it would work; will need to dupe to suspend variant on final completion
    #

    if(!$global:ADPsDriveNames){
        $smsg = "(connecting X-Org AD PSDrives)" ;
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        $global:ADPsDriveNames = mount-ADForestDrives -verbose:$($verbose) ;
    } ;
    #>
    # EXO connection


    #$reqMods+="connect-exo;Reconnect-exo;Disconnect-exo".split(";") ;
    if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
    $smsg = "(loading EXO...)" ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    #reconnect-exo -credential $pltRXO.Credential ;
    if ($script:useEXOv2) { reconnect-eXO2 @pltRXOC }
    else { reconnect-EXO @pltRXOC } ;


    # 4:45 PM 6/21/2022 exov2 hybrid bug, move rx10/adms below rxo
    if($VerbosePreference = "Continue"){
        $VerbosePrefPrior = $VerbosePreference ;
        $VerbosePreference = "SilentlyContinue" ;
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ;
    if($pltRX10){ReConnect-Ex2010 @pltRX10 }
    else { Reconnect-Ex2010 ; } ;
    if($VerbosePrefPrior -eq "Continue"){
        $VerbosePreference = $VerbosePrefPrior ;
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ;
    # which also includes loadadms (old ad/ex bug), must be done after rx10


    # load ADMS
    $reqMods+="load-ADMS".split(";") ;
    if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
    $smsg = "(loading ADMS...)" ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    load-ADMS ;

    # multi-org AD
    #still needs ADMS mount-ADForestDrives() and set-location code @ 395 (had to recode mount-admforestdrives and debug cred production code & infra-string inputs before it would work; will need to dupe to suspend variant on final completion
    #

    <#if(!$global:ADPsDriveNames){
        $smsg = "(connecting X-Org AD PSDrives)" ;
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        $global:ADPsDriveNames = mount-ADForestDrives -verbose:$($verbose) ;
    } ;
    #>


    <# RLMS connection
    $reqMods+="Get-LyncServerInSite;load-LMS;Disconnect-LMSR".split(";") ;
    if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
    write-verbose -verbose:$true  "(loading LMS...)" ;
    Reconnect-L13 ;
    #>

    # forestdom is used to build the expected Tenant onmicrosoft address filter
    #$script:forestdom=((get-adforest | select -expand upnsuffixes) |?{$_ -eq (Get-Variable  -name "$($TenOrg)Meta").value.o365_OPDomain}) ;
    #-=-get-gcfastXO use to pull a root domain (or enable-exforestview for OPEX)=-=-=-=-=-
    if($UseOP){
        <# 4:46 PM 6/21/2022 wo functional crossorg, this is all wasted code
        # suppress VerbosePreference:Continue, if set, during mod loads (VERY NOISEY)
        if($VerbosePreference -eq "Continue"){
            $VerbosePrefPrior = $VerbosePreference ;
            $VerbosePreference = "SilentlyContinue" ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        # we need $domaincontroller pop'd whether useCached or not
        # connect to ExOP X10 4:02 PM 3/23/2021 this SHOULDN'T BE A RECONNECT! should be a cold connect, *with* a pre-disconnect! I just watched it skid from TOR to CMW wo dropping connect!
        if($pltRX10){
            #Disconnect-Ex2010 -verbose:$($verbose) ;
            #get-pssession | remove-pssession ;
            # if it's not a multi-tenant process, don't pre-disconnect
            $smsg = "reconnect-Ex2010 w`n$(($pltRX10|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            ReConnect-Ex2010 @pltRX10 ;
        } else { connect-Ex2010 ; } ;
        if($VerbosePrefPrior -eq "Continue"){
            $VerbosePreference = $VerbosePrefPrior ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        # pre-clear dc, before querying
        $domaincontroller = $null ;
        # 3:24 PM 3/ 9/2022 post tenant migr, we aren't doing local anymore, use get-gcfast instead
        #$domaincontroller = get-gcfastxo -TenOrg $TenOrg -Subdomain $subdom -verbose:$($verbose) |?{$_.length};
        $domaincontroller = get-gcfast -verbose:$($verbose) |?{$_.length};
        #>
        <#
        # we don't know which subdoms may be in play
        pushd ; # cache pwd
        if( $tPsd = "$((Get-Variable  -name "$($TenOrg)Meta").value.ADForestName -replace $rgxDriveBanChars):" ){
            if(test-path $tPsd){
                $error.clear() ;
                TRY {
                    set-location -Path $tPsd -ea STOP ;
                    $objForest = get-adforest ;
                    $doms = @($objForest.Domains) ; # ad mod get-adforest vers
                    # do simple detect 2 doms (parent & child), use child (non-parent dom):
                    if(($doms|?{$_ -ne $objforest.name}|measure).count -eq 1){
                        $subdom = $doms|?{$_ -ne $objforest.name} ;
                        $domaincontroller = get-gcfastxo -TenOrg $TenOrg -Subdomain $subdom -verbose:$($verbose) |?{$_.length};
                        $smsg = "get-gcfastxo:returned $($domaincontroller)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } else {
                        # as this is just EX, and not AD search, open the forestview up - all Ex OP qrys will search entire forest
                        enable-forestview
                        $domaincontroller = $null ;
                    } ;
                    $script:forestdom=(($objForest | select -expand upnsuffixes) |?{$_ -eq (Get-Variable  -name "$($TenOrg)Meta").value.o365_OPDomain}) ;
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg= "Failed to exec cmd because: $($ErrTrapd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    popd ; # restore dir
                    Exit #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                } ;
            } else {
                $smsg = "UNABLE TO FIND *MOUNTED* AD PSDRIVE $($Tpsd) FROM `$$($TENorg)Meta!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Exit #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
            } ;
        } else {
            $smsg = "UNABLE TO RESOLVE PROPER AD PSDRIVE FROM `$$($TENorg)Meta!" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Exit #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ;
        popd ; # cd to prior dir
        #>
        # 4:47 PM 6/21/2022 still uses a dc in the getb-mailboxe low
        $domaincontroller = get-gcfast -verbose:$($verbose) |?{$_.length};

    } ; # $useOP
    #-=-=-=-=-=-=-

    # move the domaincontroller lookup code down into the per-user, user's subdomain is required to run get-aduser or Exch cmdlets to find the object.

    #-=-NON-SUSPEND, COMPLETE 1ST PASS:SuspendWhenReadyToComplete=$false, launch Suspend=$false=-=-=-=-=-=-=

    # fall back manual prompt creds
    <#
    if($TORMeta['o365_SIDUpn'] -AND $TORMeta['logon_SID']){
        $EXOMoveID=$TORMeta['o365_SIDUpn'] # EXO UPN-based admin sid
        $OPMoveID=$TORMeta['logon_SID'] ; # # ONPrem EX legacy fmt admin sid
    } ;
    #>
    # tenant & hyb creds already gotten above: EXO:$pltRXO.Credential & Ex10/AD:$pltRX10.Credential

    if(!$ThrottleMs){$ThrottleMs = 500 } ;#amt to throttle per pass, to *try* to stay out of throttling

    write-host "`a`n" ;
    write-host -foregroundcolor green "DID YOU PRECONVERT SECURITY GRPS & DUMP ACLS!?" ;
    write-host "`a`n" ;
    if($NoPrompt){
        $smsg = "(-NoPrompt: skipping interactive)" ;
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        $bRet = 'YYY'
    }else{
        $bRet=Read-Host "Enter YYY to continue. Anything else will exit"
    } ;
    if ($bRet.ToUpper() -eq "YYY") {
         Write-host "Moving on"
    } else {
         Write-Host "Invalid response. Exiting"
         # exit <asserted exit error #>
         exit 1
    } # if-block end

    <# timezone standards:
    $cstzone = [System.TimeZoneInfo]::FindSystemTimeZoneById("Central Standard Time") ;
    $AUCSTzone = [System.TimeZoneInfo]::FindSystemTimeZoneById("Cen. Australia Standard Time") ;
    $GMTzone = [System.TimeZoneInfo]::FindSystemTimeZoneById("GMT Standard Time") ;
    #>

    <#
    if($global:credo365TORSID){$exocred = $global:credo365TORSID}
    else {$exocred = Get-Credential -credential $EXOMoveID } ;

    if($global:credTORSID){$pltRX10.Credential = $global:credTORSID}
    else {$pltRX10.Credential = Get-Credential -credential $OPMoveID} ;
    #>
    <# rem it, don't want to trigger the exov2 bug, assume it's always functional, post above connect
    if($pltRX10){
        ReConnect-Ex2010 @pltRX10 ;
    } else { Reconnect-Ex2010 ; } ;
    #>

    if($BatchFile){
        $smsg= "Using -BatchName:$($BatchName)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $TargetMailboxes=import-csv -path $BatchFile | select -expand PrimarySMTPAddress;
    } elseif ($Targetmailboxes){
        # defer to parameter version
    }else {
        $smsg= "MISSING `$BATCHFILE, ABORTING!" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        Cleanup
    } ;  ;

    # moved batchname calc up to logging area (to include in log)

    #if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
    #else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    $ttl=($TargetMailboxes|measure).count ;
    $Procd=0 ;

    foreach($tMbxId in $TargetMailboxes){
        $Procd++ ;
        $sBnr="#*======v `$tmbx:($($Procd)/$($ttl)):$($tMbxId) v======" ;
        $smsg="$($sBnr)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        if ($script:useEXOv2) { reconnect-eXO2 @pltRXOC }
        else { reconnect-EXO @pltRXOC } ;

        # use new get-GCFastXO cross-org dc finder
        #$domaincontroller = get-GCFastXO -TenOrg $TenOrg -ADObject $tMbxId -verbose:$($verbose) ;
        <# post tenantmigr, no point
        #-=-=use new get-GCFastXO cross-org dc finder against a TenOrg and -ADObject-=-=-=-=-=-=
        $domaincontroller = $null ; # pre-clear, ensure no xo carryover
        if($tMbxId){
            # the get-addomaincontroller is returning an array; use the first item (second is blank)
            $domaincontroller = get-GCFastXO -TenOrg $TenOrg -ADObject $tMbxId -verbose:$($verbose) |?{$_.length} ;
        } else {throw "unpopulated `$TargetMailboxes parameter, unable to resolve a matching OR OP_ExADRoot property" ; } ;
        #-=-=-=-=-=-=-=-=
        #>

        # issue is that 2 objects are coming back: first is null, 2nd is the dc spec
        $Exit = 0 ;
        Do {
            Try {
                if(!(get-AdServerSettings).ViewEntireForest){ enable-ForestView } ;
                $ombx=get-mailbox -id $tMbxId -domaincontroller $domaincontroller ;
                # dc issues, drop it, and use dawdles
                #$ombx=get-mailbox -id $tMbxId  ;

                $Exit = $Retries ;
            } Catch {
                $smsg = "Failed to exec cmd because: $($Error[0])" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Start-Sleep -Seconds $RetrySleep ;
                    if($pltRX10){
                        ReConnect-Ex2010 @pltRX10 ;
                    } else { Reconnect-Ex2010 ; } ;
                $Exit ++ ;
                $smsg = "Try #: $Exit" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" }
                If ($Exit -eq $Retries) {
                    $smsg = "Unable to exec cmd!"
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;
            }  ;
        } Until ($Exit -eq $Retries) ;

        $rgxTenDomAddr = 'smtp:.*@\w*.mail.onmicrosoft.com' ;
        $rgxTenDomEAP = '^smtp:.*(\@\w*\.mail\.onmicrosoft.com)$'
        #$TenantDomainMail=$TORMeta['o365_TenantDomainMail'] ;
        $TenantDomainMail=(Get-Variable  -name "$($TenOrg)Meta").value.o365_TenantDomainMail ;

        # dynamically pull the onmicrosoft address from lowest priority policy
        $error.clear() ;
        TRY {
            ((get-emailaddresspolicy | sort priority -desc)[0] | select -expand EnabledEmailAddressTemplates|?{$_ -match $rgxTenDomEAP }) | out-null ;
            $OnMicrosoftAddrDomain=$matches[1] ;
        } CATCH {
            $smsg = "Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Exit #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
            # -Variable -Name PassStatus_$($tenorg) -scope Script -Value $null ;
        } ;

        if($ombx){

            if($tenantCoAddr=$ombx | select -expand emailaddresses | ?{$_ -match $rgxTenDomAddr}){
                $smsg= "mbx HAS matching address:$($tenantCoAddr)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                # moved the $OnMicrosoftAddrDomain lookup outside of the if/then
                if($OnMicrosoftAddrDomain){
                    $smsg= "mbx MISSING @TENANTDOM.mail.onmicrosoft.com:$($addr.PrimarySMTPAddress)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN} #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    # precheck for addrs
                    $smsg= "SMTP Addrs:`n$(($ombx | Select -Expand EmailAddresses | ? {$_ -like "smtp:*"}|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $ombx | Select -Expand EmailAddresses | ? {$_ -like "smtp:*"} ;
                    $smsg= "EAP Settings:`n$(($ombx|fl EmailAddressPolicyEnabled,CustomAttribute5|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $newOnMSAddr="$($ombx.alias)$($OnMicrosoftAddrDomain)" ;
                    $spltSetmailbox=@{
                        identity=$ombx.samaccountname ;
                        #domaincontroller= $domaincontroller ;
                        EmailAddresses= @{add="$($newOnMSAddr)"} ;
                        whatif=$($whatif) ;
                    } ;

                    $smsg= "Set-Mailbox w`n$(($spltSetmailbox|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    $smsg= "emailaddresses (expanded):`n$(($spltsetmailbox.emailaddresses |out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    $Exit = 0 ;
                    Do {
                        Try {
                            Set-Mailbox @spltSetmailbox ;
                            $Exit = $Retries ;
                        } Catch {
                            $smsg = "Failed to exec cmd because: $($Error[0])" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Start-Sleep -Seconds $RetrySleep ;
                            if($pltRX10){
                                ReConnect-Ex2010 @pltRX10 ;
                            } else { Reconnect-Ex2010 ; } ;
                            $Exit ++ ;
                            $smsg = "Try #: $Exit" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" }
                            If ($Exit -eq $Retries) {
                                $smsg = "Unable to exec cmd!"
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } ;
                        }  ;
                    } Until ($Exit -eq $Retries) ;

                    $1F=$false ;Do {
                        if($1F){Sleep -s 5} ;  write-host "." -NoNewLine ; $1F=$true ;
                        Try {
                            $ombx=get-Mailbox $ombx.samaccountname
                        } CATCH {
                            Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
                            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($Error[0].Exception.GetType().FullName)]{" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                        } ;
                    } Until ($ombx.emailaddresses -like '*.onmicrosoft.com') ;

                    $smsg= "`nUpdated Addrs:`n$(( $ombx.EmailAddresses |?{$_ -match 'smtp:.*'}|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):MONITORING COMMAND FOR ABOVE:" ;
                    "Do {write-host '.' -NoNewLine;Start-Sleep -m (1000 * 60)} Until (Get-exoRecipient $($ombx.userprincipalname) -ea 0| select -expand emailaddresses|?{$_ -like '*@$($TenantDomainMail)'}) ; write-host '``a' "

                } else{
                    $smsg= ":mbx MISSING @$($TenantDomainMail):$($addr.PrimarySMTPAddress)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                    else{ write-host -foregroundcolor RED "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;

                if($tenantCoAddr=$ombx | select -expand emailaddresses | ?{$_ -match [regex]'smtp:.*@$($TenantDomainMail)'}){
                    $smsg= "mbx HAS matching address:$($tenantCoAddr)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } else {
                    $smsg= "mbx MISSING @$($TenantDomainMail):$($addr.PrimarySMTPAddress)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                    else{ write-host -foregroundcolor RED "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;

            } ;

            $Exit = 0 ;
            Do {
                Try {
                    #$exorcp=Get-exoRecipient $($ombx.userprincipalname) -ea 0| select -expand emailaddresses|?{$_ -match $rgxTenDomAddr} ;
                    # go back to using static dc
                    $exorcp=Get-exoRecipient $($ombx.userprincipalname) ;
                    $Exit = $Retries ;
                } Catch {
                    $smsg = "Failed to exec cmd because: $($Error[0])" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Start-Sleep -Seconds $RetrySleep ;
                    if($pltRX10){
                        ReConnect-Ex2010 @pltRX10 ;
                    } else { Reconnect-Ex2010 ; } ;
                    $Exit ++ ;
                    $smsg = "Try #: $Exit" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" }
                    If ($Exit -eq $Retries) {
                        $smsg = "Unable to exec cmd!"
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                }  ;
            } Until ($Exit -eq $Retries) ;

            if($exorcp){
                # use the cached obj
                #$RemoteHostName = ($MigEnd|?{$_.remoteserver -like 'my*'})[0].remoteserver ;
                $MvSplat=[ordered]@{
                    Identity=$ombx.userprincipalname ;
                    remote=$true;
                    #RemoteHostName=$RemoteHostName ;
                    RemoteHostName=$null ;
                    TargetDeliveryDomain= $OnMicrosoftAddrDomain.replace('@','') # @$($TenantDomainMail)
                    RemoteCredential=$pltRX10.Credential ;
                    BadItemLimit=1000 ;
                    AcceptLargeDataLoss=$true ;
                    Suspend=$false ;
                    SuspendWhenReadyToComplete=$false ;
                    BatchName=$Batchname ;
                    whatif=$($whatif) ;
                } ;

                #
                $tMEPID=$null ;
                if((Get-Variable  -name "$($TenOrg)Meta").value.MEPArray){
                        #set-variable -Name $meta.name -Value ((get-variable -name $meta.name).value  += @{'o365_AcceptedDomains' = (Get-exoAcceptedDomain).domainname} )
                        #$smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1 ;
                        # loop the MepArray members, till you find the one the mbx.db matches on, then use it's MEPID
                        foreach($MA in (Get-Variable  -name "$($TenOrg)Meta").value.meparray){
                            #$ombx.Database
                            if($ombx.Database -match $MA.split(';')[2]){
                                $tMEPID = $MA.split(';')[1] ;
                                break ;
                            } ;
                        } ;
                } else {
                    $smsg = "UNABLE TO RESOLVE `$($TenOrg)Meta.MEPArray" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                    else{ write-host -foregroundcolor RED "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    throw $smsg ;
                } ;
                if($tMEPID){$MvSplat.RemoteHostName= $tMepID}
                else {
                    $smsg = "`$tMEPID undefined!" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                    else{ write-host -foregroundcolor RED "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    throw $smsg ;
                } ;

                if(!$NoTEST){
                    $tMEPID |foreach-object {
                        $error.clear() ;
                        TRY {
                            $smsg= "Testing OnPrem Admin account $($pltRX10.Credential.username) against $($_)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            if ($script:useEXOv2) { reconnect-eXO2 @pltRXOC }
                            else { reconnect-EXO @pltRXOC } ;
                            $oTest= ps1TestXMigrSrvrAvail -ExchangeRemoteMove -RemoteServer $_ -Credentials $pltRX10.Credential ;
                        } CATCH {
                            $smsg= "Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                            else{ write-host -foregroundcolor RED "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $bMEPFail=$true ;
                            #Exit #Opts: STOP(debug)|EXIT(close)|Continue(move on in loop cycle)
                            Continue
                        } # try/catch-E ;
                        $smsg= $oTest ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                } else {
                    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):-NoTEST param detected: Skipping MEP tests" ;
                } ;

                <# version that keys suspend off of explicit script name
                switch -regex ($ScriptBaseName){
                    "^move-EXOmailboxSuspend\.ps1$" {
                        $smsg= "Configuring:SuspendWhenReadyToComplete=`$TRUE" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } ; #Error|Warn
                        $MvSplat.SuspendWhenReadyToComplete=$true ;
                    }
                    "^move-EXOmailboxNow\.ps1$" {
                        $smsg= "Configuring:SuspendWhenReadyToComplete=`$FALSE" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } ; #Error|Warn
                        $MvSplatSuspendWhenReadyToComplete=$false ;
                    }
                    default {throw "Unrecognized FILENAME:$($ScriptNameNoExt)"}
                } ;
                #>
                # switch to explicit -Suspend param (for move into verb-exo module): $Suspend
                if($Suspend){
                    $smsg= "-Suspend specified: Configuring:SuspendWhenReadyToComplete=`$TRUE" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $MvSplat.SuspendWhenReadyToComplete=$true ;
                } else {
                    $smsg= "Configuring:SuspendWhenReadyToComplete=`$FALSE" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $MvSplat.SuspendWhenReadyToComplete=$false ;
                } ;

                $Exit = 0 ;
                Do {
                    Try {
                        $existMove=ps1GetXMovReq -Identity $mvsplat.identity -ea 0 ;
                        $Exit = $Retries ;
                    } Catch {
                        $smsg = "Failed to exec cmd because: $($Error[0])" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Start-Sleep -Seconds $RetrySleep ;
                        if($pltRX10){
                            ReConnect-Ex2010 @pltRX10 ;
                        } else { Reconnect-Ex2010 ; } ;
                        $Exit ++ ;
                        $smsg = "Try #: $Exit" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" }
                        If ($Exit -eq $Retries) {
                            $smsg = "Unable to exec cmd!"
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ;
                    }  ;
                } Until ($Exit -eq $Retries) ;

                if($existMove){
                    $smsg= "==Removing ExistMove:$($existMove.alias)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    $Exit = 0 ;
                    Do {
                        Try {
                            # add force confirm, it prompted to purge some priors
                            ps1RmvXMovReq $existMove.alias -force:$true -confirm:$false -whatif:$($whatif) ;
                            $Exit = $Retries ;
                        } Catch {
                            $smsg = "Failed to exec cmd because: $($Error[0])" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Start-Sleep -Seconds $RetrySleep ;
                            if ($script:useEXOv2) { reconnect-eXO2 @pltRXOC }
                            else { reconnect-EXO @pltRXOC } ;
                            $Exit ++ ;
                            $smsg = "Try #: $Exit" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" }
                            If ($Exit -eq $Retries) {
                                $smsg = "Unable to exec cmd!"
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } ;
                      }  ;

                    } Until ($Exit -eq $Retries) ;


                    "(waiting for move to purge)" ;
                    Do {write-host "." -NoNewLine;Start-Sleep -m (1000 * 10)} Until (!(ps1GetXMovReq -Identity $mvsplat.identity -ea 0))
                } ;

                $smsg= "===$($ombx.UserPrincipalName):$((get-alias ps1NewXMovReq).definition) w`n$(($mvSplat|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                $Exit = 0 ;
                Do {
                    Try {
                        ps1NewXMovReq @MvSplat;
                        $Exit = $Retries ;
                    } Catch {
                        $smsg = "Failed to exec cmd because: $($Error[0])" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Start-Sleep -Seconds $RetrySleep ;
                        if ($script:useEXOv2) { reconnect-eXO2 @pltRXOC }
                        else { reconnect-EXO @pltRXOC } ;
                        $Exit ++ ;
                        $smsg = "Try #: $Exit" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" }
                        If ($Exit -eq $Retries) {
                            $smsg = "Unable to exec cmd!"
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ;
                    }  ;
                } Until ($Exit -eq $Retries) ;

            } else {
                $smsg= "===$($ombx.userprinciplname) missing $((Get-Variable  -name "$($TenOrg)Meta").value.o365_TenantDom) address at EXO END.`nSKIPPING EXO MOVE!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                else{ write-host -foregroundcolor RED "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
        } else {
                $smsg= "===$($tMbxId):NOT FOUND, SKIPPING!:" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug
                else{ write-host -foregroundcolor RED "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        };

        $smsg= "$($sBnr.replace('=v','=^').replace('v=','^='))" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        # add an EXO delay to avoid issues
        Start-Sleep -Milliseconds $ThrottleMs ;
    } ;  # loop-E

    if(!$whatif){
        $smsg= "CLOUD MIGRATION STATUS:`n$((ps1GetXMovReq -BatchName $BatchName | ps1GetXMovReqStats | FL DisplayName,status,percentcomplete,itemstransferred,BadItemsEncountered|out-string).trim())`n" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $smsg= "`nContinue monitoring with:`n$((get-alias ps1GetXMovReq).definition) -BatchName $($BatchName) | $((get-alias ps1GetXMovReqStats).definition) | fl DisplayName,status,percentcomplete,itemstransferred,BadItemsEncountered`n" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    } ;

    if((get-AdServerSettings).ViewEntireForest){ disable-ForestView } ;
    

    # return the passstatus to the pipeline
    $script:PassStatus | write-output

    if((get-AdServerSettings).ViewEntireForest){ disable-ForestView } ;

    if($host.Name -eq "Windows PowerShell ISE Host" -and $host.version.major -lt 5){
        # 11:51 AM 9/22/2020 isev5 supports transcript, anything prior has to fake it
        # 8:46 AM 3/11/2015 shift the logfilename gen out here, so that we can arch it
        #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -uformat "%Y%m%d-%H%M" ) + "-ISEtrans.log")) ;
        # 2:16 PM 4/27/2015 shift to static timestamp $timeStampNow
        #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + $timeStampNow + "-ISEtrans.log")) ;
        # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
        #$Logname=(join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -format 'yyyyMMdd-HHmmtt') + "-ISEtrans.log")) ;
        # maintain-ExoUsrMbxFreeBusyDetails-TOR-ForceAll-Transcript-BATCH-EXEC-20200921-1539PM-trans-log.txt
        $Logname=$transcript.replace('-trans-log.txt','-ISEtrans-log.txt') ;
        write-host "`$Logname: $Logname";
        Start-iseTranscript -logname $Logname  -Verbose:($VerbosePreference -eq 'Continue') ;
        #Archive-Log $Logname ;
        # 1:23 PM 4/23/2015 standardize processing file so that we can send a link to open the transcript for review
        $transcript = $Logname ;
        if($host.version.Major -ge 5){ stop-transcript  -Verbose:($VerbosePreference -eq 'Continue')} # ISE in psV5 actually supports transcription. If you don't stop it, it just keeps rolling
    } else {
        write-verbose "$((get-date).ToString('HH:mm:ss')):Stop Transcript" ;
        Stop-TranscriptLog -Transcript $transcript -verbose:$($VerbosePreference -eq "Continue") ;
    } # if-E
    
    # prod is still showing a running unstopped transcript, kill it again
    $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
    
    # also trailing echo the log:
    $smsg = "`$logging:`$true:written to:`n$($logfile)" ; 
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    $smsg = "$((get-date).ToString('HH:mm:ss')):$($sBnr.replace('=v','=^').replace('v=','^='))" ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    #*------^ END SUB MAIN ^------
}

#*------^ move-MailboxToXo.ps1 ^------


#*------v new-DgTor.ps1 v------
function new-DgTor {
    <#
    .SYNOPSIS
    new-DgTor.ps1 - Create new DistributionGroup and populate. Notates requestor, ticket# and admin, in Notes field of DL
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-08-30
    FileName    : new-DgTor.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,DistributionGroup,DistributionList,Hybrid
    REVISIONS
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 2:40 PM 12/10/2021 more cleanup 
    * 4:54 PM 9/30/2021 updated CloudFirst code, and used to create functional 
    exoDG, also added code to dynamically create onprem unreplicated MailContacts 
    for CloudFirst, to represent an onprem AddrBook object ; flipped members & 
    ManagedBy to [string[]]; added UG->DG conversion example,
    with splat; swapped undependable $scriptbasename w $cmdletname (tends to show
    module as name); updated cloudfirst variant code, switched recipient &
    managedby's to raw smtpaddresses ; finally validated hybrid OnPrem DG creation as well. 
    * 4:28 PM 9/14/2021 ren: new-DL-Tor -> new-DgTor ;; debugged -CloudFirst - working as intended ; fixed pipeline bug coming out of Start-IseTranscript , properly returns newdg object to pipeline;  converted to function, add to verb-exo (once it includes proper hybrid, most approp place); -CloudFirst still undebugged
    *2:56 PM 9/13/2021 rewrote for modern modules & template, -outputObject default. Tested ExOP version, haven't done -CloudFirst debugging yet.
    # 11:05 AM 6/13/2019 updated get-admininitials()
    # 8:24 AM 2/13/2018 support empty groups (for infra EXO rule grps, to be stocked later) - looks like it was there, members are only added where specified (foreach). Adding explicit echo's to reflect the status. 
    # 2:54 PM 2/8/2018 updated to support EXO-hosted mailuser owners (members already worked without modification)
    #12:50 PM 11/27/2017 sec wants them defaulted RequireSenderAuthenticationEnabled to $true ; 
    # 1:41 PM 6/13/2017 spliced in latest 3/16/16 get-gcfast()
    # 10:35 AM 4/4/2017 added new -InetReceive:$true param, to configure RequireSenderAuthenticationEnabled=$false
    # 10:32 AM 4/4/2017 had to splice in latest loadmod set - failed if not already in EMS session
    # 12:23 PM 4/3/2017 add default RequireSenderAuthenticationEnabled  $false (allow inet mailing by default)
    # 9:50 AM 3/3/2017 Get-AdminInitials: with the new standard of Fname/name: S-[name] this needs an update to strip prefix S-
    # 9:48 AM 3/2/2017 merged in updated Add-EMSRemote Set
    # 12:44 PM 10/18/2016 update rgx for ticket to accommodate 5-digit (or 6) CW numbers "^\d{6}$"=>^\d{5,6}$
    #* 9:11 AM 9/30/2016 added pretest if(get-command -name set-AdServerSettings -ea 0)
    # 1:55 PM 6/6/2016 debugged, works. 
    # 1:52 PM 6/6/2016 cleanedup typo trailing spaces on some of the dummy hash buils
    # 12:12 PM 6/6/2016 added Execute-WithRetry(), implementing retries via function. - neither worked, just do 
    # 10:50 AM 6/6/2016 : 
        add retry support below params
        * add region tags
        * updated to enable-mbx LoadMod block
        * Move splats below constants - constants should always be in place 1st
    # 1:12 PM 2/11/2016 fixed new bug in get-GCFast, wasn't detecting blank $site
    # 12:20 PM 2/11/2016 updated to standard EMS/AD Call block & Add-EMSRemote()
    #10:49 AM 2/11/2016: updated get-GCFast to current spec, updated any calls for "-site 'lyndale'" to just default to local machine lookup
    # 7:40 AM Add-EMSRemote: 2/5/2016 another damn cls REM IT! I want to see all the connectivity info, switched wh->wv, added explicit echo's of what it's doing.
    # 11:08 AM 1/15/2016 re-updated Add-EMSRemote, using a -eq v -like with a wildcard string. Have to repush copies all over now.
    # 10:43 AM 1/13/2016 updated Add-EMSRemote set
    # 10:02 AM 1/13/2016: fixed cls bug due to spurious ";cls" included in the try/catch boilerplate: Write-Error "$((get-date).ToString('HH:mm:ss')): Command: $($_.InvocationInfo.MyCommand)" ;cls => Write-Error "$((get-date).ToString('HH:mm:ss')): Command: $($_.InvocationInfo.MyCommand)" ;
    # 9:58 AM 10/21/2015 ren $InputSplat.Site => $InputSplat.SiteCode, to sync up name standard across scripts
    # 9:08 AM 10/14/2015 added debugpref maint code to get write-debug to work
    # 11:55 AM 10/7/2015 sorted now; wasn't using -SiteOverRide in the fancy csv-fed param I was using
    #1:56 PM 10/6/2015 fix $SiteOverride, to actually override the ManagedBy's OU (BEA user was forcing to BEA vs override of LYN)
    # 1:09 PM 10/6/2015 updated code to spec - seems to work
    # 10:57 AM 10/6/2015 blanked the @InputSplat{} values
    # 10:43 AM 10/6/2015 ren paras to standard (tix->Ticket)
    # 2:34 PM 10/2/2015 fix break and port in EMSremote etc
    8:53 AM 9/4/2015 sub'd in cleanedup EMSRemote Set
    8:35 AM 9/4/2015 seems to work, from EMSRemote
    2:36 PM 9/3/2015 added -identity $dg.samaccountname to Get-DistributionGroupMember
    2:17 PM 9/3/2015 added -ea 0 to Get-DistributionGroupMember cmds (were erroring if no members)
    1:36 PM 9/3/2015 did alot of tshooing on add-emsr, to get it functional all seems to run right now
    1:12 PM 8/26/2015 removed partial GUI code and validated functions properly.
    1:15 PM 6/24/2015 added whatif test to New-DistributionGroup @DLSplat -ea Stop ;
    1:04 PM 6/24/2015 tests out functional on params as well. Looks pretty good
    12:46 PM 6/24/2015 functional, need to test params
    9:21 AM 6/24/2015 combo/hybrid old ]PSNewDL! with add-MbxAccessGrant.ps1
    1:55 PM 6/15/2015 initial version
    .DESCRIPTION
    new-DgTor.ps1 - Create new DistributionGroup and populate. Notates requestor, ticket# and admin, in Notes field of DL
    Derives DG settings from ManagedBy specified: 
    - Constructs Name using SiteCode (root child OU at 1st level of MangedBy DN): [SITECODE]-DL-[$DNameBase]
    - Find's standard DG OU within the same Site OU tree
    .PARAMETER TenOrg
    TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER Ticket
    ITSM Request/Incident Number [nnnnnn]
    .PARAMETER DNameBase
    Base Name string, for DL Name construction. [SIT-DL] will be automatically appended[Base Name String]
    .PARAMETER ManagedBy
    Specify the userid to be responsible for access-grant-approvals[name,emailaddr,alias]
    .PARAMETER HiddenFromAddressLists
    Switch to configure -HiddenFromAddressListsEnabled `$true [-HiddenFromAddressLists]
    .PARAMETER CloudFirst
    Switch to specify EXO Cloud-First DG (vs Federated replicated AD/EXOnPrem DG) [-CloudFirst]
    .PARAMETER SiteOverride
    Specify a 3-letter Site Code. Used to force DL name/placement to vary from ManagedBy's current site[3-letter Site code]
    .PARAMETER Members
    Comma-delimited string of potential users to be granted access[name,emailaddr,alias]
    .PARAMETER InetReceive
    Can receive from external senders [-InetReceive:`$true]
    .PARAMETER HiddenFromAddressLists
    Switch to configure -HiddenFromAddressListsEnabled `$true [-HiddenFromAddressLists]
    .PARAMETER OutObject
    Switch to specify to return the new DG as an object (defaults true)[-OutObject]
    .PARAMETER Whatif
    Parameter to run a Test no-change pass, and log results [-Whatif switch]
    .PARAMETER ShowDebug
    Parameter to display Debugging messages (diverts reports to alt address) [-ShowDebug switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    SystemObject
    [| get-member the output to see what .NET obj TypeName is returned, to use here]
    .EXAMPLE
    PS> new-DgTor -SiteOverride ENT -DNameBase "DL Base DisplayName" -ManagedBy MANAGERID -Members 'MEMBER1@DOMAIN.com','MEMBER2@DOMAIN.com' -HiddenFromAddressLists -showDebug -verbose -Ticket 99999 -whatif;
    Create a DL with a siteoverride (spec'ing as ENT-name, rather than alt site)
    .EXAMPLE
    PS> $ndg = new-DgTor -TenOrg TOR -DNameBase "DL BASE DISPLAYNAME" -ManagedBy MANAGERID -Members 'MEMBER1@DOMAIN.com','MEMBER2@DOMAIN.com' -HiddenFromAddressLists -showDebug -verbose -Ticket 99999 -outobject;
    Create a DG with SiteOverride and return resulting new DG as an object, assigned to $ndg
    .EXAMPLE
    $whatif=$true ; 
    reconnect-exo ; 
    TRY{
        $tugn = 'TeamsUGNamwe_GUID' ;
        $tug = Get-exoUnifiedGroup -Identity $tugn ;
        $tugmbrs = Get-exoUnifiedGroupLinks -Id $tug.name -LinkType Members ;
        $pltNDg=[ordered]@{   TenOrg='TOR' ;
            CloudFirst=$true ;
            DNameBase="IS-$($tug.displayname)" ;
            ManagedBy=($tug.managedby | get-exorecipient -ea STOP | select -expand primarysmtpaddress) ;
            Members=($tugmbrs.primarysmtpaddress| get-exorecipient -ea STOP | select -expand primarysmtpaddress) ;
            HiddenFromAddressLists=$false;
            showDebug=$true;
            verbose=$true;
            Ticket='99999' ;
            outobject=$true;
            whatif=$($whatif);
          } ;
         write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):new-DgTor w`n$(($pltNDg|out-string).trim())" ;
         $ndg = new-DgTor @pltNDg;
         $ndg ;
    } CATCH {
    Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
    break ;
    } ;
    # Traditionally the UG would then be set Hidden from Address Books, in deference to the DG
    Set-exoUnifiedGroup -Id $tug.name -HiddenFromAddressListsEnabled $true
    
    Demo conversion of a Teams Unified Group membership (which permits unsubscribes, and silent loss of mail) into a standard DG. 
    .EXAMPLE
    $whatif=$true ;
    reconnect-exo ;
    reconnect-ex2010 ;
    TRY{
        $tugn = 'TeamsUGNamwe_GUID' ;
        $tug = Get-exoUnifiedGroup -Identity $tugn ;
        $tugmbrs = Get-exoUnifiedGroupLinks -Id $tug.name -LinkType Members ;
        $pltNDg=[ordered]@{   TenOrg='TOR' ;
          CloudFirst=$false ;
          SiteOverride = 'ENT' ;
          DNameBase="IS-$($tug.displayname)" ;
          ManagedBy=($tug.managedby | get-exorecipient -ea continue | select -expand primarysmtpaddress | select -unique | get-recipient -ea continue | select -expand primarysmtpaddress | select -unique) ;
          Members=($tugmbrs.primarysmtpaddress| get-recipient -ea continue | select -expand primarysmtpaddress) ;
          HiddenFromAddressLists=$false;
          showDebug=$true;
          verbose=$true;
          Ticket='99999' ;
          outobject=$true;
          whatif=$($whatif);
         } ;
        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):new-DgTor w`n$(($pltNDg|out-string).trim())" ;
        $ndg = new-DgTor @pltNDg;
        $ndg ;
    } CATCH {
        Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
        break ;
    } ;
    # Traditionally the UG would then be set Hidden from Address Books, in deference to the DG
    Set-exoUnifiedGroup -Id $tug.name -HiddenFromAddressListsEnabled $true
    
    Demo conversion of a Teams Unified Group membership (which permits unsubscribes, and silent loss of mail) into a standard on-prem hybrid replicated DG, 
    with the prefix/SiteCode overridden to use 'ENT' over the ManagedBy's home SiteCode. 
    
    Note:An onprem DG can have MailContacts in the membership (and in the ManagedBy as well), with the same primarysmtpaddress as remote-hybrid cloud mailboxes. 
    (e.g. EXO mailboxes that aren't Hybrid/AD'd locally to the DG-hosting OnPrem mail org)
    Upon ADC replication of a MailContact member (or ManagedBy) to AzureAD, any MailContact set in either property, will be auto-replaced during replication, 
    with the matching EXO mailbox object. A neat way of maintaining hybrid onPrem-deliverable DG's, containing non-locally-replicated EXO mailboxes.
    .LINK
    https://github.com/tostka/verb-exo        
    #>
    ###Requires -Modules ActiveDirectory, AzureAD, MSOnline, ExchangeOnlineManagement, verb-ADMS, verb-Auth, verb-Ex2010, verb-EXO, verb-IO, verb-logging, verb-Text, verb-logging
    ##Requires -Modules ActiveDirectory, AzureAD, MSOnline, ExchangeOnlineManagement, verb-ADMS, verb-Auth, verb-Ex2010, verb-IO, verb-logging, verb-Text, verb-logging
    # 2:49 PM 3/8/2022 pull verb-ex2010 ref - I think it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    #Requires -Modules ActiveDirectory, AzureAD, MSOnline, ExchangeOnlineManagement, verb-ADMS, verb-Auth, verb-IO, verb-logging, verb-Text, verb-logging
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("(lyn|bcc|spb|adl)ms6(4|5)(0|1).(china|global)\.ad\.DOMAIN\.com")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    PARAM(
        [Parameter(HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
        [ValidateNotNullOrEmpty()]
        $TenOrg = 'TOR',
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2,
        [Parameter(Mandatory=$true,HelpMessage="Base Name string, for DL Name construction. [SIT-DL] will be automatically appended[Base Name String]")]
        [string]$DNameBase,
        [Parameter(Position=0,HelpMessage="ITSM Request/Incident Number [nnnnnn]")]
        #[ValidatePattern("^\d{5,6}$")]
        [string]$Ticket,
        [Parameter(Mandatory=$true,HelpMessage="Specify the userid to be responsible for access-grant-approvals[name,emailaddr,alias]")]
        [string[]]$ManagedBy,
        [Parameter(HelpMessage="Specify a 3-letter Site Code. Used to force DL name/placement to vary from ManageBy's current site[3-letter Site code]")]
        [string]$SiteOverride,
        [Parameter(HelpMessage="Comma-delimited string of potential users to be granted access[name,emailaddr,alias]")]
        [string[]]$Members,
        [Parameter(HelpMessage="Can receive from external senders [-InetReceive:`$true]")]
        [switch]$InetReceive,
        [Parameter(HelpMessage="Switch to configure -HiddenFromAddressListsEnabled `$true [-HiddenFromAddressLists]")]
        [switch]$HiddenFromAddressLists,
        [Parameter(HelpMessage="Switch to specify EXO Cloud-First DG (vs Federated replicated AD/EXOnPrem DG) [-CloudFirst]")]
        [switch]$CloudFirst,
        [Parameter(HelpMessage="Switch to specify to return the new DG as an object (defaults true)[-OutObject]")]
        [switch]$OutObject=$true,
        [Parameter(HelpMessage='Parameter to display Debugging messages (also diverts reports to alt address) [-ShowDebug switch]')]
        [switch] $showDebug=$false,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
        [switch]$whatIf=$false
    ) ;
    
    ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;         
    $verbose = ($VerbosePreference -eq "Continue") ;

    $progInterval= 500 ; # write-progress wait interval in ms
    # 1:05 PM 4/28/2017 retries
    $DoRetries = 4 ;
    $RetrySleep = 5 ;

    # 10:22 AM 2/24/2016 add an explicit vari $MaxProcessingUserLimit for max-processing users, and bump it > 4000 (causing processing aborts as of 2/17/16)
    $MaxProcessingUserLimit = 10000 ;
    # 2:20 PM 3/25/2015 added optional report inline-in email body
    $bodyAsHtml=$true ;

    # 12:15 PM 2/9/2015 add an SMTP retry limit (per user attempted)
    # 7:20 AM 5/7/2015 leveraging the varis for LineURI non-unique recoveries
    [int]$retryLimit=1; # just one retry to patch lineuri duped users and retry 1x
    [int]$retryDelay=20;    # secs wait time after failure

    # 1:57 PM 2/18/2015
    $abortPassLimit = 4;    # maximum failed users to abort entire pass
    # 9:49 AM 2/17/2015 SMTP Priority level[Normal|High|Low]
    $smtpPriority="Normal";
    # SMTP port (default is 25)
    $smtpPort = 25 ;

   
    
    if ($psISE){
            $ScriptDir = Split-Path -Path $psISE.CurrentFile.FullPath ;
            $ScriptBaseName = split-path -leaf $psise.currentfile.fullpath ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($psise.currentfile.fullpath) ;
                    $PSScriptRoot = $ScriptDir ;
            if($PSScriptRoot -ne $ScriptDir){ write-warning "UNABLE TO UPDATE BLANK `$PSScriptRoot TO CURRENT `$ScriptDir!"} ;
            $PSCommandPath = $psise.currentfile.fullpath ;
            if($PSCommandPath -ne $psise.currentfile.fullpath){ write-warning "UNABLE TO UPDATE BLANK `$PSCommandPath TO CURRENT `$psise.currentfile.fullpath!"} ;
    } else {
        if($host.version.major -lt 3){
            $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
            $PSCommandPath = $myInvocation.ScriptName ;
            $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
        } elseif($PSScriptRoot) {
            $ScriptDir = $PSScriptRoot ;
            if($PSCommandPath){
                $ScriptBaseName = split-path -leaf $PSCommandPath ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($PSCommandPath) ;
            } else {
                $PSCommandPath = $myInvocation.ScriptName ;
                $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
            } ;
        } else {
            if($MyInvocation.MyCommand.Path) {
                $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
            } else {
                throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" ;
            } ;
        } ;
    } ;
    if($showDebug){
        write-host -foregroundcolor green "`SHOWDEBUG: `$ScriptDir:$($ScriptDir)`n`$ScriptBaseName:$($ScriptBaseName)`n`$ScriptNameNoExt:$($ScriptNameNoExt)`n`$PSScriptRoot:$($PSScriptRoot)`n`$PSCommandPath:$($PSCommandPath)" ;
    } ;
    
    
    #*================v FUNCTIONS  v================

    #-------v Function _cleanup v-------
    function _cleanup {
        <#
        .SYNOPSIS
        _cleanup.ps1 - clear all objects, prep close transcript, email report and exit
        .NOTES
        Version     : 1.0.0
        Author      : Todd Kadrie
        Website     :	http://www.toddomation.com
        Twitter     :	@tostka / http://twitter.com/tostka
        CreatedDate : 2020-
        FileName    :
        License     : MIT License
        Copyright   : (c) 2020 Todd Kadrie
        Github      : https://github.com/tostka/verb-XXX
        Tags        : Powershell
        AddedCredit : REFERENCE
        AddedWebsite:	URL
        AddedTwitter:	URL
        REVISIONS
        # 8:47 AM 11/24/2020 cloned over intact from maintain-exousrmbxretentionpolicies
        # 3:15 PM 10/13/2020 added CBH, added params: summarizeStatus,
            NoTranscriptStop, TranscriptItemsLimit, each exempts certain blocks of process
            - trying to genericize for reuse on other scripts ; added html body support
            (using <pre../pre> to preserve text layout, even in outlook display
        # 12:40 PM 10/23/2018 added write-log trainling bnr
        # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
        # 8:45 AM 10/13/2015 reset $DebugPreference to default SilentlyContinue, if on
        # # 8:46 AM 3/11/2015 at some time from then to 1:06 PM 3/26/2015 added ISE Transcript
        # 8:39 AM 12/10/2014 shifted to stop-transcriptLog function
        # 7:43 AM 1/24/2014 always stop the running transcript before exiting
        .DESCRIPTION
        _cleanup.ps1 - clear all objects, prep close transcript, email report and exit
        .PARAMETER  LogPath
        Alt transcript/logfile path for mailing (rather than `$transcript/`$logfile)[-LogPath c:\path-to\log.txt]
        .PARAMETER TranscriptItemsLimit
        Number of transactions to determine Transcript inclusion[-TranscriptItemsLimit]
        .PARAMETER summarizeStatus
        Switch to output a summary of the `$script:PassStatus delimted string[-summarizeStatus]
        .PARAMETER NoTranscriptStop
        Switch to skip transcript stop & exit [-NoTranscriptStop]
        .PARAMETER ShowDebug
        Parameter to display Debugging messages [-ShowDebug switch]
        .PARAMETER Whatif
        Parameter to run a Test no-change pass [-Whatif switch]
        .EXAMPLE
        _cleanup
        Default Call
        .EXAMPLE
        $plt_cleanup=@{LogPath=$tmpcopy summarizeStatus=$true ;  NoTranscriptStop=$true ; showDebug=$($showDebug) ;  whatif=$($whatif) ; } ;
        _cleanup @pltCleanup ;
        Splatted parameter'd call
        #>
        [CmdletBinding()]
        PARAM(
            [Parameter(HelpMessage="Alt transcript/logfile path for mailing (rather than `$transcript/`$logfile)[-LogPath c:\path-to\log.txt]")]
            [ValidateScript({Test-Path $_})]
            $LogPath,
            [Parameter(HelpMessage="Number of transactions to determine Transcript inclusion[-TranscriptItemsLimit]")]
            [int] $TranscriptItemsLimit = 10,
            [Parameter(HelpMessage="Switch to output a summary of the `$script:PassStatus delimted string[-summarizeStatus]")]
            [switch] $summarizeStatus,
            [Parameter(HelpMessage="Switch to skip transcript stop & exit [-NoTranscriptStop]")]
            [switch] $NoTranscriptStop,
            [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
            [switch] $showDebug,
            [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
            [switch] $whatIf
        ) ;

        # clear all objects, prep close transcript, email report and exit
        # REVISIONS

        $smsg = "_cleanup" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        if(!$NoTranscriptStop){
            # handle transcript closure in the main script (Tenant loop)
            stop-transcript
            if(($host.Name -eq "Windows PowerShell ISE Host") -AND ($host.version.Major -lt 5)){
                $Logname=(join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -format 'yyyyMMdd-HHmmtt') + "-ISEtrans.log")) ;
                $smsg = "`$Logname: $($Logname)";
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $xRet = Start-iseTranscript -logname $Logname -Verbose:($VerbosePreference -eq 'Continue') ;
                #Archive-Log $Logname -Verbose:($VerbosePreference -eq 'Continue');
                # 1:23 PM 4/23/2015 standardize processing file so that we can send a link to open the transcript for review
                $transcript = $Logname
            } else {
                $smsg = "Stop Transcript" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $xRet = Stop-TranscriptLog -Verbose:($VerbosePreference -eq 'Continue') ;
                #if($showdebug){ $smsg = "Archive Transcript" };
                #Archive-Log $transcript -Verbose:($VerbosePreference -eq 'Continue') ;
            } # if-E
        } else {
            $smsg = "(_cleanup(): deferring transcript stop to main script)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ; # !$NoTranscriptStop

        # variant options:
        #$smtpSubj= "Proc Rpt:$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"   ;
        #Load as an attachment into the body text:
        #$body = (Get-Content "path-to-file\file.html" ) | converto-html ;
        #$SmtpBody += ("Pass Completed "+ [System.DateTime]::Now + "`nResults Attached: " +$transcript) ;
        # 4:07 PM 10/11/2018 giant transcript, no send
        #$SmtpBody += "Pass Completed $([System.DateTime]::Now)`nResults Attached:($transcript)" ;
        #$SmtpBody += "Pass Completed $([System.DateTime]::Now)`nTranscript:($transcript)" ;

        # group out the PassStatus_$($tenorg) strings into a report for eml body
        if($script:PassStatus){
            if($summarizeStatus){
                if($script:TargetTenants){
                    # loop the TargetTenants/TenOrgs and summarize each processed
                    foreach($TenOrg in $TargetTenants){
                        $SmtpBody += "`n===Processing Summary: $($TenOrg):" ;
                        # can't split an empty string
                        if((get-Variable -Name PassStatus_$($tenorg)).value){
                            if((get-Variable -Name PassStatus_$($tenorg)).value.split(';') |?{$_ -ne ''}){
                                $SmtpBody += (summarize-PassStatus -PassStatus (get-Variable -Name PassStatus_$($tenorg)).value -verbose:$($VerbosePreference -eq 'Continue') );
                            } ;
                        } else {
                            $SmtpBody += "(no processing of mailboxes in $($TenOrg), this pass)" ;
                        } ;
                        $SmtpBody += "`n" ;

                    } ;
                } ;
            } else {
                # dump PassStatus right into the email
                $SmtpBody += "`n`$script:PassStatus: $($script:PassStatus):" ;
            } ;
            if($SmtpAttachment){
                $smtpBody +="(Logs Attached)"
            };
            $SmtpBody += "`n$('-'*50)" ;
            # include transcript in body, where fewer than limit of processed items logged in PassStatus
            # no, there're 3 transcripts, stored in $Alltranscripts, but skip it#
    #        if( ($script:PassStatus.split(';') |?{$_ -ne ''}|measure).count -lt $TranscriptItemsLimit){
    #            # add full transcript if less than 10 entries processed
    #            $SmtpBody += "`nTranscript:$(gc $transcript)`n" ;
    #        } else {
                if(!$ArchPath ){ $ArchPath = get-ArchivePath } ;
                if($Alltranscripts){
                    $Alltranscripts |%{
                        #$archedTrans = join-path -path $ArchPath -childpath (split-path $transcript -leaf) ;
                        $archedTrans = join-path -path $ArchPath -childpath (split-path $_ -leaf) ;
                        $smtpBody += "`nTranscript accessible at:`n$($archedTrans)`n" ;
                    } ;
                } ;
            #};
        }
        $SmtpBody += "Pass Completed $([System.DateTime]::Now)" ;

        # body rendered in OL loses all wordrwraps
        # force strip out the html
        #$smtpBody = [regex]::Replace($smtpBody, "\<[^\>]*\>", '') ;
        # or do min html format

        $styleCSS = "<style>BODY{font-family: Arial; font-size: 10pt;}" ;
        $styleCSS += "TABLE{border: 1px solid black; border-collapse: collapse;}" ;
        $styleCSS += "TH{border: 1px solid black; background: #dddddd; padding: 5px; }" ;
        $styleCSS += "TD{border: 1px solid black; padding: 5px; }" ;
        $styleCSS += "</style>" ;

    <# simple no css
    $html = @"
<html>
<head><title>$title</title></head>
<body>
<pre>$smtpBody</pre>
</body>
</html>
"@ ;
#>
    # one with style support (goees in the <head../head> block)
    $html = @"
<html>
<head>
$($styleCSS)
<title>$title</title></head>
<body>
<pre>
$($smtpBody)
</pre>
</body>
</html>
"@ ;

        # convertto-html doesn't do raw txt, just objects
        #$smtpBody = $smtpBody | ConvertTo-Html -Head $styleCSS ;
        # use the bp html <pre../pre> version
        $smtpBody = $html ;

        # name $attachment for the actual $SmtpAttachment expected by Send-EmailNotif
        #$SmtpAttachment=$transcript ;
        # test for ERROR|CHANGE - actually non-blank, only gets appended to with one or the other
        # to test for one, (but not a regex)
        <# # always force
        #if($script:passstatus.split(';') -contains 'ERROR'){
        # or run on change/error/passstatus flag
        if([string]::IsNullOrEmpty($script:PassStatus)){
            $smsg = "No Email Report: `$script:PassStatus isNullOrEmpty" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } else {
        #>
            $Email = @{
                smtpFrom = $SMTPFrom ;
                SMTPTo = $SMTPTo ;
                SMTPSubj = $SMTPSubj ;
                #SMTPServer = $SMTPServer ;
                SmtpBody = $SmtpBody ;
                SmtpAttachment = $SmtpAttachment ;
                BodyAsHtml = $false ; # let the htmltag rgx in Send-EmailNotif flip on as needed
                verbose = $($VerbosePreference -eq "Continue") ;
            } ;
            <# DISABLED add trailing notifc
            $smsg = "Send-EmailNotif w`n$(($Email|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # 9:02 AM 9/2/2021 don't neeed email on these
            Send-EmailNotif @Email ;
            #>
        #} ;

        if(!$NoTranscriptStop){
            #EXIT # trailing tempfile _cleanup in the sub main
            #Break ; 
        } ;

    } #*------^ END Function _cleanup ^------

    #*================^ END FUNCTIONS  ^================

    #*======v SUB MAIN  v======
    
    $sBnr="`n#*======v $(${CmdletName}) : v======" ; 
    $smsg = $sBnr ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    $Verbose = ($VerbosePreference -eq 'Continue') ; 

    # *** REGION MARKER LOAD
    #region LOAD
    # *** LOADING


    # 1:00 PM 4/28/2017 email trigger vari
    $PassStatus = $null ;

    # 1:01 PM 4/28/2017 add try catch as well - this may be making it zero-tolerance and catching all minor errors, disable it
    #Set-StrictMode -Version 2.0 ;

    #region SERVICE-CONNECTIONS #*======v SERVICE-CONNECTIONS v======
    #region useEXO ; #*------v useEXO v------
    $useEXO = $false ; # non-dyn setting, drives variant EXO reconnect & query code
    if($CloudFirst){ $useEXO = $true } ; 
    if($useEXO){
        #*------v GENERIC EXO CREDS & SVC CONN BP v------
        # o365/EXO creds
        <### Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile* 
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
        Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
        .EXAMPLE
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
        Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
        .EXAMPLE
        $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
        Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
        ###>
        $o365Cred=$null ;
        if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -UserRole 'CSVC','SID' -verbose:$($verbose))){
            # make it script scope, so we don't have to predetect & purge before using new-variable
            if(get-Variable -Name cred$($tenorg) -scope Script -ea 0 ){ remove-Variable -Name cred$($tenorg) -scope Script } ;
            New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
            $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } else {
            $statusdelta = ";ERROR";
            $script:PassStatus += $statusdelta ;
            set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
            $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
            Break ;
        } ;
        <### CALLS ARE IN FORM: (cred$($tenorg))
        $pltRXO = @{Credential = $Credential ; verbose = $($verbose) ; }
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            #verbose = $($verbose) ; 
            Verbose = $FALSE ; Silent = $true ;} ; 
        if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
        else { reconnect-EXO @pltRXO } ;
        # or with Tenant-specific cred($Tenorg) lookup
        #$pltRXO creds & .username can also be used for AzureAD connections 
        Connect-AAD @pltRXO ; 
        ###>
        # configure splat for connections: (see above useage)
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            #verbose = $($verbose) ; 
            Verbose = $FALSE ; Silent = $true ;} ; 
        #*------^ END GENERIC EXO CREDS & SVC CONN BP ^------
    } # if-E $useEXO
    #endregion useEXO ; #*------^ END useEXO ^------
    
    #region UseExOP #*------v UseExOP v------ 
    # steer all onprem code on $XXXMeta.ExOPAccessFromToro & Ex10Server values
    $UseExOP=$false ; 
    if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
        $UseExOP = $true ; 
        $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ; 
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
    } else { 
        $UseExOP = $false ; 
        $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ; 
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
    } ; 
    if($UseExOP){
        #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
        # do the OP creds too
        $OPCred=$null ;
        # default to the onprem svc acct
        $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC','SID'; verbose=$($verbose)} ;
        if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
            # make it script scope, so we don't have to predetect & purge before using new-variable
            if(get-Variable -Name "cred$($tenorg)OP" -scope Script -ea 0 ){ remove-Variable -Name "cred$($tenorg)OP" -scope Script } ;
            New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
            $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } else {
            $statusdelta = ";ERROR";
            $script:PassStatus += $statusdelta ;
            set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
            $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
            Break ;
        } ;
        $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;  
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        <# CALLS ARE IN FORM: (cred$($tenorg))
            $pltRX10 = @{
            Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
            #verbose = $($verbose) ; 
            Verbose = $FALSE ; Silent = $true ; } ;  
        Reconnect-Ex2010 @pltRX10 ; # local org conns
        #$pltRx10 creds & .username can also be used for local ADMS connections
        #>
        $pltRX10 = @{
            Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
            #verbose = $($verbose) ; 
            Verbose = $FALSE ; Silent = $true ; } ;     
        
        # defer cx10/rx10, until just before get-recipients qry
        #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
        # connect to ExOP X10
        if($pltRX10){
            #ReConnect-Ex2010XO @pltRX10 ;
            ReConnect-Ex2010 @pltRX10 ;
        } else { Reconnect-Ex2010 ; } ; 
    } ;  # if-E $useEXOP

    
    #region UseOPAD #*------v UseOPAD v------
    if($UseExOP){
        write-host -foregroundcolor gray  "(loading ADMS...)" ;
        load-ADMS -Verbose:$FALSE ;
        # resolve $domaincontroller dynamic, cross-org
        # setup ADMS PSDrives per tenant 
        if(!$global:ADPsDriveNames){
            $smsg = "(connecting X-Org AD PSDrives)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $global:ADPsDriveNames = mount-ADForestDrives -verbose:$($verbose) ;
        } ; 
        if(($global:ADPsDriveNames|measure).count){
            $useEXOforGroups = $false ; 
            $smsg = "Confirming ADMS PSDrives:`n$(($global:ADPsDriveNames.Name|%{get-psdrive -Name $_ -PSProvider ActiveDirectory} | ft -auto Name,Root,Provider|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # returned object
            #         $ADPsDriveNames
            #         UserName                Status Name        
            #         --------                ------ ----        
            #         DOM\Samacctname   True  [forestname wo punc] 
            #         DOM\Samacctname   True  [forestname wo punc]
            #         DOM\Samacctname   True  [forestname wo punc]
        
        } else { 
            #-=-record a STATUS=-=-=-=-=-=-=
            $statusdelta = ";ERROR";
            $script:PassStatus += $statusdelta ;
            set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
            #-=-=-=-=-=-=-=-=
            $smsg = "Unable to detect POPULATED `$global:ADPsDriveNames!`n(should have multiple values, resolved to $()"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
            Break ;
        } ; 
    } ; 
    #if (!$domaincontroller) { $domaincontroller = get-gcfast } ;
    #if(!$domaincontroller){ if(test-path function:get-gcfast){$domaincontroller=get-gcfast} else { throw "no get-gcfast()!" } ;} else {"(existing `$domaincontroller:$($domaincontroller))"} ;
    # use new get-GCFastXO cross-org dc finde
    # default to Op_ExADRoot forest from $TenOrg Meta
    if($UseExOP){
        $domaincontroller = get-GCFastXO -TenOrg $TenOrg -subdomain ((gv -name "$($TenOrg)Meta").value['OP_ExADRoot']) -verbose:$($verbose) |?{$_.length};
    } ; 
    #endregion UseOPAD #*------^ END UseOPAD ^------

    <# MSOL CONNECTION
    $reqMods += "connect-msol".split(";") ;
    if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
    write-host -foregroundcolor gray  "(loading AAD...)" ;
    #connect-msol ;
    connect-msol @pltRXO ; 
    #>

    <#
    # AZUREAD CONNECTION
    $reqMods += "Connect-AAD".split(";") ;
    if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
    write-host -foregroundcolor gray  "(loading AAD...)" ;
    #connect-msol ;
    Connect-AAD @pltRXO ; 
    #>

    <# defined above
    # EXO connection
    $pltRXO = @{
        Credential = (Get-Variable -name cred$($tenorg) ).value ;
        verbose = $($verbose) ; } ; 
    #>
    <# 
    if($VerbosePreference = "Continue"){
        $VerbosePrefPrior = $VerbosePreference ;
        $VerbosePreference = "SilentlyContinue" ;
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ; 
    disconnect-exo ;
    if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
    else { reconnect-EXO @pltRXO } ;
    # reenable VerbosePreference:Continue, if set, during mod loads 
    if($VerbosePrefPrior -eq "Continue"){
        $VerbosePreference = $VerbosePrefPrior ;
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ;
    #>
    #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    #endregion SERVICE-CONNECTIONS #*======^ END SERVICE-CONNECTIONS ^======

    $error.clear() ;
    TRY {
        #$LMSLoaded = load-LMS ; write-host -foregroundcolor green "`$LMSLoaded: $LMSLoaded" ;
        # 12:55 PM 4/25/2017 add ems
        #$sName="Microsoft.Exchange.Management.PowerShell*"; if (!(Get-PSSnapin | where {$_.Name -eq $sName})) {Add-PSSnapin $sName -ea Stop};
        # 2:04 PM 4/26/2017 use a full func
        <#$EMSLoaded = Load-EMSSnap ; Write-Debug "`$EMSLoaded: $EMSLoaded" ;
        get-exchangeserver | out-null ;
        #$ADMTLoaded = load-ADMS ; write-host -foregroundcolor green "`$ADMTLoaded: $ADMTLoaded" ;
        #>
        <# 2nd gen disabled
        rx10 -Verbose:$false ; 
        rxo  -Verbose:$false ; 
        #cmsol -Verbose:$false ; 
        connect-ad -Verbose:$false | out-null ;;
        if(!$domaincontroller){$domaincontroller=get-gcfast} ;
        #>

        # 11:56 AM 4/24/2015 moved below func defs, in sub main
        $archPath = get-ArchivePath ;

        # 12:44 PM 4/24/2015 fine squash any array coming out (till we get it sorted)
        if($archPath -is [system.array]){
            if($bDebug) {Write-Verbose "Flattening `$archpath array" -verbose:$verbose}
            $archPath = $archPath[0] ;
        }  # if-E;

    } CATCH {
        $ErrTrapd=$Error[0] ;
        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level warn } #Error|Warn|Debug 
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #-=-record a STATUSWARN=-=-=-=-=-=-=
        $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
        if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
        if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
        #-=-=-=-=-=-=-=-=
        $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$($smsg)" } ;

        set-AdServerSettings -ViewEntireForest $false ;

        Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
    } ; 

    #*======V CONFIGURE DEFAULT LOGGING FROM PARENT SCRIPT NAME v======
    <# old code
    #$pltSL=@{ NoTimeStamp=$true ; Tag="($TenOrg)-LASTPASS" ; showdebug=$($showdebug) ; whatif=$($whatif) ; Verbose=$($VerbosePreference -eq 'Continue') ; } ;
    $pltSL=@{ NoTimeStamp=$FALSE ; Tag="($Ticket)" ; showdebug=$($showdebug) ; whatif=$($whatif) ; Verbose=$($VerbosePreference -eq 'Continue') ; } ;
    if($PSCommandPath){   $logspec = start-Log -Path $PSCommandPath @pltSL ;
    } else { $logspec = start-Log -Path ($MyInvocation.MyCommand.Definition) @pltSL ; } ;
    if($logspec){
        $logging=$logspec.logging ;
        $logfile=$logspec.logfile ;
        $transcript=$logspec.transcript ;
        if(Test-TranscriptionSupported){
            $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
            start-transcript -Path $transcript ;
        } ;
    } else {throw "Unable to configure logging!" } ;
    #>
    if(!(get-variable LogPathDrives -ea 0)){$LogPathDrives = 'd','c' };
    foreach($budrv in $LogPathDrives){if(test-path -path "$($budrv):\scripts" -ea 0 ){break} } ;
    if(!(get-variable rgxPSAllUsersScope -ea 0)){
        $rgxPSAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps(((d|m))*)1|dll)$" ;
    } ;
    if(!(get-variable rgxPSCurrUserScope -ea 0)){
        $rgxPSCurrUserScope="^$([regex]::escape([Environment]::GetFolderPath('MyDocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps((d|m)*)1|dll)$" ;
    } ;
    $pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($whatif) ;} ;
    $pltSL.Tag = ($ticket,$DNameBase -join '-') ;
    if($script:PSCommandPath){
        if(($script:PSCommandPath -match $rgxPSAllUsersScope) -OR ($script:PSCommandPath -match $rgxPSCurrUserScope)){
            $bDivertLog = $true ;
            switch -regex ($script:PSCommandPath){
                $rgxPSAllUsersScope{$smsg = "AllUsers"}
                $rgxPSCurrUserScope{$smsg = "CurrentUser"}
            } ;
            $smsg += " context script/module, divert logging into [$budrv]:\scripts"
            write-verbose $smsg  ;
            if($bDivertLog){
                if((split-path $script:PSCommandPath -leaf) -ne $cmdletname){
                    # function in a module/script installed to allusers|cu - defer name to Cmdlet/Function name
                    $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
                } else {
                    # installed allusers|CU script, use the hosting script name
                    $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $script:PSCommandPath -leaf)) ;
                }
            } ;
        } else {
            $pltSL.Path = $script:PSCommandPath ;
        } ;
    } else {
        if(($MyInvocation.MyCommand.Definition -match $rgxPSAllUsersScope) -OR ($MyInvocation.MyCommand.Definition -match $rgxPSCurrUserScope) ){
             $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $script:PSCommandPath -leaf)) ;
        } elseif(test-path $MyInvocation.MyCommand.Definition) {
            $pltSL.Path = $MyInvocation.MyCommand.Definition ;
        } elseif($cmdletname){
            $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($cmdletname).ps1") ;
        } else {
            $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$CMDLETNAME, FROM WHICH TO BUILD A START-LOG.PATH!" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            BREAK ;
        } ;
    } ;
    write-verbose "start-Log w`n$(($pltSL|out-string).trim())" ;
    $logspec = start-Log @pltSL ;
    $error.clear() ;
    TRY {
        if($logspec){
            $logging=$logspec.logging ;
            $logfile=$logspec.logfile ;
            $transcript=$logspec.transcript ;
            $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
            start-Transcript -path $transcript ;
        } else {throw "Unable to configure logging!" } ;
    } CATCH {
        $ErrTrapd=$Error[0] ;
        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    } ;

    #*======^ CONFIGURE DEFAULT LOGGING FROM PARENT SCRIPT NAME ^======

    # -----------

    $smtpToFailThru=convertFrom-Base64String -string "dG9kZC5rYWRyaWVAdG9yby5jb20=" # simple encoded addr
    # pull the notifc smtpto from the xxxMeta.NotificationDlUs value
    if(!$showdebug){
        if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs){
            $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs ;
        }elseif((Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1){
            $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1 ;
        } else {
            $smtpTo=$smtpToFailThru;
        } ;
    } else {
        # debug pass, don't send to main dl, use NotificationAddr1    if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationDlUs){
        if((Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1){
            #set-variable -Name $meta.name -Value ((get-variable -name $meta.name).value  += @{'o365_AcceptedDomains' = (Get-exoAcceptedDomain).domainname} )
            $smtpTo = (Get-Variable  -name "$($TenOrg)Meta").value.NotificationAddr1 ;
        } else {
            $smtpTo=$smtpToFailThru ;
        } ;
    }
    <# 
    if($bDivertLog){ # scriptbasename will likely be a module name, use diverted start-log values
        $smtpFrom = ((split-path $pltsl.path -leaf).replace('.','-') + "@$( (Get-Variable  -name "$($TenOrg)Meta").value.o365_OPDomain )")
    } else {
        $smtpFrom = (($scriptBaseName.replace(".","-")) + "@$( (Get-Variable  -name "$($TenOrg)Meta").value.o365_OPDomain )") ;
    } ; 
    #>
    # shift to cmdletname, more dependable
    $smtpFrom = (($CmdletName.replace(".","-")) + "@$( (Get-Variable  -name "$($TenOrg)Meta").value.o365_OPDomain )") ;
    $smtpSubj= "Proc Rpt:"
    if($whatif) {
        $smtpSubj+="WHATIF:" ;
    } else {
        $smtpSubj+="PROD:" ;
    } ;
    <#
    if($bDivertLog){ # scriptbasename will likely be a module name, use diverted start-log values
        $smtpSubj+= "$((split-path $pltsl.path -leaf)):$(get-date -format 'yyyyMMdd-HHmmtt')"   ;
    } else {
        $smtpSubj+= "$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"   ;
    } ; 
    #>
    # shift to cmdletname, more dependable
    $smtpSubj+= "$($CmdletName):$(get-date -format 'yyyyMMdd-HHmmtt')"   ;
    if(!($bodyAsHtml)){
        # if not inline attachment in body, need to load report as attachment
        $smtpAttachment=$rptfile ;
    } else {
        #9:49 AM 3/26/2015 just blank the attachment if we're not mailing it
        $smtpAttachment=$null;
    };
    # setup body as a hash
    $smtpBody = @() ;
    # (`n = CrLf in body)
    #====== ^ EMAIL HANDLING BOILERPLATE (USE IN SUB MAIN) ^==================================


    #*======v DL PSTED IN CODE  v======
    if($host.version.major -ge 3){
        $InputSplat=[ordered]@{ Dummy = $null ;  } ;
        $pltNewDG=[ordered]@{ Dummy = $null ;  } ;
        $pltSetDG=[ordered]@{ Dummy = $null ;  } ;
    } else {
        $InputSplat=@{ Dummy = $null ;  } ;
        $pltNewDG=@{ Dummy = $null ;  } ;
        $pltSetDG=@{ Dummy = $null ;  } ;

    } ;
    $InputSplat.remove("Dummy") ;
    $InputSplat.Add("DNameBase","") ; 
    $InputSplat.Add("Ticket",$($null)) ; 
    $InputSplat.Add("ManagedBy","") ; 
    $InputSplat.Add("SiteOverride","") ; 
    $InputSplat.Add("Members","") ; 
    $InputSplat.Add("InetReceive","") ; 

    $pltNewDG.remove("Dummy") ;
    $pltNewDG.Add("DisplayName",$("")) ; 
    $pltNewDG.Add("Alias",$("")) ; 
    $pltNewDG.Add("OrganizationalUnit",$("")) ; 
    $pltNewDG.Add("SamAccountName",$($null)) ; # 1:22 PM 6/6/2016 defer SamAccountName too
    $pltNewDG.Add("type",$( "Distribution")) ; 
    $pltNewDG.Add("Notes",$( $null)) ; 
    $pltNewDG.Add("ManagedBy",$($InputSplat.ManagedBy)) ; 
    $pltNewDG.Add("whatif",$($whatif)) ; 
    $pltNewDG.Add("ErrorAction","STOP") ; 

    $pltSetDG.remove("Dummy") ;
    $pltSetDG.Add("Identity","") ; 
    $pltSetDG.Add("whatif",$($whatif)) ; 
    $pltSetDG.Add("ErrorAction","STOP") ; 

    #region SPLATDEFS ; # ------ 

    $smsg = ":===PASS STARTED=== " ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    if($DNameBase){$InputSplat.DNameBase=$DNameBase};
    if($ManagedBy){$InputSplat.ManagedBy=$ManagedBy};
    #if($Description){$InputSplat.Description=$Description};
    if($Ticket){$InputSplat.Ticket=$Ticket};
    if($SiteOverride){$InputSplat.SiteOverride=$SiteOverride};
    if($Members){$InputSplat.Members=$Members};
    if($InetReceive){$InputSplat.InetReceive=$InetReceive};
    if($HiddenFromAddressLists){$InputSplat.HiddenFromAddressLists=$HiddenFromAddressLists};


    #-=-=-=-=-=-=-=-=
    # alias block switch on rcptype, handles ExOP|Exo|Exov2 variants with single aliased cmd assignements
    # pull onprem recipipent to drive balance of logic
    #rx10 -Verbose:$false ; 
    if($pltRX10){
        ReConnect-Ex2010 @pltRX10 ;
    } else { Reconnect-Ex2010 ; } ; 
    #$OpRcp = $xoRcp = $null ; 
    if($CloudFirst){$isCloud1st = $true } else { $isCloud1st = $false } ; 
    <#
    if(!$Room.identity){ 
        $smsg = "`$Room.Idenity is BLANK! Aborting to avoid returning *entire* recipient base!" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        _cleanup ; 
    } ; 
    if($OpRcp= get-recipient -id $Room.identity -ea 0 ){
        write-verbose "successful:get-recipient -id $($Room.identity) -ea 0" 
    } else {
        write-verbose "failed to get-recipient -id $($Room.identity) -ea 0 ; retry EXO (cloud1st)" 
        $xGRcp = (gcm get-*xo*recipient).name.tolower() | select -unique ; 
        $expr = "$($xGRcp) -id $Room.identity -ea STOP" ; 
        if($xoRcp= invoke-expression $expr ){
            $isCloud1st = $true ;
        } ;
    } ; 
    #>
    # aliased ExOP|EXO|EXOv2 cmdlets (permits simpler single code block for any of the three variants of targets & syntaxes)
    # each is '[aliasname];[exOcmd] (xOv2cmd & exop are converted from [exocmd])
    [array]$cmdletMaps = 'ps1GetxRcp;get-exorecipient;','ps1GetxMbx;get-exomailbox;','ps1SetxMbx;Set-exoMailbox;','ps1GetxUser;get-exoUser;',
        'ps1GetxMUsr;Get-exoMailUser','ps1SetxMUsr;Set-exoMailUser','ps1SetxCalProc;set-exoCalendarprocessing;',
        'ps1GetxCalProc;get-exoCalendarprocessing;','ps1GetxMbxFldrPerm;get-exoMailboxfolderpermission;',
        'ps1GetxMbxFldrPerm;get-exoMailboxfolderpermission','ps1AddxMbxPrm;Add-exoMailboxPermission','ps1GetxMbxPrm;Get-exoMailboxPermission',
        'ps1RmvxMbxPrm;Remove-exoMailboxPermission','ps1AddRcpPrm;Add-exoRecipientPermission','ps1GetRcpPrm;Get-exoRecipientPermission',
        'ps1RmvRcpPrm;Remove-exoRecipientPermission','ps1GetxAccDom;Get-exoAcceptedDomain;','ps1GetxRetPol;Get-exoRetentionPolicy',
        'ps1GetxDistGrp;get-exoDistributionGroup;','ps1GetxDistGrpMbr;get-exoDistributionGroupmember;','ps1GetxMsgTrc;get-exoMessageTrace;',
        'ps1GetxMsgTrcDtl;get-exoMessageTraceDetail;','ps1GetxMbxFldrStats;get-exoMailboxfolderStatistics','ps1GetxMContact;Get-exomailcontact;',
        'ps1SetxMContact;Set-exomailcontact;','ps1NewxMContact;New-exomailcontact','ps1TestxMapi;Test-exoMAPIConnectivity',
        'ps1GetxOrgCfg;Get-exoOrganizationConfig','ps1GetxMbxRegionCfg;Get-exoMailboxRegionalConfiguration',
        'ps1TestxOAuthConn;Test-exoOAuthConnectivity','ps1NewxDistGrp;new-exoDistributionGroup','ps1SetxDistGrp;set-exoDistributionGroup',
        'ps1AddxDistGrpMbr;Add-exoDistributionGroupMember','ps1RmvxDistGrpMbr;remove-exoDistributionGroupMember',
        'ps1GetxDDG;Get-exoDynamicDistributionGroup','ps1NewxDDG;New-exoDynamicDistributionGroup','ps1SetxDDG;Set-exoDynamicDistributionGroup' ;
    [array]$XoOnlyMaps = 'ps1GetxMsgTrcDtl','ps1TestxOAuthConn' ; # cmdlet alias names from above that are skipped for aliasing in EXOP
    # cmdlets from above that have diff names EXO v EXoP: these each have  schema: [alias];[xoCmdlet];[opCmdlet]; op Aliases use the opCmdlet as target
    [array]$XoRenameMaps = 'ps1GetxMsgTrc;get-exoMessageTrace;get-MessageTrackingLog','ps1AddRcpPrm;Add-exoRecipientPermission;Add-AdPermission',
            'ps1GetRcpPrm;Get-exoRecipientPermission;Get-AdPermission','ps1RmvRcpPrm;Remove-exoRecipientPermission;Remove-ADPermission' ;
    # code to summarize & indexed-hash the renamed cmdlets for variant processing
    $XoRenameMapNames = @() ; 
    $oxoRenameMaps = @{} ;
    $XoRenameMaps | foreach {     $XoRenameMapNames += $_.split(';')[0] ;     $name = $_.split(';')[0] ;     $oxoRenameMaps[$name] = $_.split(';')  ;  } ;
    # $isExOP = $isEXO = $false ; 
    # now need to accomodate cloud1st as well
    # filtering the above to subsets:
    $cmdletMapsFltrd = $cmdletmaps|?{$_.split(';')[1] -like '*DistributionGroup*'} ; 
    $cmdletMapsFltrd += $cmdletmaps|?{$_.split(';')[1] -like '*recipient'}
    #$cmdletMapsFltrd = $cmdletmaps # or use full set
    foreach($cmdletMap in $cmdletMapsFltrd){
        <# dbg code
        write-verbose $cmdletMap ;
        if($cmdletMap -eq 'ps1AddRcpPrm Add-exoRecipientPermission'){
            write-host "GOTCHA!" ;
        } ; 
        #>
        <#switch ($OpRcp.recipienttype){
            "MailUser" {
        #>
        #if(($OpRcp.recipienttype -eq 'MailUser') -OR ($xoRcp)){
        if($isCloud1st){
            $isExOP = $false ; $isEXO = $true ; 
            if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
            else { reconnect-EXO @pltRXO } ;
            # reconnect-exo @pltRXO ;
            if($script:useEXOv2){
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1].replace('-exo','-xo') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nAName = ($cmdletMap.split(';')[0]) ;
                if(-not(get-alias -name $naname -ea 0 |?{$_.Definition -eq $cmdlet.name})){
                    $nalias = set-alias -name $nAName -value ($cmdlet.name) -passthru ;
                    write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                } ;
            } else {
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nAName = ($cmdletMap.split(';')[0]);
                if(-not(get-alias -name $naname -ea 0 |?{$_.Definition -eq $cmdlet.name})){
                    $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                    write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                } ;
            } ;
        } else {
            $isExOP = $true ; $isEXO = $false ; 
            if($pltRX10){
                    ReConnect-Ex2010 @pltRX10 ;
            } else { Reconnect-Ex2010 ; } ; 
            if($XoOnlyMaps -contains $cmdletMap.split(';')[0]){
                write-verbose "$($cmdletMap.split(';')[1]) is an XO-Only cmdlet, skipping EXOP alias-creation" ;
            } else {
                if($XoRenameMapNames -contains $cmdletMap.split(';')[0]){
                    write-verbose "$($cmdletMap.split(';')[1]) is an XO-Renamed cmdlet, renaming for EXoP" ;
                    # sub -exoNOUN -> -NOUN using ExOP variant cmdlet
                    if(!($cmdlet= Get-Command $oxoRenameMaps[($cmdletMap.split(';')[0])][2] )){ throw "unable to gcm Alias definition!:$($oxoRenameMaps[($cmdletMap.split(';')[0])][2])" ; break }
                    $nAName = ($cmdletMap.split(';')[0]);
                    if(-not(get-alias -name $naname -ea 0 |?{$_.Definition -eq $cmdlet.name})){
                        $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                        write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                    } ;
                } else { 
                    # common cmdlets between all 3 systems
                    # sub -exoNOUN -> -NOUN
                    if(!($cmdlet= Get-Command $cmdletMap.split(';')[1].replace('-exo','-') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                    $nAName = ($cmdletMap.split(';')[0]);
                    if(-not(get-alias -name $naname -ea 0 |?{$_.Definition -eq $cmdlet.name})){
                        $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                        write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                    } ;
                } ; 

            } ; 
        } ;
        <#
            default { throw "Unrecognized recipienttype!:$($OpRcp.recipienttype)" }
        } ; 
        #>
    } ;  # loop-E
    #-=-=-=-=-=-=-=-=

    Write-Host -fore green "`nSpecified Base DL Name: $($InputSplat.DNameBase)" ;
    $error.clear() ;
    TRY {
        #if($ManagedBy){$oManagedBy = $ManagedBy | foreach-object {ps1GetxRcp -id $_ -ResultSize 1 -ea 'STOP' } | select -expand primarysmtpaddress  | select -unique ;} ; 
        if($ManagedBy){
            if($isCloud1st){
                #$oManagedBy = ps1GetxRcp -id $ManagedBy -ResultSize 1 -ea 'Continue' 
                #$oManagedBy = ps1GetxRcp -id $ManagedBy -ResultSize 25 -ea 'Continue' 
                $oManagedBy = $ManagedBy  | ps1GetxRcp -ResultSize 25 -ea 'Continue' 
            } else { 
                # resolving exo smtpaddresss could yield missing recips, pull -ea
                #$oManagedBy = get-recipient -id $ManagedBy -ResultSize 25 #-ea -ea 'Continue' 
                $oManagedBy = $ManagedBy | get-recipient  -ResultSize 25 -ea 'Continue' 
            } ;
        } ; 
    } CATCH {
        $ErrTrapd=$Error[0] ;
        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level warn } #Error|Warn|Debug 
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #-=-record a STATUSWARN=-=-=-=-=-=-=
        $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
        if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
        if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
        #-=-=-=-=-=-=-=-=
        $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
    } ; 

    if($isCloud1st){
        $DName=("ENT" + "-DL-" + $InputSplat.DNameBase) ;
    }else {
        $InputSplat.Add("Domain",$($oManagedBy[0].identity.tostring().split("/")[0]) ) ; 
        # force 1st ManagedBy's OU (if it's an array)
        $InputSplat.SiteCode=($oManagedBy[0].identity.tostring().split('/')[1]) ;
        if($domaincontroller){
            $InputSplat.Add("DomainController",$domaincontroller) ; 
        } ; 
        $pltNewDG.Add("DomainController",$domaincontroller) ; 
        $pltSetDG.Add("DomainController",$domaincontroller) ; 

        if($InputSplat.SiteOverride){
            $SiteCode=$InputSplat.SiteOverride;
            $InputSplat.SiteCode=$InputSplat.SiteOverride;
        } else {  
            $SiteCode=$InputSplat.SiteCode.tostring();
        } ;

        if($SiteOverride -eq 'ENT'){
            # ent-named OU, but park it in the ManagedBy's OU - no park it in LYN OU - less confusing if all ENT's are in one place
            $FindOU="^OU=Distribution\sGroups,";
            #$tmpSite = ($oManagedBy[0].identity.tostring().split('/')[1]) ;
            $tmpSite = 'LYN'
            if( ($pltNewDG.OrganizationalUnit = ((Get-ADObject -filter { ObjectClass -eq 'organizationalunit' } -ea continue | ?{($_.distinguishedname -match "$($FindOU).*OU=$($tmpSite),.*") } | select distinguishedname).distinguishedname.tostring()) )) { } else { _cleanup ; Exit ;} 
            $InputSplat.Add("SiteName", $SiteCode) ;
            $DName=($SiteCode + "-DL-" + $InputSplat.DNameBase) ;
        } else { 
            # put the DG obj in the ManagedBy's site
            $FindOU="^OU=Distribution\sGroups,";
            if( ($pltNewDG.OrganizationalUnit = ((Get-ADObject -filter { ObjectClass -eq 'organizationalunit' } -ea continue | ?{($_.distinguishedname -match "$($FindOU).*OU=$($InputSplat.SiteCode),.*") } | select distinguishedname).distinguishedname.tostring()) )) { } else { _cleanup ; Exit ;} 
            $InputSplat.Add("SiteName", $SiteCode) ;
            $DName=($SiteCode + "-DL-" + $InputSplat.DNameBase) ;
        } ;
    
    } ;

    $smsg = "`$Dname:$Dname" ; 
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

    
    $pltNewDG.Name= $pltNewDG.DisplayName = $($DName);
    $pltNewDG.Alias=$($DName.replace(" ",""));
    # shift to get-admininitials
    $admininitials=get-AdminInitials ; 
    $pltNewDG.Notes="$((get-date -format "MM/dd/yyyy"))" ;
    if($($InputSplat.Ticket)){$pltNewDG.Notes+=" #$($InputSplat.Ticket)" };
    if($isCloud1st){
        $pltNewDG.remove('SamAccountName') ; 
        $pltNewDG.remove('OrganizationalUnit') ; 
    } else {
        $pltNewDG.SamAccountName =$($DName.replace(" ","").replace("-","")) ;
    } ; 
    $pltNewDG.Type = "Distribution";
    $pltNewDG.ManagedBy =$oManagedBy.primarysmtpaddress | select -unique  ;
    $pltNewDG.Notes+=" for $($pltNewDG.ManagedBy -join ',' ) -$($admininitials)" ;

    if($members){
        $pltNewDG.members = $members | ps1GetxRcp -ErrorAction Continue | select -expand primarysmtpaddress  | select -unique ;
    } ; 

    Write-Host -fore yellow "Checking for existing $($pltNewDG.DisplayName)..."  ;
    write-verbose "$((get-date).ToString("HH:mm:ss")):`$SGSrchName:$($SGSrchName)`n`$pltNewDG.DisplayName:$($pltNewDG.DisplayName)";
    $ADGSrchName=$($pltNewDG.DisplayName);

    if($isCloud1st){
        $oDL = (ps1GetxDistGrp -identity $pltNewDG.Alias -ea silentlycontinue)
    } else { 
        $oDL = (ps1GetxDistGrp -identity $pltNewDG.Alias -domaincontroller $($domaincontroller) -ea silentlycontinue)
    } ; 

    if($oDL){
        write-verbose "Existing found: `$oDL:$($oDL.primarysmtpaddress)" ;
        write-verbose "`$oDL.DN:$($oDL.DistinguishedName)" ;
    } else {
    
        $smsg = "$((get-alias ps1NewxDistGrp).definition) w`n$(($pltNewDG|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
       
            $Exit = 0 ; 
            Do {
                Try {
                    $oDL = ps1NewxDistGrp @pltNewDG ;
                    $Exit = $Retries ; 
                } Catch {
                    Start-Sleep -Seconds $RetrySleep ; 
                    $Exit ++ ; 
                    Write-Verbose "Failed to exec cmd because: $($Error[0])" ; 
                    Write-Verbose "Try #: $Exit" ; 
                    If ($Exit -eq $Retries) {Write-Warning "Unable to exec cmd!"} ; 
                } # try-E
            } Until ($Exit -eq $Retries) # loop-E

        if($whatif){
            $smsg = "SKIPPING EXEC: Whatif-only pass";
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } else {
            # have had sporadic resolution errors, pull it back again to ensure it's fully available
            if($isCloud1st){
                do {Write-Host "." -NoNewLine;Start-Sleep -s 1} until ($odl = ps1GetxDistGrp $oDL.primarysmtpaddress -ea silentlycontinue -resultsize 1)  ;
            } else { 
                do {Write-Host "." -NoNewLine;Start-Sleep -s 1} until ($odl = ps1GetxDistGrp $oDL.primarysmtpaddress -domaincontroller $domaincontroller -resultsize 1) ;
            } ; 
            $smsg = "`$oDL:$($oDL.primarysmtpaddress)" ;
            $smsg += "`n`$oDL.DN:$($oDL.DistinguishedName)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        }  # if-E
            
    } # if-E no DL obj

    if($oDL){
        $pltSetDG.Identity=$($oDL.alias) ;
        if($isCloud1st){
            $ExistMbrs = ps1GetxDistGrpMbr -Identity $oDL.primarysmtpaddress -ErrorAction 'Stop' | select -expand primarysmtpaddress ; 
        } else { 
            $ExistMbrs = ps1GetxDistGrpMbr -Identity $odl.SamAccountName -DomainController $domaincontroller -ErrorAction 'Stop' | select -expand primarysmtpaddress ; 
        } ; 

        $pltAddDGM=[ordered]@{
            identity=$pltSetDG.identity ;
            #Member= $mbr  ; 
            ErrorAction = 'Stop' ; 
            whatif=$($whatif) ; 
            DomainController= $domaincontroller
        } ;
        if($isCloud1st){
            $pltAddDGM.remove('DomainController') ; 
        } 
        $error.clear() ;
        TRY {
            foreach($Mbr in $pltNewDG.members){
                if ($ExistMbrs -notcontains $Mbr) {
                    $smsg = "ADD:$($mbr.samaccountname)"
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    ps1AddxDistGrpMbr @pltAddDGM -member $mbr ; 
                    
                } else {
                    $smsg = "SKIPPING:$($mbr) is already a member of $($oDL.samaccountname)"
                } ; 
            }; # loop-E

            if($InputSplat.InetReceive){
                $smsg = "-InetReceive:`$true:Updating RequireSenderAuthenticationEnabled to `$false" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $pltSetDG.add("RequireSenderAuthenticationEnabled",$false) ; 
            
            } ; 

            if($InputSplat.HiddenFromAddressLists){
                $smsg = "-HiddenFromAddressLists:`$true:Setting HiddenFromAddressListsEnabled `$true" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $pltSetDG.add("HiddenFromAddressListsEnabled",$true) ; 
            } ; 

            $smsg = "$((get-alias ps1SetxDistGrp).definition) w`n$(($pltSetDG|out-string).trim())" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            ps1SetxDistGrp @pltSetDG 

        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ; 

        do{     $smsg =  "REVIEW SETTINGS: " ;
            $smsg = "$("="*6)`n$((Get-Date -Format 'HH:mm:ss')):Results:";
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            if($isCloud1st){
                $oDL=ps1GetxDistGrp -id $odl.Alias -ErrorAction stop ;
            } else { 
                $oDL=ps1GetxDistGrp -id $odl.Alias -domaincontroller $domaincontroller -ErrorAction stop ;
            } ; 
            # 10:19 AM 4/4/2017 add RequireSenderAuthenticationEnabled
            $propsDG = "DisplayName","Alias","WindowsEmailAddress","ManagedBy","RequireSenderAuthenticationEnabled","HiddenFromAddressListsEnabled" ; 
            $smsg = "`n$(($oDL| fl $propsDG |out-string).trim())" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            if($isCloud1st){
                $oDLMbrs = ps1GetxDistGrpMbr -identity $oDL.alias  -ea 0 | select primarysmtpaddress ; 
            } else { 
                $oDLMbrs = ps1GetxDistGrpMbr -identity $oDL.alias -domaincontroller $($domaincontroller) -ea 0 | select distinguishedname;
            } ; 
            $smsg = "`n$(($oDL| fl $propsDG |out-string).trim())" ; 
            $smsg += "`nMembers:`n$(($oDLMbrs|out-string).trim())" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        
            if(-not($OutObject)){
                $bRet=Read-Host "Enter Y to Refresh Review (replication latency)." ;
            } ; 
        } until ($bRet -ne "Y" -OR $OutObject);
        # 1:07 PM 9/30/2021 rem-out the mailcontact creation code, needs debugging. 
        if($isCloud1st -and -not($whatif)){
            # check for onprem recipient on smtpaddr, if none, offer to build a MailContact in unreplicated ($($TenOrg)meta.UnreplicatedOU)
            if($UseExOP){
                Reconnect-Ex2010 @pltRX10 ; 
                if($existRcp = get-recipient -id $odl.primarysmtpaddress -domaincontroller $domaincontroller -ErrorAction 0){
                    $smsg = "(existing recipient object for $($odl.primarysmtpaddress) found:$($existRcp.recipienttypedetails) - skipping MContact creation)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } else {
                    $smsg = "No conflicting OnPrem recipient found with: $($odl.primarysmtpaddress)" ; 
                    $smsg += "`nDo you want to create an *unreplicated* OnPrem MailContact to point at the EXO object?" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #*======v PS Simple YYY Confirm Prompt - psb-PSPrompt.cbp v======
                    $bRet=Read-Host "Enter YYY to continue. Anything else will exit" 
                    if ($bRet.ToUpper() -eq "YYY") {
                         Write-host "Moving on"
                            
                            # new-mailcontact -DisplayName -Name -LastName -DomainController -WhatIf -ExternalEmailAddress -Alias -PrimarySmtpAddress -OrganizationalUnit
                            $pltNewMC=[ordered]@{
                                DisplayName = "$($odl.name)-MC" ;
                                Name = "$($odl.name)-MC" ;
                                LastName = "$($odl.name)-MC";
                                DomainController = $domaincontroller;
                                ExternalEmailAddress = $odl.primarysmtpaddress;
                                Alias =  "$($odl.name.replace(' ',''))_$((new-guid).tostring().split('-')[-1])";
                                OrganizationalUnit = "OU=Unreplicated Contacts,$( (Get-Variable  -name "$($TenOrg)Meta").value.UnreplicatedOU )"
                                ErrorAction = 'STOP';
                                WhatIf = $($whatif);
                            } ; 
                            $smsg = "New-MailContact w`n$(($pltNewMC|out-string).trim())" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            $error.clear() ;
                            TRY {
                                $nmc = new-mailcontact @pltNewMC ; 
                                $propsMC = 'name','alias','recipienttype','primarysmtpaddress' ;
                                $smsg = "`n$(($nmc|ft -a $propsMC|out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } CATCH {
                                $ErrTrapd=$Error[0] ;
                                $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #-=-record a STATUSWARN=-=-=-=-=-=-=
                                $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                                if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                                if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                                #-=-=-=-=-=-=-=-=
                                $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                            } ; 

                    } else {
                         Write-Host "Invalid response. Skipping Contact creation"
                         # exit <asserted exit error #>
                         ;;exit 1

                    } # if-block end

                }; 
            } ; 
        } ; 
        #

    } else {
        if(!($Whatif)){
            $smsg =   ("FIND/CREATION FAILURE: $($InputSplat.DNameBase) not found.`n") ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        }
        else {
            $smsg = "Whatif-pass completed";
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        }
    };

    _cleanup ; # pipeline, issue is test-transcribing et all are dumping a $true |write-output and trashing the pl, need to refactor the verb-logging content to fix
    # for now move the return below _cleanup

    $smsg += $sBnr.replace('=v','=^').replace('v=','^=') ;
    $smsg += "`n-----------------------"; 
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    
    if($OutObject){
        $smsg = "(-OutObject specified: returning DG object to pipeline)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        $oDL | write-output ; 
    } ; 
    
    #write-host "xxx"
}

#*------^ new-DgTor.ps1 ^------


#*------v new-xoDGFromProperty.ps1 v------
function new-xoDGFromProperty{
    <#
    .SYNOPSIS
    new-xoDGFromProperty.ps1 - expand a property (of a DDG) into a new DDG populated with the original property's recipients (aimed at transplanting AcceptMailOnlyFrom values into AcceptMailOnlyFromDLMember's leveraging a free-standing Helpdesk-maintainable DG
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-09-02
    FileName    : new-xoDGFromProperty
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite:	URL
    AddedTwitter:	URL
    REVISIONS
    *3:20 PM 12/30/2021 updated Resolve-xoRcps calls to use -get* rather than specifying rgx matches on rtds
    * 9:23 AM 12/3/2021 updated a few wv's to pswls support
    * 4:40 PM 9/14/2021 corrected synopsis/description
    * 9:45 AM 9/2/2021 rev: added CBH, fixed existing block: Add-DistributionGroupMember -> propr xo alias:ps1AddxDistGrpMbr
    .DESCRIPTION
    new-xoDGFromProperty.ps1 - expand a property (of a DDG) into a new DG populated with the original property's recipients (aimed at transplanting AcceptMailOnlyFrom values into AcceptMailOnlyFromDLMember's populated with a free-standing Helpdesk-maintainable DG object.
    Generally, one would specify to have the new DG inherit the matching ManagedBy of the DDG.
    .PARAMETER Members
    Array of Members to be resolved against current Exchange environment [-Members `$members ]
    .PARAMETER NewDGName
    Name to be used for New DG to be populated[-NewDGName (`"`$(`$preDDG.name)-ApprovedSenders`
    .PARAMETER ManagedBy (override; defaults to ManagedBy of specified DDG)# [-ManagedBy `$preDDG.ManagedBy]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER Whatif
    Parameter to run a Test no-change pass [-Whatif switch]
    .EXAMPLE
    PS> $pltNxoDGfP=[ordered]@{
        Members=$preDDG.AcceptMessagesOnlyFrom  ;
        NewDGName=("$($preDDG.name)-ApprovedSenders") ;
        ManagedBy=$preDDG.ManagedBy ;
        whatIf=$true ;
    } ;
    if($nDG = new-xoDGFromProperty @pltNxoDGfP){
        set-exoDynamicDistributionGroup -id $preDDG.primarysmtpaddress -AcceptMessagesOnlyFromDLMembers $nDG.primarysmtpaddress -AcceptMessagesOnlyFrom $null -whatif ;
    } ;
    Generate a new DG to host a transplanted recipients value (to shift static AcceptMessagesOnlyFrom to a setparte SD-managable DG).
    Then demo's updating a the source DDG, adding the new created DG onto the DDG.AcceptMessagesOnlyFromDLMembers,
    and blanking the original DDG.AcceptMessagesOnlyFrom.
    .LINK
    https://github.com/tostka/verb-Exo
    #>
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory=$False,HelpMessage="Array of Members to be resolved against current Exchange environment [-Members `$members ]")]
        [array]$Members,
        [Parameter(Mandatory=$True,HelpMessage="Name to be used for New DG to be populated[-NewDGName (`"`$(`$preDDG.name)-ApprovedSenders`" ;)]")]
        [string]$NewDGName,
        [Parameter(Mandatory = $false, HelpMessage = "ManagedBy (override; defaults to ManagedBy of specified DDG)# [-ManagedBy `$preDDG.ManagedBy]")]
        $ManagedBy,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2,
        [Parameter(HelpMessage="Whatif Flag (defaults true, override -whatif:`$false) [-whatIf]")]
        [switch]$whatIf
    )
    if ($script:useEXOv2) { reconnect-eXO2 }
    else { reconnect-EXO } ;
    [array]$cmdletMaps = 'ps1GetxRcp;get-exorecipient;','ps1GetxDistGrp;get-exoDistributionGroup',
        'ps1NewxDistGrp;new-exoDistributionGroup' ,'ps1SetxDistGrp;set-exoDistributionGroup',
        'ps1GetxDistGrpMbr;get-exoDistributionGroupMember','ps1RmvxDistGrpMbr;remove-exoDistributionGroupMember',
        'ps1AddxDistGrpMbr;Add-exoDistributionGroupMember','ps1GetxDDG;Get-exoDynamicDistributionGroup',
        'ps1NewxDDG;New-exoDynamicDistributionGroup','ps1SetxDDG;Set-exoDynamicDistributionGroup',
        'ps1GetxOrgCfg;Get-exoOrganizationConfig' ;
    foreach($cmdletMap in $cmdletMaps){
        if($script:useEXOv2){
            if(!($cmdlet= Get-Command $cmdletMap.split(';')[1].replace('-exo','-xo') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
            $nAName = ($cmdletMap.split(';')[0]) ;
            if(-not(get-alias -name $naname -ea 0 |Where-Object{$_.Definition -eq $cmdlet.name})){
                $nalias = set-alias -name $nAName -value ($cmdlet.name) -passthru ;
                $smsg = "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
        } else {
            if(!($cmdlet= Get-Command $cmdletMap.split(';')[1])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
            $nAName = ($cmdletMap.split(';')[0]);
            if(-not(get-alias -name $naname -ea 0 |Where-Object{$_.Definition -eq $cmdlet.name})){
                $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                $smsg = "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
        } ;
    } ;
    #if($ManagedBy){$oManagedBy = ps1GetxRcp $ManagedBy -ea 'STOP' | Select-Object -expand primarysmtpaddress  | Select-Object -unique ;} ;
    if($ManagedBy){
        <# [Set-DynamicDistributionGroup (ExchangePowerShell) | Microsoft Docs - docs.microsoft.com/](https://docs.microsoft.com/en-us/powershell/module/exchange/set-dynamicdistributiongroup?view=exchange-ps)
           [Set-DistributionGroup (ExchangePowerShell) | Microsoft Docs - docs.microsoft.com/](https://docs.microsoft.com/en-us/powershell/module/exchange/set-distributiongroup?view=exchange-ps)
            -ManagedBy
            A dynamic group can only have one owner
            A [distgroup] must have at least one owner & if you don'specify... the user account that created the group is the owner. 
            ... must be a mailbox, mailuser or mail-enabled security group
        #> 
        #$oManagedBy = (Resolve-xoRcps -Recipients $ManagedBy -MatchRecipientTypeDetails '(UserMailbox|MailUser|GuestMailUser)' -ea 'STOP' -Verbose:($VerbosePreference -eq 'Continue') )  | Select-Object -unique 
        $oManagedBy = (Resolve-xoRcps -Recipients $ManagedBy -getMailboxPrincipals -ea 'STOP' -Verbose:($VerbosePreference -eq 'Continue') )  | Select-Object -unique 
    }  ; 
    if($members){
        #$members = $members | ps1GetxRcp -ErrorAction Continue | Select-Object -expand primarysmtpaddress  | Select-Object -unique ;
        $members = $members 
         #$members = (Resolve-xoRcps -Recipients $members -MatchRecipientTypeDetails '(UserMailbox|MailUser|GuestMailUser|MailContact)' -Verbose:($VerbosePreference -eq 'Continue') -ErrorAction Continue)  ; 
         $members = (Resolve-xoRcps -Recipients $members -getRecipients -Verbose:($VerbosePreference -eq 'Continue') -ErrorAction Continue)  ; 
    } ;
    $pltNDG=[ordered]@{
        DisplayName=$NewDGName;
        Name=$NewDGName;
        Members=$members ;
        #DomainController=$domaincontroller;
        Alias=([System.Text.RegularExpressions.Regex]::Replace($NewDGName,"[^1-9a-zA-Z_]",""));
        ManagedBy=$oManagedBy;
        #OrganizationalUnit = (get-organizationalunit (($preDDG.DistinguishedName.tostring().split(",") | select -Skip 1) -join ",").tostring()).CanonicalName ;
        ErrorAction = 'Stop' ;
        whatif=$($whatif);
    } ;
    if($existDG=ps1GetxDistGrp -id $pltndg.alias -ResultSize 1 -ea 0){
        $pltSetDG=[ordered]@{
            identity = $existDG.primarysmtpaddress ;
            #Members=$members ; # not supported have to add-DistributionGroupMember them in on existings
            #DomainController=$domaincontroller;
            ManagedBy=$oManagedBy;
            whatif=$($whatif);
            ErrorAction = 'Stop' ;
        } ;
        $smsg = "UpdateExisting DG:$((get-alias ps1SetxDistGrp).definition)  w`n$(($pltSetDG|out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        ps1SetxDistGrp @pltSetDG ;
        # pre-purge
        $prembrs = ps1GetxDistGrpMbr -id $pltSetDG.identity ;
        $pltModDGMbr=[ordered]@{identity= $pltSetDG.identity ;whatif = $($whatif) ;erroraction = 'STOP'  ;confirm=$false ;}
        $smsg = "Clear existing members:$((get-alias ps1RmvxDistGrpMbr).definition) w`n$(($pltModDGMbr|out-string).trim())`n$(($prembrs |out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #$prembrs | %{ps1RmvxDistGrpMbr @$pltModDGMbr -Member $_.alias  } ;
        $prembrs.distinguishedname | ps1RmvxDistGrpMbr @pltModDGMbr ;
        # ps1GetxDistGrpMbr -id $pltSetDG.identity | ps1RmvxDistGrpMbr -id $pltSetDG.identity –whatif:$($whatif) -ea STOP ;
        # then add validated from scratch
        $smsg = "re-add VALIDATED members:add-DistributionGroupMember w`n$(($pltModDGMbr|out-string).trim())`n$(($members|out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $members | ps1AddxDistGrpMbr @pltModDGMbr ;
        $pdg =  ps1GetxDistGrp -id $pltSetDG.identity ;
    } else {
        $smsg = "$((get-alias ps1NewxDistGrp).definition)  w`n$(($pltNDG|out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $pdg = ps1NewxDistGrp @pltNDG ;
    } ;
    if(!$whatif){
        # was getting notfounds, trying to update the $pdg, so re-qry it from scratch, if it comes back it's *there* for updates
        $1F=$false ;Do {if($1F){Start-Sleep -s 5} ;  write-host "." -NoNewLine ; $1F=$true ; } Until ($existDG = ps1GetxDistGrp $pltNDG.alias -EA 0) ;
        # set hidden (can't be done with new-dg command): -HiddenFromAddressListsEnabled
        $pltSetDG=[ordered]@{
            identity = $existDG.primarysmtpaddress ;
            HiddenFromAddressListsEnabled = $true ;
            whatif=$($whatif);
            ErrorAction = 'Stop' ;
        } ;
        $smsg = "HiddenFromAddressListsEnabled:UpdateExisting DG:$((get-alias ps1SetxDistGrp).definition)  w`n$(($pltSetDG|out-string).trim())" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        ps1SetxDistGrp @pltSetDG ;

        $pdg =  ps1GetxDistGrp -id $pltSetDG.identity ;
        $smsg = "Returning new DG object to pipeline" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $pdg | write-output ;

    } else {
        $smsg = "(-whatif: skipping balance of process)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $false | write-output ;
    }  ;

}

#*------^ new-xoDGFromProperty.ps1 ^------


#*------v remove-EXOLicense.ps1 v------
function remove-EXOLicense {
    <#
    .SYNOPSIS
    remove-EXOLicense.ps1 - Remove a temporary o365 license from specified MsolUser account. Returns updated MSOLUser object to pipeline.
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-07-13
    FileName    : remove-EXOLicense.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    *1:54 PM 1/13/2026 finallyu got through whati fpass; WIP more AAD->MG code updates
    * 1:30 PM 1/7/2026 WIP unupdated port from AADLicense -> MGUDLicense
    * 9:48 AM 6/17/2024 fixed credential code, spliced over code to resolve creds, and assign to $Credential
    * 4:25 PM 5/22/2023 scrapped, rewrote adapted from functional add-exoLicense(); 
     * 3:37 PM 5/17/2023 added pltRXO support
    * 12:10 PM 6/7/2022 updated cbh params
    * 5:17 PM 3/23/2022 retooling to remove msonline module dependance, and shift to AzureAD (crappy implementation GraphAPI) module
    * 12:57 PM 1/31/2022 addded -ea 0 to gv PassStatus_$($tenorg) (spurious error suppress)
    * 3:14 PM 1/18/2022 REM'D EXOP conn's (match add-exolic), this is pure msolu & exo. 
    * 1:02 PM 1/17/2022 port of add-EXOLicense to removal process
    .DESCRIPTION
    remove-EXOLicense.ps1 - Remove a temporary o365 license from specified MsolUser account. Returns updated MSOLUser object to pipeline.
    .PARAMETER users
    Array of UserPrincipalNames (or MSOLUser objects) to have a temporary Exchange License applied
    .PARAMETER Ticket
    Ticket Number [-Ticket '999999']
    .PARAMETER LicenseSkuKeys
    Array, in preference order, of XXXMeta global value LicenseSkuKey names (resolves SKUId from TenOrg global Meta vari ; runs full list removing all matches)[-LicenseSkuIds 'o365LicSkuExStd','o365LicSkuF1']
    .PARAMETER LicenseSkuIds
    Optional Array, in preference order, of LicenseSkuID (e.g. TenantName:SPE_F1) to be added, runs full list removing all matches (default process is to dynamically resolve id's from Meta LicenseSkuKeys specifications)[-LicenseSkuIds @(`$XXXMETA.o365LicSkuExStd,`$XXXMETA.o365LicSkuF1)]
    .PARAMETER Force
    switch to override normal 'skipped' license application to existing Mailbox (needed for licensed-Shared, or upgraded existing lic).
    .PARAMETER TenOrg
    TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER Credential
    Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]
    .PARAMETER UserRole
    Credential User Role spec (SID|CSID|UID|B2BI|CSVC)[-UserRole SID]    
    .PARAMETER silent
    Switch to specify suppression of all but warn/error echos.(unimplemented, here for cross-compat)
    .PARAMETER showDebug
    switch to show extended debugging output [-showdebug]
    .PARAMETER whatIf
    Whatif Flag  [-whatIf]
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    System.Object - returns summary report to pipeline
    .EXAMPLE
    PS> remove-EXOLicense -users 'Test@domain.com','Test2@domain.com' -ticket TICKETNUMBER -verbose  ;
    Process an array of users, with default 'hunting' -LicenseSkuIds array. 
    .EXAMPLE
    PS> $updatedMSOLU = remove-EXOLicense -users 'Test@domain.com','Test2@domain.com' -verbose -ticket TICKETNUMBER;
        if($updatedMSOLU.islicensed){'Y'} else { 'N'} ; 
    Process licnse removal for specified user, and post-test isLicensed status, using default license array configured on the -LicenseSkuIDs default value.
    .EXAMPLE
    PS> $whatif=$true ;
        $target = '99999,lynctest15@toro.com' ;
        if($target.contains(',')){
            $ticket,$trcp = $target.split(',') ;
            $updatedmsolu = remove-EXOLicense -users $trcp -Ticket $ticket -whatif:$($whatif) ;
            $props1 = 'UserPrincipalName','DisplayName','IsLicensed' ;
            $props2 = @{Name='Licenses';
            Expression={$_.licenses.accountskuid -join ', '}}  ;
            $smsg = "$((get-date).ToString('HH:mm:ss')):UpdatedMsolU: w`n$(($updatedmsolu| ft -auto $props1|out-string).trim())" ;
            $smsg += "`n$(($updatedmsolu| fl $props2 |out-string).trim())" ;
            write-host -foregroundcolor green $smsg ;
        } else { write-warning "`$target does *not* contain comma delimited ticket,UPN string!"} ;
    Fancier variant of above, with more post-confirm reporting
    .EXAMPLE
    PS> remove-EXOLicense -users 'Test@domain.com' -LicenseSkuIds $TORMETA.o365LicSkuExStd -ticket TICKETNUMBER;
    removal an explictly specified lic to a user (in this case, using the LicenseSku for EXCHANGESTANDARD, as stored in a global variable)
    .EXAMPLE
    PS> remove-EXOLicense -users 'Test@domain.com' -LicenseSkuIds $TORMETA.o365LicSkuF1 -ticket TICKETNUMBER;
    removal an explicitly specified lic to a user (in this case, using the LicenseSku for SPE_F1 - web-only o365 - lic as stored in a global variable)
    .EXAMPLE
    PS> remove-EXOLicense -users 'Test@domain.com' -LicenseSkuIds $TORMETA.o365LicSkuE3 -ticket TICKETNUMBER;
    removal an explicitly specified lic to a user (in this case, using the LicenseSku for ENTERPRISEPACK - E3 o365 - lic as stored in a global variable)
    .EXAMPLE
    PS> remove-EXOLicense -users 'Test@domain.com' -LicenseSkuIds 'TENANTNAME:EXCHANGESTANDARD' -ticket TICKETNUMBER;
    removal an explicitly specified lic to a user by specifying the Tenant-specific LicenseSkuID directly
    .EXAMPLE
    PS> remove-o365License -$MsoLUser.UserprincipalName -ticket TICKETNUMBER ;
    remove-o365License compatibility option
    .LINK
    https://github.com/tostka/verb-exo
    .LINK
    #>
    # migr to verb-exo, pull the dupe spec...
    # #Requires -Modules AzureAD, MSOnline, ExchangeOnlineManagement, verb-MG, verb-Auth, verb-IO, verb-logging, verb-Mods, verb-Text
    #Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\s\regex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    #[Alias('remove-o365License')]
    PARAM(
        [Parameter(Position=0,Mandatory=$False,ValueFromPipeline=$true,HelpMessage="Array of UserPrincipalNames (or MGUser objects) to have a temporary Exchange License applied")]
            #[ValidateNotNullOrEmpty()]
            #[Alias('ALIAS1', 'ALIAS2')]
            #[ValidatePattern("^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$")]
            [array]$users,
        [Parameter(Mandatory=$True,HelpMessage="Ticket Number [-Ticket '999999']")]
            [string]$Ticket,
        [Parameter(,HelpMessage="Array, in preference order, of XXXMeta global value LicenseSkuKey names (resolves SKUId from TenOrg global Meta vari ; first working lic assignment, will be applied)[-LicenseSkuIds 'o365LicSkuExStd','o365LicSkuF1']")]
            [ValidateNotNullOrEmpty()]
            [array]$LicenseSkuKeys=@('o365LicSkuExStd','o365LicSkuF1','o365LicSkuE3'),
         [Parameter(,HelpMessage="Optional Array, in preference order, of LicenseSkuID (e.g. TenantName:SPE_F1) to be added, runs full list removing all matches (default process is to dynamically resolve id's from Meta LicenseSkuKeys specifications)[-LicenseSkuIds @(`$XXXMETA.o365LicSkuExStd,`$XXXMETA.o365LicSkuF1)]")]
            #[ValidateNotNullOrEmpty()]
            [array]$LicenseSkuIds = @(), 
        [Parameter(HelpMessage="switch to override normal 'skipped' license application to existing Mailbox.[-Force]")]
            [switch] $Force,
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
            [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
            [switch] $useEXOv2=$true,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ; 
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ; 
                return $true ; 
            })]
            [string[]]$UserRole = @('ESvcCBA','CSvcCBA','SIDCBA','SID'),
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent,
        [Parameter(HelpMessage="switch to show extended debugging output [-showdebug]")]
            # included solely for backward compatibility with Removal-o365License()
            [switch] $showDebug,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
            [switch] $whatIf
    ) ;
    BEGIN{
        #region CONSTANTS_AND_ENVIRO #*======v CONSTANTS-AND-ENVIRO v======
        # function self-name (equiv to script's: $MyInvocation.MyCommand.Path) ;
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        # Get parameters this function was invoked with
        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
        $smsg = "(ParameterSetName $($PSCmdlet.ParameterSetName) is in effect)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        #region LOCAL_CONSTANTS ; #*------v LOCAL_CONSTANTS v------
        $rgxOPLic = '^CN\=ENT\-APP\-Office365\-(EXOK|F1|MF1)-DL$' ;
        $rgxXLic = '^CN\=ENT\-APP\-Office365\-(EXOK|F1|MF1)-DL$' ;
        # 9:58 AM 1/13/2026, EXCLUDE STRANGE EXO-MBX GRANTING LIC, THAT'S APPEARED:
        $rgxLicAgentExclude = '^MICROSOFT_AGENT_' ; 
        #endregion LOCAL_CONSTANTS ; #*------^ END LOCAL_CONSTANTS ^------
         <#
        # recycling the inbound above into next call in the chain
        # downstream commands
        $pltRXO = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
        } ;
        #>
        # 9:26 AM 6/17/2024 this needs cred resolution splice over latest get-exomailboxlicenses
        $o365Cred = $null ;
        if($Credential){
            $smsg = "`Credential:Explicit credentials specified, deferring to use..." ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                # get-TenantCredentials() return format: (emulating)
                $o365Cred = [ordered]@{
                Cred=$Credential ;
                credType=$null ;
            } ;
            $uRoleReturn = resolve-UserNameToUserRole -UserName $Credential.username -verbose:$($VerbosePreference -eq "Continue") ; # Username
            #$uRoleReturn = resolve-UserNameToUserRole -Credential $Credential -verbose = $($VerbosePreference -eq "Continue") ;   # full Credential support
            if($uRoleReturn.UserRole){
                $o365Cred.credType = $uRoleReturn.UserRole ;
            } else {
                $smsg = "Unable to resolve `$credential.username ($($credential.username))"
                $smsg += "`nto a usable 'UserRole' spec!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ;
                Break ;
            } ;
        } else {
            $pltGTCred=@{TenOrg=$TenOrg ; UserRole=$null; verbose=$($verbose)} ;
            if($UserRole){
                $smsg = "(`$UserRole specified:$($UserRole -join ','))" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $pltGTCred.UserRole = $UserRole;
            } else {
                $smsg = "(No `$UserRole found, defaulting to:'CSVC','SID' " ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                $pltGTCred.UserRole = 'CSVC','SID' ;
            } ;
            $smsg = "get-TenantCredentials w`n$(($pltGTCred|out-string).trim())" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            $o365Cred = get-TenantCredentials @pltGTCred
        } ;
        if($o365Cred.credType -AND $o365Cred.Cred -AND $o365Cred.Cred.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
            $smsg = "(validated `$o365Cred contains .credType:$($o365Cred.credType) & `$o365Cred.Cred.username:$($o365Cred.Cred.username)" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            # 9:58 AM 6/13/2024 populate $credential with return, if not populated (may be required for follow-on calls that pass common $Credentials through)
            if((gv Credential) -AND $Credential -eq $null){
                $credential = $o365Cred.Cred ;
            }elseif($credential.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                $smsg = "(`$Credential is properly populated; explicit -Credential was in initial call)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else {
                $smsg = "`$Credential is `$NULL, AND $o365Cred.Cred is unusable to populate!" ;
                $smsg = "downstream commands will *not* properly pass through usable credentials!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ;
                break ;
            } ;
        } else {
            $smsg = "UNABLE TO RESOLVE FUNCTIONAL CredType/UserRole from specified explicit -Credential:$($Credential.username)!" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            break ;
        } ; 

        # downstream commands
        $pltRXO = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
        } ;
        if((get-command Reconnect-EXO).Parameters.keys -contains 'silent'){
            $pltRxo.add('Silent',$silent) ;
        } ;
        # default connectivity cmds - force silent false
        $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$true) ; 
        if((get-command Reconnect-EXO).Parameters.keys -notcontains 'silent'){
            $pltRxo.remove('Silent') ;
        } ; 

        # 2:37 PM 1/7/2026 mg support
        #region cMG_SCAFFOLD ; #*------v cMG_SCAFFOLD v------
        if(-not (get-command  test-mgconnection)){
            if(-not (get-module -list Microsoft.Graph -ea 0)){
                $smsg = "MISSING Microsoft.Graph!" ;
                $smsg += "`nUse: install-module Microsoft.Graph -scope CurrentUser" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
        } ;
        $MGCntxt = test-mgconnection -Verbose:($VerbosePreference -eq 'Continue') ;
        $o365Cred = $null ;
        if($Credential -AND $MGCntxt.isConnected){
            $smsg = "Explicit -Credential:$($Credential.username) -AND `$MGCntxt.isConnected: running pre:Disconnect-MgGraph" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # Dmg returns a get-mgcontext into pipe, if you don't cap it corrupts the pipe on your current flow
            $dOut = Disconnect-MgGraph -Verbose:($VerbosePreference -eq 'Continue')
            $MGCntxt = test-mgconnection -Verbose:($VerbosePreference -eq 'Continue') ;
        };
        if($Credential){
            $smsg = "`Credential:Explicit credentials specified, deferring to use..." ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            write-verbose "get-TenantCredentials() return format: (emulating)" ;
            $o365Cred = [ordered]@{
                Cred=$Credential ;
                credType=$null ;
            } ;
            $uRoleReturn = resolve-UserNameToUserRole -UserName $Credential.username -verbose:$($VerbosePreference -eq "Continue") ; # Username
            write-verbose "w full cred opt: $uRoleReturn = resolve-UserNameToUserRole -Credential $Credential -verbose = $($VerbosePreference -eq 'Continue')"  ;
            if($uRoleReturn.UserRole){
                $o365Cred.credType = $uRoleReturn.UserRole ;
            } else {
                $smsg = "Unable to resolve `$credential.username ($($credential.username))"
                $smsg += "`nto a usable 'UserRole' spec!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ;
                Break ;
            } ;
        } else {
            if($MGCntxt.isConnected){
                if($MgCntxt.isUser){
                    $TenantTag = $TenOrg = get-TenantTag -Credential $MgCntxt.Account ;
                    $uRoleReturn = resolve-UserNameToUserRole -UserName $MgCntxt.CertificateThumbprint -verbose:$($VerbosePreference -eq "Continue") ;
                    $credential = get-TenantCredentials -TenOrg $TenOrg -UserRole $uRoleReturn.UserRole -verbose:$($VerbosePreference -eq "Continue") ;
                } elseif($MgCntxt.isCBA -AND $MgCntxt.AppName -match 'CBACert-(\w{3})'){
                        #$MgCntxt.AppName.split('-')[-1]
                        $TenantTag = $TenOrg = $matches[1]
                        # also need credential
                        $uRoleReturn = resolve-UserNameToUserRole -UserName $MgCntxt.CertificateThumbprint -verbose:$($VerbosePreference -eq "Continue") ;
                        write-verbose "ret'd obj:$uRoleReturn = [ordered]@{     UserRole = $null ;     Service = $null ;     TenOrg = $null ; } " ;
                        $credRet = get-TenantCredentials -TenOrg $TenOrg -UserRole $uRoleReturn.UserRole -verbose:$($VerbosePreference -eq "Continue")
                        $credential = $credRet.Cred ;
                }else{
                    $smsg = "UNABLE TO RESOLVE mgContext to a working TenOrg!" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                }
            } ;
            $pltGTCred=@{TenOrg=$TenOrg ; UserRole=$null; verbose=$($verbose)} ;
            if($UserRole){
                $smsg = "(`$UserRole specified:$($UserRole -join ','))" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $pltGTCred.UserRole = $UserRole;
            } else {
                $smsg = "(No `$UserRole found, defaulting to:'CSVC','SID' " ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $pltGTCred.UserRole = 'CSVC','SID' ;
            } ;
            $smsg = "get-TenantCredentials w`n$(($pltGTCred|out-string).trim())" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            $o365Cred = get-TenantCredentials @pltGTCred
        } ;
        if($o365Cred.credType -AND $o365Cred.Cred -AND $o365Cred.Cred.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
            $smsg = "(validated `$o365Cred contains .credType:$($o365Cred.credType) & `$o365Cred.Cred.username:$($o365Cred.Cred.username)" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            write-verbose "populate $credential with return, if not populated (may be required for follow-on calls that pass common $Credentials through)" ;
            if((gv Credential) -AND $Credential -eq $null){
                $credential = $o365Cred.Cred ;
            }elseif($credential.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                $smsg = "(`$Credential is properly populated; explicit -Credential was in initial call)" ;
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            } else {
                $smsg = "`$Credential is `$NULL, AND $o365Cred.Cred is unusable to populate!" ;
                $smsg = "downstream commands will *not* properly pass through usable credentials!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ;
                break ;
            } ;
        } else {
            $smsg = "UNABLE TO RESOLVE FUNCTIONAL CredType/UserRole from specified explicit -Credential:$($Credential.username)!" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            break ;
        } ;
        $pltCMG = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
        } ;
        if((get-command Connect-MG).Parameters.keys -contains 'silent'){
            $pltCMG.add('Silent',$silent) ;
        } ;
        #endregion cMG_SCAFFOLD ; #*------^ END cMG_SCAFFOLD ^------

        # 9:24 AM 1/13/2026: make remove-exolicense dyn:
        if(gcm get-ExoMailboxLicenses -ea 0){
            IF($ExMbxLicenses = get-ExoMailboxLicenses){
                TRY{
                    $TenantShortName = ((Get-MgOrganization -EA STOP).verifieddomains |?{$_.isdefault}).name.split('.')[0] ;
                    $ExGrantingLicenseSkuIds = @() ; 
                    # exclude any variant of: MICROSOFT_AGENT_365_TIER_3
                    #$rgxLicAgentExclude = '^MICROSOFT_AGENT_' ; (UP IN CONSTANTS)
                    $ExMbxLicenses.GetEnumerator() |
                        ?{$_.name -notmatch $rgxLicAgentExclude} | foreach-object{
                          $ExGrantingLicenseSkuIds += "$($TenantShortName):$($_.name)" ; 
                    } ; 
                    $smsg = "Resolved `$ExGrantingLicenseSkuIds:`n$(($ExGrantingLicenseSkuIds|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    if($ExGrantingLicenseSkuIds){
                        $LicenseSkuIds = $ExGrantingLicenseSkuIds ; 
                    };
                } CATCH {$ErrTrapd=$Error[0] ;
                    write-host -foregroundcolor gray "TargetCatch:} CATCH [$($ErrTrapd.Exception.GetType().FullName)] {"  ;
                    $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;                    
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    BREAK ; 
                } ;
                
            }ELSE{
                $smsg = "UNABLE TO:VXO\get-ExoMailboxLicenses()!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                BREAK 
            }

        }elseif(-not $LicenseSkuIds){
            $smsg = "Missing vxo\get-ExoMailboxLicenses(): Retrieve & build LicenseSkuIDS from global Meta vari" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success 
            $LicenseSkuKeys | foreach-object { $LicenseSkuIds += @((get-variable -name "$($tenorg)META").value[$_]) } ; 
        } else { 
            $smsg = "Explicit -LicenseSkuIds specified, using those licenses (in preference order)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            $LicenseSkuKeys = $LicenseSkuIds
        } ;

        #$rgxEmailAddr = '^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$ '
 
        $sBnr="`n#*======v $(${CmdletName}) : v======" ;
        $smsg = $sBnr ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        $admin = "$env:username" ;

        # check if using Pipeline input or explicit params:
        if ($PSCmdlet.MyInvocation.ExpectingInput) {
            write-verbose "Data received from pipeline input: '$($InputObject)'" ;
        } else {
            # doesn't actually return an obj in the echo
            #write-verbose "Data received from parameter input: '$($InputObject)'" ;
        } ;

    } ;  # BEGIN-E
    PROCESS{
        
        $ttl = ($users|measure).count ; $Procd=0 ;
        [array]$Rpt =@() ;
        
        foreach ($usr in $users){

            switch($usr.GetType().FullName){
                'Microsoft.Online.Administration.User' {
                    #$smsg = "(-user:MsolU detected:$($usr.userprincipalname), extracting the UPN...)" ;
                    $smsg = "MSOLUSER OBJECT IS NO LONGER SUPPORTED BY THIS FUNCTION! (flipping to resolvable UPN)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $usr = $usr.userprincipalname ;
                } ;
                'Microsoft.Open.AzureAD.Model.User' {
                    #$smsg = "(-user:AzureADU detected)" ;
                    $smsg = "AzureADU OBJECT IS NO LONGER SUPPORTED BY THIS FUNCTION! (flipping to resolvable UPN)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $usr = $usr.userprincipalname ;
                } ;
                # add missing MGGraphuser
                'Microsoft.Graph.PowerShell.Models.MicrosoftGraphUser' {
                    $smsg = "(-user:MGUser detected)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $usr = $usr.userprincipalname ;
                } ;
                'System.String'{
                    $smsg = "(-user:string detected)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    if($usr -match $rgxEmailAddress){

                        $smsg = "(-user:EmailAddress/UPN detected:$($usr))" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $usr = $usr ;
                    } else {
                        $smsg = "-Users: Unable to recognize either an MG user object, an MGUser object or a UPN string, from the specified input:`n$($usr)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        break ; 
                    } ; 
                }
                default{
                    $smsg = "Unrecognized format for -User:$($usr)!. Please specify either a user UPN, or pass a full MsolUser object." ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Break ;
                }
            }
            #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            # Looks like 1/5/2022, there are no spare E3's, maybe shift to the F3 ($TORMETA.o365LicSkuF1 = works to get mbx back).
            # (below defaults to the 'office 365 F3', the E3 alt is:  $tormeta.o365LicSkuE3 )
            # 12:06 PM 1/11/2022 add ExOnly: EXCHANGESTANDARD # Office 365 Exchange Online Only (commonly used for App
            $tUPN=$usr ;
            #$LicenseSkuIds=$TORMETA.o365LicSkuF1; # dyn from global XXXmeta
            $error.clear() ;
            TRY {

                $Exit = 0 ;
                Do {
                    Try {
                        #connect-aad @pltRXO ; 
                        $MGUser=$null ;
                        #$TenantShortName = ((Get-AzureADTenantDetail).verifieddomains |?{$_._default}).name.split('.')[0] ;
                        $pltGMGU=[ordered]@{ 
                            UserID = $tUPN ;
                            ErrorAction = 'STOP' ;
                            verbose = $($VerbosePreference -eq "Continue") ;
                        } ;
                        $MGUser = Get-MGUser @pltGMGU ;
                        $Exit = $Retries ;
                    } Catch {
                        Start-Sleep -Seconds $RetrySleep ;
                        $Exit ++ ;
                        $smsg = "Failed to exec cmd because: $($Error[0])" ;
                        $smsg += "`nTry #: $Exit" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        If ($Exit -eq $Retries) {
                            $smsg =  "Unable to exec cmd!" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ;
                        Continue ;
                    }  ;
                } Until ($Exit -eq $Retries) ;

                # 8:44 AM 12/21/2022 no, use the verb-EXO:test-EXOIsLicensed(): test-EXOIsLicensed -User $MGUser -verbose
                $IsExoLicensed = test-EXOIsLicensed -User $MGUser -Credential:$pltRXO.Credential -verbose:$pltRXO.verbose -silent:$pltRXO.silent ;
                $pltGLPList=[ordered]@{ 
                    TenOrg= $TenOrg;
                    verbose=$($VerbosePreference -eq "Continue") ;
                    credential= $pltRXO.credential ;
                    silent = $silent ; 
                } ;
                $smsg = "$($tenorg):get-MGlicensePlanList wn$(($pltGLPList|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $skus = $null ;
                $skus = get-MGlicensePlanList @pltGLPList ;

                $ombx = get-xomailbox -id $MGUser.UserPrincipalName -ea continue  ;
                $ombx = $ombx | ?{$_ -is [System.Management.Automation.PSObject]} # filtering any aberrant obj returned (legacy of prior problematic xow reliance to work around hybrid stepable pipeline bug)
                $MGLicDetails = get-MGUserLicenseDetailTDO -UPNs $MGUser.userprincipalname -Credential:$pltRXO.Credential -verbose:$pltRXO.verbose #-silent:$pltRXO.silent ; 
                #$MGLicDetails = get-MGUserLicenseDetailTDO -UPNs $MGUser.userprincipalname -Verbose:$($VerbosePreference -eq "Continue")
                $smsg = "`nExisting Mbx:`n$(($ombx | ft -a 'RecipientType','RecipientTypeDetails'|out-string).trim())" ;
                $smsg += "`n`$MGLicDetails`n$(($MGLicDetails|out-string).trim())" ;
                if($ombx.RecipientTypeDetails -eq 'SharedMailbox'){
                    $smsg += "`nSharedMailbox does not *require* a license" ;
                } ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                #if( -not($Force) -AND $ombx){
                <#if( -not($Force) -AND ($ombx.RecipientTypeDetails -eq 'SharedMailbox') ){
                    $smsg += "`n -- SKIPPING EXO-RELATED LICENSE Removal! --" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                } else
                #>
                if( ($IsExoLicensed) -OR ($Force) ){
                    # not supported on aadu: defer to: verb-AAD:test-AADUserIsLicensed(): $isLicensed = test-AADUserIsLicensed -user $MGUser -verbose
                    if($IsMGIsLicensed = test-MGUserIsLicensed -user $MGUser -Verbose:($VerbosePreference -eq 'Continue')){
                        # has a bozo lic that doesn't support a mailbox
                        $smsg = "MGUser:$($tUPN):  isLicensed (has some form of license added), and has an EXO UserMailbox-supporting license!" ;
                        $smsg += "`n(or is being -Force upgraded to an elevated license)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $smsg="confirmed $($MGUser.UserPrincipalName):is licensed/overlicensed" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;


                    foreach($LicenseSkuId in $LicenseSkuIds){
                        if( $LicenseSkuId.contains(':') ){
                            $LicenseSkuId = $LicenseSkuId.split(':')[1] ;
                            # need the skuid, not the name, could pull another licplan list indexedonName, but can also post-filter the hashtable, and get it.
                            $LicenseSkuId = ($skus.values | ?{$_.SkuPartNumber -eq $LicenseSkuId}).skuid ;
                        } ;
                        #$smsg = "(attempting license:$($LicenseSkuId)...)" ;
                        $smsg = "(attempting license:$(($skus.values | ?{$_.Skuid -eq $LicenseSkuId}).SkuPartNumber):$($LicenseSkuId)...)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        $pltRMGUL=[ordered]@{
                            Users=$MGUser.UserPrincipalName ;
                            skuid=$LicenseSkuId ;
                            Credential = $pltRXO.Credential ; 
                            verbose = $pltRXO.verbose  ; 
                            silent = $false ; 
                            erroraction = 'STOP' ;
                            whatif = $($whatif) ;
                        } ;
                        $smsg = "remove-MGUserLicense w`n$(($pltRMGUL|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        $bRet = remove-MGUserLicense @pltRMGUL ;
                        if($bRet.Success){
                            $smsg = "remove-MGUserLicense removed Licenses:$($bRet.RemovedLicenses)" ;
                            # $MGUser.AssignedLicenses.skuid
                            $smsg += "`n$(($MGUser.AssignedLicenses.skuid|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            $smsg = "Detailed Return:`n$(($bRet|out-string).trim())" ;
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            #BREAK ; # process through all lic potential removals
                        } elseif($whatif){
                            $smsg = "(whatif pass, exec skipped), " ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } elseif( -not [boolean]($bRet.RemovedLicensess)){
                            # failed removal
                            $smsg = "Failed Lic Removal:$($LicenseSkuId) (moving on to next if avail...)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Continue ;
                        } else {
                            $smsg = "FAILED TO UPDATE !" ;
                            $smsg += "`n$(($bRet|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #$Report.FixedUsageLocation = $false ;
                            if(-not $whatif){
                                BREAK;
                            }
                        } ;

                    } ;  # loop-E $LicenseSkuIds

                    #connect-aad @pltRXO ; 
                    $MGUser=$null ;
                    #$TenantShortName = ((Get-AzureADTenantDetail).verifieddomains |?{$_._default}).name.split('.')[0] ;
                    $pltGMGU=[ordered]@{ 
                        UserID = $tUPN ;
                        ErrorAction = 'STOP' ;
                        verbose = $($VerbosePreference -eq "Continue") ;
                    } ;
                    # refresh ADU post chgs & test xmbx lic stat
                    $MGUser = Get-MGUser @pltGMGU ;
                    if(-not $LicenseSkuIds){
                        # running explicit LicenseSkuIds may not have removed all EXO lic's, so no point in doing a followup confirm license-free
                        $IsExoLicensed = test-EXOIsLicensed -User $MGUser -Credential:$pltRXO.Credential -verbose:$pltRXO.verbose -silent:$pltRXO.silent ;
                        if($IsExoLicensed){
                            $smsg = "MGUser still coming back with mounted EXO-supporting license. `nRe-Running remove-EXOLicesnse pass..." ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            $pltRxLic=[ordered]@{
                                users=$MGUser.userprincipalname ;
                                ticket=$ticket ;
                                whatif=$($whatif) ;
                                Verbose=$($VerbosePreference -eq "Continue")
                                Credential = $pltRXO.Credential ;
                                silent = $false ; 
                            } ;
                            if($UserRole){
                                $smsg = "(recycle `$UserRole from script)" ; 
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                $pltRxLic.UserRole = $UserRole ; 
                            } ; 
                            #$smsg = "remove-EXOLicense w`n$(($pltRxLic|out-string).trim())" ;
                            #if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            #else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $bRet = remove-EXOLicense @pltRxLic ;
                            if($bRet) {$MGUser = $bRet } ; 
                        } else { 
                            $smsg = "Validated:$($MGUser.userprincipalname): is now EXO-unlicensed" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        } ; 
                    } elseif($whatif){
                        $smsg = "-whatif: skipping post-validation" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    } else { 
                        # running explicit LicenseSkuIds may not have removed all EXO lic's, so no point in doing a followup confirm license-free
                        $smsg = "-LicenseSkuId specified: Skipping broad test-ExoIsLicensed confirmations" ; 
                        $smsg += "`nsolely the licenses specified would have been removed," ; 
                        $smsg += "`nand may not be the complete EXO-license set" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    } ; 

                };  # if-E $ombx

            } CATCH {     
                $ErrTrapd=$Error[0] ;
                $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                Break ;
            } ;
            if(!$whatif){
                $smsg = "dawdling to ensure License change doesn't soft-delete mailbox..." ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $1F=$false ;
                Do {
                    if($1F){Sleep -s 30} ;
                    write-host "." -NoNewLine ;
                    $1F=$true ;
                #} Until (get-xomailbox -id $oMSUsr.userprincipalname -EA 0) ;
                } Until ($ombx = get-xomailbox -id $MGUser.userprincipalname -EA 0) ; # capture return (prevent from dropping into pipe)
                # get-xomailbox returns: System.Management.Automation.PSObject; not a real Mailbox object class
                $ombx = $ombx | ?{$_ -is [System.Management.Automation.PSObject]} ; # looks like an attempt to filter just the mailbox out of the pipeline return
                $smsg = "xo Mailbox confirmed!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;

            # return $MGUser to pipeline if populated

            $MGUser | write-output ;

            $smsg =  $sBnr.replace('=v','=^').replace('v=','^=') ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; # ($usr in $users)

    } # PROC-E
    END{
        <#
        $stopResults = stop-transcript ;
        $smsg = $stopResults ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #>
     } ;
 }

#*------^ remove-EXOLicense.ps1 ^------


#*------v Reset-xoMailboxFolderPermissionsRecursive.ps1 v------
function Reset-xoMailboxFolderPermissionsRecursive {
    <#
    .SYNOPSIS
    Reset-xoMailboxFolderPermissionsRecursive - Restores the default permissions for all user-accessible folders for a given mailbox. Can also be used to remove broken recipients. 
   .NOTES
    Version     : 1.0.0
    Author      : Vasil Michev
    Website     : https://www.michev.info/blog/post/2500/how-to-reset-mailbox-folder-permissions
    Twitter     :	
    CreatedDate : 2022-06-15
    FileName    : reset-XOMailboxAllFolderPerms.ps1
    License     : Not Asserted
    Copyright   : Not Asserted
    Github      : https://github.com/michevnew/PowerShell/blob/master/reset-XOMailboxAllFolderPerms.ps1
    Tags        : Powershell,ExchangeOnline,Mailbox,Delegate
    AddedCredit : Todd Kadrie
    AddedWebsite: http://www.toddomation.com
    AddedTwitter: @tostka / http://twitter.com/tostka
    REVISIONS
    * 1:44 PM 9/25/2023 debuged, whatif working; moved includedfolders, excludedfolders into targetable pre-populated params (as overriding code lists in a signed module is a mess; but a param can be done on the fly); 
         strip away outter wrapper script, in favor of descrete (verb-EXO-hosted) reusable functions; added $ThrottleMs fallback; expanded w-v, w-h & w-w into pswlt support
    * 4:43 PM 9/21/2023 works, used on 760151;  add option: We want to leave INTERNAL/EXTERNAL existing, but remove UNKNOWNS: neither is addressed by default below (INT/EXT are set to NONE, and UNKN is *ignored*).
        Add param: -RemoveUnresolveable -> targets usertype:UNKNOWN, including getr-adusere solvable, that lack populated msExchRecipientTypeDetails property
        Add param: -IgnoreInternal - skips reset of existing usertype:Internal to NONE
        Add param: -IgnoreExternal - skips reset of existing usertype:External to NONE
    * 3:35 PM 7/11/2023 works; ADD:$CalendarLimitedDetails param, to drive variant 
    default view (customized in our org), passed in via psboundparameters; 
    completely refactored ExchangeOnlineManagement ineraction to accomodate loss of 
    WinRM/PSSession connections in EOM3+; minor reformatting, added root CBH 
    * 6/15/22 vm posted version
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 12:53 PM 9/22/2023 reflect ren of ReturnFolderList -> get-XOMailboxFolderList; GetFolderPermissions -> get-XOMailboxFolderPermissionsSummary
    * 3:03 PM 7/11/2023 ADD:$CalendarLimitedDetails param, to drive variant default view (customized in our org), passed in via psboundparameters

    .DESCRIPTION
    Reset-xoMailboxFolderPermissionsRecursive - Restores the default permissions for all user-accessible folders for a given mailbox. Can also be used to remove broken recipients. 

    The Reset-xoMailboxFolderPermissionsRecursive cmdlet removes permissions for all user-accessible folders for the given mailbox(es), specified via the -Mailbox parameter. 
    The list of folders is generated via the get-XOMailboxFolderList function. 
    Configure the $includedfolders and $excludedfolders variables to granularly control the folder list.

    Default Actions:
    - wo use of ResetDefaultLevel, Existing Defaults are left unmodified
    - Existing Anonymous grants are also always left unmodified (it uses Continue, and skips any interaction with the grants).
    - If ResetDefaultLevel is used: 
        * This forces Default Calendar grants to AvailabilityOnly (MS Default) (or LimitedDetails, if CalendarLimitedDetails:$true): Set-MailboxPermission
        * and ANY OTHER Default is forced to NONE. 
        -> It strips all but Cal Default access.
    - ALL Internal & External usertype grants are REMOVED completely.

    If -Quiet is *not* used, modifications information is exported to a file in local directory named: 
    yyyy-MM-dd_HH-mm-ss_MailboxFolderPermissionsRemoved.csv (and the same info is returned as an object to pipeline)

    As originally written, this was *selective*, doesn't go after UNKNOWN "orphans" at all. clearly MV, as an MVP knows something that I don't, 
    to choose to leave UNKNOWN's unpurged while purging all existing non-Default/non-Anon Internal|External user-created entries.

    -----------
    ## Unable to find formal docs, taking a stab at _imputing_ the intent of the UserType variants:
    - Default is the generic 'class' grant for users that authenticated with the domain but don't have specific permission.
    - Anonymous is the generic 'class' grant for users that are NOT authenticated with the domain.
    - Internal appears to reflect manually-added (non-Default) grants to objects in the mailbox, that resolve to Recipient Objects
    - External appears to reflect manually-added (non-Default) grants to objects in the mailbox, that resolve to external Recipient Objects
    - Unknown appears (observed):
        - sometimes are named UserName references but consistently lack UserName (resolved RecipientPrincipal.guid.guid). 
        - frequently as broken SID references: NT:S-1-5-21-*
        - both deleted ADUser objects...
             Unable to resolve S-1-5-21-2222296782-158576315-1096482972-3663 to an existing ADUser object (likely deleted TERM)
        ... and ADUser objects that resolve in AD:
            #-=-=-=-=-=-=-=-=
            WARNING: 09:54:03:Resolved
             S-1-5-21-2222296782-158576315-1096482972-39941
             to an existing ADUser object:
            DistinguishedName : CN=FNAME LNAME,OU=Disabled,OU=Users,OU=SITE,DC=SUB,DC=SUB,DC=DOMAIN,DC=com
            enabled           : False
            samaccountname    :  ______x
            sid               : S-1-5-21-2222296782-158576315-1096482972-39941
            UserPrincipalName : FNAME.LNAME.Nelson@DOMAIN.com
            #-=-=-=-=-=-=-=-=
       - opinion: likely resolvable ADU are non-recipients: lacking in msex* attribs on ADU. But are still non-functional: confirm
            [PS]:D:\scripts $ get-aduser -id S-1-5-21-2222296782-158576315-1096482972-39941 -prop * | fl userp*,msex*
            UserPrincipalName            : FNAME.LNAME.Nelson@DOMAIN.com
            msExchALObjectVersion        : 3610
            msExchOmaAdminWirelessEnable : 4
            msExchWhenMailboxCreated     : 2/21/2011 5:24:16 AM
            -> all it's got is the 3 msex's above. Everything else is gone. Prob key test is going to be recipienttypedetails
            #-=-=-=-=-=-=-=-=
            msExchRecipientDisplayType : -2147483642
            msExchRecipientTypeDetails : 2147483648
            msExchRemoteRecipientType  : 4
            msExchSafeRecipientsHash   : {142, 23, 177, 78}
            #-=-=-=-=-=-=-=-=
        => Test get-aduser -prop * | msExchRecipientTypeDetails: if doesn't resolve, purge the NT:S-1-5-21-* entry
        -----------
    And there's a brand new EOM31+ version available today:
    [Managing mailbox folder permissions in bulk in Microsoft 365 - Blog](https://www.michev.info/blog/post/5763/managing-mailbox-folder-permissions-in-bulk-in-microsoft-365)
    # September 20, 2023	Vasil Michev

    --
    [How to reset mailbox folder permissions - Blog](https://www.michev.info/blog/post/2500/how-to-reset-mailbox-folder-permissions)

    what is the best (or at least a proper) way to "reset" folder level 
    permissions, with the added challenge of doing it in bulk

    First of all, if you simply want to "reset" the permissions on a given, 
    "known" folder, the task is easy. Say we have the user JohnSmith and we want to 
    remove any permissions on his Calendar folder

    Next, we need to exclude the "default" permissions entries, as in the 
    ones configured for the Default and Anonymous security principals. 
 
    There are many additional factors that we need to address, such as the actual 
    folder names, as depending on the localization, the Calendar folder might be 
    renamed to Kalender or whatnot. Then, what if we want to include all folders in 
    the mailbox, not just Calendar? And there are things to consider when removing 
    the permissions as well, such as dealing with orphaned entries, external 
    permissions, published Calendars 

    the building blocks we need to put together:
 
    - Account for the type of User, and depending on it handle things accordingly. 
    In other words, for each permission entry, look at the _$entry.User.UserType.Value_.
    Available values will include _Internal_, _External_ and _Unknown_ 
    and all of these will have to be handled differently

    - Utilize the _Get-MailboxFolderStatistics_ cmdlet to get a list of the 
    localized folder names and trim the list to only include folders you care about.
    There's no point in adjusting permissions on Purges folder for example

    - If you are using the above method to get the localized folder names 
    across multiple mailboxes, you need to start to account for throttling!
 
    - Decide what you want to do with the Default (and Anonymous) permission level. 
    The regex we used in the above example can be generalized to exclude other 
    entries as well, if needed


    --- Stock setting: 
    Check calendar folder permissions using Get-MailboxFolderPermission user:\calendar 
    and see if Default user has None permissions. Default user should have "AvailabilityOnly"(MS Default) or "LimitedDetails" (TTC)
    --- 
    Relevent discussion on the need/desire to purge broken SID NT:S-1... entries (in public folders in this case: breaks cloud migration).
    https://techcommunity.microsoft.com/legacyfs/online/media/2019/01/FB_Errors.FixesV6.pdf

    ---

    [Correcting Public Folder Permissions before an Office 365 Migration | Practical365](https://practical365.com/correcting-public-folder-permissions-before-an-office-365-migration/)
    Written By Steve Goodman Post published:April 1, 2020
    ...
    > Microsoft's [Source Side Validation 
    script](https://www.microsoft.com/en-us/download/confirmation.aspx?id=100414), 
    described in the blog post above, will generate a log file showing amongst 
    other things, orphaned ACLs you need to remove. However, it doesn't go as far 
    as to assist with the removal itself

    Within the file we'll see lines saying this folder <foldername> permission 
    needs to be removed for NT User:<SID>

    These lines are showing an orphaned ACL. The orphaned ACL occurs when a 
    user is deleted from Active Directory, but the permission is not removed from 
    the Public Folder. This leaves just the security identifier (the SID) showing 
    because it cannot be resolved to an actual user account

    This is a problem because when the folder is migrated to Office 365, the 
    permission cannot be re-applied as the user doesn't exist anymore

    The guidance on the Microsoft blog post doesn't provide you much detail 
    on how to use the log file to remove the permissions, and the guidance it does 
    give doesn't work on Exchange 2010. This is where the 
    Remove-PFPermissionsFromSSV script comes in.   

    The script takes the lines from the log file, and for each line with a 
    permission listed, it uses a command like the one below togGet the folder 
    permissions, find the offending permission entry, and then remove it:
 
    Get-PublicFolderClientPermission -Identity <Folder>| Where {$_.User -like 
    <SID>} | Remove-PublicFolderClientPermission -Confirm:$False 

    The story would end here if Microsoft's script was perfect, and unfortunately 
    on a recent migration I encountered a scenario where it didn't pick up all 
    problem ACLs

    The scenario in question was one where my customer, after migration, was 
    converting leaver's mailboxes to shared mailboxes. Quite rightly they were 
    following [this support 
    article](https://support.microsoft.com/en-gb/help/2710029/shared-mailboxes-are-unexpectedly-converted-to-user-mailboxes-after-di) 
    from Microsoft which recommends setting the _msExchRecipientTypeDetails_ to a 
    particular value. The result of that corrupted the way the permissions are 
    evaluated on the Public Folder permissions, so that they do not appear to be 
    "ACLable" (assignable as permissions)

    Upon further investigation, this also applies in another scenario – where 
    you remove Exchange attributes from a Mailbox but keep the underlying Active 
    Directory account (i.e. you run _Disable-Mailbox_). In that scenario the 
    permission also shows in the same way and cannot be applied on the destination 
    – nor can it be used by a user

    When this occurs the permission shows like this when examining it using 
    _Get-PublicFolderClientPermission_ or by using _ExFolders_:
 
    ![Correcting Public Folder Permissions before an Office 365 
    Migration](https://www.practical365.com/wp-content/uploads/2020/04/image-5.png)
 
    As you can see in the above example, it is prefixed with _NT User:_ and the 
    account name, rather than resolving to a Mailbox, Remote Mailbox or other 
    recipient

    To search for and then resolve this scenario, I've created a simple 
    script called _Remove-NTUSER.ps1_, which you can [download from my GitHub](https://github.com/spgoodman/p365scripts/blob/master/Remove-NTUSER.ps1).


    #-=-=-=-=-=-=-=-=

    .PARAMETER Mailbox
    Use the -Mailbox parameter to designate the mailbox. Any valid Exchange mailbox identifier can be specified. Multiple mailboxes can be specified in a comma-separated list or array, see examples below.
    .PARAMETER ResetDefaultLevel
    Switch to specify reset to *include* default permissions (e.g. coerce Default SecPrin to 'LimitedDetails' & Anonymous:None)
    .PARAMETER CalendarLimitedDetails
    Switch to default Calendar folder view to customized LimitedDetails (vs default AvailabilityOnly)
    .PARAMETER RemoveUnresolveable
    Switch to Remove broken-SID/non-ADUser-resolvable entries targets usertype:UNKNOWN, including getr-adusere solvable, that lack populated msExchRecipientTypeDetails property
    .PARAMETER IgnoreInternal
    Switch to ignore/leave-intact any pre-existing usertype:Internal folder grants
    PARAMETER IgnoreExternal
    Switch to ignore/leave-intact any pre-existing usertype:External folder grants
    .PARAMETER Ticket
    Ticket number
    .PARAMETER Quiet
    Use the -Quiet switch if you want to suppress output to the console.
    .PARAMETER includedfolders
    Configurable string array of folder names to be *included* in processing (generally defaults to these; override to use customize/targed list)[-includedfolders @('Inbox','Calendar')]
    .PARAMETER excludedfolders
    Configurable string array of folder names to be *excluded* from processing (generally defaults to these; override to use customize/targed list)[-excludedfolders @('Inbox','Calendar')]
    .PARAMETER Verbose
    The -Verbose switch provides additional details on the cmdlet progress, it can be useful when troubleshooting issues.
     .INPUTS
    A mailbox identifier.
    .OUTPUTS
    Array of Mailbox address, Folder name and User.
    .EXAMPLE
    PS> Reset-xoMailboxFolderPermissionsRecursive -Mailbox emailaddress@domain.com -ResetDefaultLevel -verbose -whatif:$true
    Typical single user FULL RESET pass , with Whatif & verbose. Includes RESET of all Default role grants to stock UNMODIFIED settings:
    - Effectively WIPES ALL USER-MODIFICATIONS from all user/publicl-accessible folders of the mailbox, 
    - Resets Calendar(s):Default role to 'LimitedDetails' (TTC, MS Default 'AvailabilityOnly' can be set using -CalendarLimitedDetails:$false) & Anonymous role:None. 
    - All other modifications perms are removed, including user configured Internal & External grants. 
    .EXAMPLE
    PS> Reset-xoMailboxFolderPermissionsRecursive -Mailbox 
    Typical single-user pass no ResetDefaultLevel (any user-modifications to the Default & Anonymous roles are left intact), commit updates.
    .EXAMPLE
    PS> Reset-xoMailboxFolderPermissionsRecursive -Mailbox emailaddress@domain.com -ticket 123456 -RemoveUnresolveable -IgnoreInternal -IgnoreExternal -whatif:$false  ; 
    Single user pass, no Default Rest, targets removal of Unresolvable 'broken' grants (NT:S-1-5-21-...) from all user/public-accessible mailbox folders.
    .EXAMPLE
    PS> Reset-xoMailboxFolderPermissionsRecursive -Mailbox emailaddress@domain.com -ticket 123456 -IgnoreInternal -IgnoreExternal -whatif:$false  ; 
    Single user pass, no Default Rest, specifies to ignore both External & Internal user-added grants (left intact). 
    Effectively, this does nothing. Defaults are left unreset. Unknown/broken aren't targeted. and even default Internal/Externals are left untargeted.
    .EXAMPLE
    PS> Reset-xoMailboxFolderPermissionsRecursive -Mailbox @('emailaddress@domain.com','emailaddres2s@domain.com') -ResetDefaultLevel -verbose -whatif:$true
    Typical two-user pass as array, using specifying to include reset of all Default role grants to stock unmoidifed settings, with Whatif & verbose. 
    .EXAMPLE
    PS> Reset-xoMailboxFolderPermissionsRecursive -Mailbox @('emailaddress@domain.com','emailaddres2s@domain.com') -CalendarLimitedDetails:$false ;
    Demo override CalendarLimitedDetails (use the MS default Calendar visibility, 'AvailabilityOnly' (vs this script's default variant 'LimitedDetails').
    .EXAMPLE
    PS> Get-ADPermission -Identity "Christopher Payne" | ?{$_.user -like "S-1-5-21*"} | Remove-ADPermission
    Remove orphaned SID with Exchange Onprem PowerShell
    .EXAMPLE
    Reset-xoMailboxFolderPermissionsRecursive -Mailbox (Get-Mailbox -RecipientTypeDetails RoomMailbox) -Verbose
    This command removes permissions on all user-accessible folders in ALL Room mailboxes in the organization.
    .LINK
    https://github.com/tostka/powershell
    #>
    #Requires -Version 3.0
    [CmdletBinding(SupportsShouldProcess)] #Make sure we can use -WhatIf and -Verbose
    #[CmdletBinding()
    PARAM(
        [Parameter(Mandatory=$False,HelpMessage="Ticket Number [-Ticket '999999']")]
            [string]$Ticket,
        [Parameter(Mandatory=$true,ValueFromPipeline=$false,HelpMessage="Use the -Mailbox parameter to designate the mailbox. Any valid Exchange mailbox identifier can be specified. Multiple mailboxes can be specified in a comma-separated list or array, see examples below.")]
            [ValidateNotNullOrEmpty()]
            [Alias("Identity")]
            [String[]]$Mailbox,
        [Parameter(HelpMessage="Switch to specify reset to *include* default permissions")]
            [switch]$ResetDefaultLevel,
        # "AvailabilityOnly" v LimitedDetails custom
        [Parameter(HelpMessage="Switch to default Calendar folder view to customized LimitedDetails (vs default AvailabilityOnly)")]
            [switch]$CalendarLimitedDetails=$true,
        [Parameter(HelpMessage="Switch to Remove broken-SID/non-ADUser-resolvable entries")]
            [switch]$RemoveUnresolveable,
        [Parameter(HelpMessage="Switch to ignore/leave-intact any pre-existing usertype:Internal folder grants[-IgnoreInternal]")]
            [switch]$IgnoreInternal,
        [Parameter(HelpMessage="Switch to ignore/leave-intact any pre-existing usertype:External folder grants[-IgnoreInternal]")]
            [switch]$IgnoreExternal,
            [switch]$Quiet,
        [Parameter(HelpMessage="Configurable string array of folder names to be *included* in processing (generally defaults to these; override to use customize/targed list)[-includedfolders @('Inbox','Calendar'))")]        
            [string[]]$includedfolders = @("Root","Inbox","Calendar","Contacts","DeletedItems","Drafts","JunkEmail","Journal","Notes","Outbox","SentItems","Tasks","CommunicatorHistory","Clutter","Archive"), 
        [Parameter(HelpMessage="Configurable string array of folder names to be *excluded* from processing (generally defaults to these; override to use customize/targed list)[-excludedfolders @('Inbox','Calendar')]")]        
            [string[]]$excludedfolders = @("News Feed","Quick Step Settings","Social Activity Notifications","Suggested Contacts", "SearchDiscoveryHoldsUnindexedItemFolder", "SearchDiscoveryHoldsFolder","Calendar Logging")
        #[Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
        #    [switch] $whatIf
    ) ; 
    # $CalendarLimitedDetails isn't coming through clean, force it up and move on for now
    BEGIN{
        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
        write-verbose "`$PSBoundParameters:`n$(($PSBoundParameters|out-string).trim())" ;
        $Verbose = ($VerbosePreference -eq 'Continue') ; 
        if($WhatIfPreference){
            $whatif = $true ; 
        } else { $whatif = $false } ; 

        $DefaultRoleUserNames = @("Default","Anonymous","Owner@local","Member@local") ; 
        if(!$ThrottleMs){$ThrottleMs = 500} ; 

        if($CalendarLimitedDetails){$CalPermsDefault = 'LimitedDetails' }
        else {$CalPermsDefault = 'AvailabilityOnly' }

        #$includedfolders = @("Root","Inbox","Calendar", "Contacts", "DeletedItems", "Drafts", "JunkEmail", "Journal", "Notes", "Outbox", "SentItems", "Tasks", "CommunicatorHistory", "Clutter", "Archive") ; 
        #$includedfolders = @("Root","Inbox","Calendar", "Contacts", "DeletedItems", "SentItems", "Tasks") #Trimmed down list of default folders
        #Exclude additional Non-default folders created by Outlook or other mail programs. Folder NAMES, not types! So make sure to include translations too!
        #Exclude SearchDiscoveryHoldsFolder and SearchDiscoveryHoldsUnindexedItemFolder as they're not marked as default folders #Exclude "Calendar Logging" on older Exchange versions
        #$excludedfolders = @("News Feed","Quick Step Settings","Social Activity Notifications","Suggested Contacts", "SearchDiscoveryHoldsUnindexedItemFolder", "SearchDiscoveryHoldsFolder","Calendar Logging") ; 
        $prpADU = 'DistinguishedName','enabled','samaccountname','sid','UserPrincipalName' ; 

        #region ENVIRO_DISCOVER ; #*------v ENVIRO_DISCOVER v------
        #if ($PSScriptRoot -eq "") {
        # 8/29/2023 fix logic break on psv2 ISE (doesn't test PSScriptRoot -eq '' properly, needs $null test).
        #if( -not (get-variable -name PSScriptRoot -ea 0) -OR ($PSScriptRoot -eq '')){
        if( -not (get-variable -name PSScriptRoot -ea 0) -OR ($PSScriptRoot -eq '') -OR ($PSScriptRoot -eq $null)){
            if ($psISE) { $ScriptName = $psISE.CurrentFile.FullPath } 
            elseif($psEditor){
                if ($context = $psEditor.GetEditorContext()) {$ScriptName = $context.CurrentFile.Path } 
            } elseif ($host.version.major -lt 3) {
                $ScriptName = $MyInvocation.MyCommand.Path ;
                $PSScriptRoot = Split-Path $ScriptName -Parent ;
                $PSCommandPath = $ScriptName ;
            } else {
                if ($MyInvocation.MyCommand.Path) {
                    $ScriptName = $MyInvocation.MyCommand.Path ;
                    $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                } else {throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" } ;
            };
            if($ScriptName){
                $ScriptDir = Split-Path -Parent $ScriptName ;
                $ScriptBaseName = split-path -leaf $ScriptName ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($ScriptName) ;
            } ; 
        } else {
            if($PSScriptRoot){$ScriptDir = $PSScriptRoot ;}
            else{
                write-warning "Unpopulated `$PSScriptRoot!" ; 
                $ScriptDir=(Split-Path -parent $MyInvocation.MyCommand.Definition) + "\" ;
            }
            if ($PSCommandPath) {$ScriptName = $PSCommandPath } 
            else {
                $ScriptName = $myInvocation.ScriptName
                $PSCommandPath = $ScriptName ;
            } ;
            $ScriptBaseName = (Split-Path -Leaf ((& { $myInvocation }).ScriptName))  ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
        } ;
        if(-not $ScriptDir){
            write-host "Failed `$ScriptDir resolution on PSv$($host.version.major): Falling back to $MyInvocation parsing..." ; 
            $ScriptDir=(Split-Path -parent $MyInvocation.MyCommand.Definition) + "\" ;
            $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ; 
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;     
        } else {
            if(-not $PSCommandPath ){
                $PSCommandPath  = $ScriptName ; 
                if($PSCommandPath){ write-host "(Derived missing `$PSCommandPath from `$ScriptName)" ; } ;
            } ; 
            if(-not $PSScriptRoot  ){
                $PSScriptRoot   = $ScriptDir ; 
                if($PSScriptRoot){ write-host "(Derived missing `$PSScriptRoot from `$ScriptDir)" ; } ;
            } ; 
        } ; 
        if(-not ($ScriptDir -AND $ScriptBaseName -AND $ScriptNameNoExt)){ 
            throw "Invalid Invocation. Blank `$ScriptDir/`$ScriptBaseName/`ScriptNameNoExt" ; 
            BREAK ; 
        } ; 

        $smsg = "`$ScriptDir:$($ScriptDir)" ;
        $smsg += "`n`$ScriptBaseName:$($ScriptBaseName)" ;
        $smsg += "`n`$ScriptNameNoExt:$($ScriptNameNoExt)" ;
        $smsg += "`n`$PSScriptRoot:$($PSScriptRoot)" ;
        $smsg += "`n`$PSCommandPath:$($PSCommandPath)" ;  ;
        write-verbose $smsg ; 
        #endregion ENVIRO_DISCOVER ; #*------^ END ENVIRO_DISCOVER ^------        
        write-verbose "checking depednant function availability..." ; 
        $depCmdlets = @('get-XOMailboxFolderList','get-XOMailboxFolderPermissionsSummary') ; 
        $depCmdlets | foreach-object{if(get-command $_ ){write-verbose "gcm'd:dependant function:$($_)"} else { $smsg = "Missing dependant function:$($_)" ; write-warning $smsg ; throw $smsg ; }} ;
        # EOM3+ NO PSS SUPP
        #if (-not ((Get-ConnectionInformation).tokenstatus -eq 'Active')){ Write-Error "No active Exchange connection detected, please connect first. To connect to ExO: https://technet.microsoft.com/en-us/library/jj984289(v=exchg.160).aspx" -ErrorAction Stop ;} ; 
        #Prepare the list of mailboxes
        $smsg = "Parsing the Mailbox parameter..."
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        $SMTPAddresses = @{}
        foreach ($mb in $Mailbox) {
            Start-Sleep -Milliseconds 80 #Add some delay to avoid throttling...
            #Make sure a matching mailbox is found and return its Primary SMTP Address
            #$SMTPAddress = (Invoke-Command -Session $session -ScriptBlock { Get-Mailbox $using:mb | Select-Object -ExpandProperty PrimarySmtpAddress } -ErrorAction SilentlyContinue).Address
            # eom3+ direct no pss
            #$SMTPAddress = Get-xoMailbox $mb | Select-Object -ExpandProperty PrimarySmtpAddress -ErrorAction SilentlyContinue;
            #*======v BP Wrapper for running EXO dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp) v======
            # define the splat of all params:
            $pltGMbx = [ordered]@{identity =  $mb ; erroraction = 'STOP'; verbose = $($VerbosePreference -eq "Continue") ;} ;
            $cmdlet = 'get-Mailbox' ; $verb,$noun = $cmdlet.split('-') ;  #Spec cmdletname (VERB-NOUN), & split v/n
            TRY{$xoS = Get-ConnectionInformation -ErrorAction STOP }CATCH{reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP }
            TRY{
                if((-not $xos) -OR ($xoS | ?{$_.tokenstatus -notmatch 'Active|Expired' -AND $_.State -ne 'Connected'} )){reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP } ; 
                if($xos){
                    $xcmd = "$verb-$($xoS.ModulePrefix)$noun `@pltGMbx" ; # build cmdline w splat, then echo:
                    $smsg = "$($([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value)) w`n$(($pltGMbx|out-string).trim())" ;
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    $SMTPAddress  = invoke-expression $xcmd  | 
                        Select-Object -ExpandProperty PrimarySmtpAddress -ErrorAction SilentlyContinue;
                    if($SMTPAddress){
                        $smsg = "(confirmed valid $([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value) output)" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                    }
                } else { 
                    $smsg = "Missing `$xos EXO connection!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    throw $smsg ; BREAK ; 
                } 
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            } ; 
            <# version 12:43 PM 9/21/2023 moved cixo up to 1st, won't have prefix if not populated, also needs to fail/retry to ensure conn;  
            11:48 AM 9/20/2023 minor tweaks ; 3:01 PM 9/19/2023 initial 
            ## this runs: 1) connection status check, w rxo on demand; 2) splat wrapper with integrated prefix support; 3) try/catch on exec; 
            useful alias: cixo => get-connectioninformation;
            #>
            #*======^ END BP wrapper for running dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp)  ^======
            if (-not $SMTPAddress) { if (-not $Quiet) { 
                $smsg = "Mailbox with identifier $mb not found, skipping..." ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; }; 
                continue 
            } elseif (($SMTPAddress.count -gt 1) -or ($SMTPAddresses[$mb]) -or ($SMTPAddresses.ContainsValue($SMTPAddress))) { 
                $smsg = "Multiple mailboxes matching the identifier $mb found, skipping..."; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                continue 
            }else { $SMTPAddresses[$mb] = $SMTPAddress } ; 
        }
        if (-not $SMTPAddresses -or ($SMTPAddresses.Count -eq 0)) { Throw "No matching mailboxes found, check the parameter values." } ; 
        $smsg = "The following list of mailboxes will be used: ""$($SMTPAddresses.Values -join ", ")""" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
        $smsg = "List of default folder TYPES that will be used: ""$($includedfolders -join ", ")""" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
        $smsg = "List of folder NAMES that will be excluded: ""$($excludedfolders -join ", ")""" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
    }
    PROCESS{
        $out = @() ; 
        foreach ($smtp in $SMTPAddresses.Values) {
            $smsg = $sBnrS="`n#*------v PROCESSING Mailbox: $($smtp)... v------" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H2 } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            Start-Sleep -Milliseconds 800  ; #Add some delay to avoid throttling...
            $smsg = "Obtaining folder list for mailbox ""$smtp""..." ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            $folders = get-XOMailboxFolderList $smtp ; 
            $smsg = "A total of $($folders.count) folders found for $($smtp)." ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            if (-not $folders) {
                $smsg = "No matching folders found for $($smtp), skipping..." ; 
                continue  ; 
            } ; 
            #Cycle over each folder we are interested in
            foreach ($folder in $folders) {
                $smsg = "`n==PROCESSING:$($folder.name)`n" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H3 } 
                else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                #"Fix" for folders with "/" characters, treat the Root folder separately
                if ($folder.FolderType -eq "Root") { $foldername = $smtp }
                else { $foldername = $folder.Identity.ToString().Replace([char]63743,"/").Replace($smtp,$smtp + ":") } ; 
                $fPermissions = get-XOMailboxFolderPermissionsSummary $foldername
                if (-not $ResetDefaultLevel) { 
                    $smsg = "no -ResetDefaultLevel: exempting username:$($DefaultRoleUserNames -join '|') from processing" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;  ; 
                    $fPermissions = $fPermissions | ? {$_.UserName -notin @("Default","Anonymous","Owner@local","Member@local")}
                    #$fPermissions = $fPermissions | ? {$_.UserName -notin @($($DefaultRoleUserNames)))}
                }  ; #filter out default permissions -> doesn't process defaults, leaves them intact
                if (-not $fPermissions) { 
                    $smsg = "No permission entries found for $($foldername), skipping..." ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    continue  ; 
                } ; 

                #Remove the folder permissions for each delegate
                foreach ($u in $fPermissions) {
                    $smsg = "`n" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    if ($u.UserType -eq "Default") {
                        <# effectively: This forcec Default Cal to AvailOnly (or LtdDetails), and any other Default to NONE. -> It strips all but Cal Default access.
                         Details: 
                            Default perms only get here if $ResetDefaultLevel:$true, this forces xxx:\Calendar Defaults to $CalPermsDefaul (AvailabilityOnly (MS default) or LimitedDetails (local Org), depending on specification)
                            Non Cal folders get set to NONE
                        #>
                        #UserType enumeration https://docs.microsoft.com/en-us/previous-versions/office/developer/exchange-server-2010/ff319704(v%3Dexchg.140) hardcoded solely: Default|Anonymous|Internal|External|Unknown
                        if ($ResetDefaultLevel) {
                            <# https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes?view=powershell-7.3#the-using-scope-modifier
                                scope $using: - Used to access variables defined in another scope while running scripts via cmdlets like Start-Job and Invoke-Command.

                            #>
                            TRY {
                                $smsg = "Resetting permissions on ""$foldername"" for principal ""Default""." ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
                                else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                if ($folder.FolderType -eq "Calendar") {
                                    # force any Calendar folder Default grant to AvailOnly (or LtdDetails)
                                    #if (($u.AccessRights -join ",") -ne "AvailabilityOnly") {
                                    # TTC customizes the view as LimitedDetails: $CalPermsDefault
                                    if (($u.AccessRights -join ",") -ne $CalPermsDefault) {
                                        #Invoke-Command -Session $session -ScriptBlock { Set-MailboxFolderPermission -Identity $Using:foldername -User Default -AccessRights AvailabilityOnly -WhatIf:$using:WhatIfPreference -Confirm:$false } -ErrorAction Stop -HideComputerName ;
                                        # can't use -session $session with EOM3+, try direct calls; should work
                                        #Set-xoMailboxFolderPermission -Identity $foldername -User Default -AccessRights AvailabilityOnly -WhatIf:$WhatIfPreference -Confirm:$false -ErrorAction Stop ;
                                        #Set-xoMailboxFolderPermission -Identity $foldername -User Default -AccessRights $CalPermsDefault -WhatIf:$WhatIfPreference -Confirm:$false -ErrorAction Stop ;
                                        #*======v BP Wrapper for running EXO dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp) v======
                                        # define the splat of all params:
                                        $pltSMbxFP = [ordered]@{
                                            Identity =$foldername ;
                                            User ='Default' ;
                                            AccessRights =$CalPermsDefault ;
                                            WhatIf =$WhatIfPreference ;
                                            Confirm =$false ;
                                            ErrorAction = 'Stop' ; 
                                            verbose = $($VerbosePreference -eq "Continue") ;
                                        } ;
                                        $cmdlet = 'Set-MailboxFolderPermission' ; $verb,$noun = $cmdlet.split('-') ;  #Spec cmdletname (VERB-NOUN), & split v/n
                                        TRY{$xoS = Get-ConnectionInformation -ErrorAction STOP }CATCH{reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP }
                                        TRY{
                                            if((-not $xos) -OR ($xoS | ?{$_.tokenstatus -notmatch 'Active|Expired' -AND $_.State -ne 'Connected'} )){reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP } ; 
                                            if($xos){
                                                $xcmd = "$verb-$($xoS.ModulePrefix)$noun `@pltSMbxFP" ; # build cmdline w splat, then echo:
                                                $smsg =  "$($([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value)) w`n$(($pltSMbxFP|out-string).trim())" ;
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                                $RET = invoke-expression $xcmd  ;
                                                if($RET){
                                                    $smsg = "(confirmed valid $([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value) output)" ; 
                                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                                }
                                            } else { 
                                                $smsg = "Missing `$xos EXO connection!" ; 
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                                throw $smsg ; BREAK ; 
                                            } 
                                        } CATCH {
                                            $ErrTrapd=$Error[0] ;
                                            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                        } ; 
                                        <# version 12:43 PM 9/21/2023 moved cixo up to 1st, won't have prefix if not populated, also needs to fail/retry to ensure conn;  
                                        11:48 AM 9/20/2023 minor tweaks ; 3:01 PM 9/19/2023 initial 
                                        ## this runs: 1) connection status check, w rxo on demand; 2) splat wrapper with integrated prefix support; 3) try/catch on exec; 
                                        useful alias: cixo => get-connectioninformation;
                                        #>
                                        #*======^ END BP wrapper for running dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp)  ^======
                                    } else { continue } ; 
                                    $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $folder.name;"User" = $u.UserName;"AccessRights" = "AvailabilityOnly"}) ; 
                                } else {
                                    # force any non-calendar folder with a Default grant, to NONE
                                    if (($u.AccessRights -join ",") -ne "None") {
                                        #Invoke-Command -Session $session -ScriptBlock { Set-MailboxFolderPermission -Identity $Using:foldername -User Default -AccessRights None -WhatIf:$using:WhatIfPreference -Confirm:$false } -ErrorAction Stop -HideComputerName 
                                        # eom3+ no pss
                                        #Set-xoMailboxFolderPermission -Identity $Using:foldername -User Default -AccessRights None -WhatIf:$using:WhatIfPreference -Confirm:$false -ErrorAction Stop ;
                                    
                                        #*======v BP Wrapper for running EXO dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp) v======
                                        # define the splat of all params:
                                        $pltSMbxFP = [ordered]@{
                                            Identity =$foldername ;
                                            User ='Default' ;
                                            AccessRights = 'None' ;
                                            WhatIf =$WhatIfPreference ;
                                            Confirm =$false ;
                                            ErrorAction = 'Stop' ; 
                                            verbose = $($VerbosePreference -eq "Continue") ;
                                        } ;
                                        $cmdlet = 'Set-MailboxFolderPermission' ; $verb,$noun = $cmdlet.split('-') ;  #Spec cmdletname (VERB-NOUN), & split v/n
                                        TRY{$xoS = Get-ConnectionInformation -ErrorAction STOP }CATCH{reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP }
                                        TRY{
                                            if((-not $xos) -OR ($xoS | ?{$_.tokenstatus -notmatch 'Active|Expired' -AND $_.State -ne 'Connected'} )){reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP } ; 
                                            if($xos){
                                                $xcmd = "$verb-$($xoS.ModulePrefix)$noun `@pltSMbxFP" ; # build cmdline w splat, then echo:
                                                $smsg = "$($([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value)) w`n$(($pltSMbxFP|out-string).trim())" ;
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                                $RET = invoke-expression $xcmd  ;
                                                if($RET){$smsg = "(confirmed valid $([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value) output)" ; if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; }
                                            } else { 
                                                $smsg = "Missing `$xos EXO connection!" ; 
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                                throw $smsg ; BREAK ; 
                                            } 
                                        } CATCH {
                                            $ErrTrapd=$Error[0] ;
                                            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                        } ; 
                                        <# version 12:43 PM 9/21/2023 moved cixo up to 1st, won't have prefix if not populated, also needs to fail/retry to ensure conn;  
                                        11:48 AM 9/20/2023 minor tweaks ; 3:01 PM 9/19/2023 initial 
                                        ## this runs: 1) connection status check, w rxo on demand; 2) splat wrapper with integrated prefix support; 3) try/catch on exec; 
                                        useful alias: cixo => get-connectioninformation;
                                        #>
                                        #*======^ END BP wrapper for running dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp)  ^======
                                    }
                                    else { continue } ; 
                                    $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $folder.name;"User" = $u.UserName;"AccessRights" = "None"}) ; 
                                } ; 
                                $out += $outtemp; if (-not $Quiet -and -not $WhatIfPreference) { 
                                    #$outtemp 
                                    $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                }  ; #Write output to the console unless the -Quiet parameter is used
                            } CATCH {
                                #$_ | fl * -Force; continue
                                $smsg = "`n$(($_ | fl *|out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                continue
                            }  ; #catch-all for any unhandled errors
                        } else { continue } ; 

                    } elseif ($u.UserType -eq "Anonymous") { 
                        $smsg = "$($u.username):UserType:Anonymous, skipping processing" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        continue 
                        #Maybe set them all to none when $resetdefault is used?

                    } elseif ($u.UserType -eq "Unknown") { 
                        <# Add param: -RemoveUnresolveable -> targets usertype:UNKNOWN, including getr-adusere solvable, that lack populated msExchRecipientTypeDetails property
                        Add param: -IgnoreInternal - skips reset of existing usertype:Internal to NONE
                        Add param: -IgnoreExternal - skips reset of existing usertype:External to NONE
                        Switch to ignore/leave-intact any pre-existing usertype:Internal folder grants
                        Switch to ignore/leave-intact any pre-existing usertype:External folder grants
                        #>
                        $smsg = "'UNKNOWN entry':" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        $DoRemove = $false ; 
                        if($RemoveUnresolveable -AND ($u.UserName -match '^NT:S-1-5-21-')){
                            $smsg = "(entry UserName appears to be a BROKEN SID (SECURITY IDENTIFYER == DELETED USER OBJECT/NON-RECIPIENT)" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        
                            $smsg = "(attempting: get-aduser -id $($u.UserName.replace('NT:','')) )" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

                            $DoRemove = $false ; 
                            TRY{
                                if($ADU =  get-aduser -id ($u.UserName.replace('NT:','')) -ErrorAction SilentlyContinue -prop msExchRecipientTypeDetails){
                                    $smsg = "Resolved`n $($u.UserName.replace('NT:',''))`n to an existing ADUser object:`n$(($adu | fl $prpADU |out-string).trim())" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                }else {
                                    $DoRemove = $true ; 
                                    $smsg = "Unable to resolve $($u.UserName.replace('NT:','')) to an existing ADUser object: => REMOVE Grant!" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                    $DoRemove = $true ; 
                                } ; 
                            } CATCH [Microsoft.ActiveDirectory.Management.ADIdentityNotFoundException]{
                                $smsg = "Unable to resolve $($u.UserName.replace('NT:','')) to an existing ADUser object: => REMOVE Grant!" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                $DoRemove = $true ;
                            } CATCH {
                                $smsg = "$(($_ | fl * |out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                continue 
                            };#catch-all for any unhandled errors
                            if($ADU){
                                $smsg = "Test for EX recipient: populated  msExchRecipientTypeDetail" ; 
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                if($ADU.msExchRecipientTypeDetails){
                                    $smsg = "Found ADUser:$($ADU.userprincipalname) *has* populated msExchRecipientTypeDetail:$($ADU.msExchRecipientTypeDetail)`n*LEAVING EXISTING GRANT IN PLACE!" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                    $DoRemove = $false ; 
                                } else { 
                                    $smsg = "Found ADUser:$($ADU.userprincipalname) has *NO* populated msExchRecipientTypeDetail:$($ADU.msExchRecipientTypeDetail)`n*=> Non-Recipient Security Principal: REMOVE Grant!" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                    $DoRemove = $true ; 
                                } ; 
                             } ;    
                            
                        } elseif($RemoveUnresolveable -AND ($u.User -eq $null)){
                            # non-guid likely still has blank User/user.RecipientPrincipa.guid.guid ($_.user.RecipientPrincipal.value resolve)
                            $smsg = "entry UserName is populated non SID but User is blank (reflects unresolved underlying RecipientPrincipa.guid.guid)" ; 
                            $smsg += "`n$(($u | fl *|out-string).trim())" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                            $smsg += "`n(Setting `$DoRemove:`$true)" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            $DoRemove = $true ; 
                        } else { 
                            $DoRemove = $false ; 
                            # 12:19 PM 9/25/2023 the DC, entry falls through here, it's got no 
                            $smsg = "Skipping orphaned permissions entry: $($u.UserName)";
                            $smsg += "`n$(($u | fl *|out-string).trim())" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
                            else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            continue  ; 
                        } ; 

                        # removal handling here on $DoRemove spec
                        if($DoRemove){
                            $smsg = "`nREMOVING NON-FUNCTIONAL GRANT!"
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                            # eom3+ no pss
                            #Remove-xoMailboxFolderPermission -Identity $foldername -User $u.User -WhatIf:$WhatIfPreference -Confirm:$false -ErrorAction Stop ;
                            <#
                            # Expand the full name out of the above:
                            Get-exoMailboxFolderPermission -Identity "$($TMBX):\Calendar" | select -expand User | select -expand displayname
                            # out: 
                            NT:S-1-5-21-2222296782-158576315-1096482972-20544
                            #
                            # Target it for removal:(can use the name displayed):
                            Remove-xoMailboxFolderPermission -Identity "$($tmbx):\Calendar” -User "NT:S-1-5-21-2222296782-158576315-1096482972-20544" -whatif ; 
                            => use the populated $u.UserName from this script as -User
                            #>
                            #*======v BP Wrapper for running EXO dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp) v======
                            # define the splat of all params:
                            $pltRMbxFP = [ordered]@{
                                Identity =$foldername ;
                                #User =$u.User ; # user is blank on UNKNOWN's so use username
                                User = $u.UserName ; 
                                #AccessRights = 'None' ;
                                WhatIf =$WhatIfPreference ;
                                Confirm =$false ;
                                ErrorAction = 'Stop' ; 
                                verbose = $($VerbosePreference -eq "Continue") ;
                            } ;
                            $cmdlet = 'Remove-MailboxFolderPermission' ; $verb,$noun = $cmdlet.split('-') ;  #Spec cmdletname (VERB-NOUN), & split v/n
                            TRY{$xoS = Get-ConnectionInformation -ErrorAction STOP }CATCH{reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP }
                            TRY{
                                if((-not $xos) -OR ($xoS | ?{$_.tokenstatus -notmatch 'Active|Expired' -AND $_.State -ne 'Connected'} )){reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP } ; 
                                if($xos){
                                    $xcmd = "$verb-$($xoS.ModulePrefix)$noun `@pltRMbxFP" ; # build cmdline w splat, then echo:
                                    $smsg = "$($([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value)) w`n$(($pltRMbxFP|out-string).trim())" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                    $RET = invoke-expression $xcmd  ;
                                    if($RET){$smsg = "(confirmed valid $([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value) output)" ; if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; }
                                } else { 
                                    $smsg = "Missing `$xos EXO connection!" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                    throw $smsg ; BREAK ; 
                                } 
                            } CATCH {
                                $ErrTrapd=$Error[0] ;
                                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                            } ; 
                            <# version 12:43 PM 9/21/2023 moved cixo up to 1st, won't have prefix if not populated, also needs to fail/retry to ensure conn;  
                            11:48 AM 9/20/2023 minor tweaks ; 3:01 PM 9/19/2023 initial 
                            ## this runs: 1) connection status check, w rxo on demand; 2) splat wrapper with integrated prefix support; 3) try/catch on exec; 
                            useful alias: cixo => get-connectioninformation;
                            #>
                            #*======^ END BP wrapper for running dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp)  ^======
                            $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $folder.name;"User" = $u.UserName}) ;
                            #Write output to the console unless the -Quiet parameter is used 
                            $out += $outtemp; if (-not $Quiet -and -not $WhatIfPreference) { 
                                #$outtemp 
                                $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            }  ; #Write output to the console unless the -Quiet parameter is used
                        } else { 
                            $smsg = "`$DoRemove:$($DoRemove): skipping removal of usertype:UNKNOWN grant" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        } ; 

                    } else {
                        # other: External|Internal wind up here
                        if ($u.UserType -eq "External") { $u.User = $u.UserName }
                        <#
                        Add param: -IgnoreInternal - skips reset of existing usertype:Internal to NONE
                        Add param: -IgnoreExternal - skips reset of existing usertype:External to NONE
                        #>
                        if($u.UserType -eq "External" -AND $IgnoreExternal){
                            $smsg = "UserType:External with -IgnoreExternal specified: *SKIPPING* default purge of EXTERNAL Grant:" ;
                            $smsg += "`n`n$(($u | ft -a identity,user,usertype,username,accessrights|out-string).trim())" ;  
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            Continue 
                        } 
                        if($u.UserType -eq "Internal" -AND $IgnoreInternal){ 
                            $smsg = "UserType:Internal with -IgnoreInternal specified: *SKIPPING* default purge of INTERNAL Grant:" ; 
                            $smsg += "`n`n$(($u | ft -a identity,user,usertype,username,accessrights|out-string).trim())" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            Continue 
                        } 
                        TRY {
                            if (-not $u.User) { continue } ; 
                            $smsg = "Removing permissions on ""$foldername"" for principal ""$($u.UserName)""." ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
                            else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            #Invoke-Command -Session $session -ScriptBlock { Remove-MailboxFolderPermission -Identity $Using:foldername -User $Using:u.User -WhatIf:$using:WhatIfPreference -Confirm:$false } -ErrorAction Stop -HideComputerName ;
                            # eom3+ no pss
                            #Remove-xoMailboxFolderPermission -Identity $foldername -User $u.User -WhatIf:$WhatIfPreference -Confirm:$false -ErrorAction Stop ;
                            #*======v BP Wrapper for running EXO dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp) v======
                            # define the splat of all params:
                            $pltRMbxFP = [ordered]@{
                                Identity =$foldername ;
                                User =$u.User ;
                                #AccessRights = 'None' ;
                                WhatIf =$WhatIfPreference ;
                                Confirm =$false ;
                                ErrorAction = 'Stop' ; 
                                verbose = $($VerbosePreference -eq "Continue") ;
                            } ;
                            $smsg = "Spec cmdletname (VERB-NOUN), then convert cmdlet & splat to `$xcmd string" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            $cmdlet = 'Remove-MailboxFolderPermission' ; $verb,$noun = $cmdlet.split('-') ;  #Spec cmdletname (VERB-NOUN), & split v/n
                            TRY{$xoS = Get-ConnectionInformation -ErrorAction STOP }CATCH{reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP }
                            TRY{
                                if((-not $xos) -OR ($xoS | ?{$_.tokenstatus -notmatch 'Active|Expired' -AND $_.State -ne 'Connected'} )){reconnect-exo ; $xoS = Get-ConnectionInformation -ErrorAction STOP } ; 
                                if($xos){
                                    $xcmd = "$verb-$($xoS.ModulePrefix)$noun `@pltRMbxFP" ; # build cmdline w splat, then echo:
                                    $smsg = "$($([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value)) w`n$(($pltRMbxFP|out-string).trim())" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                    $RET = invoke-expression $xcmd  ;
                                    if($RET){$smsg = "(confirmed valid $([regex]::match($xcmd,"^(\w+)-(\w+)" ).groups[0].value) output)" ; if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; }
                                } else { 
                                    $smsg = "Missing `$xos EXO connection!" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                    throw $smsg ; BREAK ; 
                                } 
                            } CATCH {
                                $ErrTrapd=$Error[0] ;
                                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                            } ; 
                            <# version 12:43 PM 9/21/2023 moved cixo up to 1st, won't have prefix if not populated, also needs to fail/retry to ensure conn;  
                            11:48 AM 9/20/2023 minor tweaks ; 3:01 PM 9/19/2023 initial 
                            ## this runs: 1) connection status check, w rxo on demand; 2) splat wrapper with integrated prefix support; 3) try/catch on exec; 
                            useful alias: cixo => get-connectioninformation;
                            #>
                            #*======^ END BP wrapper for running dynamic prefixed-EOM310+ cmdlets (psb-PsXoPrfx.cbp)  ^======
                            $outtemp = New-Object psobject -Property ([ordered]@{"Mailbox" = $smtp;"FolderName" = $folder.name;"User" = $u.UserName}) ;
                            #Write output to the console unless the -Quiet parameter is used 
                            $out += $outtemp; if (-not $Quiet -and -not $WhatIfPreference) { 
                                #$outtemp 
                                $smsg = "`n$(($outtemp | ft -a |out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            }  ; #Write output to the console unless the -Quiet parameter is used
                        } CATCH [System.Management.Automation.RemoteException] {
                            if (-not $Quiet) {
                                if ($_.CategoryInfo.Reason -eq "UserNotFoundInPermissionEntryException") { 
                                    $smsg = "WARNING: No existing permissions entry found on ""$foldername"" for principal ""$($u.UserName)""" 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                }elseif ($_.CategoryInfo.Reason -eq "CannotChangePermissionsOnFolderException") { 
                                    $smsg = "ERROR: Folder permissions for ""$foldername"" CANNOT be changed!" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                }elseif ($_.CategoryInfo.Reason -eq "CannotRemoveSpecialUserException") { 
                                    $smsg = "ERROR: Folder permissions for ""$($u.UserName)"" CANNOT be changed!" 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                }elseif ($_.CategoryInfo.Reason -eq "ManagementObjectNotFoundException") { 
                                    $smsg = "ERROR: Folder ""$foldername"" not found, this should not happen..."
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                }elseif ($_.CategoryInfo.Reason -eq "InvalidInternalUserIdException") { 
                                    $smsg = "ERROR: ""$($u.UserName)"" is not a valid security principal for folder-level permissions..."
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                }else {
                                    $smsg = "`n$(($_ | fl *|out-string).trim())" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                                    continue
                                }  ; #catch-all for any unhandled errors
                            } ;  # if-E !quiet
                        } catch {$_ | fl * -Force; continue} ;#catch-all for any unhandled errors
                    } # if-E
                }  ; # ACE loop-E
            } ;  # FOLDERS loop-E
            $smsg = $sBnrS.replace('-v','-^').replace('v-','^-')
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H2 } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success

        }  # MBX loop-E
    } ; # PROC-E
    END{
        if ($out) {
            #$out | Export-Csv -Path "$((Get-Date).ToString('yyyy-MM-dd_HH-mm-ss'))_MailboxFolderPermissionsRemoved.csv" -NoTypeInformation -Encoding UTF8 -UseCulture ;
            #$opath = "$((Get-Date).ToString('yyyy-MM-dd_HH-mm-ss'))_MailboxFolderPermissionsRemoved.csv" ; 
            #$smsg = "Exporting results to the CSV file...`n$($opath)" ;
            #$out | Export-Csv -Path $opath -NoTypeInformation -Encoding UTF8 -UseCulture ;
            [string]$opath = $null ; 
            if($ticket){$opath += "$($TICKET)-" }
            # $opath += "$($item)_MailboxFolderPermissionsRemoved-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ; 
            if(($SMTPAddresses.Values |  measure | select -expand count ) -gt 3){
                $opath += "$($SMTPAddresses.Values[0]),xxx_MailboxFolderPermissionsRemoved-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ; 
            } else { 
                $opath += "$($SMTPAddresses.Values -join ',')_MailboxFolderPermissionsRemoved-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ; 
            } ; 
            $oPath = join-path -path (join-path -path $ScriptDir -childpath "logs") -ChildPath $opath ; 
            $smsg = "Exporting results to the CSV file...`n$($opath)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            TRY{
                $out | Export-Csv -Path $opath -NoTypeInformation -Encoding UTF8 -UseCulture ;
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
            #Write output to the console unless the -Quiet parameter is used
            #if (-not $Quiet -and -not $WhatIfPreference) { return $out | Out-Default }  ; 
            if (-not $Quiet -and -not $WhatIfPreference) { return $out  }  ; # above is returning as an array of text with no fields; output the object and aggregate it
        } else { 
            $smsg = "Output is empty, skipping the export to CSV file..." ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
            else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
        } ;
        $smsg = "Finish..." ;
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
    }
}

#*------^ Reset-xoMailboxFolderPermissionsRecursive.ps1 ^------


#*------v resolve-AppIDToCBAFriendlyName.ps1 v------
function resolve-AppIDToCBAFriendlyName {
    <#
    .SYNOPSIS
    resolve-AppIDToCBAFriendlyName - Delivers a 'username' equivelent for CBA authenticated connections: Resolves AppID (commonly from EOM:get-connectioninformation cmdlet) to equiv CBA cert FriendlyName (resolves AppID to password on a local profile\Keys\*.psxml cred file (which contins the cred AppID); then resolves the matched cred.username (which is a local installed cert Thumbprint) to the locally-installed cert, and returns the cert's FriendlyName.
    .NOTES
    Version     : 1.0.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2024-07-03
    FileName    : resolve-AppIDToCBAFriendlyName.ps1
    License     : MIT License
    Copyright   : (c) 2024 Todd Kadrie
    Github      : https://bitbucket.com/tostka/verb-Auth
    REVISIONS
    * 10:19 AM 7/3/2024 init, adapted from resolve-usernametouserrole(); 
    .DESCRIPTION
    resolve-AppIDToCBAFriendlyName - Delivers a 'username' equivelent for CBA authenticated connections: Resolves AppID (commonly from EOM:get-connectioninformation cmdlet) to equiv CBA cert FriendlyName (resolves AppID to password on a local profile\Keys\*.psxml cred file (which contins the cred AppID); then resolves the matched cred.username (which is a local installed cert Thumbprint) to the locally-installed cert, and returns the cert's FriendlyName.

    Returns local cert's FriendlyName, as a connected 'username' equivelent for Certificate-Based-Authentication (CBA) Exchange Online connections 

    UserRole: (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)
    Service = (Op|O365)
    TenOrg = Tenant 3-letter 'Tag' ; 
    And for Certificate-Based-Authentication (CBA), it also returns: 
    FriendlyName: [certificate's configured FriendlyName value, which generally summarizes the Service, TenOrg & User role as well].

    .PARAMETER Credential
    Credential to be resolved to UserRole[-Credential [credential object]]
    .PARAMETER AppId
    Guid corresponding to an Entra/AzureAD Registered AppID to be resolved to UserRole summary[-AppID 'dannnnad-endn-nnan-nnnn-nenennnnnafe']
    .EXAMPLE
    PS> if($xosession = get-connectioninformation){
    PS>     if($xosession.CertificateAuthentication){
    PS>         $uRoleReturn = resolve-AppIDToCBAFriendlyName -AppID $xosession.AppId -verbose:$($VerbosePreference -eq "Continue")  ; 
    PS>         $certUname = $uRoleReturn.FriendlyName ; 
    PS>         $certTag = $uRoleReturn.TenOrg ; 
    PS>     } ; 
    PS>     if($xoSession.TokenStatus -eq 'Active'){
    PS>         $smsg = "Connected to " ; 
    PS>         switch ($xosession.IsEopSession){
    PS>           $true { $smsg += "Sec & Compl PS "}  
    PS>           $false {$smsg += "XO EOM PS " } 
    PS>         } ; 
    PS>         if($xosession.CertificateAuthentication){
    PS>             $smsg += "using CBA:" ; 
    PS>             $smsg += " $($certUname)" ; 
    PS>         } ; 
    PS>         write-host $smsg ; 
    PS>         $prpConn = 'Organization','UserPrincipalName','ModulePrefix','CertificateAuthentication','AppId','TenantID','ConnectionId','IsEopSession','TokenStatus','State' ; 
    PS>         $hsDetails = @"
    PS> Conneciton Details:
    PS> $(($xosession | select $prpConn[0..2] | ConvertTo-Markdowntable -Border -NoDashRow|out-string).trim())
    PS> $(($xosession | select $prpConn[3..5] | ConvertTo-Markdowntable -Border -NoDashRow|out-string).trim())
    PS> $(($xosession | select $prpConn[6..9] | ConvertTo-Markdowntable -Border -NoDashRow|out-string).trim())
    PS> "@ ; 
    PS>         write-verbose $hsDetails ;  
    PS>     } else { 
    PS>         $smsg = "Not currently connected (TokenStatus:$($xoSession.TokenStatus))" ; 
    PS>         $smsg += "`nPreviously: " 
    PS>         switch ($xosession.IsEopSession){
    PS>           $true { $smsg += "Sec & Compl PS"}  
    PS>           $false {$smsg += "XO EOM PS" } 
    PS>         } ; 
    PS>         if($xosession.CertificateAuthentication){
    PS>             $smsg += " using CBA:" ; 
    PS>             $smsg += " $($certUname)" ; 
    PS>         } ; 
    PS>         write-host -foregroundcolor yellow $smsg ; 
    PS>     } ; 
    PS> } else { 
    PS>     write-host -foregroundcolor yellow "No connection info returned" ; 
    PS> } ;    
    Demo parsing get-connectioninformation results to report connection details
    .EXAMPLE
    $uRoleReturn = resolve-AppIDToCBAFriendlyName -UserName $Credential.username -verbose:$($VerbosePreference -eq "Continue") ; 
    Resolve Username string into UserRole value
    .EXAMPLE
    $uRoleReturn = resolve-AppIDToCBAFriendlyName -Credential $Credential -verbose = $($VerbosePreference -eq "Continue") ; 
    Resolve Credential object into UserRole value
    .LINK
    https://bitbucket.com/tostka/verb-Auth
    #>
    [CmdletBinding()] 
    Param(
        #[Parameter(Mandatory = $false, HelpMessage = "Credential to be resolved to UserRole[-Credential [credential object]]")]
        #    [System.Management.Automation.PSCredential]$Credential,
        [Parameter(Mandatory=$false,HelpMessage="Guid corresponding to an Entra/AzureAD Registered AppID to be resolved to UserRole summary[-AppID 'dannnnad-endn-nnan-nnnn-nenennnnnafe']")]
            [ValidateScript({
                [boolean]([guid]$_)
            })]
            [string[]]$AppId
    ) ;
    BEGIN {
        $verbose = ($VerbosePreference -eq "Continue") 
        if(-not $rgxCertThumbprint){$rgxCertThumbprint = '[0-9a-fA-F]{40}' } ; # if it's a 40char hex string -> cert thumbprint  
        if(-not $rgxSmtpAddr){$rgxSmtpAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ; } ; # email addr/UPN
        if(-not $rgxDomainLogon){$rgxDomainLogon = '^[a-zA-Z][a-zA-Z0-9\-\.]{0,61}[a-zA-Z]\\\w[\w\.\- ]+$' } ; # DOMAIN\samaccountname 
        if(-not $rgxCBACertFname){$rgxCBACertFname = 'O365-o365_.*cbacert-\w{3}-\w-.*\.psxml'} ; 
        $prpcert = 'Subject','Issuer','FriendlyName','NotBefore','NotAfter','HasPrivateKey','Thumbprint' ; 
    } ;
    PROCESS {
        
        if(test-path -path (join-path (split-path $profile) 'keys')){
            if($credfiles = gci "$(join-path (split-path $profile) 'keys')\*.psxml" |? name -match $rgxCBACertFname){
                foreach($cfile in $credfiles){
                    TRY{
                        $sBnr4="`n#*``````v processing $($cfile.fullname) v``````" ; 
                        $smsg = $sBnr4 ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        
                        if($tmpcred= Import-Clixml $cfile.fullname -ea STOP){
                            $pw = $tmpcred.GetNetworkCredential().Password ; 
                            $smsg = "comparing AppID:`n$($AppId)" ; 
                            $smsg += "`nto $($cfile.name) cert pw:`n$($pw)" ; 
                            write-verbose $smsg ; 
                            if($AppID -eq $pw){
                                write-verbose "Matched AppID->tmpcred.Password:`ntmpcred Uname is the cert thumb: $($tmpcred.username)"
                                $uRoleReturn = [ordered]@{
                                    UserRole = $null ; 
                                    Service = $null ; 
                                    TenOrg = $null ; 
                                } ;
                                if($tcert = gci "cert:\currentuser\my\$($tmpcred.username)"){
                                    if($tcert  | ?{$_.notbefore -le (get-date ) -le $_.notafter}){
                                        $smsg = "(cert is still within NotBefore<>NotAfter range)" ; 
                                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                    } else { 
                                        $smsg = "matched cert for thumbprint:cert:\currentuser\my\$($tmpcred.username)" ; 
                                        $smsg += "`nIS EXPIRED!" ; 
                                        $smsg += "`n$(($tcert | FL $prpcert |out-string).trim())" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                    } ; 
                                    if($tcert.FriendlyName){
                                        $smsg = "adding cert FriendlyName to return..." ; 
                                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                        $uRoleReturn.add('FriendlyName',$tcert.friendlyname) ; 
                                    }elseif($tcert.Subject){
                                        $tempFname = $tcert.subject.split('.')[0].replace('CN=','').replace('o365','o365_') ; 
                                        $uRoleReturn.add('FriendlyName',$tempFname) ;
                                    } else { 
                                        $smsg = "Unable to find/parse either a FriendlyName or Subject on the cert, into a suitable RoleName analog" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                    } ; 
                                    if($uRoleReturn.FriendlyName){
                                        # [regex]::match($variX.name,'^cred(?<Svc>\w{2})(?<TenOrg>\w{3})(?<URole>.*)$').captures[0].groups['URole'].value
                                        #[regex]::match($tcert.subject.split('.')[0].replace('CN=','').replace('o365','o365_'),
                                        $regexCBAFriendName = "(?<Service>.*)_(?<URole>.*)CBACert-(?<TenOrg>\w{3})" ; 
                                        #"o365_(?<URole>.*)CBACert-(?<TenOrg>\w{3})" ; 
                                        if($hits = [regex]::match($uRoleReturn.FriendlyName,$regexCBAFriendName)){
                                            $uRoleReturn.UserRole = $hits.Groups['URole'].value ; 
                                            # $ServiceNames = 'o365','OP' 
                                            $uRoleReturn.Service = $hits.Groups['Service'].value ; #'o365'
                                            $uRoleReturn.TenOrg =  $hits.Groups['TenOrg'].value
                                        }else { 
                                            $smsg = "Unable to rgx `$uRoleReturn.FriendlyName" ; 
                                            $smsg += "`n$($uRoleReturn.FriendlyName)" ; 
                                            $smsg += "`nwith $($regexCBAFriendName)" ; 
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                        } ; 
                                        $smsg = "Returning `$uRoleReturn summary to pipeline`n$(($uRoleReturn|out-string).trim())" ; 
                                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                        [pscustomobject]$uRoleReturn | Write-Output ; 
                                        break ; 
                                    } ; 
                                }else {
                                    $smsg = "Unable to: gci cert:\currentuser\my\$($tmpcred.username)" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                } ;  
                            } ;
                        }else {
                            $smsg = "Unable to import a content from: $($cfile.fullname) " ; 
                            $SMSG += "Does not appear configured for local .psxml credential storage!" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        } ; 
                        $smsg = $sBnr4.replace('`v','`^').replace('v`','^`') ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ; 

                } ;  # loop-E

            } else { 
                $smsg = "No local CBA-Auth `$rgxCBACertFname files found ($($rgxCBACertFname))!" ; 
                $SMSG += "Does not appear configured for local .psxml credential storage!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            } ; 
        } else { 
            $smsg = "LOCAL PROFILE LACKS A KEYS SUBDIR!" ; 
            $SMSG += "Does not appear configured for local .psxml credential storage!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ; 

    } ;  # PROC-E
    END{
        if(-not $uRoleReturn.UserRole){
            $smsg = "FAILED TO RESOLVE AppId :$($AppId) succesffully against an installed local .psxml file & installed certificate combo!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            $uRoleReturn = [ordered]@{
                UserRole = 'FAILED_RESOLUTION' ; 
                Service = 'FAILED_RESOLUTION' ; 
                TenOrg = 'FAILED_RESOLUTION' ;  
            } ;
            [pscustomobject]$uRoleReturn | Write-Output ; 
        } ;  
    } ;
}

#*------^ resolve-AppIDToCBAFriendlyName.ps1 ^------


#*------v resolve-Name.ps1 v------
Function resolve-Name {
    <#
    .SYNOPSIS
    resolve-Name.ps1 - Port 7nlu to a verb-EXO function. Resolves a displayname into Exchange Online/Exchange Onprem mailbox/MsolUser/AzureADUser/ADUser info, and licensing status. Detect's cross-org hybrid AD objects as well. 
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-06-09
    FileName    : resolve-Name.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-EXO
    Tags        : Powershell,ExchangeOnline,Exchange,MsolUser,AzureADUser,ADUser
    REVISIONS
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 2:40 PM 12/10/2021 more cleanup 
    * 1:17 PM 6/10/2021 added missing $exMProps add lic grp memberof check for aadu, for x-hyb users; add missing $rgxLicGrp, as $rgxLicGrpDN & $rgxLicGrpDName (aduser & aaduser respectively); pulled datestamps on echo's, simplified echo's (removed "$($smsg)")
    * 4:00 PM 6/9/2021 added alias 'nlu' (7nlu is still ahk macro) ; fixed typo; expanded echo for $lic;flipped -displayname to -identifier, and handle smtpaddr|alias|displayname lookups ; init; 
    .DESCRIPTION
    resolve-Name.ps1 - Port 7nlu to a verb-EXO function. Resolves a mailbox user Identifier into Exchange Online/Exchange Onprem mailbox/MsolUser/AzureADUser info, and licensing status. Detect's cross-org hybrid AD objects as well. 
    .PARAMETER TenOrg
    Tenant Org designator (defaults to TOR)
    .PARAMETER Identifier
    User Displayname|UPN|alias to be resolved[-Identifier 'Some Username'
    .PARAMETER Ticket
    Ticket # [-Ticket nnnnn]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    .EXAMPLE
    resolve-Name -Identifier 'Some User'
    Command-line resolve displayname to summary details.
    .EXAMPLE
    resolve-Name -Identifier 'Some.User@domain.com'
    Command-line resolve email address to summary details.
    .EXAMPLE
    resolve-Name -Identifier 'alias'
    Command-line resolve mail alias value to summary details.
    .EXAMPLE
    resolve-Name
    Where no -Identifier is specified, defaults to checking clipboard for a Identifier equivelent.
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    ##Requires -Modules ActiveDirectory,AzureAD,MSOnline,verb-Auth,verb-IO,verb-Mods,verb-Text,verb-AAD,verb-ADMS,verb-Ex2010,verb-logging
    # 2:49 PM 3/8/2022 pull verb-ex2010 ref - I think it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    #Requires -Modules ActiveDirectory,AzureAD,MSOnline,verb-Auth,verb-IO,verb-Mods,verb-Text,verb-AAD,verb-ADMS,verb-logging
    [CmdletBinding()]
    [Alias('nlu')]
    PARAM(
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOR']")]
        $TenOrg = 'TOR',
        [Parameter(Position=0,Mandatory=$False,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="User Identifier to be resolved[-Identifier 'Some Username'")]        
        $Identifier,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2
    ) ;
    BEGIN {
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        
        #$propsXmbx = 'UserPrincipalName','Alias','ExchangeGuid','Database','ExternalDirectoryObjectId','RemoteRecipientType'
        #$propsOPmbx = 'UserPrincipalName','SamAccountName','RecipientType','RecipientTypeDetails' ; 
        $exMProps='samaccountname','alias','windowsemailaddress','DistinguishedName''RecipientType','RecipientTypeDetails' ;

        #$adprops = "samaccountname", "msExchRemoteRecipientType", "msExchRecipientDisplayType", "msExchRecipientTypeDetails", "userprincipalname" ;
        $adprops = "samaccountname","UserPrincipalName","memberof","msExchMailboxGuid","msexchrecipientdisplaytype","msExchRecipientTypeDetails","msExchRemoteRecipientType"
        
        [regex]$rgxDname = "^[\w'\-,.][^0-9_!?????/\\+=@#$%?&*(){}|~<>;:[\]]{2,}$"
        # below doesn't encode cleanly, mainly black diamonds - better w alt font (non-lucida console)
        #"^[a-zA-Z??????acce????ei????ln??????????uu??zz??c????????ACCEE????????ILN??????????UU??ZZ????C???? ,.'-]+$"
        [regex]$rgxEmailAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$"
        [regex]$rgxCMWDomain = $CMWMeta.rgxCMWDomain ;
        [regex]$rgxExAlias = "^[0-9a-zA-Z-._+&]{1,64}$" ;
        # used for adu.memberof
        [regex]$rgxLicGrpDN = $TorMeta.rgxLicGrpDN ;  ; 
        # used for taadu memberof
        [regex]$rgxLicGrpDName = $CMWMeta.rgxLicGrpDName ;
        #XXXX" ;  
        # cute, we've got cmw AAD grps with trailing spaces: 'XXX-XXX-E3-DL ', pull trailing $

        if(!$Identifier -AND (gcm get-clipboard) -AND (get-clipboard)){
            $Identifier = get-clipboard ;
            #$cb = get-clipboard ; 
        } elseif($Identifier){


        } else {
            write-warning "No Identifier specified, and clipboard did not match 'Identifier' content" ; 
            Break ;
        } ; 

        <#[regex]$rgxDname = "^[\w'\-,.][^0-9_!?????/\\+=@#$%?&*(){}|~<>;:[\]]{2,}$"
        # below doesn't encode cleanly, mainly black diamonds
        #"^[a-zA-Z??????acce????ei????ln??????????uu??zz??c????????ACCEE????????ILN??????????UU??ZZ????C???? ,.'-]+$"
        [regex]$rgxEmailAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$"
        #>
        $IdentifierType = $null ; 
        switch -regex ($Identifier){
            $rgxExAlias {
                write-verbose "(`$Identifier appears to be an Alias)" ;
                $IdentifierType = "Alias" ;
                #$Displayname = $Identifier.split('@')[0].replace('.',' ')
                #$nameparts = $Identifier.split('@')[0].replace('.',' ').split(' ')
                $nameparts = $Identifier.split(' ')
                break;
            } ;
            $rgxDname {
                write-verbose "(`$Identifier appears to be a DisplayName)" ;
                $IdentifierType = "DisplayName" ;
                $nameparts = $Identifier.split(' ')
                break;
            }
            $rgxEmailAddr {
                write-verbose "(`$Identifier appears to be an SmtpAddress)" ;
                $IdentifierType = "SmtpAddress" ;
                #$Displayname = $Identifier.split('@')[0].replace('.',' ')
                $nameparts = $Identifier.split('@')[0].replace('.',' ').split(' ')
                break;
            } ;
            default {
                write-warning "Unable to resolve -Identifier ($($Identifier)) into a proper DisplayName|EmailAddress|Alias string" ;
                $IdentifierType = $null ;
                break ;
            }
        } ;
        #if($Identifier -match $rgxDname){
        #        $nameparts = $Identifier.split(' ')
        switch (($nameparts|measure).count){
            "1" {
                # it's an alias
                #Identifier = vString 
                $fname = "" 
                $lname = $nameparts
            }
            "2" {
                <#/*
                RegExMatch(vString, "^\w*\s\w*$", displayname)
                RegExMatch(vString, "\w*(?=[\s])", fname)
                RegExMatch(vString, "(?<=\s)\w*$", lname)
                */
                #>
                #displayname = vString 
                $fname = $nameparts[0] ;
                $lname = $nameparts[1] ;
            }
            default{
                # assume the last 2/* are the last name ( concat no space for searches).
                #displayname = vString 
                $fname = $nameparts[0] ; 
                $lname = $nameparts[1..[int]($nameparts.getupperbound(0))] -join ' ' ;
            }
        } ;
        #} ; 
        
        $sBnr="===v Input (& splits): '$($Identifier)' | '$($fname)' | '$($lname)' v===" ;
        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr)" ;
        #-=-=configure EXO EMS aliases to cover useEXOv2 requirements-=-=-=-=-=-=
        # have to preconnect, as it gcm's the targets
        if ($script:useEXOv2) { reconnect-eXO2 -verbose:$($verbose)}
        else { reconnect-EXO -verbose:$($verbose)} ;
        # in this case, we need an alias for EXO, and non-alias for EXOP
        [array]$cmdletMaps = 'ps1GetxRcp;get-exorecipient;','ps1GetxMbx;get-exomailbox;','ps1GetxUser;get-exoUser;'
        foreach($cmdletMap in $cmdletMaps){
            if($script:useEXOv2){
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1].replace('-exo','-xo') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
            } else {
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;                
                write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
            } ;
        } ;
    
        # shifting from ps1 to a function: need updates self-name:
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;

        #$sBnr="#*======v START PASS:$($ScriptBaseName) v======" ; 
        <#$sBnr="#*======v START PASS:$(${CmdletName}) v======" ; 
        $smsg= $sBnr ;   
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green $smsg } ;
        #>
        
        
        $UseOP=$true ; 

        $useEXO = $true ; # non-dyn setting, drives variant EXO reconnect & query code
        if($useEXO){
            #*------v GENERIC EXO CREDS & SVC CONN BP v------
            # o365/EXO creds
            <### Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile* 
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
            Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
            Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
            Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            ###>
            $o365Cred=$null ;
            if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -UserRole 'CSVC','SID' -verbose:$($verbose))){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                if(get-Variable -Name cred$($tenorg) -scope Script -ea 0){remove-variable -Name cred$($tenorg) -scope Script} ; 
                New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
                $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ; 
                write-verbose $smsg  ;
            } else {
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
                write-verbose $smsg  ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                Break ;
            } ;
            <### CALLS ARE IN FORM: (cred$($tenorg))
            $pltRXO = @{Credential = $Credential ; verbose = $($verbose) ; }
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                verbose = $($verbose) ; } ; 
            if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
            else { reconnect-EXO @pltRXO } ;
            # or with Tenant-specific cred($Tenorg) lookup
            #$pltRXO creds & .username can also be used for AzureAD connections 
            Connect-AAD @pltRXO ; 
            ###>
            # configure splat for connections: (see above useage)
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                verbose = $($verbose) ; } ; 
            #
            #*------^ END GENERIC EXO CREDS & SVC CONN BP ^------
        } # if-E $useEXO

        if($UseOP){
            #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
            # do the OP creds too
            $OPCred=$null ;
            # default to the onprem svc acct
            $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC','SID'; verbose=$($verbose)} ;
            if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                if(get-Variable -Name "cred$($tenorg)OP" -scope Script -ea 0){remove-variable -Name "cred$($tenorg)OP" -scope Script} ; 
                New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ; 
                write-verbose $smsg  ;
            } else {
                $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                write-verbose $smsg  ;
                throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                Break ;
            } ;
            $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;  
            write-verbose $smsg  ; 
            <# CALLS ARE IN FORM: (cred$($tenorg))
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                verbose = $($verbose) ; }
            ReConnect-Ex2010XO @pltRX10 ; # cross-prem conns
            Reconnect-Ex2010 @pltRX10 ; # local org conns
            #$pltRx10 creds & .username can also be used for local ADMS connections
            #>
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                verbose = $($verbose) ; } ;     
            # TEST
        
            # defer cx10/rx10, until just before get-recipients qry
            #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
            # connect to ExOP X10
            if($pltRX10){
                #ReConnect-Ex2010XO @pltRX10 ;
                ReConnect-Ex2010 @pltRX10 ;
            } else { Reconnect-Ex2010 ; } ; 
        } ;  # if-E $useEXOP

        <# already confirmed in modloads
        # load ADMS
        $reqMods += "load-ADMS".split(";") ;
        if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
        #>
        write-verbose "(loading ADMS...)" ;
        # 2:12 PM 6/9/2021 load-ADMS is returning boolean, capture it
        $bRet = load-ADMS -verbose:$($verbose) ;

        if($UseOP){
            # resolve $domaincontroller dynamic, cross-org
            # setup ADMS PSDrives per tenant 
            if(!$global:ADPsDriveNames){
                $smsg = "(connecting X-Org AD PSDrives)" ;
                write-verbose $smsg  ;
                $global:ADPsDriveNames = mount-ADForestDrives -verbose:$($verbose) ;
            } ; 
            if(($global:ADPsDriveNames|measure).count){
                $useEXOforGroups = $false ; 
                $smsg = "Confirming ADMS PSDrives:`n$(($global:ADPsDriveNames.Name|%{get-psdrive -Name $_ -PSProvider ActiveDirectory} | ft -auto Name,Root,Provider|out-string).trim())" ;
                write-verbose $smsg  ;
                # returned object
                #         $ADPsDriveNames
                #         UserName                Status Name        
                #         --------                ------ ----        
                #         DOM\Samacctname   True  [forestname wo punc] 
                #         DOM\Samacctname   True  [forestname wo punc]
                #         DOM\Samacctname   True  [forestname wo punc]
        
            } else { 
                #-=-record a STATUS=-=-=-=-=-=-=
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                #-=-=-=-=-=-=-=-=
                $smsg = "Unable to detect POPULATED `$global:ADPsDriveNames!`n(should have multiple values, resolved to $()"
                write-warning $smsg  ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                Break ;
            } ; 
        } ; 
        #if (!$domaincontroller) { $domaincontroller = get-gcfast } ;
        #if(!$domaincontroller){ if(test-path function:get-gcfast){$domaincontroller=get-gcfast} else { throw "no get-gcfast()!" } ;} else {"(existing `$domaincontroller:$($domaincontroller))"} ;
        # use new get-GCFastXO cross-org dc finde
        # default to Op_ExADRoot forest from $TenOrg Meta
        $domaincontroller = get-GCFastXO -TenOrg $TenOrg -subdomain ((gv -name "$($TenOrg)Meta").value['OP_ExADRoot']) -verbose:$($verbose) |?{$_.length};


        # MSOL CONNECTION
        $reqMods += "connect-msol".split(";") ;
        if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
        write-verbose "(loading AAD...)" ;
        #connect-msol ;
        connect-msol @pltRXO ; 
        #

        # AZUREAD CONNECTION
        $reqMods += "Connect-AAD".split(";") ;
        if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
        write-verbose "(loading AAD...)" ;
        #connect-msol ;
        Connect-AAD @pltRXO ; 
        #


        #
        <# EXO connection
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            verbose = $($verbose) ; } ; 
        if($VerbosePreference = "Continue"){
            $VerbosePrefPrior = $VerbosePreference ;
            $VerbosePreference = "SilentlyContinue" ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ; 
        #disconnect-exo ;
        if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
        else { reconnect-EXO @pltRXO } ;
        # reenable VerbosePreference:Continue, if set, during mod loads 
        if($VerbosePrefPrior -eq "Continue"){
            $VerbosePreference = $VerbosePrefPrior ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        #>

        
        # 3:00 PM 9/12/2018 shift this to 1x in the script ; - this would need to be customized per tenant, not used (would normally be for forcing UPNs, but CMW uses brand UPN doms)
        

        # Clear error variable
        $Error.Clear() ;
        

    } ;  # BEGIN-E
    PROCESS {
        <#$IdentifierType = "DisplayName" ;
        $IdentifierType = "SmtpAddress" ;
        $IdentifierType = "Alias" ;
        #>
        $pltGetxUser=[ordered]@{
            ErrorAction = 'STOP' ;
        } ;
        switch -regex($IdentifierType){
            '(Alias|SmtpAddress)'{
                $pltGetxUser.add('Identity',$Identifier) ;
            }
            'DisplayName'{
                $fltr = "displayname -like '$Identifier'" ; 
                $pltGetxUser.add('filter',$fltr) ;
            }
            default {
                write-warning "Unable to resolve `$IdentifierType ($($IdentifierType)) into a recognized value" ;
                break ;
            }
        } ;

        write-verbose "$((get-alias ps1GetxUser).definition) w`n$(($pltGetxUser|out-string).trim())" ;         
        #rxo ; cmsol ; caad ; rx10 ;
        $error.clear() ;
        TRY {
            $txUser =ps1GetxUser @pltGetxUser ;
            if($msolu = get-msoluser -user $txUser.UserPrincipalName |?{$_.islicensed}){
            #if($msolu = get-msoluser -user $txUser.UserPrincipalName ){
                $tAADu = get-AzureAdUser -objectID $msolu.UserPrincipalName |?{($_.provisionedplans.service -eq 'exchange')} ;
                if($taadu.extensionproperty.onPremisesDistinguishedName -match $rgxCMWDomain){
                    $bCmwAD=$true ;
                    write-host -fo yellow "ADUser is onprem CMW hybrid!:`n$($taadu.extensionproperty.onPremisesDistinguishedName)" ; 
                } elseif($taadu.DirSyncEnabled -AND $taadu.ImmutableId) {
                    #$tadu = get-aduser -filter {UserPrincipalName -eq $txUser.UserPrincipalName }
                    # no use the converted immutableid
                    $guid=New-Object -TypeName guid (,[System.Convert]::FromBase64String($taadu.ImmutableId)) ;
                    $tadu = get-aduser -Identity $guid.guid ; 
                };
            } else { 
                write-warning "No matching licensed MSolu:(get-msoluser -user $txUser.UserPrincipalName)" ; 
            } ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            write-warning $smsg ;
        } ; 
        switch ($txUser.Recipienttype){
            'UserMailbox'{
                $error.clear() ;
                TRY {$xmbx = ps1GetxMbx -id $txUser.UserPrincipalName -ea stop }
                CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    write-warning $smsg ;
                } ; 
            }
            'MailUser'{
                $error.clear() ;
                TRY {$opmbx = get-mailbox -id $txUser.UserPrincipalName -ea stop }
                CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    write-warning $smsg ;
                } ; 
            } ;
            default {write-warning "non-mailbox/mailuser object"} 
        } ; 
        if($txUser){
            if($tadu){"=get-ADUser:>`n$(($tadu |fl samaccountn*,userpr*,msRTCSIP-PrimaryU*,msRTCSIP-L*,msRTCSIP-Usere*,tit*|out-string).trim())" 
            } else {
                write-host "=get-ADUser:>(Non-local AD user)`n=$((get-alias ps1GetxUser).definition):`n$(($txUser|fl userpr*,tit*,Offi*,Compa*|out-string).trim())" 
            } ;
            if($xmbx){"=get-Xmbx>:`n$(($xmbx| fl ($exMProps |?{$_ -notmatch '(samaccountname|DistinguishedName)'})|out-string).trim())" } ;
            if($opmbx){"=get-OPmbx>:`n$(($opmbx| fl $exMProps |out-string).trim())" };
            if($msolu){
                write-host "$(($msolu|fl @{Name='HasLic';Expression={$_.IsLicensed }},@{Name='LicIssue';Expression={$_.LicenseReconciliationNeeded }}|out-string).trim())" ; 
            "Licenses Assigned:`n$((($msolu.licenses.AccountSkuId) -join ";" | out-string).trim())" ;
                if(!($bCmwAD)){
                    if($LicGrp = $tadu.memberof -match $rgxLicGrpDN){
                        write-host "LicGrp(AD):$(($LicGrp|out-string).trim())" ; 
                    } else { 
                        write-host "LicGrp(AD):(no ADUser.memberof matched pattern:`n$($rgxLicGrpDN.tostring())" ; 
                    } ; 
                } else {
                    write-host -fo yellow  "Unable to expand ADU, user is hybrid AD from $($CMWMeta.adforestname) domain`nproxying AzureADUser memberof" ; 
                    if($taadu){
                        $mbrof = $taadu | Get-AzureADUserMembership | select DisplayName,DirSyncEnabled,MailEnabled,SecurityEnabled,Mail,objectid ;
                        if($LicGrp = $mbrof.displayname -match $rgxLicGrpDName){
                            write-host "LicGrp(AAD):$(($LicGrp|out-string).trim())" ; 
                        } else { 
                            write-host "LicGrp(AAD):(no ADUser.memberof matched pattern:`n$($rgxLicGrpDName.tostring())" ; 
                        } ; 
                    } else { 
                        write-warning "(unpopulated AzureADUser: skipping memberof)" ; 
                    }
                } ; 
            }else {
                write-warning "Unable to find matching MsolU for $Identifier" ; 
            } ; 
        } ; 
        
    } ;  # PROC-E
    END {
        # =========== wrap up Tenant connections
        <# suppress VerbosePreference:Continue, if set, during mod loads (VERY NOISEY)
        if($VerbosePreference = "Continue"){
            $VerbosePrefPrior = $VerbosePreference ;
            $VerbosePreference = "SilentlyContinue" ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        if($script:useEXOv2){
            disconnect-exo2 -verbose:$($verbose) ;
        } else {
            disconnect-exo -verbose:$($verbose) ;
        } ;
        # aad mod *does* support disconnect (msol doesen't!)
        #Disconnect-AzureAD -verbose:$($verbose) ;
        # reenable VerbosePreference:Continue, if set, during mod loads
        if($VerbosePrefPrior -eq "Continue"){
            $VerbosePreference = $VerbosePrefPrior ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        #>
        # clear the script aliases
        write-verbose "clearing ps1* aliases in Script scope" ; 
        get-alias -scope Script |Where-Object{$_.name -match '^ps1.*'} | ForEach-Object{Remove-Alias -alias $_.name} ;

        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr.replace('=v','=^').replace('v=','^='))" ;
        
        write-verbose "(explicit EXIT...)" ;
        Break ;


    } ;  # END-E
}

#*------^ resolve-Name.ps1 ^------


#*------v resolve-user.ps1 v------
function resolve-user {
    <#
    .SYNOPSIS
    resolve-user.ps1 - Resolve specified array of -users (displayname, emailaddress, samaccountname) to mail asset, lic & ticket descriptors
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-07-13
    FileName    : resolve-user.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 10:48 AM 1/19/2026 bugfix: $pltCcOPSvcs.UserRole (postfilter, not match test)
    * 4:31 PM 1/6/2026 fixed brace mismatch; updated in latest CONNECT_O365SERVICES, CALL_CONNECT_O365SERVICES, CALL_CONNECT_OPSERVICES, START_LOG_OPTIONS
    * 10:35 AM 12/22/2025 pasted in latest start_log block for holistic from psparamt; added missing per-user lop stop transcript, right below write_output block
    * 3:04 PM 12/12/2025 was still diverting logging when .psm1 module into modules dir; also outputing massive export-clixml 3gb files, needed testing of the content prior to exports. 
    - found that, since adding Get-MgUser Microsoft.graph to the mix, export-clixml can no longer export importable xml code. Even if you message it and pretest with convertto-xml, and try/catch for export errors (none). 
    still junk output xml. 
    - so coded in json export support; added -useJson & -Depth parameter (defaults to 2), and along the way found that Value/value key use in exports causes json to throw up, so coded up vio\convert-fromJsonSmart() which works past the issue
    (traps specific error, and mmd-conversion replaces instances of the first duplicated key, with the second key name). Necessary to get back to importable exported files from this process. 
    * 4:40 PM 12/11/2025 finished conversion to - marginally functional MG\get-MGUser, get-MGUserLicenseDetails, get-MGUserManager support. 
    rebuilt the property filters to accomodate the mg variant property names; 
    added get-mguserFull(), which force pulls a complete set of usable properties, returns the mguser object to pipeline
    rejiggered properties to populate fields that are there, but empty by default, at least the useful ones. 
    There are some audit log & service tied props, that throw Access Denied.
    Also had to add Group read all scope to get memberof (and still went to the long-functional Exchange-based memberof resolution, the MG is another 💩 show).
    $MGPermissionsScope = @("User.Read.All","Group.Read.All")
    renamed regions AAD -> MG refs 
    Shift of cloud user to MG rEsulted in a new bug - convert-clixml suddenly began never infishing, and genreated a 8gb .xml file
    Attempts to test scale revealed graph.api produces broken unclosed xml elements: 
        `Get-MgUser` piped to `Export-Clixml` is often caused by an issue in how 
        PowerShell handles complex or deeply nested objects during the XML 
        serialization process. This is a known issue within PowerShell itself, 
        especially when dealing with certain object structures returned by the 
        Microsoft Graph cmdlets.  
    Recommendations were to simplfiy the objects:
    Everything but the new MGUser, MGUserManager were long standing normal objs
    - I reselected MGUser with the same $prpMGUser set that spec'd the -propertiees for the Get-MgUser cmd
    - I also converted the MGUserManager hashtable (what comes out of the qry) into a psCustomObject, and remounded it to the exportable object. 
    That ccombo worked past the issues, and resulted in 800k-1.7mb xml files for single accounts. 
    Ridiculous that MS forces this type of half baked garbage on us, when we've had long-standing high-function solutions *for years*


    * 4:35 PM 12/10/2025 extensive fixes: damage from MS fully blocking al AzureAdUser access, and forced march to marginally compat get-MGUser command. Had to do a lot of revising, including in connecto o365 functions. Also fixed breaks in start-log call (was logging into module dir). 
    * 9:39 AM 10/10/2025 add: if -getQuotaUsage, and sharedmailbox recipienttypedetails, output info about Deleted Items & Sent Items OL mgmt regkeys.
    * 1:45 PM 9/23/2025 removed err-source connect-exo2 call (retured) ; added expanded mobile device reporting, testing Microsoft Nativ esync protocol (Outlook|REST clienttype) tests, explciit 'EAS' stigma tagging in outputs (wastes time t-shooting unsupported 3rd-party clients; given Security formally prefers OLM client over otheres).
    * 2:24 PM 8/1/2025 pulled unused whpassfail defs
    * 10:55 AM 4/15/2025 updated added param -ResolveForwards:
        -  to expand MailContacts into object that forwards the contact (net of MsgTracese that show the contact as a leaf recipient, informs *who* forwarded to the contact) ; 
        - new func: resolve-RMbxForwards() pulls all Rmbxs w ForwardingAddress populated, 
            grcps the Forward & builds an indexed hash to look up the primarysmtpAddress of the forwarding target, against  the detail of the forwarding mailbox 
            (for -ResolveForwards lookup speed, run a series of MailContact addresses through, and it only has to build the hash once, recycling the hash for the full set)
        - Also adds extra returned properties: opMailContact,opContactForwards,xoMailContact,xoMailboxForwardingAddress,xoContactForwards
        - made normal MailContact rcp exclusion conditional: exempts when running -ResolveForwards
        - Also expanded rmbx/opmbx/xombx to expand and fully report ForwardingAddress targeted rcp object
        - spliced in new resolve-Enviornment() & Start-Log code to match; working: works
        
    * 3:21 PM 4/12/2025 usable for now ; WIP implemented initial attempt at getting Forwarded MailContacts coded, still throwing odd errors, tho it completes, run against 3  contact addresess.
    * 12:40 PM 1/16/2025 UPDATED cbh WITH DETAILED PARAM DESC & OUTPUT SAMPLES ; 
         fixed missing -getMobile support in the force trailing pass; fixed mis applied $hSum.xoMapiStats for proper metrics
    * 4:41 PM 1/9/2025 rebuffered in latest Server Connections, found that the 
        assumption could use the existing PS session context for REMS, was bogus. So 
        re-enabled the OP cred gather even for useExopNoDep conns. Also reworked 
        connect-exchangeserverTdo() to actually use the credentials passed in, and 
        added the missing import-module $PSS to make the session actually functional 
        for running cmds, wo popping cred prompts. 
    * 8:53 AM 12/31/2024 cbh typo: cleared duped param Tenorg
    * 10:45 AM 12/27/2024 param aliass 'Quota','Perms' ; default -silent $true; updated propsADU to include desc & info ; add: $propsDG &  $propsADL7 ; rework into a loop for perm group summary dump; moved members & managedby into the grp summary; 
        removed nonewlines on the initial OP mbx/rmbx type; tweaked unlic & disabled ww's to only fire on inapprop config (smbx v umbx)
    * 3:43 PM 12/26/2024 add: -getPerms, runs Get-xoMailboxPermission & get-xoRecipientPermissions, outputs/returns non-SELF matches, and expands any group members in user or trustee
         add: aduser.info field, echo into output, if pop'd; 
        bugfix/cmw uses r: as room dname prefix, not recog'd as dname: #updated: $rgxDName CMW uses : in their room names, so went for broader AD dname support, per AI, and web specs, added 1-256char AD restriction         $rgxDName
        also pushed dname in the detect type switch below samaccountname (which is more specific filter) ; added 'RemoteRoomMailbox' &  'RemoteEquipmentMailbox' switch clauses on typedetails handlers; 
        tweaked lic test to exempt shared/room/equip from isUnlicened warnings.
    * 3:44 PM 12/4/2024 updated to support non-hybrid cloud recipients, w ADC sync'd ADU->AADU; updated enviro_discover etc from latest vers
    * 9:04 AM 11/27/2024 add SharedMbx quota support: flipped logic to pull xomailbox to pull any $hSum.xoRcp|?{$_.recipienttype -eq 'UserMailbox'... (any mailbox type), vs orig: recipienttypedetails, which would only stock UserMailbox details type.
    * 4:40 PM 10/16/2024 added code to do above, users I thot were c1 weren't, had rmbxs, so it needs further testing;  cloud first: VEN,INT,AA,HH, may not match ADU properly, but if they have AADU & AADUser.DirSyncEnabled, the .aaduser.ExtensionProperty.onPremisesDistinguishedName will point to the assoicated ADU! Need to re-resolve when missing ADU
    * 12:50 PM 10/11/2024 substantial rewrites in query code to accomodate apostrophe's in names (selective rewrap " vs ' for queries). Still not great, still doesn't necessarily work searching dname on apostrophe'd names, but it gets through the pass wo crashing (as it did previously).
    * 12:06 PM 9/23/2024 added param for regex to detect non-raw text names; ahdd running $usr input through Remove-StringDiacritic & Remove-StringLatinCharacters() ; 
    * 2:16 PM 6/24/2024: rem'd out #Requires -RunasAdministrator; sec chgs in last x mos wrecked RAA detection
    * 4:28 PM 2/27/2024 updated path-detect code (was discovering into the Mods dir);  updated CBH, quota mbx size, LegalHold example; add additional reporting/detecting to LegalHold status; fixed borked/non-dumping $prpMbxHold = ...@{n="InPlaceHolds";e={ ($_.inplaceholds (*KEY* indicator of a hold in place); updated prompts to echo DiscoveryHolds folder & it's newestItem (both indicate LHs, and if not curr, when it was disabled)
    * 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
    * 12:22 PM 9/26/2023 nesting limit loop, pulled vxo & vx2010  reqs
    * 3:59 PM 9/25/2023 working, ready to drop back into vxo finished in-port of get-xoMailboxQuotaStatus support, now functional, also expanded the mbxstat filter to cover room|shared|Equip recipienttypedetails variants; 
        appears I spliced over $getQuotaUsage support from get-xoMailboxQuotaStatus, looks like it needs to be debugged.
    * 12:43 PM 9/18/2023 re-removed the obsolete xow support: EOM31+ doesn't need it.
    * 3:47 PM 12/14/2022 spliced in xow support. Works on initial pass.
    # 3:57 PM 6/29/2022 fundemental retool for exov2 requirements; pulled all 
        aliasing (wasn't functional for exov2, didn't want to rewrite, and with hard 
        mfa req, exov2 is only way forward, there'll never be verb-EXOnoun use again, 
        due to MS fundemental seizure of the prefix for their 13 'special' cmdlets. 
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 3:55 PM 2/22/2022 extended the cloud federate test code, to include an INT block (though there's no hybrid to arbitrate, the users are onprem in AD at INT)
    * 12:24 PM 2/1/2022 updated CBH, added a crlf on the console echo (headers weren't lining up); added -getMobile & get-exoMobileDeviceStats support, with conditional md output block; added full aliased xo cmds, implementing full -exov2 support.
    * 2:51 PM 12/27/2021 flipped DN & Desc from md tbl to fl (drops a crlf) ; 
         flipped $propsMailx output to md fmt split lines (condensed output vertically) ; 
         added forward props to propsMailx, and test & echo to tag forwarded mbxs; wrapped $prop* vari's for legibility
    * 11:02 AM 12/13/2021 #11111:had $hsum IsADDisabled, typo: to IsAADDisabled
    * 2:40 PM 12/10/2021 more cleanup ; added $hsum.isDirSynced, for further bulk filter/profiling
        flipped $hsum.isUnlicensed -> Islicensed & added msol.Islicensed test to pop ; 
        appears to work in console - output a stack of filterable objects into collection variable.
        further tweaking and nobrain t-shooting outputs ; added 
        output switches: 
        isNoBrain,isSplitBrain,isUnlicensed,IsDisabledOU,IsADDisabled,IsAADDisabled for 
        postfiltering large collections in bulk, to identify patterns ; reformulated 
        nobrain detec, to have an unlic'd block as well as a licensed - with deadwood 
        offboard nobrains, they'll never have a lic. 
    * 4:19 PM 12/9/2021 improved pipeline support; fixed pipeline param mbinding fails ; added supoort for resolving
        baddomain users or op.mailusers where need to resolve aadu.immutableid to
        aduser, to *ensure* we have a hardmatch of problem objects (resolving baddomain
        DDG-DL-AllDOMAIN recipients to internal NoBrain etc. Still doesn't seem to be
        setting $hsum.NoBrain properly in outputs, but is dropping direct to pipe. May
        have borked single-indiceent xml object dumps tho.
    * 10:30 AM 11/8/2021 fixed CBH/HelpMessage tagging on -outobject
    * 3:30 PM 10/12/2021 added new Name:ObjName_guid support (new hires turn up with aduser named this way); added some marginal multi xoRcp & xoMailbox handling (loops outputs on the above, and the mapiTest), but doesn't do full AzureAD,Msoluser,MailUser,Guest lookups for these. It's really about error-suppression, and notifying the issue more than returning the full picture
    * 1:04 PM 9/28/2021 added:$AADUserManager lookup and dump of UPN, OpDN & mail (for correlating what email pol a user should have -> the one their manager does)
    * 1:52 PM 9/17/2021 moved $props to top ; test enabled/acctenabled, licRecon & mapi test results and use ww on issues ; flipped caad's to -silent (match cmsol 1st echo's to confirm tenant, rest silent); ren $xMProps -> $propsMailx, $XMFedProps-> $propsXMFed, $lProps -> $propsLic,$adprops -> $propsADU, $aaduprops -> $propsAADU, $aaduFedProps -> $propsAADUfed, $RcpPropsTbl -> $propsRcpTbl, $pltgM-> $pltGMailObj, $pltgMU -> $pltgMsoUsr
    * 4:33 PM 9/16/2021 fixed typo in get-AzureAdUser call, reworked output (aadu into markdown delimited wide layout), moved user detaiil reporting to below aadu, and output the federated AD remote DN, (proxied through AADU ext prop)
    * 10:56 AM 9/9/2021 force-resolve xoMailbox, added AADUser pop to the msoluser pop block; added test-xxMapiConnectivity as well; expanded ADU outputs - description, when*, Enabled, to look for terms/recent-hires/disabled accts
    * 3:05 PM 9/3/2021 fixed bugs introduced trying to user MaxResults (msol|aad), which come back param not recog'd when actually used - had to implement as postfiltering to assert open set return limits. ; Also implemented $xxxMeta.rgxOPFederatedDom check to resolve obj primarysmtpaddress to federating AD or AAD.
    * 11:20 AM 8/30/2021 added $MaxResults (shutdown return-all recips in addr space, on failure to match oprcp or xorcp ; fixed a couple of typos; minior testing/logic improvements. Still needs genercized 7pswlt support.
    * 1:30 PM 8/27/2021 new sniggle: CMW user that has EXOP mbx, remote: Added xoMailUser support, failed through DName lookups to try '*lname*' for near-missies. Could add trailing 'lnamne[0-=3]* searches, if not rcp/xrcps found...
    * 9:16 AM 8/18/2021 $xMProps: add email-drivers: CustomAttribute5, EmailAddressPolicyEnabled
    * 12:40 PM 8/17/2021 added -outObject, outputs a full descriptive object for each resolved recipient ; added a $hSum hash and shifted all the varis into mountpoints in the hash, with -outObject, the entire hash is conv'd to an obj and appended to $Rpt ; renamed most of the varis/as objects very clearly for what they are, as sub-props of the output objects. Wo -outobject, the usual comma-delim'd string of addresses is output.
    * 3:26 PM 7/29/2021 had sorta bug (AD context was xxxx:, gadu failing throwing undefined error), but debugging added extensive verbose echos, and an AD-specific try/catch to trap AD notfound errors (notorious, they throw terminating fails, unlike other modules; which crashes out processing even when using -EA continue). So it hardens up the fail recovery process.
    * 12:55 PM 7/19/2021 added guest & exo-mailcontact support (resolving missing ext-federated addresses), retolled logic down to grcp & gxrcp to drive balance of tests.
    * 12:05 PM 7/14/2021 rem'd requires: verb-exo  rem'd requires version 5 (gen'ing 'version' is specified more than once.); rem'd the $rgxSamAcctName, gen's parsing errors compiling into mod ;  added alias 'ulu'; added mailcontact excl on init grcp, to force those to exombx qry ; init vers
    .DESCRIPTION
    resolve-user.ps1 - Resolve specified array of -users (displayname, emailaddress, samaccountname) to mail asset, lic & ticket descriptors

    Typical summary block written to console (write-host, not pipeline):

        10:06:45:===v (1/1):Input: 'lynctest14@DOMAIN.COM' | 'lynctest14' | '' v===(EML)
        get-Rmbx/xMbx: (Rmbx *SHARED*)
        (xSMbx)(TOR USER, fed:SUB.DOMAIN.COM)
        SamAccountName | WindowsEmailAddress
        lynctest14     | lynctest14@DOMAIN.COM
        Office | RecipientTypeDetails | RemoteRecipientType     | IsDirSynced
               | RemoteSharedMailbox  | Migrated, SharedMailbox |
        ExternalDirectoryObjectId | CustomAttribute5 | EmailAddressPolicyEnabled
                                  |                  | True
        Outlook (xoMAPI) Access Test Result:Success
        =get-AADuser lynctest14@DOMAIN.COM>:
        =get-AADuserManager lynctest14@DOMAIN.COM>:
        ===$hSum.ADUser:
        UPN                 | DName       | FName | LName       | Title
        lynctest14@DOMAIN.COM | lync test14 |       | lync test14 |
        Company | Dept | Ofc
                |      |
        Street | City | State | Zip | Phone | Mobile
               |      |       |     |       |
        Enabled | DN
        False   | CN=lync test14,OU=users,OU=SITE,DC=sd,DC=sub,DC=domain,DC=com
        whenCreated           | whenChanged
        5/13/2015 11:32:01 AM | 12/19/2024 3:18:41 PM
        Desc :
        LicenseGroup:(unresolved, direct-assigned other?)
        (AADUserMgr was blank, or unresolved)
        10:06:49: INFO:
        lynctest14@DOMAIN.COM Is RecipientTypeDetails:SharedMailbox _expected unlicensed_
        ===^ (1/1):Input: 'lynctest14@DOMAIN.COM' | 'lynctest14' | '' ^===(EML)


    Key parameter options: 

    -getMobile parameter, to return details on xo MobileDevices in use with the EXO mailbox
        Note: 
            - adds inline output:
                xoMobileDeviceStats Count:2
                Evaluates and reports on Outlook Mobile use, OLM ClientType sync, 
                Stigmatizes and NOTE:'s EAS use with Best Effort support status. 
            - adds outobject property:
            $results:
                xoMobileDeviceStats    (LastSyncTime -LE 30D)
                xoMobileDeviceStatsOLD (LastSyncTime -GT 30D)
                xoMobileOutlookClients (OL Mobile clients)
                xoMobileOtherClients   (Non-OL Mobile clients)
                xoMobileOMSyncTypes    ('Outlook' (MS Native Sync) v 'REST' (legacy GAPI))
                xoMobileOtherSyncTypes ('EAS' et al)
        
        Typical Summary Block - Iphone
        ===$hsum.xoMobileDeviceStats:
        =get-xMob1:(ACTIVE)>
        FriendlyName   | DevType | DevOs             | ClntType | DevID
        iPhone 16 Plus | iPhone  | iOS 18.6.2 22G100 | EAS      | VC6DOHnnnnnnnnnnnnVOUL7KLK
        1stSyncTime  | LastSyncTime  | LastSuccSync  | #Folders
        4/3/25 19:23 | 9/23/25 14:22 | 9/23/25 14:22 | 98
        =get-xMob2:(inactive)>
        FriendlyName  | DevType | DevOs             | ClntType | DevID
        iPhone 7 Plus | iPhone  | iOS 15.8.3 19H386 | EAS      | 15UG7D5nnnnnnnnnnnR14T7EM8
        1stSyncTime  | LastSyncTime | LastSuccSync | #Folders
        8/29/24 8:24 | 4/4/25 6:46  | 4/4/25 6:46  | 83
        ---NON-Outlook Mobile Clients:(device-vendor-supported): 2
        DeviceFriendlyName ClientType LastSyncTime  LastSuccSync
        ------------------ ---------- ------------  ------------
        iPhone 16 Plus     EAS        9/23/25 14:22 9/23/25 14:22
        iPhone 7 Plus      EAS        4/4/25 6:46   4/4/25 6:46

        The following devices use device-vendor-provided/supported 'ExchangeActiveSync/EAS' Mobile clients!
        PLEASE NOTE: By policy EAS clients are *Best Effort* supported:
        Where issues are experienced with legacy EAS/ActiveSync clients,
        Users should be urged to move to _Supported_ Microsoft Outlook Mobile for IOS or Android
        DeviceFriendlyName ClientType LastSyncTime  LastSuccSync
        ------------------ ---------- ------------  ------------
        iPhone 16 Plus     EAS        9/23/25 14:22 9/23/25 14:22
        iPhone 7 Plus      EAS        4/4/25 6:46   4/4/25 6:46   

        Typical Summary Block - Outlook Mobile Android 
        ===$hsum.xoMobileDeviceStats:
        =get-xMob1:(ACTIVE)>
        FriendlyName | DevType | DevOs | ClntType | DevID
                     | Outlook | 15    | Outlook  | D115DF6C8E0nnnnnnnnnnnnn0682152D
        1stSyncTime  | LastSyncTime  | LastSuccSync  | #Folders
        2/24/25 9:03 | 9/23/25 13:52 | 9/23/25 13:52 | 0
        =get-xMob2:(inactive)>
        FriendlyName | DevType | DevOs | ClntType | DevID
                     | Outlook | 14    | Outlook  | 5D9DF50F879nnnnnnnnnnnnnC0B6988D
        1stSyncTime   | LastSyncTime  | LastSuccSync  | #Folders
        8/17/23 17:50 | 2/24/25 22:29 | 2/24/25 22:29 | 0
        =get-xMob3:(inactive)>
        FriendlyName | DevType     | DevOs              | ClntType | DevID
        aaa-8aaa1a2  | WindowsMail | Windows 10.0.17134 | EAS      | BEB93DA5nnnnnnnnnnnn974B6036A907
        1stSyncTime   | LastSyncTime | LastSuccSync | #Folders
        1/24/22 14:58 |              |              | 0
        +++Supported Outlook Mobile Clients: 2

        -----$hsum.xoMobileOMSyncTypes: Outlook
        ++User has has one or more fully compliant 'MS Native Sync'-protocol Outlook Mobile clients
        ---NON-Outlook Mobile Clients:(device-vendor-supported): 1
        DeviceFriendlyName ClientType LastSyncTime LastSuccSync
        ------------------ ---------- ------------ ------------
        aaa-8aaa1a2        EAS

        The following devices use device-vendor-provided/supported 'ExchangeActiveSync/EAS' Mobile clients!
        PLEASE NOTE: By policy EAS clients are *Best Effort* supported:
        Where issues are experienced with legacy Eas/ActiveSync clients,
        Users should be urged to move to _Supported_ Microsoft Outlook Mobile for IOS or Android
        DeviceFriendlyName ClientType LastSyncTime LastSuccSync
        ------------------ ---------- ------------ ------------
        aaa-8aaa1a2        EAS
        14:18:54: INFO:

        PS> $results.xoMobileDeviceStats | ft -a

        FirstSyncTime         LastPolicyUpdateTime  LastSyncAttemptTime  LastSuccessSync      DeviceType  DeviceID                         DeviceUserAgent       DeviceWipeSentTime DeviceWipeRequestTime DeviceWipeAckTime
        -------------         --------------------  -------------------  ---------------      ----------  --------                         ---------------       ------------------ --------------------- -----------------
        1/24/2022 8:58:54 PM                                                                  WindowsMail XXXnnXAnnAAnnnnXnnnnnnnXn0nnAn0n MSFT-WIN-3/10.0.17134
        8/17/2023 10:50:16 PM 1/16/2025 10:08:42 AM 1/16/2025 5:45:14 PM 1/16/2025 5:45:14 PM Outlook     nXnXXn0XnnnXn0nnAAXA0XnnX0XnnnnX Outlook-Android/2.0



    -getQuotaUsage parameter, returns details on xo MailboxFolderStatistics and effective Quota, 
        Used with users with mailbox size issues (and/or LegalHold symptoms)

        Note: use of -getQuotaUsage also does an extensive check for LegalHold signs in the mailbox. including reporting on:
            - xoMailbox.LitigationHoldEnabled
            - xoMailbox.InPlaceHolds, 
            - xoMailbox.ComplianceTagHoldApplied
            - xoMailbox.DelayHoldApplied 
            - xoMailbox.DelayReleaseHoldApplied 
            - checks if xoMailboxFolderStats 'DiscoveryHolds' folder has ItemsInFolder -gt 0

    - getPerms parameter, returns Get-xoMailboxPermission & 
        Get-xoRecipientPermission, non-SELF grants, and membership of any grant 
        groups (XO-only)

        - Adds added inline output (per grant and nested group w membership)

            ## xoMailboxPermission:
            Identity   User                       AccessRights
            --------   ----                       ------------
            XAXXxxxxxx ABC-SEC-Email-XAXXxxxxxx-G {FullAccess}

            ### Expanded Perm Group Summaries:
            -----------
            Identity                   | PrimarySmtpAddress
            ABC-XXX-Xxaxx-XAXXxxxxxx-G | ABC-XXX-Xxaxx-XAXXxxxxxx-G@DOMAIN.COM
            RecipientType              | RecipientTypeDetails       | ManagedBy
            MailUniversalSecurityGroup | MailUniversalSecurityGroup | Xxxaxxx Xaxax
            Description :
            #### Members:
            Alias   PrimarySmtpAddress       RecipientType RecipientTypeDetails
            -----   ------------------       ------------- --------------------
            xaxaxxx Xxxaxxx.Xaxax@DOMAIN.COM   UserMailbox   UserMailbox
            ..


            ## xoRecipientPermission:
            Identity   Trustee                    AccessControlType AccessRights Inherited
            --------   -------                    ----------------- ------------ ---------
            XAXXxxxxxx ABC-XXX-Xxaxx-XAXXxxxxxx-G Allow             {SendAs}


            ### Expanded Perm Group Summaries:
            -----------
            Identity                   | PrimarySmtpAddress
            ABC-XXX-Xxaxx-XAXXxxxxxx-G | ABC-XXX-Xxaxx-XAXXxxxxxx-G@DOMAIN.COM
            RecipientType              | RecipientTypeDetails       | ManagedBy
            MailUniversalSecurityGroup | MailUniversalSecurityGroup | Xxxaxxx Xaxax
            Description :
            #### Members:
            Alias   PrimarySmtpAddress       RecipientType RecipientTypeDetails
            -----   ------------------       ------------- --------------------
            xaxaxxx Xxxaxxx.Xaxax@DOMAIN.COM   UserMailbox   UserMailbox
            ...


    - outObject parameter causes it to return a system.object summary to the pipeline. 
        Can be captured in a variable when calling, for further analysis of the components of the resolved user/mailbox object:

         $results = resolve-user -outObject -users 'USERLOGON@DOMAIN.COM'  ;  

         By default, the returned object includes the following properties & full object copies (if found and resolvable):

            dname           : lynctest14@DOMAIN.COMlync test14
            fname           : lynctest14
            lname           : lync test14
            OPRcp           : SD.SUB.DOMAIN.COM/ABC/USERS/lync test14
            xoRcp           : lync test14_0650dc758f
            OPMailbox       :
            OPRemoteMailbox : lync test14
            ADUser          : CN=lync test14,OU=users,OU=SITE,DC=sd,DC=sub,DC=domain,DC=com
            Federator       : SUB.DOMAIN.COM
            xoMailbox       : lync test14
            xoMUser         :
            xoUser          :
            xoMemberOf      :
            txGuest         :
            OPMapiTest      :
            xoMapiTest      : {Microsoft.Exchange.Monitoring.MapiTransactionOutcome}
            MsolUser        :
            AADUser         : class User {}
            AADUserMgr      :
            AADUserLics     :
            LicenseGroup    :
            isDirSynced     : True
            isNoBrain       : False
            isSplitBrain    : False
            IsLicensed      : 0
            IsDisabledOU    : False
            IsADDisabled    : 0
            IsAADDisabled   : 0

    The following items above are substantial copies of the original cloud or OnPrem objects:

        OPRcp           : OnPrem recipient details
        xoRcp           : Cloud recipient details
        OPMailbox       : OnPrem mailbox details (if present)
        OPRemoteMailbox : OnPrem RemoteMailbox details
        ADUser          : OnPrem ActiveDirectory ADUser object details
        xoMailbox       : Cloud mailbox details 
        xoMUser         : Cloud MailUser object details 
        xoUser          : Cloud Exchange Online 'User' object details
        txGuest         : Cloud Guest details
        OPMapiTest      : Results of OnPrem mailbox access tests
        xoMapiTest      : Results of cloud mailbox access tests
        MsolUser        : Cloud MsolUser object details
        AADUser         : Cloud AzureADUser object details
        AADUserMgr      : Cloud subject user's 'ManagedBy' AzureADUser object details

        Each can be accessed, if -outObject was used and the output assigned to a variable, as a dotted-property of the variable ($variable.property):

            PS> $$results.xomailbox

                Name                   Alias      ServerName    ProhibitSendQuota
                ----                   -----      ----------    -----------------
                lync test14_0650dc758f lynctest14 xxnxx0nxxnnnn 10 GB (10,737,418,240 bytes)


    .PARAMETER users
    Array of user descriptors: displayname, emailaddress, UPN, samaccountname (checks clipboard where unspecified)[-users 'xxx','yyy']
    .PARAMETER Ticket
    Ticket Number [-Ticket '999999']
    .PARAMETER getMobile
    switch to return mobiledevice info for target user[-getMobile]
    .PARAMETER getQuotaUsage
    switch to return Quota & MailboxFolderStatistics & LegalHold analysis (XO-only)[-getQuotaUsage]
    .PARAMETER DeletedItems
    switch to return Quota & MailboxFolderStatistics & LegalHold analysis and return information about DeletedItems and RecoverableItems folders(XO-only)[-DeletedItems]
    .PARAMETER getPerms
    switch to return Get-xoMailboxPermission & Get-xoRecipientPermission, non-SELF grants, and membership of any grant groups (XO-only)[-getPerms]
    .PARAMETER ResolveForwards
    switch to resolve MailContact email addresses against the population of forwarded RemoteMailbox objects(XO-only)[-ResolveForwards]
    .PARAMETER xoMobileDeviceOLDThreshold
    Integer days since LastSyncAttemptTime that classifies a MobileDevice as xoMobileDeviceStatsOLD (defaults to 30)[-xoMobileDeviceOLDThreshold 45]
    .PARAMETER rgxAccentedNameChars
    Regular Expression that identifies input 'user' strings that should have diacriticals/latin/non-simple english characters replaced, before lookups (has default value, used to override for future temp exclusion)[-rgxAccentedNameChars `$rgx]
    .PARAMETER TenOrg
    TenantTag value, indicating Tenants to connect to[-TenOrg 'ABC']
    .PARAMETER Credential
    Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]
    .PARAMETER UserRole
    Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER silent
    Silent output (suppress status echos, defaults true)[-silent]
    .PARAMETER outObject
    switch to return a system.object summary to the pipeline[-outObject]
    .PARAMETER useJson
    switch to format object pipeline & file exports in JSON format (vs default .xml, avoids issues with export-cliXML and MG module data)[-useJson]
    .PARAMETER Depth
    Integer 'depth' to be used for export-clixml (or convertto-json, where -useJson specified) cmdlet for exporting report object to the output format. Directly impacts resulting file size and extent to which full nested objects are captured in the export. Defaults to 2
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    System.Object - returns summary report to pipeline
    .EXAMPLE
    PS> resolve-user 
    Default, no user identifier specified: attempts to parse a user descriptor from clipboard contents
    .EXAMPLE
    PS> resolve-user -users 'John Public'
    Process user displayname
    .EXAMPLE
    PS> resolve-user -users 'Test@domain.com','User Name','Alias','ExternalContact@emaildomain.com','confroom@tenant.onmicrosoft.com' -verbose ;
    Process an array of descriptors
    .EXAMPLE
    PS> $results = resolve-user -outobject -users 'Test@domain.com','John Public','Alias','ExternalContact@emaildomain.com','confroom@tenant.onmicrosoft.com''  ;
    PS> $feds = $results| group federator | select -expand name ;
    PS> write-verbose "echo filtered subsets" ;
    PS> ($results| ?{$_.federator -eq $feds[1] }).xomailbox
    PS> ($results| ?{$_.federator -eq $feds[1] }).xomailbox.primarysmtpaddress
    PS> write-verbose "profile results:" ; 
    PS> $analysis = foreach ($data in $resolved_objects){
    PS>     $Rpt = [ordered]@{
    PS>         PrimarySmtpAddress = $data.xorcp.primarysmtpaddress ; 
    PS>         ADUser_UPN = $data.aduser.userprincipalname ; 
    PS>         AADUser_UPN = $data.aaduser.UserPrincipalName ; 
    PS>         isDirSynced = $data.isDirSynced ; 
    PS>         IsNoBrain = $data.IsNoBrain ; 
    PS>         isSplitBrain = $data.isSplitBrain;
    PS>         IsLicensed = $data.IsLicensed;
    PS>         IsDisabledOU = $data.IsDisabledOU;
    PS>         IsADDisabled = $data.IsADDisabled; 
    PS>         IsAADDisabled = $data.IsAADDisabled;
    PS>     } ; 
    PS>     [pscustomobject]$Rpt ; 
    PS> } ; 
    PS> write-verbose "output tabular results" ; 
    PS> $analysis | ft -auto ;
    
    Demo does the following: 
        - Process array of users, specify return detailed object (-outobject), for post-processing & filtering,
        - Group results on federation sources,
        - Output summary of EXO mailboxes for the second federator
        - Then output the primary smtpaddress for all EXO mailboxes resolved to that federator
        - Then create a summary object of the is* properties and UPN, primarySmtpAddress, 
        - Finally display the summary as a console table
    .EXAMPLE
    PS> $rptNNNNNN_FName_LName_Domain_com = ulu -o -users 'FName.LName@Domain.com' ;  $rpt655692_FName_LName_Domain_com | xxml .\logs\rpt655692_FName_LName_Domain_com.xml
    Example (from ahk 7uluo! macro parser output) that creates a variable based on ticketnumber & email address (with underscores for alphanums), from the output, and then exports the variable content to xml. 
    Assigns to an immediately parsable inmem variable, along with the canned .xml that can be reloaded in future, or attached to a ticket.
    .EXAMPLE
    PS> $999999Rpt = resolve-user fname.lname@DOMAIN.COM -Ticket 99999 -getQuotaUsage -outObject ; 

        10:39:53:===v (1/1):Input: 'FNAME.LNAME@DOMAIN.COM' | 'FNAME' | 'LNAME' v===(EML)
        get-Rmbx/xMbx: (Rmbx)(TOR USER, fed:SUB.DOMAIN.COM)
        SamAccountName | WindowsEmailAddress
        LNAMEFI         | FNAME.LNAME@DOMAIN.COM
        Office | RecipientTypeDetails | RemoteRecipientType | IsDirSynced
                | RemoteUserMailbox    | Migrated            |
        ExternalDirectoryObjectId | CustomAttribute5 | EmailAddressPolicyEnabled
                                    |                  | True
        Outlook (xoMAPI) Access Test Result:Success
        xoMailboxStats Count:1
        10:39:56: INFO:  (-getQuotaUsage:running lengthy Get-xoMailboxFolderStatistics...)
        =get-AADuser FNAME.LNAME@DOMAIN.COM>:
        =get-AADuserManager FNAME.LNAME@DOMAIN.COM>:
        ===$hSum.ADUser: 
        UPN                 | DName      | FName | LName | Title                             
        FNAME.LNAME@DOMAIN.COM | FNAME LNAME | FNAME | LNAME  | Supervisor II, Distribution Center
        Company | Dept                            | Ofc          
                | Operations Distribution El Paso | El Paso-D, TX
        Street | City | State | Zip | Phone           | Mobile
                |      |       |     | +1 915 231 7404 |
        Enabled | DN                                                          
        True    | CN=FNAME LNAME,OU=Users,OU=ELP,DC=SD,DC=sub,DC=domain,DC=com
        whenCreated          | whenChanged         
        8/18/2017 4:13:54 PM | 2/23/2024 8:23:33 AM
        Desc : 8/21/17 FT for FNAME LNAME 146294 -bk
        LicenseGroup:(direct-assigned E3)
        ===$hSum.MGUserMgr: 
        UserPrincipalName       | Mail                   
        FNAME.LNAME@DOMAIN.COM | FNAME.LNAME@DOMAIN.COM
        OpOU : OU=Users,OU=ELP,DC=SD,DC=sub,DC=domain,DC=com
        10:40:06: PROMPT:  UserPrincipalName       | Mail                   
        FNAME.LNAME@DOMAIN.COM | FNAME.LNAME@DOMAIN.COM
        OpOU : OU=Users,OU=ELP,DC=SD,DC=sub,DC=domain,DC=com

        Licenses::
        MCOEV, FLOW_FREE, MCOPSTNC, ENTERPRISEPACK, POWER_BI_STANDARD, EMS, Microsoft_Teams_Audio_Conferencing_select_dial_out

        which specify the following size limits:
        IssueWarningQuotaMB        : 14336
        ProhibitSendQuotaMB        : 15360
        ProhibitSendReceiveQuotaMB : 17408
        (UseDatabaseQuotaDefaults:False)

        Current TotalMailboxSizeMB: 10912.2

        10:40:06: PROMPT:  QuotaStatus: Mailbox is below mandated SendReceiveQuotaMB by 4,447.80 megabytes
        10:40:06: PROMPT:  
        With the following non-zero folder metrics

        Folder                                                               Items SizeMB  OldestItem NewestItem          FolderType               
        ------                                                               ----- ------  ---------- ----------          ----------               
        annnnnnn-nbne-nnnn-anne-necncannbnnn\Inbox                           23774 5764.38 20230111   02/27/2024 16:37:25 Inbox                    
        annnnnnn-nbne-nnnn-anne-necncannbnnn\Deleted Items                   12434 4599.58 20220323   02/27/2024 16:35:34 DeletedItems             
        ...
        annnnnnn-nbne-nnnn-anne-necncannbnnn\Top of Information Store        1     0                                      Root
        10:40:06: INFO:  
        ===output to::
        D:\scripts\logs\823795-FNAME.LNAME@DOMAIN.COM-folder-sizes-NONHIDDEN-NONZERO-run20240227-1039AM.xml

        10:40:09: WARNING:  
        10:40:09: WARNING:  
        10:40:09: WARNING:  EVIDENCE OF LEGAL HOLD DETECTED!:
        10:40:09: WARNING:  LitigationHoldEnabled    : False
        10:40:09: WARNING:  
        10:40:09: WARNING:  InPlaceHolds             : UniHnbnednbn-bndn-nnnf-nddn-annndnndnnae, UniHnnnneene-ndnd-naae-annn-nnnnnnnnnncn
        10:40:09: WARNING:  
        10:40:09: WARNING:  ComplianceTagHoldApplied : False
        10:40:09: WARNING:  
        10:40:09: WARNING:  DelayHoldApplied         : False
        10:40:09: WARNING:  
        10:40:09: WARNING:  DelayReleaseHoldApplied  : False
        10:40:09: WARNING:  
        10:40:09: WARNING:  
        10:40:09: WARNING:  Folder          Items    SizeMB OldestItem NewestItem          FolderType                    
        10:40:09: WARNING:  
        10:40:09: WARNING:  ------          -----    ------ ---------- ----------          ----------                    
        10:40:09: WARNING:  
        10:40:09: WARNING:  DiscoveryHolds 267225 101967.69            02/21/2024 08:42:57 RecoverableItemsDiscoveryHolds
        10:40:09: WARNING:  
        10:40:09: WARNING:  
        10:40:09: WARNING:  - DiscoveryHolds folder: If In-Place Hold is enabled or if a Microsoft 365 or Office 365 retention policy is assigned to the mailbox, this subfolder contains all items that meet the hold query parameters and are hard deleted.
        10:40:09: WARNING:  - DiscoveryHolds folder.NewestItem: Will reflect *last time LegalHold captured an item* (e.g. if/when LH was disabled and stopped holding traffic, if in the past)
        10:40:09: WARNING:  
    
    Example that includes the -getQuotaUsage parameter, to return details on xo MailboxFolderStatistics and effective Quota, around users with mailbox size issues, and assigns the returned summary to the variable `$999999Rpt
    Note: use of -getQuotaUsage also does an extensive check for LegalHold signs in the mailbox. including reporting on:
        - xoMailbox.LitigationHoldEnabled
        - xoMailbox.InPlaceHolds, 
        - xoMailbox.ComplianceTagHoldApplied
        - xoMailbox.DelayHoldApplied 
        - xoMailbox.DelayReleaseHoldApplied 
        - checks if xoMailboxFolderStats 'DiscoveryHolds' folder has ItemsInFolder -gt 0
    .EXAMPLE
    PS> $999999Rpt = resolve-user fname.lname@DOMAIN.COM -Ticket 99999 -getPerms -outObject ; 

        # [... additional Permissions output returned]
        10:42:56: PROMPT:
        ## xoMailboxPermission:
        Identity                             User                          AccessRights
        --------                             ----                          ------------
        xx299x9x-x51x-4562-8xx8-x2x45796x2xx ABC-SEC-Email-xxxxxxxxxxxxx-G {FullAccess}

        ### Expanded Perm Group Summaries:
        -----------
        Identity                             | PrimarySmtpAddress
        522x58x1-11x9-4x28-x391-1x8xxx211xxx | ABC-SEC-Email-xxxxxxxxxxxxx-G@DOMAIN.COM
        RecipientType              | RecipientTypeDetails       | ManagedBy
        MailUniversalSecurityGroup | MailUniversalSecurityGroup | Christie Moore
        Description :
        #### Members:
        Alias   PrimarySmtpAddress        RecipientType RecipientTypeDetails
        -----   ------------------        ------------- --------------------
        xxxxxxx xxxxxxxx.xxxxx@DOMAIN.COM UserMailbox   UserMailbox

        ## xoRecipientPermission:
        Identity                             Trustee                              AccessControlType AccessRights Inherited
        --------                             -------                              ----------------- ------------ ---------
        xx299x9x-x51x-4562-8xx8-x2x45796x2xx 522x58x1-11x9-4x28-x391-1x8xxx211xxx Allow             {SendAs}

        ### Expanded Perm Group Summaries:
        -----------
        Identity                             | PrimarySmtpAddress
        522x58x1-11x9-4x28-x391-1x8xxx211xxx | ABC-SEC-Email-xxxxxxxxxxxxx-G@DOMAIN.COM
        RecipientType              | RecipientTypeDetails       | ManagedBy
        MailUniversalSecurityGroup | MailUniversalSecurityGroup | Christie Moore
        Description :
        #### Members:
        Alias   PrimarySmtpAddress        RecipientType RecipientTypeDetails
        -----   ------------------        ------------- --------------------
        xxxxxxx xxxxxxxx.xxxxx@DOMAIN.COM UserMailbox   UserMailbox
    .EXAMPLE
    PS> $999999Rpt = resolve-user fname.lname@DOMAIN.COM -Ticket 99999 -getMobile -outObject ;
        
            .EXAMPLE
    PS> $results = resolve-user -users 'John Public' -getmobile -outobject ; 
        
        ...
        xoMobileDeviceStats Count:2
        ...

        $results.xoMobileDeviceStats: 

        FirstSyncTime         LastPolicyUpdateTime  LastSyncAttemptTime  LastSuccessSync      DeviceType  DeviceID                         DeviceUserAgent       DeviceWipeSentTime DeviceWipeRequestTime DeviceWipeAckTime
        -------------         --------------------  -------------------  ---------------      ----------  --------                         ---------------       ------------------ --------------------- -----------------
        8/17/2023 10:50:16 PM 1/16/2025 10:08:42 AM 1/16/2025 5:45:14 PM 1/16/2025 5:45:14 PM Outlook     nXnXXn0XnnnXn0nnAAXA0XnnX0XnnnnX Outlook-Android/2.0
    
    Demo with the -getMobile parameter, to return details on xo MobileDevices in use with the EXO mailbox. Demos default output 'xoMobileDeviceStats Count' echo, and detailed xoMobileDeviceStats object output
    .EXAMPLE
    PS> resolve-user -users FNAME.LNAME@DOMAIN.com -Ticket 999999 -usejson -depth 2 ; 
    Example using json output, to Depth of 2.
    .LINK
    https://github.com/tostka/verb-exo
    #>

    #Requires -Modules ActiveDirectory, MSOnline, AzureAD, ExchangeOnlineManagement, verb-AAD, verb-ADMS, verb-Auth, verb-IO, verb-logging
    ##Requires -RunasAdministrator
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    [Alias('ulu')]
    PARAM(
        [Parameter(Position=0,Mandatory=$False,ValueFromPipeline=$true,HelpMessage="Array of user descriptors: displayname, emailaddress, UPN, samaccountname (checks clipboard where unspecified)[-users 'xxx','yyy']")]
            #[ValidateNotNullOrEmpty()] # pulls string from clipboard if not populated
            [Alias('UserPrincipalName', 'Samaccountname','DisplayName','Name')]
            [array]$users,
        [Parameter(Mandatory=$False,HelpMessage="Ticket Number [-Ticket '999999']")]
            [string]$Ticket,
        [Parameter(HelpMessage="switch to return mobiledevice info for target user[-getMobile]")]
            [Alias('Mobile')]
            [switch] $getMobile,
        [Parameter(HelpMessage="switch to return Quota & MailboxFolderStatistics & LegalHold analysis (XO-only)[-getQuotaUsage]")]
            [Alias('Quota')]
            [switch]$getQuotaUsage,
        [Parameter(HelpMessage="switch to return Quota & MailboxFolderStatistics & LegalHold analysis and return information about DeletedItems and RecoverableItems folders(XO-only)[-DeletedItems]")]
            #[Alias('')]
            [switch]$DeletedItems,
        [Parameter(HelpMessage="switch to return Get-xoMailboxPermission & Get-xoRecipientPermission, non-SELF grants, and membership of any grant groups (XO-only)[-getPerms]")]
            [Alias('Perms','getPermissions')]
            [switch]$getPerms,
        [Parameter(HelpMessage="switch to resolve MailContact email addresses against the population of forwarded RemoteMailbox objects(XO-only)[-ResolveForwards]")]
            [switch]$ResolveForwards,
        [Parameter(HelpMessage="Integer days since LastSyncAttemptTime that classifies a MobileDevice as xoMobileDeviceStatsOLD (defaults to 30)[-xoMobileDeviceOLDThreshold 45]")]
            [int]$xoMobileDeviceOLDThreshold = 30,
        [Parameter(HelpMessage="Regular Expression that identifies input 'user' strings that should have diacriticals/latin/non-simple english characters replaced, before lookups (has default value, used to override for future temp exclusion)[-rgxAccentedNameChars `$rgx]")]
            [ValidateNotNullOrEmpty()]
            [regex]$rgxAccentedNameChars = "[^a-zA-Z0-9\s\.\(\)\{\}\/\&\$\#\@\,\`"\'\’\:\–_-]",
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'ABC']")]
            [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ;
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ;
                return $true ;
            })]
            [string[]]$UserRole =  @('ESvcCBA','CSvcCBA','SIDCBA','SID','CSVC'),
            #@('SID','CSVC'),
            # flip to promptless svcAcct use (SID triggers mauth on phn_, includ failthru sid etc trailing, for admins that don't config cba
            # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
            [switch] $useEXOv2=$true,
        [Parameter(HelpMessage="Silent output (suppress status echos, defaults true)[-silent]")]
            [switch] $silent=$true,
        [Parameter(HelpMessage="switch to return a system.object summary to the pipeline[-outObject]")]
            [switch] $outObject,        
        [Parameter(HelpMessage="switch to format object pipeline & file exports in JSON format (vs default .xml, avoids issues with export-cliXML and MG module data)[-useJson]")]
            [switch]$useJson,
        [Parameter(HelpMessage="Integer 'depth' to be used for export-clixml (or convertto-json, where -useJson specified) cmdlet for exporting report object to the output format. Directly impacts resulting file size and extent to which full nested objects are captured in the export. Defaults to 2")]
            [int]$Depth = 2
    ) ;
    BEGIN{
        #region CONSTANTS_AND_ENVIRO ; #*======v CONSTANTS_AND_ENVIRO v======
        #region CONSTANTS_AND_ENVIRO ; #*======v CONSTANTS_AND_ENVIRO v======
        #region ENVIRO_DISCOVER ; #*------v ENVIRO_DISCOVER v------
        push-TLSLatest
        $Verbose = [boolean]($VerbosePreference -eq 'Continue') ; 
        $rPSCmdlet = $PSCmdlet ; # an object that represents the cmdlet or advanced function that's being run. Available on functions w CmdletBinding (& $args will not be available). (Blank on non-CmdletBinding/Non-Adv funcs).
        $rPSScriptRoot = $PSScriptRoot ; # the full path of the executing script's parent directory., PS2: valid only in script modules (.psm1). PS3+:it's valid in all scripts. (Funcs: ParentDir of the file that hosts the func)
        $rPSCommandPath = $PSCommandPath ; # the full path and filename of the script that's being run, or file hosting the funct. Valid in all scripts.
        $rMyInvocation = $MyInvocation ; # populated only for scripts, function, and script blocks.
        # - $MyInvocation.MyCommand.Name returns name of a function, to identify the current command,  name of the current script (pop'd w func name, on Advfuncs)
        # - Ps3+:$MyInvocation.PSScriptRoot : full path to the script that invoked the current command. The value of this property is populated only when the caller is a script (blank on funcs & Advfuncs)
        # - Ps3+:$MyInvocation.PSCommandPath : full path and filename of the script that invoked the current command. The value of this property is populated only when the caller is a script (blank on funcs & Advfuncs)
        #     ** note: above pair contain information about the _invoker or calling script_, not the current script
        $rPSBoundParameters = $PSBoundParameters ; 
        #region PREF_VARI_DUMP ; #*------v PREF_VARI_DUMP v------
        <#$script:prefVaris = @{
            whatifIsPresent = $whatif.IsPresent
            whatifPSBoundParametersContains = $rPSBoundParameters.ContainsKey('WhatIf') ; 
            whatifPSBoundParameters = $rPSBoundParameters['WhatIf'] ;
            WhatIfPreferenceIsPresent = $WhatIfPreference.IsPresent ; # -eq $true
            WhatIfPreferenceValue = $WhatIfPreference;
            WhatIfPreferenceParentScopeValue = (Get-Variable WhatIfPreference -Scope 1).Value ;
            ConfirmPSBoundParametersContains = $rPSBoundParameters.ContainsKey('Confirm') ; 
            ConfirmPSBoundParameters = $rPSBoundParameters['Confirm'];
            ConfirmPreferenceIsPresent = $ConfirmPreference.IsPresent ; # -eq $true
            ConfirmPreferenceValue = $ConfirmPreference ;
            ConfirmPreferenceParentScopeValue = (Get-Variable ConfirmPreference -Scope 1).Value ; 
            VerbosePSBoundParametersContains = $rPSBoundParameters.ContainsKey('Confirm') ; 
            VerbosePSBoundParameters = $rPSBoundParameters['Verbose'] ;
            VerbosePreferenceIsPresent = $VerbosePreference.IsPresent ; # -eq $true
            VerbosePreferenceValue = $VerbosePreference ;
            VerbosePreferenceParentScopeValue = (Get-Variable VerbosePreference -Scope 1).Value;
            VerboseMyInvContains = '-Verbose' -in $rPSBoundParameters.UnboundArguments ; 
            VerbosePSBoundParametersUnboundArgumentContains = '-Verbose' -in $rPSBoundParameters.UnboundArguments 
        } ;
        write-verbose "`n$(($script:prefVaris.GetEnumerator() | Sort-Object Key | Format-Table Key,Value -AutoSize|out-string).trim())`n" ; 
        #>
        #endregion PREF_VARI_DUMP ; #*------^ END PREF_VARI_DUMP ^------
        #region RV_ENVIRO ; #*------v RV_ENVIRO v------
        $pltRvEnv=[ordered]@{
            PSCmdletproxy = $rPSCmdlet ; 
            PSScriptRootproxy = $rPSScriptRoot ; 
            PSCommandPathproxy = $rPSCommandPath ; 
            MyInvocationproxy = $rMyInvocation ;
            PSBoundParametersproxy = $rPSBoundParameters
            verbose = [boolean]($PSBoundParameters['Verbose'] -eq $true) ; 
        } ;
        write-verbose "(Purge no value keys from splat)" ; 
        $mts = $pltRVEnv.GetEnumerator() |?{$_.value -eq $null} ; $mts |%{$pltRVEnv.remove($_.Name)} ; rv mts -ea 0 -whatif:$false -confirm:$false; 
        $smsg = "resolve-EnvironmentTDO w`n$(($pltRVEnv|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        if(get-command resolve-EnvironmentTDO -ea STOP){}ELSE{
            $smsg = "UNABLE TO gcm resolve-EnvironmentTDO!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            BREAK ; 
        } ; 
        $rvEnv = resolve-EnvironmentTDO @pltRVEnv ; 
        $smsg = "`$rvEnv returned:`n$(($rvEnv |out-string).trim())" ; 
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        #endregion RV_ENVIRO ; #*------^ END RV_ENVIRO ^------
        #region NETWORK_INFO ; #*======v NETWORK_INFO v======
        if(get-command resolve-NetworkLocalTDO  -ea STOP){}ELSE{
            $smsg = "UNABLE TO gcm resolve-NetworkLocalTDO !" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            BREAK ; 
        } ; 
        $netsettings = resolve-NetworkLocalTDO ; 
        if($env:Userdomain){ 
            switch($env:Userdomain){
                'CMW'{
                    #$logon_SID = $CMW_logon_SID 
                }
                'TORO'{
                    #$o365_SIDUpn = $o365_Toroco_SIDUpn ; 
                    #$logon_SID = $TOR_logon_SID ; 
                }
                $env:COMPUTERNAME{
                    $smsg = "%USERDOMAIN% -EQ %COMPUTERNAME%: $($env:computername) => non-domain-connected, likely edge role Ex server!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    if($netsettings.Workgroup){
                        $smsg = "WorkgroupName:$($netsettings.Workgroup)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;                    
                    } ; 
                } ; 
                default{
                    $smsg = "$($env:userdomain):UNRECOGIZED/UNCONFIGURED USER DOMAIN STRING!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    THROW $SMSG 
                    BREAK ; 
                }
            } ; 
        } ;  # $env:Userdomain-E
        #endregion NETWORK_INFO ; #*======^ END NETWORK_INFO ^======
        #region OS_INFO ; #*------v OS_INFO v------
        <# os detect, covers Server 2016, 2008 R2, Windows 10, 11
        if (get-command get-ciminstance -ea 0) {$OS = (Get-ciminstance -class Win32_OperatingSystem)} else {$Os = Get-WMIObject -class Win32_OperatingSystem } ;
        #$isWorkstationOS = $isServerOS = $isW2010 = $isW2011 = $isS2016 = $isS2008R2 = $false ;
        write-host "Detected:`$Os.Name:$($OS.name)`n`$Os.Version:$($Os.Version)" ;
        if ($OS.name -match 'Microsoft\sWindows\sServer') {
            $isServerOS = $true ;
            if ($os.name -match 'Microsoft\sWindows\sServer\s2016'){$isS2016 = $true ;} ;
            if ($os.name -match 'Microsoft\sWindows\sServer\s2008\sR2') { $isS2008R2 = $true ; } ;
        } else { 
            if ($os.name -match '^Microsoft\sWindows\s11') {
                $isWorkstationOS = $true ;
                if ($os.name -match 'Microsoft\sWindows\s11') { $isW2011 = $true ; } ;
            } elseif ($os.name -match '^Microsoft\sWindows\s10') {
                $isWorkstationOS = $true ; $isW2010 = $true
            } else {
                $isWorkstationOS = $true ;
            } ;         
        } ; 
        #>
        #endregion OS_INFO ; #*------^ END OS_INFO ^------
        #region TEST_EXOPLOCAL ; #*------v TEST_EXOPLOCAL v------
        if(get-command test-LocalExchangeInfoTDO -ea STOP){}ELSE{
            $smsg = "UNABLE TO gcm test-LocalExchangeInfoTDO !" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            BREAK ; 
        } ; 
        $lclExOP = test-LocalExchangeInfoTDO ; 
        write-verbose "Expand returned NoteProperty properties into matching local variables" ; 
        if($host.version.major -gt 2){
            $lclExOP.PsObject.Properties | ?{$_.membertype -eq 'NoteProperty'} | foreach-object{set-variable -name $_.name -value $_.value -verbose -whatif:$false -Confirm:$false ;} ;
        }else{
            write-verbose "Psv2 lacks the above expansion capability; just create simpler variable set" ; 
            $ExVers = $lclExOP.ExVers ; $isLocalExchangeServer = $lclExOP.isLocalExchangeServer ; $IsEdgeTransport = $lclExOP.IsEdgeTransport ;
        } ;
        #
        #endregion TEST_EXOPLOCAL ; #*------^ END TEST_EXOPLOCAL ^------

                                                        <#
    #region PsParams ; #*------v PSPARAMS v------
    $PSParameters = New-Object -TypeName PSObject -Property $rPSBoundParameters ;
    # DIFFERENCES $PSParameters vs $PSBoundParameters:
    # - $PSBoundParameters: System.Management.Automation.PSBoundParametersDictionary (native obj)
    # test/access: ($PSBoundParameters['Verbose'] -eq $true) ; $PSBoundParameters.ContainsKey('Referrer') #hash syntax
    # CAN use as a @PSBoundParameters splat to push through (make sure populated, can fail if wrong type of wrapping code)
    # - $PSParameters: System.Management.Automation.PSCustomObject (created obj)
    # test/access: ($PSParameters.verbose -eq $true) ; $PSParameters.psobject.Properties.name -contains 'SenderAddress' ; # cobj syntax
    # CANNOT use as a @splat to push through (it's a cobj)
    write-verbose "`$rPSBoundParameters:`n$(($rPSBoundParameters|out-string).trim())" ;
    # pre psv2, no $rPSBoundParameters autovari to check, so back them out:
    #>
        <# recycling $rPSBoundParameters into @splat calls: (can't use $psParams, it's a cobj, not a hash!)
        # rgx for filtering $rPSBoundParameters for params to pass on in recursive calls (excludes keys matching below)
        $rgxBoundParamsExcl = '^(Name|RawOutput|Server|Referrer)$' ; 
        if($rPSBoundParameters){
                $pltRvSPFRec = [ordered]@{} ;
                # add the specific Name for this call, and Server spec (which defaults, is generally not 
                $pltRvSPFRec.add('Name',"$RedirectRecord" ) ;
                $pltRvSPFRec.add('Referrer',$Name) ; 
                $pltRvSPFRec.add('Server',$Server ) ;
                $rPSBoundParameters.GetEnumerator() | ?{ $_.key -notmatch $rgxBoundParamsExcl} | foreach-object { $pltRvSPFRec.add($_.key,$_.value)  } ;
                write-host "Resolve-SPFRecord w`n$(($pltRvSPFRec|out-string).trim())" ;
                Resolve-SPFRecord @pltRvSPFRec  | write-output ;
        } else {
            $smsg = "unpopulated `$rPSBoundParameters!" ;
            write-warning $smsg ;
            throw $smsg ;
        };     
        #>
        #endregion PsParams ; #*------^ END PSPARAMS ^------    
        #endregion ENVIRO_DISCOVER ; #*------^ END ENVIRO_DISCOVER ^------

        #region COMMON_CONSTANTS ; #*------v COMMON_CONSTANTS v------
    
        if(-not $DoRetries){$DoRetries = 4 } ;    # # times to repeat retry attempts
        if(-not $RetrySleep){$RetrySleep = 10 } ; # wait time between retries
        if(-not $RetrySleep){$DawdleWait = 30 } ; # wait time (secs) between dawdle checks
        if(-not $DirSyncInterval){$DirSyncInterval = 30 } ; # AADConnect dirsync interval
        if(-not $ThrottleMs){$ThrottleMs = 50 ;}
        if(-not $rgxDriveBanChars){$rgxDriveBanChars = '[;~/\\\.:]' ; } ; # ;~/\.:,
        if(-not $rgxCertThumbprint){$rgxCertThumbprint = '[0-9a-fA-F]{40}' } ; # if it's a 40char hex string -> cert thumbprint  
        if(-not $rgxSmtpAddr){$rgxSmtpAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ; } ; # email addr/UPN
        if(-not $rgxDomainLogon){$rgxDomainLogon = '^[a-zA-Z][a-zA-Z0-9\-\.]{0,61}[a-zA-Z]\\\w[\w\.\- ]+$' } ; # DOMAIN\samaccountname 
        if(-not $exoMbxGraceDays){$exoMbxGraceDays = 30} ; 
        if(-not $XOConnectionUri ){$XOConnectionUri = 'https://outlook.office365.com'} ; 
        if(-not $SCConnectionUri){$SCConnectionUri = 'https://ps.compliance.protection.outlook.com'} ; 
        if(-not $XODefaultPrefix){$XODefaultPrefix = 'xo' };
        if(-not $SCDefaultPrefix){$SCDefaultPrefix = 'sc' };
        #$rgxADDistNameGAT = ",$(($TORMeta.UnreplicatedOU -split ',' | select -skip 1 ) -join ',')" 
        #$rgxADDistNameAT = ",$(($TORMeta.UnreplicatedOU -split ',' | select -skip 2 ) -join ',')"

        write-verbose "Coerce configured but blank Resultsize to Unlimited" ; 
        if(get-variable -name resultsize -ea 0){
            if( ($null -eq $ResultSize) -OR ('' -eq $ResultSize) ){$ResultSize = 'unlimited' }
            elseif($Resultsize -is [int]){} else {throw "Resultsize must be an integer or the string 'unlimited' (or blank)"} ;
        } ; 
        #$ComputerName = $env:COMPUTERNAME ;
        #$NoProf = [bool]([Environment]::GetCommandLineArgs() -like '-noprofile'); # if($NoProf){# do this};
        # XXXMeta derived constants:
        # - AADU Licensing group checks
        # calc the rgxLicGrpName fr the existing $xxxmeta.rgxLicGrpDN: (get-variable tormeta).value.rgxLicGrpDN.split(',')[0].replace('^','').replace('CN=','')
        #$rgxLicGrpName = (get-variable -name "$($tenorg)meta").value.rgxLicGrpDN.split(',')[0].replace('^','').replace('CN=','')
        # use the dn vers LicGrouppDN = $null ; # | ?{$_ -match $tormeta.rgxLicGrpDN}
        #$rgxLicGrpDN = (get-variable -name "$($tenorg)meta").value.rgxLicGrpDN
        # email trigger vari, it will be semi-delimd list of mail-triggering events
        $script:PassStatus = $null ;
        # TenOrg or other looped-specific PassStatus (auto supported by 7pswlt)
        #New-Variable -Name PassStatus_$($tenorg) -scope Script -Value $null ;
        [array]$SmtpAttachment = $null ;
        #write-verbose "start-Timer:Master" ; 
        $swM = [Diagnostics.Stopwatch]::StartNew() ;
        # $ByPassLocalExchangeServerTest = $true # rough in, code exists below for exempting service/regkey testing on this variable status. Not yet implemented beyond the exemption code, ported in from orig source.
        #endregion COMMON_CONSTANTS ; #*------^ END COMMON_CONSTANTS ^------
        #region LOCAL_CONSTANTS ; #*------v LOCAL_CONSTANTS v------        
        $rgxEmailAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ;
        # added support for . fname lname delimiter (supports pasted in dirname of email addresses, as user)
        $rgxDName = "^([a-zA-Z]{2,}(\s|\.)[a-zA-Z]{1,}'?-?[a-zA-Z]{2,}\s?([a-zA-Z]{1,})?)" ;
        #updated: CMW uses : in their room names, so went for broader AD dname support, per AI, and web specs, added 1-256char AD restriction
        $rgxDName ="[a-zA-Z0-9\s$([Regex]::Escape('/\[:;|=,+*?<>') + '\]' + '\"')]{1,256}" ; 
        #"^([a-zA-Z]{2,}\s[a-zA-Z]{1,}'?-?[a-zA-Z]{2,}\s?([a-zA-Z]{1,})?)" ;
        $rgxObjNameNewHires = "^([a-zA-Z]{2,}(\s|\.)[a-zA-Z]{1,}'?-?[a-zA-Z]{2,}\s?([a-zA-Z]{1,})?)_[a-z0-9]{10}"  # Name:Fname LName_f4feebafdb (appending uniqueness guid chunk)
        $rgxSamAcctNameTOR = "^\w{2,20}$" ; # up to 20k, the limit prior to win2k
        #$rgxSamAcctName = "^[^\/\\\[\]:;|=,+?<>@?]+$" # no char limit ;
        $MaxRecips = 25 ; # max number of objects to permit on a return resultsize/,ResultSetSize, to prevent empty set return of everything in the addressspace
        # interpolate from TORMETA
        $rgxADDistNameGAT = ",$(($TORMeta.UnreplicatedOU -split ',' | select -skip 1 ) -join ',')" 
        $rgxADDistNameAT = ",$(($TORMeta.UnreplicatedOU -split ',' | select -skip 2 ) -join ',')"
        #$DNDOM = @() ; 
        #$TORMeta.adforestname.split('.') | %{$dndom += "DC=$($_)"} ;
        #$rgxADDistNameAT = [regex]::Escape($DNDOM -join ',') ; 

        # props dyn filtering: write-host "=get-xMbx:>`n$(($hSum.xoMailbox |fl ($xMprops |?{$_     -notmatch '(sam.*|dist.*)'})|out-string).trim())`n-Title:$($hSum.xoUser.Title)";
        # $propsMailx: add email-drivers: CustomAttribute5, EmailAddressPolicyEnabled
        # 11:01 AM 12/27/2021 add forwarding settings (critical to bounce/block tracking for RM)
        #$propsMailx='samaccountname','windowsemailaddress','DistinguishedName','Office','RecipientTypeDetails','RemoteRecipientType','IsDirSynced','ExternalDirectoryObjectId','CustomAttribute5','EmailAddressPolicyEnabled' ;
        $propsMailx='samaccountname','windowsemailaddress','DistinguishedName','Office','RecipientTypeDetails','RemoteRecipientType',
            'IsDirSynced','ExternalDirectoryObjectId','CustomAttribute5','EmailAddressPolicyEnabled',
            'DeliverToMailboxAndForward','DeliverToMailboxAndForward','ForwardingSmtpAddress' ;
        # pulls: 'ImmutableId',
        # 1:41 PM 12/27/2021 add multiline md tbl output
        $propsMailxL1 = 'SamAccountName','WindowsEmailAddress' ; 
        $propsMailxL2 = 'Office','RecipientTypeDetails','RemoteRecipientType', 'IsDirSynced' ;
        $propsMailxL3 = 'ExternalDirectoryObjectId','CustomAttribute5','EmailAddressPolicyEnabled' ; 
        $propsMailxL4 = 'DistinguishedName' ; 
        $propsMailxL5 = 'ForwardingAddress','ForwardingSmtpAddress','DeliverToMailboxAndForward' ;        
        $propsXMFed = 'samaccountname','windowsemailaddress','DistinguishedName','Office','RecipientTypeDetails','RemoteRecipientType',
            'ImmutableId','ExternalDirectoryObjectId','CustomAttribute5','EmailAddressPolicyEnabled' ;
        $propsLic = @{Name='HasLic'; Expression={$_.IsLicensed }},@{Name='LicIssue'; Expression={$_.LicenseReconciliationNeeded }} ;
        $propsADU = 'UserPrincipalName','DisplayName','GivenName','Surname','Title','Company','Department','PhysicalDeliveryOfficeName',
            'StreetAddress','City','State','PostalCode','TelephoneNumber','MobilePhone','Enabled','DistinguishedName',
            'Description','Info','whenCreated','whenChanged'

        #'samaccountname','UserPrincipalName','distinguishedname','Description','title','whenCreated','whenChanged','Enabled','sAMAccountType','userAccountControl' ;
        $propsADUsht = 'Enabled','Description','whenCreated','whenChanged','Title' ;
        $propsAADU = 'UserPrincipalName','DisplayName','GivenName','Surname','Title','Company','Department','PhysicalDeliveryOfficeName',
            'StreetAddress','City','State','PostalCode','TelephoneNumber','MobilePhone','Enabled','DistinguishedName' ;
        #'UserPrincipalName','name','ImmutableId','DirSyncEnabled','LastDirSyncTime','AccountEnabled' ;
        $propsMGU = 'UserPrincipalName','DisplayName','GivenName','Surname','JobTitle','CompanyName','Department','officeLocation',
            'StreetAddress','City','State','PostalCode','BusinessPhones','MobilePhone','accountEnabled'
        # 12:34 PM 12/11/2025 doesn't exist in MGU proprs (onprem,'onPremisesDistinguishedName' is closest, OnPrem OU) ;
        #'UserPrincipalName','name','ImmutableId','DirSyncEnabled','LastDirSyncTime','AccountEnabled' ;
        # 3:59 PM 10/9/2024 used for complete miss gadu search results props
        $prpADU = 'DistinguishedName','GivenName','Surname','Name','UserPrincipalName','mailNickname','SamAccountName','physicalDeliveryOfficeName','msExchRecipientDisplayType','msExchRecipientTypeDetails','msExchRemoteRecipientType','msExchWhenMailboxCreated' ; 
        $propsAADUfed = 'UserPrincipalName','name','ImmutableId','DirSyncEnabled','LastDirSyncTime' ;
        $propsRcpTbl = 'Alias','PrimarySmtpAddress','RecipientType','RecipientTypeDetails' ;
        $propsDG = 'Identity','PrimarySmtpAddress','Description','RecipientType','RecipientTypeDetails','ManagedBy' ; 
        # line1-X AADU outputs
            #$propsMailx='samaccountname','windowsemailaddress','DistinguishedName','Office','RecipientTypeDetails','RemoteRecipientType','IsDirSynced','ImmutableId','ExternalDirectoryObjectId','CustomAttribute5','EmailAddressPolicyEnabled' ;
        <# full size
        $propsADL1 = 'UserPrincipalName','DisplayName','GivenName','Surname','Title' ;
        $propsADL2 = 'Company','Department','PhysicalDeliveryOfficeName' ;
        $propsADL3 = 'StreetAddress','City','State','PostalCode','TelephoneNumber','MobilePhone' ;
        # non-ADU props
        #$propsADL4 = 'DirSyncEnabled','ImmutableId','LastDirSyncTime','UsageLocation' ;
        #$propsADL5 = 'ObjectType','UserType' ;
        #>
        # abbreviated:
        $propsADL1 = @{Name='UPN';Expression={$_.UserPrincipalName }}, @{Name='DName';Expression={$_.DisplayName }}, 
            @{Name='FName';Expression={$_.GivenName }},@{Name='LName';Expression={$_.Surname }},
            @{Name='Title';Expression={$_.Title }};
        $propsADL2 = @{Name='Company';Expression={$_.Company }},@{Name='Dept';Expression={$_.Department }},
            @{Name='Ofc';Expression={$_.PhysicalDeliveryOfficeName }} ;
        $propsADL3 = @{Name='Street';Expression={$_.StreetAddress }}, 'City','State',
            @{Name='Zip';Expression={$_.PostalCode }}, @{Name='Phone';Expression={$_.TelephoneNumber }}, 
            @{Name='Mobile';Expression={$_.MobilePhone }} ;
        $propsADL4 = 'Enabled',@{Name='DN';Expression={$_.DistinguishedName }} ;
        #$propsADL4 = @{Name='Dsync';Expression={$_.DirSyncEnabled }}, @{Name='ImutID';Expression={$_.ImmutableId }}, @{Name='LastDSync';Expression={$_.LastDirSyncTime }}, @{Name='UseLoc';Expression={$_.UsageLocation }};
        #$propsADL5 = 'ObjectType','UserType' ;
        $propsADL5 = 'whenCreated','whenChanged' ; 
        $propsADL6 = @{Name='Desc';Expression={$_.Description }} ;
        $propsADL7 = 'Info' ;
        
        # line1-5 AADU outputs
        <# full size
        $propsAADL1 = 'UserPrincipalName','DisplayName','GivenName','Surname','JobTitle' ;
        $propsAADL2 = 'CompanyName','Department','PhysicalDeliveryOfficeName' ;
        $propsAADL3 = 'StreetAddress','City','State','PostalCode','TelephoneNumber','Mobile' ;
        $propsAADL4 = 'DirSyncEnabled','ImmutableId','LastDirSyncTime','UsageLocation' ;
        $propsAADL5 = 'ObjectType','UserType' ;
        #>
        # abbreviated:
        $propsAADL1 = @{Name='UPN';Expression={$_.UserPrincipalName }}, @{Name='DName';Expression={$_.DisplayName }}, 
            @{Name='FName';Expression={$_.GivenName }},@{Name='LName';Expression={$_.Surname }},
            @{Name='Title';Expression={$_.JobTitle }};
        $propsAADL2 = @{Name='Company';Expression={$_.CompanyName }},@{Name='Dept';Expression={$_.Department }},
            @{Name='Ofc';Expression={$_.PhysicalDeliveryOfficeName }} ;
        $propsAADL3 = @{Name='Street';Expression={$_.StreetAddress }}, 'City','State',
            @{Name='Zip';Expression={$_.PostalCode }}, @{Name='Phone';Expression={$_.TelephoneNumber }}, 'Mobile' ;
        $propsAADL4 = @{Name='Dsync';Expression={$_.DirSyncEnabled }}, @{Name='ImutID';Expression={$_.ImmutableId }}, 
            @{Name='LastDSync';Expression={$_.LastDirSyncTime }}, @{Name='UseLoc';Expression={$_.UsageLocation }};
        $propsAADL5 = 'ObjectType','UserType', @{Name='Enabled';Expression={$_.AccountEnabled }} ;
        # MGU equivs
        $propsMGUL1 = @{Name='UPN';Expression={$_.UserPrincipalName }}, @{Name='DName';Expression={$_.DisplayName }},
            @{Name='FName';Expression={$_.GivenName }},@{Name='LName';Expression={$_.Surname }},
            @{Name='Title';Expression={$_.JobTitle }};
        $propsMGUL2 = @{Name='Company';Expression={$_.CompanyName }},@{Name='Dept';Expression={$_.Department }},
            @{Name='Ofc';Expression={$_.officeLocation }} ;    
        $propsMGUL3 = @{Name='Street';Expression={$_.StreetAddress }}, 'City','State',
            @{Name='Zip';Expression={$_.PostalCode }}, @{Name='Phone';Expression={$_.BusinessPhones }},
            @{Name='Mobile';Expression={$_.MobilePhone }} ; 
        $propsMGUL4 = @{Name='Dsync';Expression={$_.OnPremisesSyncEnabled }}, @{Name='ImutID';Expression={$_.OnPremisesImmutableId }},
            @{Name='LastDSync';Expression={$_.OnPremisesLastSyncDateTime }}, @{Name='UseLoc';Expression={$_.UsageLocation }};
        $propsMGUL5 = @{Name='ObjectType';Expression={'User'}}, @{Name='UserType';Expression={$_.UserType}}
        # configured ObjectType as a static 'User', as it's no longer a property and implied by the underlying class/object type returned.

        #$propsAADMgr = 'UserPrincipalName','Mail',@{Name='OpDN';Expression={$_.ExtensionProperty.onPremisesDistinguishedName }} ;
        # get mgr OU, not DN: ExtensionProperty.onPremisesDistinguishedName.split(',') | select -skip 1 ) -join ','
        $propsAADMgr = 'UserPrincipalName','Mail',
            @{Name='OpOU';Expression={($_.ExtensionProperty.onPremisesDistinguishedName.split(',') | select -skip 1) -join ',' }} ;
        $propsAADMgrL1 = 'UserPrincipalName','Mail' ;
        $propsAADMgrL2 = @{Name='OpOU';Expression={($_.ExtensionProperty.onPremisesDistinguishedName.split(',') | select -skip 1) -join ',' }} ;
        # MGU vers
        $propsMGUMgr = @{Name='userPrincipalName';Expression={$_.userPrincipalName }},
            @{Name='mail';Expression={$_.mail}} ; 
        #$propsMGUMgrL1 = 'UserPrincipalName','Mail' ;
        #$propsMGUMgrL2 = @{Name='OpOU';Expression={($_.onPremisesDistinguishedName.split(',') | select -skip 1) -join ',' }} ;
        # NOTE w mg, and the mgUserManager, it's a hashtable/dictionary, and to get it to return key/values, YOU HAVE TO EXACTLY MATCH THE CASE OF THE KEY! userPrincipalName <> UserPrincipalName (1st works, 2nd doesn't)
        $propsMGUMgrL1 = @{Name='userPrincipalName';Expression={$_.userPrincipalName }},
            @{Name='mail';Expression={$_.mail}} 
        $propsMGUMgrL2 = @{Name='OpOU';Expression={ ($_.onPremisesDistinguishedName.split(',') | select -skip 1) -join ',' }} ;  
        $sQot = [char]34 ;
        $sQotS = [char]39 ;

        # 2:42 PM 10/9/2024 add prp for multi-recipient match ft -a dumps
        #$prpFTARcp = 'Name','RecipientTypeDetails','RecipientType','PrimarySmtpAddress','alias' ; 

        if($getMobile){
            # mobile device props
            #$MDtbl=[ordered]@{NoDashRow=$true } ; # out-markdowntable splat
            #$propsMobDevStats = 'DeviceFriendlyName','DeviceType','DeviceOS','ClientType','DeviceID',
            #    'FirstSyncTime','LastSyncAttemptTime','LastSuccessSync','NumberOfFoldersSynced' ; 
            $propsMobL1 = @{Name='FriendlyName';Expression={$_.DeviceFriendlyName }},@{Name='DevType';Expression={$_.DeviceType }},
                @{Name='DevOs';Expression={$_.DeviceOS }},@{Name='ClntType';Expression={$_.ClientType }},
                @{Name='DevID';Expression={$_.DeviceID }} ; 
            # shorten times: (get-date '6/20/2021 1:45:34 AM' -format 'M/d/yy H:mmtt');
            <#
            $propsMobL2 = @{Name='1stSyncTime';Expression={(get-date $_.FirstSyncTime -format 'M/d/yy H:mmtt') }},
                @{Name='LastSyncTime';Expression={(get-date $_.LastSyncAttemptTime -format 'M/d/yy H:mmtt') }},
                @{Name='LastSuccSync';Expression={(get-date $_.LastSuccessSync -format 'M/d/yy H:mmtt') }},
                @{Name='#Folders';Expression={$_.NumberOfFoldersSynced }} ; 
            #>
            # converttimes to local
            $propsMobL2 = @{Name='1stSyncTime';Expression={(get-date $_.FirstSyncTime.ToLocalTime() -format 'M/d/yy H:mm') }},
                @{Name='LastSyncTime';Expression={(get-date $_.LastSyncAttemptTime.ToLocalTime() -format 'M/d/yy H:mm') }},
                @{Name='LastSuccSync';Expression={(get-date $_.LastSuccessSync.ToLocalTime() -format 'M/d/yy H:mm') }},
                @{Name='#Folders';Expression={$_.NumberOfFoldersSynced }} ; 
            # add for tight summaries
            $prpEASDevs = 'DeviceFriendlyName','ClientType',@{Name='LastSyncTime';Expression={(get-date $_.LastSyncAttemptTime.ToLocalTime() -format 'M/d/yy H:mm') }},
                @{Name='LastSuccSync';Expression={(get-date $_.LastSuccessSync.ToLocalTime() -format 'M/d/yy H:mm') }} ; 
        } ; 
        if($getQuotaUsage){

            # 12:54 PM 9/18/2023 adds for MbxFolderStats, Quota & LegalHold eval:
            $prpStat = 'DisplayName',@{n="DBIssueWarningQuotaMB";e={[math]::round($_.DatabaseIssueWarningQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                @{n="DBProhibitSendQuotaMB";e={[math]::round($_.DatabaseProhibitSendQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                @{n="DBProhibitSendReceiveQuotaMB";e={[math]::round($_.DatabaseProhibitSendReceiveQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                @{n="TotalMailboxSizeMB";e={[math]::round($_.TotalItemSize.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                'LastLogonTime' ,'LastLogoffTime' ;

            $prpFldr = @{Name='Folder'; Expression={$_.Identity.tostring()}},@{Name="Items"; Expression={$_.ItemsInFolder}}, 
                @{n="SizeMB"; e={[math]::round($_.FolderSize.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}}, 
                @{Name="OldestItem"; Expression={get-date $_.OldestItemReceivedDate -f "yyyyMMdd"}}, 
                @{Name="NewestItem"; Expression={$_.NewestItemReceivedDate -f "yyyyMMdd"}},"FolderType" ;

            $prpFldrDeleted = @{Name='Folder'; Expression={$_.Identity.tostring()}},@{Name="Items"; Expression={$_.ItemsInFolder}}, 
                @{n="SizeMB"; e={[math]::round($_.FolderSize.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}}, 
                @{n="TreeSizeMB"; e={[math]::round($_.FolderAndSubfolderSize.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}}, 
                @{Name="OldestItem"; Expression={get-date $_.OldestItemReceivedDate -f "yyyyMMdd"}}, 
                @{Name="NewestItem"; Expression={$_.NewestItemReceivedDate -f "yyyyMMdd"}},"FolderType" ;

            # 10:01 AM 2/27/2024 new spec for reporting on LegalHold symptom folders
            $prpFldrLH = @{Name='Folder'; Expression={$_.Name.tostring()}},@{Name="Items"; Expression={$_.ItemsInFolder}}, 
                @{n="SizeMB"; e={[math]::round($_.FolderSize.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}}, 
                @{Name="OldestItem"; Expression={get-date $_.OldestItemReceivedDate -f "yyyyMMdd"}}, 
                @{Name="NewestItem"; Expression={$_.NewestItemReceivedDate -f "yyyyMMdd"}},"FolderType" ;
                
            # 9:41 AM 2/27/2024 fixed borked InPlaceHolds expansion (was empty, and the prop is where JanelS holds actually *appear*)
            $prpMbxHold = 'LitigationHoldEnabled',@{n="InPlaceHolds";e={ ($_.inplaceholds ) -join ', '}},
                'ComplianceTagHoldApplied','DelayHoldApplied','DelayReleaseHoldApplied' ; 

            $rgxHiddn = '.*\\(Versions|SubstrateHolds|DiscoveryHolds|Yammer.*|Social\sActivity\sNotifications|Suggested\sContacts|Recipient\sCache|PersonMetadata|Audits|Calendar\sLogging|Purges)$' ; 
            $rgxDelItmsShow = '.*\\(Deleted Items|Recoverable Items|Deletions|DiscoveryHolds|Purges|SubstrateHolds|Versions)$' ; 

        } ; 
        # 2:31 PM 12/26/2024
        # getPerms
        if($getPerms){

            # 12:54 PM 9/18/2023 adds for MbxFolderStats, Quota & LegalHold eval:
            $prpRPerms = 'Identity','Trustee','AccessControlType','AccessRights','Inherited' ;

            $prpMPerms = 'Identity','User','AccessRights'

        } ; 
        $rgxOPLic = '^CN\=ENT\-APP\-Office365\-(EXOK|F1|MF1)-DL$' ;
        $rgxXLic = '^CN\=ENT\-APP\-Office365\-(EXOK|F1|MF1)-DL$' ;
        #endregion LOCAL_CONSTANTS ; #*------^ END LOCAL_CONSTANTS ^------        
    
        #region ENCODED_CONTANTS ; #*------v ENCODED_CONTANTS v------
        # ENCODED CONsTANTS & SUPPORT FUNCTIONS:
        #region 2B4 ; #*------v 2B4 v------
        if(-not (get-command 2b4 -ea 0)){function 2b4{[CmdletBinding()][Alias('convertTo-Base64String')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ; PROCESS{$str|%{[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_))}  };} ; } ; 
        #endregion 2B4 ; #*------^ END 2B4 ^------
        #region 2B4C ; #*------v 2B4C v------
        # comma-quoted return
        if(-not (get-command 2b4c -ea 0)){function 2b4c{ [CmdletBinding()][Alias('convertto-Base64StringCommaQuoted')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ;BEGIN{$outs = @()} PROCESS{[array]$outs += $str | %{[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_))} ; } END {'"' + $(($outs) -join '","') + '"' | out-string | set-clipboard } ; } ; } ; 
        #endregion 2B4C ; #*------^ END 2B4C ^------
        #region FB4 ; #*------v FB4 v------
        # DEMO: $SitesNameList = 'THluZGFsZQ==','U3BlbGxicm9vaw==','QWRlbGFpZGU=' | fb4 ;
        if(-not (get-command fb4 -ea 0)){function fb4{[CmdletBinding()][Alias('convertFrom-Base64String')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ; PROCESS{$str | %{ [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($_)) }; } ; } ; }; 
        #endregion FB4 ; #*------^ END FB4 ^------
        # FOLLOWING CONSTANTS ARE USED FOR DEPENDANCY-LESS CONNECTIONS
        if(-not $CMW_logon_SID){$CMW_logon_SID = 'Q01XXGQtdG9kZC5rYWRyaWU=' | fb4 } ; 
        if(-not $o365_Toroco_SIDUpn){$o365_Toroco_SIDUpn = 'cy10b2RkLmthZHJpZUB0b3JvLmNvbQ==' | fb4 } ;
        if(-not $TOR_logon_SID){$TOR_logon_SID = 'VE9ST1xrYWRyaXRzcw==' | fb4 } ; 

        #endregion ENCODED_CONTANTS ; #*------^ END ENCODED_CONTANTS ^------
    
        #endregion CONSTANTS_AND_ENVIRO ; #*======^ CONSTANTS_AND_ENVIRO ^======
    
        #region WHPASSFAIL ; #*======v WHPASSFAIL v======
        $whTPad = 72  ; $whTChar = '.' ; # scale $whTPad to longest Testing:xxx line you use in the test array
        if(-not $whPASS){$whPASS = @{ Object = "$([Char]8730) PASS`n" ; ForegroundColor = 'Green' ; NoNewLine = $true  } }
        if(-not $whFAIL){$whFAIL = @{'Object'= if ($env:WT_SESSION) { "$([Char]8730) FAIL`n"} else {" !X! FAIL`n"}; ForegroundColor = 'RED' ; NoNewLine = $true } } ;
        # light diagonal cross: ╳ U+2573 DOESN'T RENDER IN PS, use it if WinTerm
        if(-not $psPASS){$psPASS = "$([Char]8730) PASS`n" } # $smsg = $pspass + " :Tested Drives" ; write-host $smsg ;
        if(-not $psFAIL){$psFAIL = if ($env:WT_SESSION) { "$([Char]8730) FAIL`n"} else {" !X! FAIL`n"} } ; # $smsg = $psfail + " :Tested Drives" ; write-warning $smsg ;    
        <# WHPASSFAIL:SAMPLE TESTS:
        #region WHPASSFAILSimpleTest ; #*------v WHPASSFAILSimpleTest v------
        $tFormat = 'NTFS' ; 
        $smsg = "Testing: Volume.FileSystem against: $($tFormat)" ; #Write-Host "$($smsg)... " -NoNewline ;
        $smsg += " $($whTChar * ($whTPad - $smsg.length))" ; Write-Host "$($smsg) " -NoNewline ;
        if ($VOL.FileSystem -eq $tFormat) {Write-Host @whPASS} else {write-host @whFAIL };
        #endregion WHPASSFAILSimpleTest ; #*------^ END WHPASSFAILSimpleTest ^------    
        #region WHPASSFAILCapacityTest ; #*------v WHPASSFAILCapacityTest v------
        # Test: Capacity match, threshold vs %:
        $tSpaceThresh = 10 * 1GB ; # .9 (for %)
        if($tSpaceThresh -gt 1000){ $smsg = "Testing: Volume.SizeRemainingStatus against: $(RndTo3($tSpaceThresh/1GB))GB" }
        elseif($tSpaceThresh -lt 1){$smsg = "Testing: Volume.SizeRemainingStatus against: $(RndTo3($tSpaceThresh * 100))%" }
        else {$smsg = "Testing: Volume.SizeRemainingStatus against: $($tSpaceThresh)" } ;
        $smsg += " $($whTChar * ($whTPad - $smsg.length))" ; Write-Host "$($smsg) " -NoNewline ;
        if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        if($tSpaceThresh -lt 1){
            $smsg = "Detected $($tSpaceThresh) is a percentage free test" ;
            if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            if ($tv.SizeRemaining / $tv.Size -lt $tSpaceThresh) {
                $rptDrive.SizeRemainingStatus = $false ;
                write-host @whFAIL ;
                $smsg = "Insufficient free space on DB drive: $($tv.DriveLetter): $(RndTo2($tv.SizeRemaining/1GB)) GB, needs at least $($tv.Size/1GB * $tSpaceThresh) GB" ;
                $rptDrive.DriveIssues += @($smsg)
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $rptDrive.SizeRemainingStatus = $true ;
                Write-Host @whPASS ;   ;
                $smsg = "DB drive: $($tv.DriveLetter): $(RndTo2($tv.SizeRemaining/1GB)) GB free, sufficient for install" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
        }else{
            $smsg = "Detected $($tSpaceThresh) is a free space floor test" ;
            if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            if ($tv.SizeRemaining -lt $tSpaceThresh){
                $rptDrive.SizeRemainingStatus = $false ;
                write-host @whFAIL ;
                $smsg = "Insufficient free space on $($rptDrive.DriveRole -join ',') drive: $(RndTo2($tv.SizeRemaining/1GB)) GB, needs at least $(RndTo2($tSpaceThresh/1GB)) GB" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $rptDrive.SizeRemainingStatus = $true ;
                Write-Host @whPASS ;   ;
                $smsg = "$($rptDrive.DriveRole -join ','): $(RndTo2($tv.SizeRemaining/1GB)) GB free, sufficient for install" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
        } ; 
        #endregion WHPASSFAILCapacityTest ; #*------^ END WHPASSFAILCapacityTest ^------
        #>
        #endregion WHPASSFAIL ; #*======^ END WHPASSFAIL ^======

        #endregion CONSTANTS_AND_ENVIRO ; #*------^ END CONSTANTS_AND_ENVIRO ^------

        #region CHECK_PREREQS ; #*------v CHECK_PREREQS v------
        # critical dependancy Meta variables
        $MetaNames = 'TOR','CMW','TOL' # ,'NOSUCH' ; 
        # critical dependancy Meta variable properties
        $MetaProps = 'legacyDomain','o365_TenantDomain' #,'DOESNTEXIST' ; 
        $isBased = $true ; $gvMiss = @() ; $ppMiss = @() ; 
        foreach($met in $metanames){
            write-verbose "chk:`$$($met)Meta" ; 
            if(-not (gv -name "$($met)Meta" -ea 0)){
                $isBased = $false; $gvMiss += "$($met)Meta" ; 
            } ; 
            foreach($mp in $MetaProps){
                write-verbose "chk:`$$($met)Meta.$($mp)" ; 
                #if(-not (gv -name "$($met)Meta" -ea 0).value[$mp]){ # testing has a value, not is present as a spec!
                if(-not (gv -name "$($met)Meta" -ea 0).value.keys -contains $mp){$isBased = $false; $ppMiss += "$($met)Meta.$($mp)" ; } ; 
            } ; 
        } ; 
        if($gvmiss){write-warning "Missing Dependant Meta variables:`n$(($gvMiss |%{"`$$($_)" }) -join ',')" } ; 
        if($ppMiss){write-warning "Missing Dependant Meta vari properties:`n$(($ppMiss |%{"`$$($_)" }) -join ',')" } ; 
        if(-not $isBased){ write-warning  "missing critical dependancy profile config!" } ; 
        #endregion CHECK_PREREQS ; #*------^ END CHECK_PREREQS ^------

        #region FUNCTIONS ; #*======v FUNCTIONS v======

        # 2b4() 2b4c() & fb4() are located up in the CONSTANTS_AND_ENVIRO\ENCODED_CONTANTS block ( to convert Constant assignement strings)
        
        #region FUNCTIONS_INTERNAL ; #*======v FUNCTIONS_INTERNAL v======

        #*------v Function resolve-RMbxForwards v------
        function resolve-RMbxForwards(){
            <#
            .SYNOPSIS
            Resolves out all RemoteMailboxes (OnPrem) with ForwardingAddress configured; converts the mailboxes into a hashtable keyed on ForwardingAddress. Returns the hash to the pipeline
            .EXAMPLE
            PS> $hshForwards = resolve-RMbxForwards ; 
            PS> $smsg = "Recipient:$($tid) => $($hshForwards[$tid])" ; 
            PS> write-host $smsg ;
            .NOTES
            VERSION:
            * 3:18 PM 4/12/2025 init
            #>
            write-host "get-remotemailbox  -ResultSize unlimited | ?{`$_.ForwardingAddress}..." ; 
            $fwdRmbxs = get-remotemailbox  -ResultSize unlimited | ?{$_.ForwardingAddress} ; 
            $hshForwards = @{} ;  
            write-host "[" ; 
            $forwardedSummary = $fwdRmbxs |%{
                write-host -NoNewline '.'
                $target = $_ ; 
                $smsg = "$(($target | ft -a primarysmtpaddress,forwardingaddress|out-string).trim())" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $fwd = $null; 
                if($fwd = get-recipient -id $target.ForwardingAddress -resultsize 1 | select -expand primarysmtpaddress){
                   $hshForwards[$fwd] = $target ; 
                } ; 
            } ; 
            write-host "]" ; 
            $hshForwards | write-output 
        } ; 
        #*------^ END Function resolve-RMbxForwards ^------

        #endregion GET_XOMOBILEDATA ; #*------^ END get-xoMobileData ^------
        function get-xoMobileData {
            <#
            .SYNOPSIS
            Runs EXO get-xoMobildDevice qrys, and parses results into approp $hSum properties (single common function to reduce dupe queries)
            .EXAMPLE
            PS> get-xoMobileData ;             
            .NOTES
            VERSION:
            * 10:52 AM 9/23/2025init
            #>
            # 
            if($xmbx){
                $smsg = "'xoMobileDeviceStats':Get-xoMobileDeviceStatistics -Mailbox $($xmbx.ExchangeGuid.guid)"
                if($verbose){
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose $smsg } ;
                } ;
                #$hsum.xoMobileDeviceStats  +=  Get-xoMobileDeviceStatistics -Mailbox $xmbx.userprincipalname -ea STOP ;
                # wasn't getting data back: shift to the .xomailbox.ExchangeGuid.guid, it's 100% going to hit and return data
                $xoMobileDeviceStats +=  Get-xoMobileDeviceStatistics -Mailbox $hSum.xoMailbox.exchangeguid.guid -ea STOP | sort LastSuccesssync -Descending ;
            }else{
                $smsg = "'xoMobileDeviceStats':Get-xoMobileDeviceStatistics -Mailbox $($xmbx.ExchangeGuid.guid)"
                if($verbose){
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose $smsg } ;
                } ;
                #$hsum.xoMobileDeviceStats  +=  Get-xoMobileDeviceStatistics -Mailbox $xmbx.userprincipalname -ea STOP ;
                # wasn't getting data back: shift to the .xomailbox.ExchangeGuid.guid, it's 100% going to hit and return data
                $xoMobileDeviceStats = +=  Get-xoMobileDeviceStatistics -Mailbox $hSum.xoMailbox.exchangeguid.guid -ea STOP | sort LastSuccesssync -Descending ;
            }
            #$hsum.xoMobileDeviceStats  +=  Get-xoMobileDeviceStatistics -Mailbox $hSum.xoMailbox.exchangeguid.guid -ea STOP ;
            $hsum.xoMobileDeviceStats  +=  @($xoMobileDeviceStats | ?{$_.LastSyncAttemptTime -ge (get-date).adddays(-1 * $xoMobileDeviceOLDThreshold)})
            $smsg = "xoMobileDeviceStats Count:$(($hsum.xoMobileDeviceStats|measure).count)" ;
            $hsum.xoMobileDeviceStatsOLD  +=  @($xoMobileDeviceStats | ?{$_.LastSyncAttemptTime -lt (get-date).adddays(-1 * $xoMobileDeviceOLDThreshold)})
            $smsg += "`nxoMobileDeviceStatsOLD Count:$(($hsum.xoMobileDeviceStatsOLD|measure).count)" ;
            $hsum.xoMobileOutlookClients += @($xoMobileDeviceStats | ?{$_.DeviceType -match 'Outlook' -OR $_.DeviceUserAgent -match 'Outlook' -OR $_.DeviceModel  -match 'Outlook'}) ;
            $hsum.xoMobileOtherClients += @($xoMobileDeviceStats | ?{$_.DeviceType -notmatch 'Outlook' -AND $_.DeviceUserAgent -notmatch 'Outlook' -AND $_.DeviceModel  -notmatch 'Outlook'}) ;
            $hsum.xoMobileOMSyncTypes += @(($hsum.xoMobileOutlookClients | group ClientType | select -expand Name ) -join ';')
            if($hsum.xoMobileOMSyncTypes -match 'REST'){
                $smsg += "`n+User has one or more *legacy* 'REST' Outlook Mobile clients" ;
            }elseif($hsum.xoMobileOMSyncTypes -match 'Outlook'){
                $smsg += "`n+++User has has one or more fully compliant 'MS Native Sync'-protocol Outlook Mobile clients" ;
            } ;
            $hsum.xoMobileOtherSyncTypes += @(($hsum.xoMobileOtherClients | group ClientType | select -expand Name ) -join ';')            
            if($hsum.xoMobileOtherClients| ?{$_.ClientType -eq 'EAS'}){ ;
                $smsg += "`n---User has one or more device-vendor-provided 'ExchangeActiveSync' Mobile clients!" ;
                #$smsg += "`nPLEASE NOTE: BY POLICY EAS CLIENTS ARE *BEST EFFORT* supported:"
                #$smsg += "`nWHERE ISSUES ARE EXPERIENCED WITH LEGACY EAS/ACTIVESYNC CLIENTS," ;
                #$smsg += "`nUSERS SHOULD BE URGED TO MOVE TO SUPPORTED MS OUTLOOK MOBILE FOR IOS OR ANDROID CLIENTS" ;
            }
            write-host -foregroundcolor green $smsg ;
        } ; 
        #endregion GET_XOMOBILEDATA ; #*------^ END get-xoMobileData ^------

        #region GET_MGUSERFULL ; #*------v get-MgUserFull v------
        function get-MgUserFull{
            <#
            .SYNOPSIS
            get-MgUserFull.ps1 - Wrapper for get-MGUser that *forces* it to return a full set of user properties, to approx the get-AzureAdUser that they've taken away, wo less f'ing around retrying queries.
            .NOTES
            Version     : 0.0.
            Author      : Todd Kadrie
            Website     : http://www.toddomation.com
            Twitter     : @tostka / http://twitter.com/tostka
            CreatedDate : 2025-
            FileName    : get-MgUserFull.ps1
            License     : MIT License
            Copyright   : (c) 2025 Todd Kadrie
            Github      : https://github.com/tostka/verb-XXX
            Tags        : Powershell
            AddedCredit : REFERENCE
            AddedWebsite: URL
            AddedTwitter: URL
            REVISIONS
            * 10:46 AM 12/11/2025 reworked $prpMGUser list, added items that are unpop'd propoerties, and pushed useful Additionalproperties from OnPrem, into expansion, updated CBH
            * 12:18 PM 12/10/2025 init
            .DESCRIPTION
            get-MgUserFull.ps1 - Wrapper for get-MGUser that *forces* it to return a full set of user properties, to approx the get-AzureAdUser that they've taken away, wo less f'ing around retrying queries.

            MS has lobotomized get-MgUser as compares to the long-standing functional get-AzureAdUser 
            and returning the full suite of user properties now requires a bunch of horse hockey to retrieve - in favor of their cheesball, money grubbing 'lean' property set. 
            fk-em! We're going to force a full property set return, *every time*
            For fancier filter & top use, use those to return an MGUser with a userid, and then recycle the user ID into this, to retrieve a fully populated user object

            .PARAMETER  UserID
            Useridentifier (UPN, GUID etc) [-UserID UPN@DOMAIN.COM]
            .INPUTS
            None. Does not accepted piped input.(.NET types, can add description)
            .OUTPUTS
            Microsoft.Graph.PowerShell.Models.MicrosoftGraphUser
            System.Boolean
            [| get-member the output to see what .NET obj TypeName is returned, to use here]
            .EXAMPLE
            PS> $mgu = get-MgUserFull -userid UPN@DOMAIN.COM ; 
            Typical call
            .LINK
            https://github.com/tostka/verb-MG
            #>
            [CmdletBinding()]
            PARAM(
                [Parameter(HelpMessage="Array of Useridentifiers (UPN, GUID etc) [-UserID UPN@DOMAIN.COM]")]
                    [ValidateNotNullOrEmpty()]
                    [string[]]$UserID
            )
            BEGIN{
                # FORCE fully populated key user properties (overrides default return of subset garbage)
                $prpMGUser = @(
                    # Identity
                    'id','userPrincipalName','mail','mailNickname','proxyAddresses','otherMails','otherMails',
                    # Display/profile
                    'displayName','givenName','surname','jobTitle','department','companyName',
                    'mobilePhone','businessPhones','preferredLanguage',
                    'jobTitle',
                    'department','companyName',
                    'StreetAddress','city','state','PostalCode','country',
                    'officeLocation','UsageLocation',
                    # Account state
                    'accountEnabled','userType',
                    # Licensing
                    'assignedLicenses','assignedPlans',
                    # Hybrid / sync
                    'onPremisesImmutableId','onPremisesDistinguishedName','onPremisesSecurityIdentifier',
                    'OnPremisesUserPrincipalName','onPremisesSamAccountName','onPremisesDomainName',
                    'onPremisesSyncEnabled','OnPremisesLastSyncDateTime','OnPremisesProvisioningErrors','onPremisesExtensionAttributes'
                    # add prev missing sync data props
                    # Misc often used
                    'creationType', 'CreatedDateTime','DeletedDateTime','EmployeeHireDate','EmployeeId','EmployeeType','HireDate',  
                    'Manager',
                    'LicenseAssignmentStates','LicenseDetails','ProvisionedPlans',
                    'MemberOf',
                    # add AdditionalProperties pulls (should move to primary property, also accessible as .additionalproperties['xxx'] property      
                    'mobilePhone','businessPhones',
                    'preferredLanguage'
                ) | select -unique ; 
                if(-not (get-command Get-MgUser)){
                    $smsg = "Missing Get-MgUser!" ; 
                    $smsg += "`nPre-connect to Microsoft.Graph via:" ;
                    $smsg += "`nConnect-MgGraph -Scopes 'User.Read.All', 'Directory.Read.All', 'Group.Read.All'" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    BREAK ; 
                } ; 
                #region IS_PIPELINE ; #*------v IS_PIPELINE v------
                # check if using Pipeline input or explicit params:
                if ($PSCmdlet.MyInvocation.ExpectingInput) {
                    $smsg = "Data received from pipeline input: '$($InputObject)'" ;
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                } else {
                    # doesn't actually return an obj in the echo
                    #$smsg = "Data received from parameter input: '$($InputObject)'" ;
                    #if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    #else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                } ;
                #endregion IS_PIPELINE ; #*------^ END IS_PIPELINE ^------
            } 
            PROCESS{
                foreach($id in $userid){
                    TRY{
                        $smsg = "Get-MgUser -UserId $($id)" ; 
                        if($VerbosePreference -eq "Continue"){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        $MGUser = Get-MgUser -UserId $id -Property $prpMGUser -erroraction STOP ; 
                    } CATCH {$ErrTrapd=$Error[0] ;
                        write-host -foregroundcolor gray "TargetCatch:} CATCH [$($ErrTrapd.Exception.GetType().FullName)] {"  ;
                        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        CONTINUE
                     } ;            
                    if($MGUser){
                        $MGUser | write-output ; 
                    } else{
                        $smsg = "UNABLE TO: Get-MgUser -UserId $($userid)" ; 
                        if(gcm Write-MyWarning -ea 0){Write-MyWarning $smsg } else {
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ;
                    }; 
                } # loop-E
            } ;  # PROC-E
        } ; 
        #endregion GET_MGUSERFULL ; #*------^ END get-MgUserFull ^------

        #endregion FUNCTIONS_INTERNAL ; #*======^ END FUNCTIONS_INTERNAL ^======

        #region FUNCTIONS_FULLYEXTERNAL ; #*======v FUNCTIONS_FULLYEXTERNAL v======

        #region CONNECT_O365SERVICES ; #*======v verb-exo\connect-O365Services v======
        if(-not (get-childitem function:connect-O365Services -ea 0)){
            $smsg = "MISSING DEPENDANT: verb-exo\connect-O365Services!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            break ; 
        } ;
        #endregion CONNECT_O365SERVICES ; #*======^ END verb-exo\connect-o365services ^======
        
        #endregion FUNCTIONS_FULLYEXTERNAL ; #*======^ END FUNCTIONS_FULLYEXTERNAL ^======

        #endregion FUNCTIONS ; #*======^ END FUNCTIONS ^======

        #region SERVICE_CONNECTIONS #*======v END SERVICE_CONNECTIONS v======
        $MGPermissionsScope = @("User.Read.All","Group.Read.All") # get-AzureAdUser baseline requirements, memberof requires groupread as well

        #region BROAD_SVC_CONTROL_VARIS ; #*======v BROAD_SVC_CONTROL_VARIS  v======   
        $useO365 = $true ; 
        $useOP = $true ;     
        # (config individual svcs in each block)
        #endregion BROAD_SVC_CONTROL_VARIS ; #*======^ END BROAD_SVC_CONTROL_VARIS ^======

        #region TEST_EXO_CONN ; #*------v TEST_EXO_CONN v------
        # ALT: simplified verify EXO conn: ALT to full CONNECT_O365SERVICES block - USE ONE OR THE OTHER!
        $useEXO = $true ; 
        $useSC = $false ; 
        if(-not $XOConnectionUri ){$XOConnectionUri = 'https://outlook.office365.com'} ;
        if(-not $SCConnectionUri){$SCConnectionUri = 'https://ps.compliance.protection.outlook.com'} ;
        $EXOtestCmdlet = 'Get-xoOrganizationConfig' ; 
        if(gcm $EXOtestCmdlet -ea 0){
            $conns = Get-ConnectionInformation -ea STOP  ; 
            $hasEXO = $hasSC = $false ; 
            #if($conns | %{$_ | ?{$_.ConnectionUri -eq 'https://outlook.office365.com' -AND $_.State -eq 'Connected' -AND $_.TokenStatus -eq 'Active'}}){
            $conns | %{
                if($_ | ?{$_.ConnectionUri -eq $XOConnectionUri}){$hasEXO = $true } ; 
                if($_ | ?{$_.ConnectionUri -eq $SCConnectionUri}){$hasSC = $true } ; 
            }
            if($useEXO -AND $hasEXO){
                write-verbose "EXO ConnectionURI present" ; 
            }elseif(-not $useEXO){}else{
                $smsg = "No Active EXO connection: Run - Connect-ExchangeOnline -Prefix xo -  before running this script!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                BREAK ; 
            } ; 
            if($useSC -AND $hasSC){
                write-verbose "SCI ConnectionURI present" ; 
            }elseif(-not $useSC){}else{
                $smsg = "No Active SC connection: Run - Connect-IPPSSession -Prefix SC -  before running this script!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                BREAK ; 
            } ; 
        }else {
            $smsg = "Missing gcm get-xoMailboxFolderStatistics: ExchangeOnlineManagement module *not* loaded!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            BREAK ; 
        } ;     
        #endregion TEST_EXO_CONN ; #*------^ END TEST_EXO_CONN ^------
    
        #region CALL_CONNECT_OPSERVICES ; #*======v CALL_CONNECT_OPSERVICES v======
        #$useOP = $false ; 
        if($useOP){
            $pltCcOPSvcs=[ordered]@{
                # environment parameters:
                EnvSummary = $rvEnv ;
                NetSummary = $netsettings ;
                XoPSummary = $lclExOP ;
                # service choices
                UseExOP = $true ;
                useForestWide = $true ;
                useExopNoDep = $false ;
                ExopVers = 'Ex2010' ;
                UseOPAD = $true ;
                useExOPVers = $useExOPVers; # 'Ex2010' ;
                # Service Connection parameters
                TenOrg = $TenOrg ; # $global:o365_TenOrgDefault ;
                Credential = $Credential ;
                #[ValidateSet("SID","ESVC","LSVC")]
                #UserRole = $UserRole ; # @('SID','ESVC') ;
                # if inheriting same $userrole param/default, that was already used for cloud conn, filter out the op unsupported CBA roles
                # exclude csvc as well, go with filter on the supported ValidateSet from get-HybridOPCredentials: ESVC|LSVC|SID
                UserRole = $UserRole |?{$_ -match '(ESVC|LSVC|SID)' -AND $_ -notmatch 'CBA'} ; # @('SID','ESVC') ;
                # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
                silent = $silent ;
            } ;
    
            write-verbose "(Purge no value keys from splat)" ;
            $mts = $pltCcOPSvcs.GetEnumerator() |?{$_.value -eq $null} ; $mts |%{$pltCcOPSvcs.remove($_.Name)} ; rv mts -ea 0 ;
            if((get-command connect-OPServices -EA STOP).parameters.ContainsKey('whatif')){
                $pltCcOPSvcsnDSR.add('whatif',$($whatif))
            } ;
            $smsg = "connect-OPServices w`n$(($pltCcOPSvcs|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $ret_CcOPSvcs = connect-OPServices @pltCcOPSvcs ; 
    
            # #region CONFIRM_CCOPRETURN ; #*------v CONFIRM_CCOPRETURN v------
            # matches each: $plt.useXXX:$true to matching returned $ret.hasXXX:$true
            $vplt = $pltCcOPSvcs ; $vret = 'ret_CcOPSvcs' ;  ; $ACtionCommand = 'connect-OPServices' ; 
            $vplt.GetEnumerator() |?{$_.key -match '^use' -ANd $_.value -match $true} | foreach-object{
                $pltkey = $_ ;
                $smsg = "$(($pltkey | ft -HideTableHeaders name,value|out-string).trim())" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $vtests = @() ;  $vFailMsgs = @()  ; 
                $tprop = $pltkey.name -replace '^use','has';
                if($rProp = (gv $vret).Value.psobject.properties | ?{$_.name -match $tprop}){
                    $smsg = "$(($rprop | ft -HideTableHeaders name,value |out-string).trim())" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    if($rprop.Value -eq $pltkey.value){
                        $vtests += $true ; 
                        $smsg = "Validated: $($pltKey.name):$($pltKey.value) => $($rprop.name):$($rprop.value)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    } else {
                        $smsg = "NOT VALIDATED: $($pltKey.name):$($pltKey.value) => $($rprop.name):$($rprop.value)" ;
                        $vtests += $false ; 
                        $vFailMsgs += "`n$($smsg)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    };
                } else{
                    $smsg = "Unable to locate: $($pltKey.name):$($pltKey.value) to any matching $($rprop.name)!)" ;
                    $smsg = "" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                } ; 
            } ; 
            if($useOP -AND $vtests -notcontains $false){
                $smsg = "==> $($ACtionCommand): confirmed specified connections *all* successful " ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            }elseif($vtests -contains $false -AND (get-variable ret_CcOPSvcs) -AND (gv -name "$($tenorg)meta").value.o365_opdomain.split('.')[0].toupper() -ne $env:userdomain){
                $smsg = "==> $($ACtionCommand): FAILED SOME SPECIFIED CONNECTIONS" ; 
                $smsg += "`nCROSS-ORG ONPREM CONNECTION: ATTEMPTING TO CONNECT TO ONPREM '$((gv -name "$($tenorg)meta").value.o365_Prefix)' $((gv -name "$($tenorg)meta").value.o365_opdomain.split('.')[0].toupper()) domain, FROM $($env:userdomain)!" ;
                $smsg += "`nEXPECTED ERROR, SKIPPING ONPREM ACCESS STEPS (force `$useOP:$false)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $useOP = $false ; 
            }elseif(-not $useOP -AND -not (get-variable ret_CcOPSvcs)){
                $smsg = "-useOP: $($useOP), skipped connect-OPServices" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else {
                $smsg = "==> $($ACtionCommand): FAILED SOME SPECIFIED CONNECTIONS" ; 
                $smsg += "`n`$ret_CcOPSvcs:`n$(($ret_CcOPSvcs|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $sdEmail.SMTPSubj = "FAIL Rpt:$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"
                $sdEmail.SmtpBody = "`n===Processing Summary:" ;
                if($vFailMsgs){
                    $sdEmail.SmtpBody += "`n$(($vFailMsgs|out-string).trim())" ; 
                } ; 
                $sdEmail.SmtpBody += "`n" ;
                if($SmtpAttachment){
                    $sdEmail.SmtpAttachment = $SmtpAttachment
                    $sdEmail.smtpBody +="`n(Logs Attached)" ;
                };
                $sdEmail.SmtpBody += "Pass Completed $([System.DateTime]::Now)" ;
                $smsg = "Send-EmailNotif w`n$(($sdEmail|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Send-EmailNotif @sdEmail ;
                throw $smsg ; 
                BREAK ; 
            } ; 
            #endregion CONFIRM_CCOPRETURN ; #*------^ END CONFIRM_CCOPRETURN ^------
            #region CONFIRM_OPFORESTWIDE ; #*------v CONFIRM_OPFORESTWIDE v------    
            if($useOP -AND $pltCcOPSvcs.useForestWide -AND $ret_CcOPSvcs.hasForestWide -AND $ret_CcOPSvcs.AdGcFwide){
                $smsg = "==> $($ACtionCommand): confirmed has BOTH .hasForestWide & .AdGcFwide ($($ret_CcOPSvcs.AdGcFwide))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success        
            }elseif($pltCcOPSvcs.useForestWide -AND (get-variable ret_CcOPSvcs) -AND (gv -name "$($tenorg)meta").value.o365_opdomain.split('.')[0].toupper() -ne $env:userdomain){
                $smsg = "`nCROSS-ORG ONPREM CONNECTION: ATTEMPTING TO CONNECT TO ONPREM '$((gv -name "$($tenorg)meta").value.o365_Prefix)' $((gv -name "$($tenorg)meta").value.o365_opdomain.split('.')[0].toupper()) domain, FROM $($env:userdomain)!" ;
                $smsg += "`nEXPECTED ERROR, SKIPPING ONPREM FORESTWIDE SPEC" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $useOP = $false ; 
            }elseif($useOP -AND $pltCcOPSvcs.useForestWide -AND -NOT $ret_CcOPSvcs.hasForestWide){
                $smsg = "==> $($ACtionCommand): MISSING CRITICAL FORESTWIDE SUPPORT COMPONENT:" ; 
                if(-not $ret_CcOPSvcs.hasForestWide){
                    $smsg += "`n----->$($ACtionCommand): MISSING .hasForestWide (Set-AdServerSettings -ViewEntireForest `$True) " ; 
                } ; 
                if(-not $ret_CcOPSvcs.AdGcFwide){
                    $smsg += "`n----->$($ACtionCommand): MISSING .AdGcFwide GC!:`n((Get-ADDomainController -Discover -Service GlobalCatalog).hostname):326) " ; 
                } ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $smsg = "MISSING SOME KEY CONNECTIONS. DO YOU WANT TO IGNORE, AND CONTINUE WITH CONNECTED SERVICES?" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $bRet=Read-Host "Enter YYY to continue. Anything else will exit"  ;
                if ($bRet.ToUpper() -eq "YYY") {
                    $smsg = "(Moving on), WITH THE FOLLOW PARTIAL CONNECTION STATUS" ;
                    $smsg += "`n`n$(($ret_CcOPSvcs|out-string).trim())" ; 
                    write-host -foregroundcolor green $smsg  ;
                } else {
                    throw $smsg ; 
                    break ; #exit 1
                } ;         
            }; 
            #endregion CONFIRM_OPFORESTWIDE ; #*------^ END CONFIRM_OPFORESTWIDE ^------
        } ; 
        #endregion CALL_CONNECT_OPSERVICES ; #*======^ END CALL_CONNECT_OPSERVICES ^======
    
        #endregion SERVICE_CONNECTIONS #*======^ END SERVICE_CONNECTIONS ^======
        
        #region IS_PIPELINE ; #*------v IS_PIPELINE v------
        # finally if we're using pipeline, and aggregating, we need to aggreg outside of the process{} block
        if($PSCmdlet.MyInvocation.ExpectingInput){
            # pipeline instantiate an aggregator here
        } ;

        # check if using Pipeline input or explicit params:
        if ($PSCmdlet.MyInvocation.ExpectingInput) {
            $smsg = "Data received from pipeline input: '$($InputObject)'" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } else {
            # doesn't actually return an obj in the echo
            #$smsg = "Data received from parameter input: '$($InputObject)'" ;
            #if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            #else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ;
        #endregion IS_PIPELINE ; #*------^ END IS_PIPELINE ^------
    }#  # BEG-E 
    PROCESS{
        $Error.Clear() ; 
       
        if(-not $users){
            $users= (get-clipboard).trim().replace("'",'').replace('"','') ;
            if($users){
                write-verbose "No -users specified, detected value on clipboard:`n$($users)" ;
            } else {
                write-warning "No -users specified, nothing matching dname, emailaddress or samaccountname, found on clipboard. EXITING!" ;
                Break ;
            } ;
        } else {
            write-verbose "($(($users|measure).count)) user(s) specified:`n'$($users -join "','")'" ;
        } ;

        $ttl = ($users|measure).count ; $Procd=0 ;
        [array]$Rpt =@() ;
        # with pipeline input, the pipeline evals as either $_ (if unmapped to a param in binding), or iterating on the mapped value.
        #     the foreach loop below doesn't actually loop. Process{} is the loop with a pipeline-fed param, and the bound - $users - variable once per pipeline bound element - per array item on an array -
        #     is run with the $users value populated with each element in turn. IOW, the foreach is a single-run pass, and the Process{} block is the loop.
        # you need both a bound $users at the top - to handle explicit assigns resolve-user -users $variable.
        # with a process {} block to handle any pipeline passed input. The pipeline still maps to the bound param: $users, but the entire process{} is run per element, rather than iteratign the internal $users foreach.
        #region PIPELINE_PROCESSINGLOOP ; #*------v PIPELINE_PROCESSINGLOOP v------
        foreach ($usr in $users){
            # $pltSL.Tag = $((@($ticket,$usr) |?{$_}) -join '-')
            #region START_LOG_OPTIONS #*======v START_LOG_OPTIONS v======
            $useSLogHOl = $true ; # one or 
            $useTransPath = $false ; # TRANSCRIPTPATH
            $useTransRotate = $false ; # TRANSCRIPTPATHROTATE
            $useStartTrans = $false ; # STARTTRANS
            $useTransNoDep = $false ; # TRANSCRIPT_NODEP
            $useTransBasicScript = $false ; # BASIC_SCRIPT_TRANSCRIPT
            #region START_LOG_HOLISTIC #*------v START_LOG_HOLISTIC v------
            if($useSLogHOl){
                # Single log for script/function example that accomodates detect/redirect from AllUsers scope'd installed code, and hunts a series of drive letters to find an alternate logging dir (defers to profile variables)
                #${CmdletName} = $rPSCmdlet.MyInvocation.MyCommand.Name ;
                if(-not (get-variable LogPathDrives -ea 0)){$LogPathDrives = 'd','c' };
                foreach($budrv in $LogPathDrives){if(test-path -path "$($budrv):\scripts" -ea 0 ){break} } ;
                if(-not (get-variable rgxPSAllUsersScope -ea 0)){$rgxPSAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps(((d|m))*)1|dll)$" ;} ;
                if(-not (get-variable rgxPSCurrUserScope -ea 0)){$rgxPSCurrUserScope="^$([regex]::escape([Environment]::GetFolderPath('MyDocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps((d|m)*)1|dll)$" ;} ;
                $pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ;} ;
                if($whatif.ispresent){$pltSL.add('whatif',$($whatif))}
                elseif($WhatIfPreference.ispresent ){$pltSL.add('whatif',$WhatIfPreferenc)} ;         
                # if using [CmdletBinding(SupportsShouldProcess)] + -WhatIf:$($WhatIfPreference):
                #$pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($WhatIfPreference) ;} ;
                #$pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag="$($ticket)-$($TenOrg)-LASTPASS-" ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($WhatIfPreference) ;} ;
                #$pltSL.Tag = $((@($ticket,$usr) |?{$_}) -join '-')
                #if($ticket){$pltSL.Tag = $ticket} ;
                #$pltSL.Tag = $env:COMPUTERNAME ; 
                $pltSL.Tag = $((@($ticket,$usr) |?{$_}) -join '-')
                $tagfields = 'ticket','UserPrincipalName','folderscope' ; # DomainName TenOrg ModuleName 
                $tagfields | foreach-object{$fld = $_ ; if(get-variable $fld -ea 0 |?{$_.value} ){$pltSL.Tag += @($((get-variable $fld).value))} } ; 
                if($pltSL.Tag -is [array]){$pltSL.Tag = $pltSL.Tag -join '-' } ; 
                #$transcript = ".\logs\$($Ticket)-$($DomainName)-$(split-path $rMyInvocation.InvocationName -leaf)-$(get-date -format 'yyyyMMdd-HHmmtt')-trans-log.txt" ; 
                #$pltSL.Tag += "-$($DomainName)"
                #
                if($rPSBoundParameters.keys){ # alt: leverage $rPSBoundParameters hash
                    $sTag = @() ; 
                    #$pltSL.TAG = $((@($rPSBoundParameters.keys) |?{$_}) -join ','); # join all params
                    if($rPSBoundParameters['Summary']){ $sTag+= @('Summary') } ; # build elements conditionally, string
                    if($rPSBoundParameters['Number']){ $sTag+= @("Number$($rPSBoundParameters['Number'])") } ; # and keyname,value
                    $pltSL.Tag += "-$($sTag -join ',')" ; # 4:46 PM 7/16/2025 flipped to append, not assign
                } ; 
                #
                if($rvEnv.isScript){
                    write-host "`$script:PSCommandPath:$($script:PSCommandPath)" ;
                    write-host "`$PSCommandPath:$($PSCommandPath)" ;
                    if($rvEnv.PSCommandPathproxy){ $prxPath = $rvEnv.PSCommandPathproxy }
                    elseif($script:PSCommandPath){$prxPath = $script:PSCommandPath}
                    elseif($rPSCommandPath){$prxPath = $rPSCommandPath} ; 
                } ; 
                if($rvEnv.isFunc){
                    if($rvEnv.FuncDir -AND $rvEnv.FuncName){
                            $prxPath = join-path -path $rvEnv.FuncDir -ChildPath $rvEnv.FuncName ; 
                    } else {
                        write-warning "Missing either `$rvEnv.FuncDir -OR `$rvEnv.FuncName!" ; 
                    } ; 
                } ; 
                if(-not $rvEnv.isFunc){
                    # under funcs, this is the scriptblock of the func, not a path
                    if($rvEnv.MyInvocationproxy.MyCommand.Definition){$prxPath2 = $rvEnv.MyInvocationproxy.MyCommand.Definition }
                    elseif($rvEnv.MyInvocationproxy.MyCommand.Definition){$prxPath2 = $rvEnv.MyInvocationproxy.MyCommand.Definition } ; 
                } ; 
                if($prxPath){
                    # 12/12/2025 new code to patch no-ext $prxPath
                    if(-not [System.IO.Path]::GetExtension($prxPath)){
                        write-verbose "no-extension `$prxpath, asserting fake ext (.ps1|.psm1 as approp)" ;                         
                        switch($rvEnv.runSource){
                            'Function'{$prxPath = "$($prxPath).psm1" }
                            'ExternalScript'{$prxPath = "$($prxPath).ps1" }
                            default {
                                $smsg = "NO RECOGNIZED `$rvEnv.runSource: '$($rvEnv.runSource)'`nUNABLE TO SAFELY TEST FOR AllUsers or CU SCOPE!: ABORTING (Could log into module hosting dir!)" ; 
                                write-warning $smsg ; throw $smsg ; 
                                BREAK ; 
                            }
                        } ; 
                    } ; 
                    if(($prxPath -match $rgxPSAllUsersScope) -OR ($prxPath -match $rgxPSCurrUserScope)){
                        $bDivertLog = $true ; 
                        switch -regex ($prxPath){
                            $rgxPSAllUsersScope{$smsg = "AllUsers"} 
                            $rgxPSCurrUserScope{$smsg = "CurrentUser"}
                        } ;
                        $smsg += " context script/module, divert logging into [$budrv]:\scripts" 
                        write-verbose $smsg  ;
                        if($bDivertLog){
                            if((split-path $prxPath -leaf) -ne $rvEnv.CmdletName){
                                # function in a module/script installed to allusers|cu - defer name to Cmdlet/Function name
                                $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($rvEnv.CmdletName).ps1") ;
                            } else {
                                # installed allusers|CU script, use the hosting script name
                                $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $prxPath -leaf)) ;
                            }
                        } ;
                    } else {
                        $pltSL.Path = $prxPath ;
                    } ;
                }elseif($prxPath2){
                    # 12/12/2025 new code to patch no-ext $prxPath2
                    if(-not [System.IO.Path]::GetExtension($prxPath2)){
                        write-verbose "no-extension `$prxPath2, asserting fake ext (.ps1|.psm1 as approp)" ;                         
                        switch($rvEnv.runSource){
                            'Function'{$prxPath2 = "$($prxPath2).psm1" }
                            'ExternalScript'{$prxPath2 = "$($prxPath2).ps1" }
                            default {
                                $smsg = "NO RECOGNIZED `$rvEnv.runSource: '$($rvEnv.runSource)'`nUNABLE TO SAFELY TEST FOR AllUsers or CU SCOPE!: ABORTING (Could log into module hosting dir!)" ; 
                                write-warning $smsg ; throw $smsg ; 
                                BREAK ; 
                            }
                        } ; 
                    } ; 
                    if(($prxPath2 -match $rgxPSAllUsersScope) -OR ($prxPath2 -match $rgxPSCurrUserScope) ){
                            $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $prxPath2 -leaf)) ;
                    } elseif(test-path $prxPath2) {
                        $pltSL.Path = $prxPath2 ;
                    } elseif($rvEnv.CmdletName){
                        $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($rvEnv.CmdletName).ps1") ;
                    } else {
                        $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$rvEnv.CmdletName, FROM WHICH TO BUILD A START-LOG.PATH!" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        BREAK ;
                    } ; 
                } else{
                    $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$rvEnv.CmdletName, FROM WHICH TO BUILD A START-LOG.PATH!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    BREAK ;
                }  ;
                write-verbose "start-Log w`n$(($pltSL|out-string).trim())" ; 
                $logspec = start-Log @pltSL ;
                $error.clear() ;
                TRY {
                    if($logspec){
                        $logging=$logspec.logging ;
                        $logfile=$logspec.logfile ;
                        $transcript=$logspec.transcript ;
                        $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                        if($stopResults){
                            $smsg = "Stop-transcript:$($stopResults)" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        } ; 
                        $startResults = start-Transcript -path $transcript -whatif:$false -confirm:$false;
                        if($startResults){
                            $smsg = "start-transcript:$($startResults)" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ; 
                    } else {throw "Unable to configure logging!" } ;
                } CATCH [System.Management.Automation.PSNotSupportedException]{
                    if($host.name -eq 'Windows PowerShell ISE Host'){
                        $smsg = "This version of $($host.name):$($host.version) does *not* support native (start-)transcription" ; 
                    } else { 
                        $smsg = "This host does *not* support native (start-)transcription" ; 
                    } ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    #region SendMailAlert ; #*------v SendMailAlert v------
                    $SmtpBody += "`n===FAIL Summary:" ;
                    $SmtpBody += "`n$('-'*50)" ;
                    $SmtpBody += "`n$('-'*50)" ;
                    $smsg += "`n$(($smsg |out-string).trim())" ; 
                    $sdEmail = @{
                        smtpFrom = $SMTPFrom ;
                        SMTPTo = $SMTPTo ;
                        SMTPSubj = $SMTPSubj ;
                        #SMTPServer = $SMTPServer ;
                        SmtpBody = $SmtpBody ;
                        SmtpAttachment = $SmtpAttachment ;
                        BodyAsHtml = $false ; # let the htmltag rgx in Send-EmailNotif flip on as needed
                        verbose = $($VerbosePreference -eq "Continue") ;
                    } ;
                    $smsg = "Send-EmailNotif w`n$(($sdEmail|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Send-EmailNotif @sdEmail ;

                    #endregion SendMailAlert ; #*------^ END SendMailAlert ^------
                } ;
            } ; 
            #endregion START_LOG_HOLISTIC #*------^ END START_LOG_HOLISTIC ^------
            # ...
            #endregion START_LOG_OPTIONS #*======^ START_LOG_OPTIONS ^======

            #region VARI_SETUP ; #*------v VARI_SETUP v------
            #$fname = $lname = $dname = $OPRcp = $OPMailbox = $OPRemoteMailbox = $ADUser = $xoRcp = $xoMailbox = $xoUser = $xoMemberOf = $MsolUser = $LicenseGroup = $null ;
            $isEml=$isDname=$isSamAcct=$isXORcpMulti  = $false ;

            $hSum = [ordered]@{
                dname = $null ;
                fname = $null ;
                lname = $null ;
                OPRcp = $null ;
                xoRcp = $null ;
                OPMailbox = $null ;
                OPRemoteMailbox = $null ;
                ADUser = $null ;
                Federator = $null ;
                xoMailbox = $null ;
                xoMUser = $null ;
                xoUser = $null ;
                xoMemberOf = $null ;
                txGuest = $null ;
                OPMapiTest = $null ;
                xoMapiTest = $null ;
                MsolUser = $null ;
                #AADUser = $null ; # added for MailUser variant
                MGUser = $null ; # 12:43 PM 12/10/2025 added with M$ forced block of all azuread access, and forced migration to crappy MG module calls
                #AADUserMgr = $null ;
                MGUserMgr = $null ; # 12:43 PM 12/10/2025 added with M$ forced block of all azuread access, and forced migration to crappy MG module calls
                #AADUserLics = $null ; 
                MGUserLics = $null ; # 12:43 PM 12/10/2025 added with M$ forced block of all azuread access, and forced migration to crappy MG module calls
                LicenseGroup = $null ;
                isDirSynced = $null 
                isNoBrain = $false ;
                isSplitBrain = $false;
                #isUnlicensed = $false ;
                IsLicensed = $false ; 
                IsDisabledOU = $false ; 
                IsADDisabled = $false ; 
                #IsAADDisabled = $false ; 
                IsMGDisabled = $false ; 
            } ;
            $procd++ ;
            write-verbose "processing:$($usr)" ;
            if($getMobile){
                
                $smsg = "(-getMobile:retrieving user xo MobileDevices)" ; 
                if($verbose){
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-verbose $smsg } ; 
                } ; 
                $hsum.add('xoMobileDeviceStats',$null) ; 
                $hsum.add('xoMobileDeviceStatsOLD',$null) ; 
                # 9:22 AM 9/23/2025 add xoMobileOutlookClients, xoMobileOMSyncTypes, reflecting supported Outlook Mobile client & the ClientType spec in use for the OLM 'Microsoft's native sync technology'
                # add xoMobileDeviceTypes, xoMobileOtherSyncTypes to make iphone/android types immed vis
                $hsum.add('xoMobileOutlookClients',$null) ; 
                $hsum.add('xoMobileOtherClients',$null) ; 
                $hsum.add('xoMobileOMSyncTypes',$null) ; 
                #$hsum.add('xoMobileDeviceTypes',$null) ; 
                $hsum.add('xoMobileOtherSyncTypes',$null) ; 
                
            } ; 
            if($getQuotaUsage){
                $smsg = "(-getQuotaUsage:retrieving user xo Mailbox*Statistics & Effective Quotas)" ; 
                if($verbose){
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-verbose $smsg } ; 
                } ; 
                $hsum.add('xoMailboxStats',$null) ; 
                $hsum.add('xoMailboxFolderStats',$null) ; 
                $hsum.add('xoEffectiveQuotas',$null) ; 
                $hsum.add('xoNetOfSendReceiveQuotaMB',$null) ; 
                [string]$ofMbxFolderStats = $logfile.replace('LOG-BATCH-EXEC',"folder-sizes-NONHIDDEN-NONZERO").replace('-log','') ; 
                #$ofile.replace('REPORT',"folder-sizes-NONHIDDEN-NONZERO") ; 

            } ; 
            # 2:35 PM 12/26/2024 getPerms
            if($getPerms){
                $hsum.add('xoMailboxPermission',$null) ; 
                $hsum.add('xoRecipientPermission',$null) ; 
                #$hsum.add('xoMailboxPermissionGroupManagedBy',$null) ; # moved into the group summary
                $hsum.add('xoMailboxPermissionGroups',@()) ; 
                $hsum.add('xoRecipientPermissionGroups',$null) ; 
                #$hsum.add('xoRecipientPermissionGroupManagedBy',@()) ; 
            }
            # 2:44 PM 4/12/2025 add ResolveForwards Mailcontact/ForwardingAddress resolution
            if($ResolveForwards){
                $hsum.add('opMailContact',$null) ;
                $hsum.add('opContactForwards',$null) ; 
                $hsum.add('xoMailContact',$null) ;
                $hsum.add('xoMailboxForwardingAddress',$null) ; 
                $hsum.add('xoContactForwards',$null) ; 
            }
            if($usr -match $rgxAccentedNameChars){
                # 9:36 AM 9/23/2024 pre remove all diacritics & latin chars 
                #Remove-StringDiacritic -String 'Helen Bräuchle' |Remove-StringLatinCharacters
                $smsg = "Remove-StringDiacritic -String $($usr) (if needed)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $usr = Remove-StringDiacritic -String $usr ; 
            
                $smsg = "Remove-StringLatinCharacters -String $($usr) (if needed)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $usr = Remove-StringLatinCharacters -String $usr ; 
            } ; 

            switch -regex ($usr){
                $rgxEmailAddr {
                # $rgxEmailAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ;
                    $hSum.fname,$hSum.lname = $usr.split('@')[0].split('.') ;
                    $hSum.dname = $usr ; # temp set eml as dname, re-resolved to proper further on
                    write-verbose "(detected user ($($usr)) as EmailAddr)" ;
                    $isEml = $true ;
                    Break ;
                }
                $rgxObjNameNewHires{
                # $rgxObjNameNewHires = "^([a-zA-Z]{2,}(\s|\.)[a-zA-Z]{1,}'?-?[a-zA-Z]{2,}\s?([a-zA-Z]{1,})?)_[a-z0-9]{10}"  
                # Name:Fname LName_f4feebafdb (appending uniqueness guid chunk)
                    write-verbose "(detected user ($($usr)) as ObjNameNewHires)" ;
                    $hSum.fname,$hSum.lname = $usr.split('_')[0].split(' ');
                    $hSum.dname = $usr.split('_')[0] ;
                    write-verbose "(detected user ($($usr)) as DisplayName)" ;
                    $isObjName = $true ;
                    Break ;
                }
                $rgxSamAcctNameTOR {
                # $rgxSamAcctNameTOR = "^\w{2,20}$" ; # up to 20c, the limit prior to win2k
                    $hSum.lname = $usr ;
                    write-verbose "(detected user ($($usr)) as SamAccountName)" ;
                    $isSamAcct  = $true ;
                    Break ;
                }
                # move dname below samacct, it's a broader spec
                $rgxDName {
                    # $rgxDName = "^([a-zA-Z]{2,}(\s|\.)[a-zA-Z]{1,}'?-?[a-zA-Z]{2,}\s?([a-zA-Z]{1,})?)" ;
                    #updated: CMW uses : in their room names, so went for broader AD dname support, per AI, and web specs, added 1-256char AD restriction
                    #$rgxDName ="[a-zA-Z0-9\s$([Regex]::Escape('/\[:;|=,+*?<>') + '\]' + '\"')]{1,256}" ; 
                    if($usr.contains('.')){
                        write-verbose "(replacing period in DName)" ;
                        $usr = $usr.replace('.',' ') ;
                    };
                    $hSum.fname,$hSum.lname = $usr.split(' ') ;
                    $hSum.dname = $usr ;
                    write-verbose "(detected user ($($usr)) as DisplayName)" ;
                    $isDname = $true ;
                    Break ;
                }
                default {
                    write-warning "$((get-date).ToString('HH:mm:ss')):No -user specified, nothing matching dname, emailaddress or samaccountname, found on clipboard. EXITING!" ;
                    #Break ;
                } ;
            } ;
            #endregion VARI_SETUP ; #*------^ END VARI_SETUP ^------

            $sBnr="===v ($($Procd)/$($ttl)):Input: '$($usr)' | '$($hSum.fname)' | '$($hSum.lname)' v===" ;
            if($isEml){$sBnr+="(EML)"}
            elseif($isDname){$sBnr+="(DNAM)"}
            elseif($isObjName){$sBnr+="(ONAM)"}
            elseif($isSamAcct){$sBnr+="(SAM)"}
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr)" ;

            write-host -foreground yellow "get-Rmbx/xMbx: " -nonewline;

            #region SPLAT_SETUP ; #*------v SPLAT_SETUP v------
            # $isEml=$isDname=$isSamAcct=$false ;
            $MDtbl=[ordered]@{NoDashRow=$true } ; # out-markdowntable splat
            $pltGMailObj=[ordered]@{
                ResultSize = $MaxRecips ;
            } ;
            if($isEml -OR $isSamAcct){
                write-verbose "processing:'identity':$($usr)" ;
                $pltGMailObj.add('identity',$usr) ;
            } ;
            if($isObjName){
                # filter on Name, (not dname)
                $dname = $hSum.dname
                # 11:00 AM 10/11/2024 if dname contains ', have to variant quotewrap
                if($usr -match "[']"){
                    $fltr = "name -like " + $sQot + $usr + $sQot ;
                }else {
                    $fltr = "name -like '$usr'" ;
                } ; 
                write-verbose "processing:'filter':$($fltr)" ;
                $pltGMailObj.add('filter',$fltr) ;
            } ;
            if($isDname){
                # interestinb bug: switched to $hSum.dname: ISE is fine, but ConsoleHost fails to expand the $fltr properly.
                # standard is: Variables: Enclose variables that need to be expanded in single quotation marks (for example, '$User'). Don't use curly-brackets (impedes expansion)
                # workaround: looks like have to proxy the $hsum.Dname, to provide a single non-dotted variable name
                $dname = $hSum.dname
                # 11:00 AM 10/11/2024 if dname contains ', have to variant quotewrap
                if($dname -match "[']"){
                    $fltr = "displayname -like " + $sQot + $dname + $sQot ; 
                }else {
                    $fltr = "displayname -like '$dname'" ;
                } ; 
                # 8:47 AM 10/9/2024 where suffixed 'fname lname (SIT)', need functional wildcard to even hope to hit it, lets see if follow on fname lname filters gap fill, when dname is suffixed arbitrarily
                write-verbose "processing:'filter':$($fltr)" ;
                $pltGMailObj.add('filter',$fltr) ;
            } ;
            #endregion SPLAT_SETUP ; #*------^ END SPLAT_SETUP ^------

            $error.clear() ;

            #write-verbose "get-[exo]Recipient w`n$(($pltGMailObj|out-string).trim())" ;
            #write-verbose "get-recipient w`n$(($pltGMailObj|out-string).trim())" ;
            # exclude contacts, they don't represent real onprem mbx assoc, and we need to refer those to EXO mbx qry anyway.
            write-verbose "get-recipient w`n$(($pltGMailObj|out-string).trim())" ;
            #rx10 -Verbose:$false -silent ;

            #region OPRCP_DISCOVERY ; #*------v OPRCP_DISCOVERY v------
            if($resolveForwards){
                $smsg = "-resolveForwards: (include MailContacts)`nget-recipient w`n$(($pltGMailObj|out-string).trim())`n..." ; 
            }else{
                $smsg = "get-recipient w`n$(($pltGMailObj|out-string).trim())`n...| ?{$_.recipienttypedetails -ne 'MailContact'}" ; 
            } ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            
            #if($hSum.OPRcp=get-recipient @pltGMailObj -ea 0 | select -first $MaxRecips | ?{$_.recipienttypedetails -ne 'MailContact'}){
            if($hSum.OPRcp=get-recipient @pltGMailObj -ea 0 | select -first $MaxRecips ){
                if($resolveForwards){
                    
                } else { 
                    $hSum.OPRcp | ?{$_.recipienttypedetails -ne 'MailContact'} ; 
                } ; 
                $smsg = "`$hSum.OPRcp found as `n$(($pltGMailObj.GetEnumerator() | ?{$_.key -ne 'ResultSize'}  | ft -a key,value|out-string).trim())" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                
            } elseif($isDname -and $hsum.lname) {
                # put in missing *, hits on mis-spellings 'Spark' matches 'Sparks' w wildcard
                if($hsum.lname -match "[']"){
                    if(-not $resolveForwards){
                        $fltr = "recipienttypedetails -ne " + $sQot + "MailContact" + $sQot ; 
                        $fltr += " -AND displayname -like " + $sQot + $($hsum.lname) + $sQot ;
                    } else {
                        $fltr = "displayname -like " + $sQot + $($hsum.lname) + $sQot ;
                    };
                    
                }else {
                    if(-not $resolveForwards){
                        $fltr = "recipienttypedetails -ne 'MailContact'" ; 
                        $fltr += " -AND displayname -like '$($hsum.lname)'" ;
                    } else { 
                        $fltr += "displayname -like '$($hsum.lname)'" ;
                    } 
                } ; 
                if($hsum.fname){
                    # try first 3 of fname first
                    if($hsum.fname -match "[']"){
                        $fltr += " -AND firstName -like " + $sQot + $($hsum.fname.substring(0,3)) + "*" + $sQot ; 
                    }else {
                        $fltr += " -AND firstName -like '$($hsum.fname.substring(0,3))*'" ; 
                    } ; 
                    
                    #if($hSum.OPRcp=get-recipient -filter $fltr -ea 0 | select -first $MaxRecips |?{$_.recipienttypedetails -ne 'MailContact'}){
                    if($hSum.OPRcp=get-recipient -filter $fltr -ea 0 | select -first $MaxRecips){
                        if($resolveForwards){
                            
                        } else { 
                            $hSum.OPRcp = $hSum.OPRcp |?{$_.recipienttypedetails -ne 'MailContact'}
                        } ;
                        $smsg = "`$hSum.OPRcp found as `n$(($pltGMailObj.GetEnumerator() | ?{$_.key -ne 'ResultSize'}  | ft -a key,value|out-string).trim())" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    }elseif($hsum.fname){
                        # retry first initial
                        if($hsum.lname -match "[']"){
                            if($resolveForwards){
                                $fltr = "lastName -like " + $sQot + $($hsum.lname) + "*" + $sQot ; 
                            }else {
                                $fltr = "recipienttypedetails -ne " + $sQot + "MailContact" + $sQot + " -AND lastName -like " + $sQot + $($hsum.lname) + "*" + $sQot ; 
                            };
                        }else {
                            if($resolveForwards){
                                $fltr = "lastName -like '$($hsum.lname)*'" ; 
                            }else {
                                $fltr = "recipienttypedetails -ne 'MailContact' -AND lastName -like '$($hsum.lname)*'" ; 
                            } ;
                        } ; 
                        if($hsum.fname -match "[']"){
                                $fltr += " -AND firstName -like " + $sQot + $($hsum.fname.substring(0,1)) + "*" + $sQot ; 
                        }else {
                            $fltr += " -AND firstName -like '$($hsum.fname.substring(0,1))*'" ; 
                        } ; 
                        
                        #if($hSum.OPRcp=get-recipient -filter $fltr -ea 0 | select -first $MaxRecips |?{$_.recipienttypedetails -ne 'MailContact'}){
                        if($hSum.OPRcp=get-recipient -filter $fltr -ea 0 | select -first $MaxRecips){
                            if($resolveForwards){}else {
                                $hSum.OPRcp=$hSum.OPRcp  |?{$_.recipienttypedetails -ne 'MailContact'} ; 
                            }
                            $smsg = "`$hSum.OPRcp found as `n$(($pltGMailObj.GetEnumerator() | ?{$_.key -ne 'ResultSize'}  | ft -a key,value|out-string).trim())" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        }elseif($hsum.lname){
                            # do wildcard lname matches
                            if($hsum.lname -match "[']"){
                                if($resolveForwards){
                                    $fltr = "lastName -like " + $sQot + $($hsum.lname) + "*" + $sQot ; 
                                }else {
                                    $fltr = "recipienttypedetails -ne " + $sQot + "MailContact" + $sQot + " -AND lastName -like " + $sQot + $($hsum.lname) + "*" + $sQot ; 
                                }
                            }else {
                                if($resolveForwards){
                                    $fltr = "lastName -like '$($hsum.lname)*'" ; 
                                }else{
                                    $fltr = "recipienttypedetails -ne 'MailContact' -AND lastName -like '$($hsum.lname)*'" ; 
                                }
                            } ; 
                            
                            #if($hSum.OPRcp=get-recipient -filter $fltr -ea 0 | select -first $MaxRecips |?{$_.recipienttypedetails -ne 'MailContact'}){
                            if($hSum.OPRcp=get-recipient -filter $fltr -ea 0 | select -first $MaxRecips){
                                if($resolveForwards){

                                }else{
                                    $hSum.OPRcp=$hSum.OPRcp |?{$_.recipienttypedetails -ne 'MailContact'} ; 
                                }
                                $smsg = "`$hSum.OPRcp found as `n$(($pltGMailObj.GetEnumerator() | ?{$_.key -ne 'ResultSize'}  | ft -a key,value|out-string).trim())" ; 
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            }else{
                                $smsg = "(Failed to OP:get-recipient on:$($usr))"
                                if($isDname){$smsg += " or *$($hsum.lname )*"}
                                write-host $smsg ;                            
                            } ;
                        }
                    } ; 
   
                } ; 
            } ; 
            #endregion OPRCP_DISCOVERY ; #*------^ END OPRCP_DISCOVERY ^------

            #region ECHO_OPRCP ; #*------v ECHO_OPRCP v------
            if(-not $hsum.OpRcp){
                $smsg = "(Failed to OP:get-recipient on:$($usr))"
                if($isDname){$smsg += " or *$($hsum.lname )*"}
                write-host $smsg ;
            } else {
                # 8:55 AM 10/9/2024 arrays come through (esp for suffixed duped names): put in an explicit loop
                #$prpFTARcp = 'Name','RecipientTypeDetails','RecipientType','PrimarySmtpAddress','alias'
                $smsg = "`$hSum.OPRcp:`n$(($hSum.OPRcp | ft -a $prpFTARcp |out-string).trim())" ;
                if($hSum.OPRcp -is [array]){
                    $smsg += "`n==> MULTIPLE RECIPIENTS MATCHED!" ; 
                    write-warning $smsg ; 
                } else { 
                    write-verbose $smsg ; 
                } ; 
                $hSum.OPRcp | ForEach-Object{
                    $tmpRcp = $_ ; 
                    #switch ($hSum.OPRcp.recipienttypedetails){
                    switch ($tmpRcp.recipienttypedetails){
                        'RemoteUserMailbox' {write-host "(Rmbx)"}
                        # 8:53 AM 10/9/2024 add to cover mbx2shared conversion results
                        'RemoteSharedMailbox' {write-host "(Rmbx *SHARED*)"} 
                        # 12:23 PM 12/26/2024 add resource & remote res's
                        'RemoteRoomMailbox' {write-host "(Rmbx *ROOM*)"} 
                        'RemoteEquipmentMailbox' {write-host "(Rmbx *EQUIP*)"} 
                        'UserMailbox' {write-host "(Mbx)"}
                        'SharedMailbox' {write-host "(SMbx)"}
                        'RoomMailbox' {write-host "(RoomMbx)"}
                        'EquipmentMailbox' {write-host "(EquipMbx)"}
                        'MailUser' {
                            $smsg = "MAILUSER WO RMBX DETECTED! - POSSIBLE NOBRAIN?"
                            write-warning $smsg
                            #$hsum.isNoBrain = $true ;    
                        }
                        'MailUniversalDistributionGroup' {write-host "(DG)"}
                        'DynamicDistributionGroup'  {write-host "(DDG)"}
                        'MailContact' {write-host "(MC)"]}
                        default{
                            #$smsg = "Unable to resolve `$hSum.OPRcp.recipienttypedetails:$($hSum.OPRcp.recipienttypedetails)" ; 
                            $smsg = "Unable to resolve `$hSum.OPRcp.recipienttypedetails:$($tmpRcp.OPRcp.recipienttypedetails)" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            throw $smsg ; 
                            break ; 
                        }
                    }
                }  # loop-E 
            } ; # if-E
            #endregion ECHO_OPRCP ; #*------^ END ECHO_OPRCP ^------

            #region XORCP_DISCOVERY ; #*------v XORCP_DISCOVERY v------
            #if ($useEXOv2) { reconnect-eXO2 @pltRXOC }
            #else { reconnect-EXO @pltRXOC } ;
            #write-host -foreground yellow "get-xoMbx/xMbx: " -nonewline;
            if($resolveForwards){
                $smsg = "get-xorecipient w`n$(($pltGMailObj|out-string).trim())`n..." ;
            } else { 
                $smsg = "get-xorecipient w`n$(($pltGMailObj|out-string).trim())`n...| ?{$_.recipienttypedetails -ne 'MailContact'}" ;                
            }
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

            #if($hSum.xoRcp=get-xorecipient @pltGMailObj -ea 0 | select -first $MaxRecips | ?{$_.recipienttypedetails -ne 'MailContact'}){
            if($hSum.xoRcp=get-xorecipient @pltGMailObj -ea 0 | select -first $MaxRecips){
                if($resolveForwards){

                }else {
                    $hSum.xoRcp=$hSum.xoRcp  | ?{$_.recipienttypedetails -ne 'MailContact'}
                }
                $smsg = "`$hSum.xoRcp found as `n$(($pltGMailObj.GetEnumerator() | ?{$_.key -ne 'ResultSize'}  | ft -a key,value|out-string).trim())" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                
            } elseif($isDname -and $hsum.lname) {
                
                # put in missing *, hits on mis-spellings 'Spark' matches 'Sparks' w wildcard
                if($hsum.lname -match "[']"){
                    if($resolveForwards){
                        $fltr = "lastName -like " + $sQot + $($hsum.lname) + "*" + $sQot ;
                    }else {
                        $fltr = "recipienttypedetails -ne " + $sQot + "MailContact" + $sQot ;
                        $fltr += " -AND lastName -like " + $sQot + $($hsum.lname) + "*" + $sQot ;
                    }
                }else{
                    if($resolveForwards){
                        $fltr += "lastName -like '$($hsum.lname)*'" ;
                    }else {
                        $fltr = "recipienttypedetails -ne 'MailContact'" ;
                        $fltr += " -AND lastName -like '$($hsum.lname)*'" ;
                    }
                } ; 
                if($hsum.fname){
                    # try first 3 of fname first
                    if($hsum.fname -match "[']"){
                        $fltr += " -AND firstName -like " + $sQot + $($hsum.fname.substring(0,3)) + "*" + $sQot ;
                    }else{
                        $fltr += " -AND firstName -like '$($hsum.fname.substring(0,3))*'" ;
                    } ; 
                    #if($hSum.xoRcp=get-xorecipient -filter $fltr -ea 0 | select -first $MaxRecips |?{$_.recipienttypedetails -ne 'MailContact'}){
                    if($hSum.xoRcp=get-xorecipient -filter $fltr -ea 0 | select -first $MaxRecips){
                        if($resolveForwards){

                        }else {
                            $hSum.xoRcp=$hSum.xoRcp  |?{$_.recipienttypedetails -ne 'MailContact'}
                        }
                        $smsg = "`$hSum.xoRcp found as `n$(($pltGMailObj.GetEnumerator() | ?{$_.key -ne 'ResultSize'}  | ft -a key,value|out-string).trim())" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    }elseif($hsum.fname){
                        # retry first initial
                        if($hsum.lname -match "[']"){
                            if($resolveForwards){
                                $fltr = "lastName -like " + $sQot + $($hsum.lname) + "*" + $sQot ;
                            }else {
                                $fltr = "recipienttypedetails -ne " + $sQot + "MailContact" + $sQot + " -AND lastName -like " + $sQot + $($hsum.lname) + "*" + $sQot ;
                            }
                        } else { 
                            if($resolveForwards){
                                $fltr = "lastName -like '$($hsum.lname)*'" ;
                            }else{
                                $fltr = "recipienttypedetails -ne 'MailContact' -AND lastName -like '$($hsum.lname)*'" ;
                            }
                        }
                        if($hsum.fname -match "[']"){
                            $fltr += " -AND firstName -like " + $sQot + $($hsum.fname.substring(0,1)) + "*" + $sQot ;
                        } else { 
                            $fltr += " -AND firstName -like '$($hsum.fname.substring(0,1))*'" ;
                        } ; 

                        #if($hSum.xoRcp=get-xorecipient -filter $fltr -ea 0 | select -first $MaxRecips |?{$_.recipienttypedetails -ne 'MailContact'}){
                        if($hSum.xoRcp=get-xorecipient -filter $fltr -ea 0 | select -first $MaxRecips ){
                            if($resolveForwards){

                            }else {
                                $hSum.xoRcp=$hSum.xoRcp |?{$_.recipienttypedetails -ne 'MailContact'} ; 
                            } ; 
                            $smsg = "`$hSum.xoRcp found as `n$(($pltGMailObj.GetEnumerator() | ?{$_.key -ne 'ResultSize'}  | ft -a key,value|out-string).trim())" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        }elseif($hsum.lname){
                            # do wildcard lname matches
                            if($hsum.fname -match "[']"){
                                if($resolveForwards){
                                    $fltr = "lastName -like " + $sQot + $($hsum.lname) + "*" + $sQot ;
                                }else {
                                    $fltr = "recipienttypedetails -ne " + $sQot + "MailContact" + $sQot + " -AND lastName -like " + $sQot + $($hsum.lname) + "*" + $sQot ;
                                }
                            } else { 
                                if($resolveForwards){
                                       $fltr = "lastName -like '$($hsum.lname)*'" ;
                                }else{
                                    $fltr = "recipienttypedetails -ne 'MailContact' -AND lastName -like '$($hsum.lname)*'" ;
                                }
                            } ; 
                            #if($hSum.xoRcp=get-xorecipient -filter $fltr -ea 0 | select -first $MaxRecips |?{$_.recipienttypedetails -ne 'MailContact'}){
                            if($hSum.xoRcp=get-xorecipient -filter $fltr -ea 0 | select -first $MaxRecips){
                                if($resolveForwards){
                                }else{
                                    $hSum.xoRcp=$hSum.xoRcp |?{$_.recipienttypedetails -ne 'MailContact'}
                                }
                                $smsg = "`$hSum.xoRcp found as `n$(($pltGMailObj.GetEnumerator() | ?{$_.key -ne 'ResultSize'}  | ft -a key,value |out-string).trim())" ; 
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            }else{
                                $smsg = "(Failed to OP:get-xorecipient on:$($usr))"
                                if($isDname){$smsg += " or *$($hsum.lname )*"}
                                write-host $smsg ;
                            } ;
                        }
                    } ;
                } ;
            } ; 
            #endregion XORCP_DISCOVERY ; #*------^ END XORCP_DISCOVERY ^------

            #region ECHO_XORCP ; #*------v ECHO_XORCP v------
            if(-not $hSum.xoRcp){
                $smsg = "(Failed to OP:get-recipient on:$($usr))"
                if($isDname){$smsg += " or *$($hsum.lname )*"}
                write-host $smsg ;
            } else {
                # 8:55 AM 10/9/2024 arrays come through (esp for suffixed duped names): put in an explicit loop
                #$prpFTARcp = 'Name','RecipientTypeDetails','RecipientType','PrimarySmtpAddress','alias' ; 
                $smsg = "`$hSum.xoRcp:`n$(($hSum.xoRcp | ft -a $prpFTARcp |out-string).trim())" ;
                if($hSum.xoRcp -is [array]){
                    $smsg += "`n==> MULTIPLE RECIPIENTS MATCHED!" ; 
                    write-warning $smsg ; 
                } else {
                    write-verbose $smsg ;
                } ;
                $hSum.xoRcp | ForEach-Object{
                    $tmpxRcp = $_ ;
                    #switch ($hSum.xoRcp.recipienttypedetails){
                    # patched in xo equiv variants, added SharedMailbox too
                    switch ($tmpxRcp.recipienttypedetails){
                        'RemoteUserMailbox' {write-host "(Rmbx)" -nonewline}
                        # 8:53 AM 10/9/2024 add to cover mbx2shared conversion results
                        'RemoteSharedMailbox' {write-host "(Rmbx *SHARED*)" -nonewline}
                        # 12:23 PM 12/26/2024 add resource & remote res's
                        'RemoteRoomMailbox' {write-host "(Rmbx *ROOM*)" -nonewline}
                        'RemoteEquipmentMailbox' {write-host "(Rmbx *EQUIP*)" -nonewline}
                        'UserMailbox' {write-host "(xMbx)" -nonewline}
                        'SharedMailbox' {write-host "(xSMbx)" -nonewline}
                        'RoomMailbox' {write-host "(xRoomMbx)" -nonewline}
                        'EquipmentMailbox' {write-host "(xEquipMbx)" -nonewline}
                        # no rmbx, but remote obj?
                        'MailUser' {
                            $smsg = "xMAILUSER WO MBX DETECTED! - POSSIBLE NOBRAIN?"
                            write-warning $smsg
                            #$hsum.isNoBrain = $true ;
                        }
                        "GuestMailUser" {
                            $smsg = "xGuestMailUser detected, likely external forest/Inet Guest!"
                            write-warning $smsg
                        } ;
                        'MailUniversalDistributionGroup' {write-host "(xDG)" -nonewline}
                        'DynamicDistributionGroup'  {write-host "(xDDG)" -nonewline}
                        'MailContact' {write-host -nonewline "(xMC)" }
                        default{
                            #$smsg = "Unable to resolve `$hSum.xoRcp.recipienttypedetails:$($hSum.xoRcp.recipienttypedetails)" ; 
                            $smsg = "Unable to resolve `$hSum.xoRcp.recipienttypedetails:$($tmpxRcp.OPRcp.recipienttypedetails)" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            throw $smsg ; 
                            break ; 
                        }
                    }
                }  # loop-E
            } ; # if-E
            #endregion ECHO_XORCP ; #*------^ END ECHO_XORCP ^------

            # new rules, with INT/VEN AADU anchored to ADU, but xoMbx anchored solely to AADU (and not OP rcp), it's possible to completely fail onprem get-recipient, and still have a functional mailbox in cloud, that's operating properly.

            #region NONUNIQUE_RCPS_ABORT ; #*------v NONUNIQUE_RCPS_ABORT v------
            $abortReport = $false ; 
            if( ($hSum.OPRcp -OR $hSum.xoRcp) -AND ( ($hSum.OPRcp -is [array]) -AND ($hSum.xoRcp -is [array]) ) ){
                # failed to isolate both op & xo unique recip
                $abortReport = $true ;
            }elseif( ($hSum.OPRcp -OR $hSum.xoRcp) -AND ( ($hSum.xoRcp -isnot [array]) -AND ($hSum.OPRcp -is [array] ) ) ){
                # single cloud, mult onprem -> could be non-hybrid cloud-first recip
                $abortReport = $false ;
            }elseif( ($hSum.OPRcp -OR $hSum.xoRcp) -AND ( ($hSum.OPRcp -isnot [array]) -AND ($hSum.xoRcp -is [array]) ) ){
                # single OP recip, mult cloud; could be legit unonboarded OP rcp
                $abortReport = $false ; 
            } ; 

            if($abortReport){
                $smsg = "`n`n==RecipientArray(s) detected:"
                $smsg += "`nDumping initial OP & XO RecipientLists"
                $smsg += "`nto permit you to winnow down a single targeted user from the returns,"
                $smsg += "`nfor a fresh targeted pass!`n`n" ; 
                #if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                #else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                write-hostCallOutTDO -Object $smsg -Type Warning -Nowrap ;

                $smsg = "`$hSum.OPRcp match(es):`n$(($hSum.OPRcp | ft -a $prpFTARcp |out-string).trim())`n" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $smsg = "`$hSum.xoRcp match(es):`n$(($hSum.xoRcp | ft -a $prpFTARcp |out-string).trim())`n" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                BREAK ; 
            } ; 
            #endregion NONUNIQUE_RCPS_ABORT ; #*------^ END NONUNIQUE_RCPS_ABORT ^------

            #region OP_V_XO_RCPEXPAND ; #*------v OP_V_XO_RCPEXPAND v------
            if($hSum.OPRcp){
                #region OPRCP_EXPAND ; #*------v OPRCP_EXPAND v------
                # 9:41 AM 10/9/2024 with array loops we need to accomodate, and aggregate - or it throws errors tying to get-remotemailbox -id [array]
                # also need to += all assigns to acomodate both lookups, not just the last one
                if($hSum.OPRcp -is [array]){
                    $smsg = "ARRAY of OPRcps! Inconcistent results will be returned on attempts following, likely errors!" ; 
                    $smsg += "`n(need to isolate single specific identifier from these outputs, and rerun fresh pass)" ; 
                    write-warning $smsg ; 
                } ; 
                $hSum.OPRcp | ForEach-Object{
                    $tmpRcp = $_ ; 
                    $error.clear() ;
                    TRY {
                        switch -regex ($tmpRcp.recipienttype){
                            "UserMailbox" {
                                write-verbose "'UserMailbox':get-mailbox $($tmpRcp.identity)"
                                $bufferRcp = $null ; 
                                $bufferRcp = get-mailbox $tmpRcp.identity -resultsize $MaxRecips | select -first $MaxRecips ; 
                                #if($hSum.OPMailbox += get-mailbox $tmpRcp.identity -resultsize $MaxRecips | select -first $MaxRecips ){ ;
                                if($bufferRcp){
                                    $hSum.OPMailbox += $bufferRcp ; 
                                    #write-verbose "`$hSum.OPMailbox:`n$(($hSum.OPMailbox|ft -a |out-string).trim())" ;
                                    if($outObject){

                                    } else {
                                        #$Rpt += $hSum.OPMailbox.primarysmtpaddress ;
                                        $Rpt += $bufferRcp.primarysmtpaddress
                                    } ;
                                    write-verbose "'UserMailbox':Test-MAPIConnectivity -identity $($hSum.OPMailbox.userprincipalname)"
                                    $bufferRcp = $null ; 
                                    $bufferRcp  =  Test-MAPIConnectivity -identity $hSum.OPMailbox.userprincipalname ;
                                    if($bufferRcp){
                                        $hSum.OPMapiTest  += $bufferRcp ;
                                        $smsg = "Outlook (MAPI) Access Test Result:$($bufferRcp.OPMapiTest.result)" ;
                                        if($bufferRcp.OPMapiTest.result -eq 'Success'){
                                            write-host -foregroundcolor green $smsg ;
                                        } else {
                                            write-WARNING $smsg ;
                                        } ;
                                    } else { 
                                        write-warning "Failed to return Test-MAPIConnectivity -identity $($hSum.OPMailbox.userprincipalname) !" ; 
                                    } ; 
                                } ;
                            }
                            "MailUser" {
                                write-verbose "'MailUser':get-remotemailbox $($tmpRcp.identity)"
                                $bufferRcp = $null ; 
                                $bufferRcp  = get-remotemailbox $tmpRcp.identity -resultsize $MaxRecips -ea 0 | select -first $MaxRecips ; 
                                #if($hSum.OPRemoteMailbox += get-remotemailbox $tmpRcp.identity -resultsize $MaxRecips -ea 0 | select -first $MaxRecips){
                                if($bufferRcp){
                                    $hSum.OPRemoteMailbox += $bufferRcp ; 
                                    write-verbose "`$hSum.OPRemoteMailbox:`n$(($hSum.OPRemoteMailbox|ft -a |out-string).trim())" ;
                                }else{
                                    $smsg = "RecipientTypeDetails:MailUser with NO Rmbx! (NoBrain?)" ;
                                    write-warning $smsg ;
                                    if($hsum.xoRcp.ExternalDirectoryObjectId){
                                        # of course has match to AADU  - always does - we're going to need the AADU before we can lookup the ADU
                                        # $pltGadu.identity  +=  $hSum.AADUser.ImmutableId | convert-ImmuntableIDToGUID | select -expand guid ;
                                        #caad  -Verbose:$false -silent ;
                                        #write-verbose "OPRcp:Mailuser, ensure GET-ADUSER pulls AADUser.matched object for cloud recipient:`nfallback:get-AzureAdUser  -objectid $($hsum.xoRcp.ExternalDirectoryObjectId)" ;
                                        write-verbose "OPRcp:Mailuser, ensure Get-MgUser pulls MgUser.matched object for cloud recipient:`nfallback:Get-MgUser -userid $($hsum.xoRcp.ExternalDirectoryObjectId)" ;
                                        # have to postfilter, if want specific count -maxresults catch's with no $error[0]
                                        #$hSum.AADUser   +=  get-AzureAdUser  -objectid $hsum.xoRcp.ExternalDirectoryObjectId | select -first $MaxRecips;  ;
                                        # sub in Get-MgUser get-MgUserFull                                       
                                        $hSum.MGUser   +=  get-MgUserFull -userid $hsum.xoRcp.ExternalDirectoryObjectId | select -first $MaxRecips;  ;
                                    } else {
                                        throw "Unsupported object, blank `$hsum.xoRcp.ExternalDirectoryObjectId!" ;
                                    } ;
                                }
                                if($outObject){

                                } else {
                                    $Rpt += $hSum.OPRemoteMailbox.primarysmtpaddress ;
                                } ;
                            } ;
                            "MailContact" {
                                #$hSum.OPRemoteMailbox += get-remotemailbox $txR.identity  ;
                                #$Rpt += $hSum.OPRemoteMailbox.primarysmtpaddress ;

                                $bufferRcp = $null ; 
                                $bufferRcp  = get-mailcontact $tmpRcp.identity -resultsize $MaxRecips -ea 0 | select -first $MaxRecips ; 
                                #if($hSum.opMailContact += get-mailcontact $tmpRcp.identity -resultsize $MaxRecips -ea 0 | select -first $MaxRecips ; ){
                                if($bufferRcp){
                                    $hSum.opMailContact += $bufferRcp ; 
                                    write-verbose "`$hSum.opMailContact:`n$(($hSum.opMailContact|ft -a |out-string).trim())" ;
                                }else{
                                    $smsg = "RecipientTypeDetails:MailContact with NO Contact!!" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                }
                                $smsg = "$($tmpRcp.primarysmtpaddress): matches an EXO MailContact with external Email: $($bufferRcp.primarysmtpaddress)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                if($ResolveForwards){
                                    if(-not $hshForwards){
                                        $hshForwards = resolve-RMbxForwards ;
                                    } ;
                                    $tid = $bufferRcp.primarysmtpaddress ;
                                    if($hshForwards[$tid]){
                                        write-host "$($bufferRcp.primarysmtpaddress):Forwarding Contact"
                                        $smsg = "Recipient:$($tid) => $($hshForwards[$tid])" ;
                                        write-host $smsg ;
                                        $hsum.opContactForwards = $hshForwards[$tid] ;
                                    } ;
                                } ;
                                break ;
 
                            }
                            default {
                                write-warning "$((get-date).ToString('HH:mm:ss')):Unsupported RecipientType:($tmpRcp.recipienttype). EXITING!" ;
                                Break ;
                            }
                        }
                        #region OP_GADU ; #*------v OP_GADU v------
                        <# get-aduser docs say -REsultSetSize is documented,
                        [Get-ADUser (ActiveDirectory) | Microsoft Docs - docs.microsoft.com/](https://docs.microsoft.com/en-us/powershell/module/activedirectory/get-aduser?view=windowsserver2019-ps)
                         but use of it throws: Parameter set cannot be resolved using the specified named parameters.
                         pull it and post filter to 1...
                        #>
                        #ResultSetSize = $MaxRecips
                        #$pltGadu=[ordered]@{Identity = $null ; Properties='*' ;errorAction='STOP' ; } ;
                        $pltGadu=[ordered]@{Identity = $null ; Properties=$propsADU ;errorAction='STOP' ; } ;
                        if($hSum.OPRemoteMailbox ){
                            # get-aduser dox but doesn't really support ResultSetSize, post filter for it.
                            $pltGadu.identity = $hSum.OPRemoteMailbox.samaccountname ;
                        }elseif($hSum.OPMailbox){
                            $pltGadu.identity = $hSum.OPMailbox.samaccountname ;
                        } else {
                            # cloud-first or no brain, neither oprmbx or opmailbox;  should have populated $hSum.AADUser above, use immutable lookup
                            #if($hSum.AADUser.DirSyncEnabled){
                            # forcedmigr aad -> mg: Get-MgUserManager 
                            #  $mgu.OnPremisesSyncEnabled
                             if($hSum.MGUser.OnPremisesSyncEnabled){
                                $smsg = "Falling back to AADU Immutable lookup to locate replicated adu source" ;
                                #if($pltGadu.identity = $hSum.AADUser.ImmutableId | convert-ImmuntableIDToGUID | select -expand guid){
                                # forcedmigr aad -> mg:
                                # ren'd: OnPremisesImmutableId : UC7OjGZAYUK/qsVZatOR6g==
                                if($pltGadu.identity = $hSum.MGUser.OnPremisesImmutableId | convert-ImmuntableIDToGUID | select -expand guid){
                                    #$smsg = "(Resolved AADU.Immutable ->GUID:$($pltGadu.identity))" ;
                                    $smsg = "(Resolved MGU.Immutable ->GUID:$($pltGadu.identity))" ;
                                    write-verbose $smsg ;
                                }else {
                                    $smsg = "UNABLE TO RESOLVE ADU.IMMUTABLEID TO ADU GUID!"
                                    write-warning $smsg ;
                                    throw $smsg ;
                                }
                            } else {
                                #$smsg = "$AADUsuer not DirSyncEnabled: CLOUD FIRST!"
                                $smsg = "$MGUser not OnPremisesSyncEnabled: CLOUD FIRST!"
                                write-warning $smsg ;
                                #throw $smsg ;
                            } ;
                        };
                        if($pltGadu.identity){
                            <# this is throwing a blank fail
                            WARNING: 15:04:18:Failed processing .
                            Error Message:
                            Error Details:
                            # and dumping balance of processing
                            issue: was in adms drive: :xxxx, gadu was searching root domain only
                            so it was a search fail, throwing an error, but didn't return details. Still good idea to trap not found and echo it
                            #>
                            #$hSum.ADUser  += Get-ADUser @pltGadu ;
                            write-verbose "Get-ADUser w`n$(($pltGadu|out-string).trim())" ;
                            # try a nested local trycatch, against a missing result
                            Try {
                                #Get-ADUser $DN -ErrorAction Stop ;
                                $hSum.ADUser  += Get-ADUser @pltGadu | select -first $MaxRecips ;
                            } Catch [Microsoft.ActiveDirectory.Management.ADIdentityNotFoundException] {
                                write-warning "(no matching ADuser found:$($pltGadu.identity))" ;
                            } catch {
                                $ErrTrapd=$Error[0] ;
                                $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                Continue ;
                            } ;

                            write-verbose "`$hSum.ADUser:`n$(($hSum.ADUser|fl $propsADU| out-string).trim())" ;
                            $smsg = "(TOR USER, fed:$($TORMeta.adforestname))" ;
                            $hSum.Federator = $TORMeta.adforestname ;
                            write-host -Fore yellow $smsg ;
                        
                            # swap to md tbl fmt
                            if($hSum.OPRemoteMailbox){$MailRecip = $hSum.OPRemoteMailbox } ; 
                            if($hSum.OPMailbox){$MailRecip = $hSum.OPMailbox } ; 
                            $smsg = "$(($MailRecip| select $propsMailxL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                            $smsg += "`n$(($MailRecip|select $propsMailxL2 |out-markdowntable @MDtbl|out-string).trim())" ;
                            $smsg += "`n$(($MailRecip|select $propsMailxL3 |out-markdowntable @MDtbl|out-string).trim())" ;
                            #$smsg += "`n$(($MailRecip|select $propsMailxL4 |out-markdowntable @MDtbl|out-string).trim())" ;
                            #$smsg += "`n$(($MailRecip|select $propsMailxL4 | fl |out-string).trim())" ;
                            # drop L4 it's DN, which is already in ADU md tbl
                            # flip dn L4 to fl (suppress crlf)

                            write-host $smsg ;

                            if($hSum.OPRemoteMailbox.ForwardingAddress -OR $hSum.OPMailbox.ForwardingAddress){
                                write-host $smsg ; # echo pending, using ww below
                                $smsg = "==FORWARDED rMBX!:" ; 
                                # 10:31 AM 4/15/2025 resolve target of forward
                                $smsg += "`n$(($MailRecip|select $propsMailxL5 |out-markdowntable @MDtbl|out-string).trim())" ; 
                                if($fAddrRcp = $MailRecip.forwardingaddress| get-recipient -ea 0){
                                    $smsg += "`nFORWARDS TO OBJECT:`n$(($fAddrRcp | select name,RecipientType,PrimarySmtpAddress |out-markdowntable @MDtbl|out-string).trim())" ; 
                                } else{
                                     $smsg += "UNABLE TO RESOLVE forwardingaddress TO FUNCTIONAL RECIPIENT!(get-recipient)!" ;
                                }; 
                                write-warning $smsg ;
                            } ; 

                            #$smsg += "`n$(($hSum.ADUser |fl $propsADUsht  |out-string).trim())"
                            # these are already in the ADU md tbl dump, drop them
                            #$smsg = "$(($hSum.ADUser |fl $propsADUsht  |out-string).trim())"
                            #write-host $smsg ;
                        } ;
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Continue ;
                    } ;
                    #endregion OP_GADU ; #*------^ END OP_GADU ^------
                }  # loop-E $hSum.OPRcp
                #endregion OPRCP_EXPAND ; #*------^ END OPRCP_EXPAND ^------
            }elseif($hSum.xoRcp){
                #region XORCP_EXPAND ; #*------v XORCP_EXPAND v------
                foreach($txR in $hSum.xoRcp){
                    TRY {
                        switch -regex ($txR.recipienttypedetails){
                            "UserMailbox" {
                                #write-verbose "$((get-alias ps1GetxMbx).definition) w`n$(($pltGMailObj|out-string).trim())" ;
                                write-verbose "get-exomailbox w`n$(($pltGMailObj|out-string).trim())" ;
                                if($hSum.xoMailbox += get-xomailbox @pltGMailObj -ea 0 | select -first $MaxRecips ){
                                    write-verbose "`$hSum.xoMailbox:`n$(($hSum.xoMailbox|out-string).trim())" ;
                                    if($outObject){

                                    } else {
                                        $Rpt += $hSum.xoMailbox.primarysmtpaddress ;
                                    } ;
                                    if($hSum.xoMailbox -is [system.array]){
                                        write-warning "Multiple mailboxes matched!" ;
                                    } ;
                                    # accomodate array returned (multiple matches):
                                    $ino = 0 ;
                                    foreach($xmbx in $hSum.xoMailbox){
                                        $ino++ ;
                                        if($hSum.xoMailbox -isnot [system.array]){
                                            $smsg = "xmbx$($ino):$($xmbx.userprincipalname)" ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        } ;
                                        write-verbose "'xoUserMailbox':Test-exoMAPIConnectivity $($xmbx.userprincipalname)"
                                        $hSum.xoMapiTest  +=  Test-xoMAPIConnectivity -identity $xmbx.userprincipalname ;
                                        $smsg = "Outlook (xoMAPI) Access Test Result:$($hsum.xoMapiTest.result)" ;
                                        if($hsum.xoMapiTest.result -eq 'Success'){
                                            write-host -foregroundcolor green $smsg ;
                                        } else {
                                            write-WARNING $smsg ;
                                        } ;
                                        #region xogetMobile ; #*------v xogetMobile v------
                                        if($getMobile){
                                            get-xoMobileData ; 
                                            <#
                                            $smsg = "'xoMobileDeviceStats':Get-xoMobileDeviceStatistics -Mailbox $($xmbx.ExchangeGuid.guid)"
                                            if($verbose){
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                else{ write-verbose $smsg } ; 
                                            } ; 
                                            #$hsum.xoMobileDeviceStats  +=  Get-xoMobileDeviceStatistics -Mailbox $xmbx.userprincipalname -ea STOP ; 
                                            # wasn't getting data back: shift to the .xomailbox.ExchangeGuid.guid, it's 100% going to hit and return data 
                                            $hsum.xoMobileDeviceStats  +=  Get-xoMobileDeviceStatistics -Mailbox $xmbx.ExchangeGuid.guid -ea STOP ; 
                                            $smsg = "xoMobileDeviceStats Count:$(($hsum.xoMobileDeviceStats|measure).count)" ;
                                            write-host -foregroundcolor green $smsg ;
                                            #>
                                        } ; 
                                        #endregion xogetMobile ; #*------^ END xogetMobile ^------
                                        #region xogetQuotaUsage ; #*------v getQuotaUsage v------
                                        if($getQuotaUsage){
                                            $pltGMbxStatX=[ordered]@{
                                                identity = $hSum.xoMailbox.exchangeguid ;
                                                ErrorAction = 'STOP' ; 
                                            } ;
                                            $smsg = "Get-xoMailboxStatistics  w`n$(($pltGMbxStatX|out-string).trim())"
                                            if($verbose){
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                else{ write-verbose $smsg } ; 
                                            } ; 
                                            $hSum.xoMailboxStats  +=  Get-xoMailboxStatistics @pltGMbxStatX | select $prpStat;
                                            $smsg = "xoMailboxStats Count:$(($hsum.xoMailboxStats|measure).count)" ;
                                            write-host -foregroundcolor green $smsg ;

                                            If($hSum.xoMailbox.UseDatabaseQuotaDefaults){
                                                $hSum.xoEffectiveQuotas  +=  $hSum.xoMailboxStats | select @{N ='IssueWarningQuotaMB'; e={$_.DBIssueWarningQuotaMB}},
                                                @{n='ProhibitSendQuotaMB'; e={$_.DBProhibitSendQuotaMB}},
                                                @{n='ProhibitSendReceiveQuotaMB';e={$_.DBProhibitSendReceiveQuotaMB}}; 
                                            } else {
                                                $hSum.xoEffectiveQuotas  +=  $hSum.xoMailbox | select @{n="IssueWarningQuotaMB";e={[math]::round($_.IssueWarningQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                                                @{n="ProhibitSendQuotaMB";e={[math]::round($_.ProhibitSendQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                                                @{n="ProhibitSendReceiveQuotaMB";e={[math]::round($_.ProhibitSendReceiveQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}} ;
                                            } ;  
                                            $hSum.xoNetOfSendReceiveQuotaMB  +=  $hSum.xoEffectiveQuotas.ProhibitSendQuotaMB - $hSum.xoMailboxStats.TotalMailboxSizeMB ; 

                                            $pltGMbxStatX.add('IncludeOldestAndNewestItems',$true) ; 
                                            $smsg = "Get-xoMailboxFolderStatistics  w`n$(($pltGMbxStatX|out-string).trim())" ;
                                            if($verbose){
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                else{ write-verbose $smsg } ; 
                                            } ; 
                                            TRY{
                                                $hsum.xoMailboxFolderStats  +=  Get-xoMailboxFolderStatistics @pltGMbxStatX  ;

                                                $smsg = "Export FolderStats to`n$(($ofMbxFolderStats|out-string).trim())" ;
                                                if($verbose){
                                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                    else{ write-verbose $smsg } ; 
                                                } ; 
                                                if($DeletedItems){
                                                    $hsum.xoMailboxFolderStats | 
                                                        select $prpFldrDeleted | sort TreeSizeMB -desc | export-csv  -path $ofMbxFolderStats -notype ;

                                                }else{
                                                    $hsum.xoMailboxFolderStats | ?{$_.ItemsInFolder -gt 0 -AND $_.identity -notmatch $rgxHiddn } | 
                                                        select $prpFldr | sort SizeMB -desc | export-csv  -path $ofMbxFolderStats -notype ;
                                                } ; 

                                            } CATCH {
                                                $ErrTrapd=$Error[0] ;
                                                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                                write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                                            } ; 
                                        } ; 
                                        #endregion xogetQuotaUsage ; #*------^ END xogetQuotaUsage ^------
                                        #region xogetPerms ; #*------v xogetPerms v------
                                        if($getPerms){
                                            $pltGMbxPermX=[ordered]@{
                                                identity = $hSum.xoMailbox.exchangeguid ;
                                                ErrorAction = 'STOP' ;
                                            } ;
                                            $smsg = "Get-xoMailboxPermission  w`n$(($pltGMbxPermX|out-string).trim())"
                                            if($verbose){
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                                else{ write-verbose $smsg } ;
                                            } ;
                                            TRY{
                                                $hSum.xoMailboxPermission  +=  Get-xoMailboxPermission @pltGMbxPermX | ?{$_.user -notmatch 'NT\sAUTHORITY\\SELF'} | select $prpMPerms;
                                                $smsg = "xoMailboxPermission Count:$(($hsum.xoMailboxPermission|measure).count)" ;
                                                write-host -foregroundcolor green $smsg ;
                                                if($hSum.xoMailboxPermission){
                                                    foreach($grp in ($hSum.xoMailboxPermission.user | 
                                                        get-xorecipient  | ?{$_.recipienttype -eq 'MailUniversalSecurityGroup'}) ){
                                                        $hshGrpSumm = [ordered]@{
                                                            Identity = $grp.Identity
                                                            PrimarySmtpAddress = $grp.PrimarySmtpAddress ;
                                                            Description = $grp.Description ;
                                                            RecipientType = $grp.RecipientType ;
                                                            RecipientTypeDetails = $grp.RecipientTypeDetails ;
                                                            ManagedBy = ($grp | get-xodistributiongroup | select -expand managedby | get-xorecipient -ea 0) ;
                                                            Members = ($grp | get-xodistributiongroupmember | get-xorecipient  -ea 0) ;
                                                        } ; 
                                                        $hSum.xoMailboxPermissionGroups += [pscustomobject]$hshGrpSumm ; 
                                                    } ;
                                                } else {
                                                    $smsg = "(no non-SELF Get-xoMailboxPermission returned)" ; 
                                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                                };
                                            } CATCH {
                                                $ErrTrapd=$Error[0] ;
                                                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                                write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                                            } ;
                                            $smsg = "Get-xoRecipientPermission  w`n$(($pltGMbxPermX|out-string).trim())"
                                            if($verbose){
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                                else{ write-verbose $smsg } ;
                                            } ;
                                            TRY{
                                                $hsum.xoRecipientPermission += Get-xoRecipientPermission @pltGMbxPermX | ?{$_.trustee -notmatch 'NT\sAUTHORITY\\SELF'}  | select $prpRPerms;
                                                $smsg = "xoRecipientPermission Count:$(($hsum.xoRecipientPermission|measure).count)" ;
                                                write-host -foregroundcolor green $smsg ;
                                                if($hsum.xoRecipientPermission){
                                                    foreach($grp in ($hsum.xoRecipientPermission.trustee | 
                                                        get-xorecipient  | ?{$_.recipienttype -eq 'MailUniversalSecurityGroup'}) ){
                                                        $hshGrpSumm = [ordered]@{
                                                            Identity = $grp.Identity
                                                            PrimarySmtpAddress = $grp.PrimarySmtpAddress ;
                                                            Description = $grp.Description ;
                                                            RecipientType = $grp.RecipientType ;
                                                            RecipientTypeDetails = $grp.RecipientTypeDetails ;
                                                            ManagedBy = ($grp | get-xodistributiongroup | select -expand managedby | get-xorecipient -ea 0) ;
                                                            Members = ($grp | get-xodistributiongroupmember | get-xorecipient  -ea 0) ;
                                                        } ; 
                                                        $hSum.xoRecipientPermissionGroups += [pscustomobject]$hshGrpSumm ;
                                                    } ;
                                                } else {
                                                    $smsg = "(no non-SELF Get-xoRecipientPermission returned)" ; 
                                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                                };
                                            } CATCH {
                                                $ErrTrapd=$Error[0] ;
                                                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                                                write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                                            } ;
                                        } ; 
                                        #endregion xogetPerms ; #*------^ END xogetPerms ^------
                                        #region ResolveForwards ; #*------v ResolveForwards v------
                                        # we don't need the hash-Rmbx lookup process, just expand the fwd address to matching recip
                                        if($hSum.xoMailbox.ForwardingAddress){
                                            $smsg = "NOTE:$($hSum.xoMailbox.userprincipalname) has *populated* ForwardingAddress!:" ; 
                                            $smsg += "`nForwardingAddress`n$(($hSum.xoMailbox.ForwardingAddress|out-string).trim())" ;
                                            if($fAddrRcp = $hSum.xoMailbox.ForwardingAddress | get-xorecipient -ea 0){
                                                $smsg += "`n=> which forwards into object`n$(($faddrrcp | ft -a name,RecipientType,PrimarySmtpAddress|out-string).trim())" ;
                                            } else { 
                                                $smsg += "==> UNABLE TO RESOLVE THE ABOVE OBJECT INTO GET-XORECIPIENT (NO RETURN)!" ; 
                                            } ; 
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                        };
                                        #endregion ResolveForwards ; #*------^ END ResolveForwards ^------
                                    } ; # foreach($xmbx in $hSum.xoMailbox)
                                    break ;
                                } ;
                            }
                            "MailUser" {
                                # external mail recipient, *not* in TTC - likely in other rgs, and migrated to remote EXOP enviro
                                #$hSum.OPRemoteMailbox += get-remotemailbox $txR.identity  ;
                                caad -silent -verbose:$false ;
                                #write-verbose "`$txR | $((get-alias ps1GetxMUsr).definition)..." ;
                                write-verbose "`$txR | Get-xoMailUser..." ;
                                $hSum.xoMUser  +=  $txR | Get-xoMailUser -ResultSize $MaxRecips | select -first $MaxRecips ;
                                #write-verbose "`$txR | $((get-alias ps1GetxUser).definition)..." ;
                                write-verbose "`$txR | get-xoUser ..." ;
                                $hSum.xoUser  +=  $txR | get-xouser -ResultSize $MaxRecips | select -first $MaxRecips ;
                                write-verbose "`$hSum.xoUser:`n$(($hSum.xoUser|ft -a |out-string).trim())" ;
                                #write-verbose "get-AzureAdUser  -objectid $($hSum.xoUser.userPrincipalName)" ;
                                #$hSum.AADUser   +=  get-AzureAdUser  -objectid $hSum.xoMUser.userPrincipalName -Top $MaxRecips ;
                                write-verbose "`$hSum.xoMUser:`n$(($hSum.xoMUser|ft -a |out-string).trim())" ;
                                #$Rpt += $hSum.OPRemoteMailbox.primarysmtpaddress ;
                                write-host "$($txR.ExternalEmailAddress): matches a MailUser object with UPN:$($hSum.xoMUser.userPrincipalName)" ;
                                if($outObject){

                                } else {
                                    $Rpt += $hSum.xoMUser.primarysmtpaddress ;
                                } ;
                                break ;
                            } ;
                            "GuestMailUser" {
                                #$hSum.OPRemoteMailbox += get-remotemailbox $txR.identity  ;
                                caad -silent -verbose:$false ;
                                #write-verbose "`$txR | $((get-alias ps1GetxUser).definition)..." ;
                                write-verbose "`$txR | get-xoUser..." ; 
                                $hSum.xoUser  +=  $txR | get-xouser -ResultSize $MaxRecips | select -first $MaxRecips ;
                                write-verbose "`$hSum.xoUser:`n$(($hSum.xoUser|ft -a |out-string).trim())" ;
                                write-verbose "get-AzureAdUser  -objectid $($hSum.xoUser.userPrincipalName)" ;
                                #$hSum.txGuest  +=  get-AzureAdUser  -objectid $hSum.xoUser.userPrincipalName -Top $MaxRecips | select -first $MaxRecips ;
                                # forced upgrade blocked AAD -> MG
                                $hSum.txGuest  +=  get-MgUserFull -userid $hsum.xoRcp.ExternalDirectoryObjectId | select -first $MaxRecips;  ;
                                write-verbose "`$hSum.txGuest:`n$(($hSum.txGuest|ft -a |out-string).trim())" ;
                                #$Rpt += $hSum.OPRemoteMailbox.primarysmtpaddress ;
                                write-host "$($txR.ExternalEmailAddress): matches a Guest object with UPN:$($hSum.xoUser.userPrincipalName)" ;
                                if($null -eq $hSum.txGuest.EmailAddresses){
                                    write-warning "Guest appears to have damage from conficting replicated onprem MailContact, as it's EmailAddresses property is *blank*" ;
                                } ;
                                break ;
                            } ;
                            "MailContact" {
                                $bufferRcp = $null ;
                                $bufferRcp  = get-xomailcontact $txR.identity -resultsize $MaxRecips -ea 0 | select -first $MaxRecips ;
                                if($bufferRcp){
                                    $hSum.xoMailContact += $bufferRcp ;
                                    write-verbose "`$hSum.opMailContact:`n$(($hSum.opMailContact|ft -a |out-string).trim())" ;
                                }else{
                                    $smsg = "RecipientTypeDetails:MailContact with NO Contact!!" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                }
                                $smsg = "$($txR.primarysmtpaddress): matches an EXO MailContact with external Email: $($bufferRcp.externalemailaddress)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                if($ResolveForwards){
                                    if(-not $hshForwards){
                                        $hshForwards = resolve-RMbxForwards ;
                                    } ;
                                    $tid = $bufferRcp.primarysmtpaddress ;
                                    if($hshForwards[$tid]){
                                        write-host "$($bufferRcp.primarysmtpaddress):Forwarding Contact"
                                        $smsg = "Recipient:$($tid) => $($hshForwards[$tid])" ;
                                        write-host $smsg ;
                                        $hsum.xoContactForwards = $hshForwards[$tid] ;
                                    } ;
                                } ;
                                break ;
                            } ;
                            "MailUniversalSecurityGroup" {
                                #$hSum.OPRemoteMailbox += get-remotemailbox $txR.identity  ;
                                #$Rpt += $hSum.OPRemoteMailbox.primarysmtpaddress ;
                                write-host "$($txR.primarysmtpaddress): matches an EXO MailUniversalSecurityGroup with Dname: $($txR.displayname)" ;
                                break ;
                            } ;
                            default {
                                write-warning "$((get-date).ToString('HH:mm:ss')):Unsupported RecipientType:($hSum.OPRcp.recipienttype). EXITING!" ;
                                Break ;
                            }
                        }
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Continue ;
                    } ;
                }  # loop-E $hSum.xoRcpx
                # contacts and guests won't drop with $hSum.OPRemoteMailbox or $hSum.OPMailbox populated
                #region XO_GADU ; #*------v XO_GADU v------
                TRY {
                    $pltGadu=[ordered]@{Identity = $null ; Properties='*' ;errorAction='SilentlyContinue'} ;
                    if($hSum.OPRemoteMailbox ){
                        $pltGadu.identity = $hSum.OPRemoteMailbox.samaccountname;
                    }elseif($hSum.OPMailbox){
                        $pltGadu.identity = $hSum.OPMailbox.samaccountname ;
                    }elseif(-not $hsum.OPRcp -AND $hsum.xorcp -AND $hSum.xomailbox){
                        $smsg = "XOMailbox with NO OPRcp/Rmbx/MUser" ;
                        write-host -foregroundcolor yellow $smsg ;
                        if($hsum.xoRcp.ExternalDirectoryObjectId){
                            # of course has match to AADU  - always does - we're going to need the AADU before we can lookup the ADU
                            if(-not $hSum.MGUser){
                                # $pltGadu.identity  +=  $hSum.AADUser.ImmutableId | convert-ImmuntableIDToGUID | select -expand guid ;
                                #Connect-AAD -Verbose:$false -silent ;
                                write-verbose "xoMailbox: ensure GET-ADUSER pulls MGUser.matched object for cloud recipient:`nfallback:get-AzureAdUser  -objectid $($hsum.xoRcp.ExternalDirectoryObjectId)" ;
                                # have to postfilter, if want specific count -maxresults catch's with no $error[0]
                                #$hSum.AADUser   +=  get-AzureAdUser  -objectid $hsum.xoRcp.ExternalDirectoryObjectId | select -first $MaxRecips;  ;
                                # forced upgrade blocked AAD -> MG
                                $hSum.MGUser   +=  get-MgUserFull -userid $hsum.xoRcp.ExternalDirectoryObjectId | select -first $MaxRecips; 
                            } ; 
                        } else {
                            throw "Unsupported object, blank `$hsum.xoRcp.ExternalDirectoryObjectId!" ;
                        } ;
                        if($hSum.xomailbox.IsDirSynced){
                            # doesn't mean hybrid exchange obj, means ADU anchored object
                            write-host "XOMailbox.IsDirSynced: anchored to ADUser" ; 
                            #if($hSum.AADUser.ExtensionProperty.onPremisesDistinguishedName){
                            # forcedmigr aad -> mg:
                            if($hsum.MGuser.OnPremisesDistinguishedName){
                                #switch -regex ($hSum.AADUser.ExtensionProperty.onPremisesDistinguishedName){
                                switch -regex ($hsum.MGuser.OnPremisesDistinguishedName){
                                    $rgxADDistNameAT{
                                        #$pltGadu.identity = $hSum.AADUser.ExtensionProperty.onPremisesDistinguishedName ; 
                                        $pltGadu.identity = $hsum.MGuser.OnPremisesDistinguishedName
                                        #$pltGadu.add('server',(($hSum.AADUser.ExtensionProperty.onPremisesDistinguishedName.split(',') | ?{$_ -match 'DC='} ) -replace 'DC=','') -join '.') ; 
                                        $pltGadu.add('server',(($hsum.MGuser.OnPremisesDistinguishedName.split(',') | ?{$_ -match 'DC='} ) -replace 'DC=','') -join '.') ; 
                                    }
                                    default{
                                        $smsg = "Unrecognized MGuser.OnPremisesDistinguishedName!" ; 
                                        $smsg += "`n$($hsum.MGuser.OnPremisesDistinguishedName)" ; 
                                        throw $smsg ;
                                    }
                                } ; 
                            } else {
                                write-warning "blank MGuser.OnPremisesDistinguishedName! (non-ADUser-sync'd object)" ; 
                            } ;  
                        }else{
                            write-warning "xomailbox is *NOT* IsDirSynced!, Cloud-first recipient, wo anchored ADUser object!" ; 
                        }
                    } else {
                        write-warning "NO FUNCTIONAL COMBO OF OPRcp xoRcp OR xoMailbox!" ; 
                    };
                    if($pltGadu.identity){
                        write-verbose "Get-ADUser w`n$(($pltGadu|out-string).trim())" ;
                        # try a nested local trycatch, against a missing result
                        Try {
                            #Get-ADUser $DN -ErrorAction Stop ;
                            $hSum.ADUser  += Get-ADUser @pltGadu | select -first $MaxRecips ;
                        } Catch [Microsoft.ActiveDirectory.Management.ADIdentityNotFoundException] {
                            write-warning "(no matching ADuser found:$($pltGadu.identity))" ;
                        } catch {
                            $ErrTrapd=$Error[0] ;
                            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Continue ;
                        } ;

                        write-verbose "`$hSum.ADUser:`n$(($hSum.ADUser|fl $propsADU | out-string).trim())" ;
                        $smsg = "(TOR USER, fed:$($TORMeta.adforestname))" ;
                        $hSum.Federator  +=  $TORMeta.adforestname ;
                        write-host -Fore yellow $smsg ;
                        if($hSum.OPRemoteMailbox){
                            $smsg = "$(($hSum.OPRemoteMailbox |fl $propsMailx|out-string).trim())"
                            #$smsg += "`n-Title:$($hSum.ADUser.Title)"
                            #$smsg += "`n$(($hSum.ADUser |fl 'Enabled','Description','whenCreated','whenChanged','Title' |out-string).trim())"
                            $smsg += "`n$(($hSum.ADUser |fl 'Enabled','Description','Info','whenCreated','whenChanged','Title' |out-string).trim())"
                        } ;
                        if($hSum.OPMailbox){
                            $smsg =  "$(($hSum.OPMailbox |fl $propsMailx|out-string).trim())" ;
                            #$smsg += "`n$(($hSum.ADUser |fl 'Enabled','Description','whenCreated','whenChanged','Title' |out-string).trim())"
                            $smsg += "`n$(($hSum.ADUser |fl 'Enabled','Description','Info','whenCreated','whenChanged','Title' |out-string).trim())"
                        } ; 
                        if( -not $hsum.OPRcp -AND $hsum.xoRcp -AND $hsum.xomailbox){ 
                            $smsg = "Cloud Mailbox is nonDirSync'd NON-HYBRID mail object!" ; 
                            $smsg += "`n$(($hSum.xoMailbox |fl $propsMailx|out-string).trim())" ; 
                            if($hsum.ADUser){
                                #if($hsum.Aaduser.DirSyncEnabled){
                                # forcedmigr aad -> mg:
                                if($hsum.MgUser.OnPremisesSyncEnabled){
                                    $smsg += "`nbut ADUser Object IS dirsync'd to AzureADUser object" ; 
                                } else { 
                                    $smsg += "`nADUser Object IS NOT dirsync'd to AzureADUser object" ; 
                                } ; 
                                #$smsg += "`n$(($hSum.ADUser |fl 'Enabled','Description','whenCreated','whenChanged','Title' |out-string).trim())"
                                $smsg += "`n$(($hSum.ADUser |fl 'Enabled','Description','Info','whenCreated','whenChanged','Title' |out-string).trim())"
                            } else {
                                $smsg += "`nNO ADUser Object appears to be cloud-first MGUser object" ;
                            }; 
                        } ;
                        if( -not $hsum.OPRcp -AND -not $hsum.xoRcp -AND $hSum.ADUser -AND $hsum.MGUser){
                            $smsg = "No detected OnPrem or Cloud Mail Recipient Objects detected" ; 
                            if($hSum.ADUser){
                                $smsg += "`nADUser Object IS NOT dirsync'd to MgUser object" ; 
                            } ; 
                            if($hsum.MgUser.OnPremisesSyncEnabled){
                                $smsg += "`nbut ADUser Object IS dirsync'd to MgUser object" ; 
                            } ; 
                        } ; 
                        write-host $smsg ;
                    } ;
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Continue ;
                } ;
                #endregion XO_GADU ; #*------^ END XO_GADU ^------
                #endregion XORCP_EXPAND ; #*------^ END XORCP_EXPAND ^------
                if($outObject){

                } else {
                    $Rpt += $hSum.xoMailbox.primarysmtpaddress ;
                } ;
                $ino = 0 ;
                foreach($xmbx in $hSum.xoMailbox){
                    $ino++;
                    if($hSum.xoMailbox -isnot [system.array]){
                        $smsg = "xmbx$($ino):$($xmbx.userprincipalname)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    if($xmbx.isdirsynced){
                        # can be federated to VEN|CMW|Toro
                        switch -regex ($xmbx.primarysmtpaddress.split('@')[1]){
                            $CMWMeta.rgxOPFederatedDom {
                                $smsg="(CMW USER, fed:$($CMWMeta.adforestname))" ;
                                $hSum.Federator  +=  $CMWMeta.adforestname ;
                            }
                            $TORMeta.rgxOPFederatedDom {
                                $smsg="(TOR USER, fed:$($TORMeta.adforestname))" ;
                                $hSum.Federator  +=  $TORMeta.adforestname ;
                            }
                            $VENMeta.rgxOPFederatedDom {
                                $smsg="(VEN USER, fed:$($venmeta.o365_TenantLabel))" ;
                                $hSum.Federator  +=  $VENMETA.o365_TenantLabel ;
                            }
                            $INTMeta.rgxOPFederatedDom {
                                $smsg="(INT USER, fed:$($INTmeta.o365_TenantLabel))" ;
                                $hSum.Federator  +=  $INTMETA.o365_TenantLabel ;
                            }

                        } ;
                    } elseif($hSum.xoMuser.IsDirSynced){
                        switch -regex ($xmbx.primarysmtpaddress.split('@')[1]){
                            $CMWMeta.rgxOPFederatedDom {
                                $smsg="(CMW USER, fed:$($CMWMeta.adforestname))" ;
                                $hSum.Federator  +=  $CMWMeta.adforestname ;
                            }
                            $TORMeta.rgxOPFederatedDom {
                                $smsg="(TOR USER, fed:$($TORMeta.adforestname))" ;
                                $hSum.Federator  +=  $TORMeta.adforestname ;
                            }
                            $VENMeta.rgxOPFederatedDom {
                                $smsg="(VEN USER, fed:$($venmeta.o365_TenantLabel))" ;
                                $hSum.Federator  +=  $VENMETA.o365_TenantLabel ;
                            }
                            $INTMeta.rgxOPFederatedDom {
                                $smsg="(INT USER, fed:$($INTmeta.o365_TenantLabel))" ;
                                $hSum.Federator  +=  $INTMETA.o365_TenantLabel ;
                            }
                        } ;
                    }else{
                        [regex]$rgxTenDom = [regex]::escape("@$($tormeta.o365_TenantDomain)")
                        if($hsum.xoRcp.primarysmtpaddress -match $rgxTenDom){
                                $smsg="(CLOUD-1ST ACCT, unfederated)" ;
                                $hSum.Federator  +=  $TORMeta.o365_TenantDom ;

                        } else {
                            $smsg="(CLOUD-1ST ACCT, unfederated)" ;
                            $hSum.Federator  +=  $TORMeta.o365_TenantDom ;
                        } ;
                    } ;
                } ;  # loop-E
                write-host -Fore yellow $smsg ;
                # skip user lookup if guest already pulled it
                if(-not $hSum.xoUser){
                    $ino = 0 ;
                    foreach($xmbx in $hSum.xoMailbox){
                        #write-verbose "$((get-alias ps1GetxUser).definition) -id $($xmbx.UserPrincipalName)"
                        write-verbose "get-xoUser -id $($xmbx.UserPrincipalName)"
                        $hSum.xoUser += get-xouser -id $xmbx.UserPrincipalName -ResultSize $MaxRecips ;
                        write-verbose "`$hSum.xoUser:`n$(($hSum.xoUser|ft -a |out-string).trim())" ;
                    } ;
                } ; 

                if($hSum.xoMailbox){
                    $ino = 0 ;
                    foreach($xmbx in $hSum.xoMailbox){
                        $ino++ ;
                        if($hSum.xoMailbox -isnot [system.array]){
                            $smsg = "xmbx$($ino):$($xmbx.userprincipalname)" ;
                            write-host $smsg ;
                        } ;
                        write-host -foreground yellow "=get-xMbx:> " -nonewline;
                        write-host "$(($hSum.xoMailbox |fl ($propsMailx |?{$_ -notmatch '(sam.*|dist.*)'})|out-string).trim())`n-Title:$($hSum.xoUser.Title)";
                    } ;
                    #region xogetMobile2 ; #*------v xogetMobile2 v------
                    if($getMobile){
                        write-host -foreground yellow "===`$hsum.xoMobileDeviceStats: " #-nonewline;
                        $ino = 0 ;
                        foreach($xmob in $hsum.xoMobileDeviceStats){
                            $ino++ ;
                            if($hsum.xoMobileDeviceStats -is [system.array]){
                                 write-host -foreground yellow "=get-xMob$($ino):> " #-nonewline;
                            } else { 
                                write-host -foreground yellow "=get-xMobileDev:> " #-nonewline;
                            } ; 
                            $smsg = "$(($xmob | select $propsMobL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                            $smsg += "`n$(($xmob | select $propsMobL2 |out-markdowntable @MDtbl |out-string).trim())" ;
                            write-host $smsg ;
                        } ;

                    } ; 
                    #endregion xogetMobile2 ; #*------^ END xogetMobile2 ^------

                }elseif($hSum.xoMUser){
                    write-host "=get-xMUSR:>`n$(($hSum.xoMUser |fl ($propsMailx |?{$_ -notmatch '(sam.*|dist.*)'})|out-string).trim())`n-Title:$($hSum.xoUser.Title)";
                }elseif($hSum.txGuest){
                    write-host "=get-AADU:>`n$(($hSum.txGuest |fl userp*,PhysicalDeliveryOfficeName,JobTitle|out-string).trim())"
                } ;

                # populate xoMemberOf
                TRY {
                    #write-verbose "$((get-alias ps1GetxRcp).definition) -Filter {Members -eq '$($hSum.xoUser.DistinguishedName)'}`n -RecipientTypeDetails GroupMailbox,MailUniversalDistributionGroup,MailUniversalSecurityGroup"
                    write-verbose "get-xorecipient -Filter {Members -eq '$($hSum.xoUser.DistinguishedName)'}`n -RecipientTypeDetails GroupMailbox,MailUniversalDistributionGroup,MailUniversalSecurityGroup"
                    $hSum.xoMemberOf  +=  get-xorecipient -Filter "Members -eq '$($hSum.xoUser.DistinguishedName)'" -RecipientTypeDetails GroupMailbox,MailUniversalDistributionGroup,MailUniversalSecurityGroup ;
                    write-verbose "`$hSum.xoMemberOf:`n$(($hSum.xoMemberOf|out-string).trim())" ;
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Continue ;
                } ;
            } else {
                #region XORCP_RETRY ; #*------v XORCP_RETRY v------
                write-warning "(no matching EXOP or EXO recipient object:$($usr))"
                # do near Lname[0-3]* searches for comparison
                if($hSum.lname){
                    write-warning "Lname ($($hSum.lname) parsed from input),`nattempting similar LName g-rcp:...`n(up to `$MaxRecips:$($MaxRecips))" ;
                    $lname = $hsum.lname ;
                    #$fltrB = "displayname -like '*$lname*'" ;
                    #write-verbose "RETRY:get-recipient -filter {$($fltr)}" ;
                    #get-recipient "$($txusr.lastname.substring(0,3))*"| sort name
                    $substring = "$($hSum.lname.substring(0,3))*"
                    
                    if($resolveForwards){
                        write-host "get-recipient -id $($substring) -ea 0 :"
                    }else{
                        write-host "get-recipient -id $($substring) -ea 0 |?{$_.recipienttypedetails -ne 'MailContact'} :"
                    }
                    #==9:21 AM 10/8/2024:  since HR/WD change to SamAcctName as employe#, the above won't match any user created since 2022 or so. , 
                    # need to search on last name first

                    #if($hSum.Rcp += get-recipient -id "$($substring)" -ea 0 -ResultSize $MaxRecips | select -first $MaxRecips |?{$_.recipienttypedetails -ne 'MailContact'}){
                    if($hSum.Rcp += get-recipient -id "$($substring)" -ea 0 -ResultSize $MaxRecips | select -first $MaxRecips){
                        if($resolveForwards){

                        }else{
                            $hSum.Rcp = $hSum.Rcp  |?{$_.recipienttypedetails -ne 'MailContact'}
                        }
                        #$hSum.Rcp | write-output ;
                        # $propsRcpTbl
                        write-host -foregroundcolor yellow "`n$(($hSum.Rcp | ft -a $propsRcpTbl |out-string).trim())" ;
                    } ;
                    #write-host "$((get-alias ps1GetxRcp).definition) -id $($substring) -ea 0 |?{$_.recipienttypedetails -ne 'MailContact'} : "
                    if($resolveForwards){
                        write-host "get-xorecipient -id $($substring) -ea 0 : "
                    }else {
                        write-host "get-xorecipient -id $($substring) -ea 0 |?{$_.recipienttypedetails -ne 'MailContact'} : "
                    }
                    #if($hSum.xoRcp += get-xorecipient -id "$($substring)" -ea 0 -ResultSize $MaxRecips | select -first $MaxRecips |?{$_.recipienttypedetails -ne 'MailContact'}){
                    if($hSum.xoRcp += get-xorecipient -id "$($substring)" -ea 0 -ResultSize $MaxRecips | select -first $MaxRecips){
                        if($resolveForwards){

                        }else {
                            $hSum.xoRcp = $hSum.xoRcp|?{$_.recipienttypedetails -ne 'MailContact'} 
                        }
                        #$hSum.xoRcp | write-output ;
                        write-host -foregroundcolor yellow "`n$(($hSum.xoRcp | ft -a $propsRcpTbl |out-string).trim())" ;
                    } ;


                } ;
                #endregion XORCP_RETRY ; #*------^ END XORCP_RETRY ^------
                #region GADU_NAME ; #*------v GADU_NAME v------
                # do ADUser search on fname/lname
                if($hSum.lname){
                    # try as surname & givenname
                    if($hSum.lname -match "[']"){
                        $fltr = "surname -eq " + $sQot + $($hSum.lname) + $sQot ; 
                    }else{
                        $fltr = "surname -eq '$($hSum.lname)'"
                    }
                    #$fltr = "givenname -eq '$($hSum.givenname)'" ;
                    if($hSum.fname){
                        if($hSum.fname -match "[']"){
                            $fltr += " -AND givenname -eq " + $sQot + $($hSum.fname) + $sQot ;
                        }else{
                            $fltr += " -AND givenname -eq '$($hSum.fname)'"
                        } ;
                    } ; 
                    if($tmpADo = get-aduser -filter $fltr -ea 0 -Properties *| select -first $MaxRecips){
                        $smsg = "Matched on:get-aduser -filter $($fltr) " ; 
                        write-verbose $smsg ; 
                    }elseif($hSum.lname){
                        # treat as a samaccountname                        
                        if($tmpADo = get-aduser -identity $hSum.lname -ea 0 -Properties *| select -first $MaxRecips){
                            $smsg = "Matched on:get-aduser -identity $($hSum.fname)" ; 
                            write-verbose $smsg ; 
                        } ; 
                    }
                    if($tmpADo){
                        # |?{$_.recipienttypedetails -ne 'MailContact'}){
                        $rno = 0 ; 
                        $tmpADo | foreach-object {
                            $thisADU = $_ ; 
                            $rno++
                            #$hSum.ADUser +=  $thisADU ; 
                            # formatted dump
                            $hsADU=@"

ADUser #$($rno):DN:$(($thisADU.distinguishedname|out-string).trim())
$(($thisADU | ft -a $prpADU[1..3]|out-string).trim())
$(($thisADU | ft -a  $prpADU[4..7]|out-string).trim()) 
$(($thisADU | ft -a  $prpADU[8..11]|out-string).trim())

"@ ;
                            write-host $hsADU ; 
                       } ; 
                    } ; 
                } 
                #endregion GADU_NAME ; #*------^ END GADU_NAME ^------
                #region GMGU_NAME ; #*------v GMGU_NAME v------
                # do MGUser search on fname/lname
                if($hSum.lname){
                    # try as surname & givenname
                    # Get-AzureADGroup -filter "displayName eq 'ENT-SEC-SslVpn-AU-Administrators-DL'" ; 
                    # works: get-AzureAdUser -Filter "surname eq '$($hSum.surname)' and givenname eq '$($hSum.givenname)'"
                    if($hsum.lname -match "[']"){
                        $fltr = "surname eq " + $sQot + $($hsum.lname) + $sQot ;
                    }else{
                        $fltr = "surname eq '$($hsum.lname)'" ; 
                    }
                    #$fltr = "givenname -eq '$($hSum.givenname)'" ;
                    if($hSum.fname){
                        if($hsum.lname -match "[']"){
                            $fltr += " and givenname eq " + $sQot + $($hsum.fname) + $sQot ;
                        }else{
                            $fltr += " and givenname eq '$($hsum.fname)'"
                        }
                    } ; 
                    #if($tmpAADo = get-AzureAdUser  -filter $fltr -ea 0 | select -first $MaxRecips){
                    # forced M$ migre AAD -> MG
                    # Get-MgUser -Filter "givenName eq 'John' and surname eq 'Doe'" -All
                    if($tmpAADo = Get-MgUser -filter $fltr  -All -ea 0 | select -first $MaxRecips){
                        $smsg = "Matched on:get-AzureAdUser -filter $($fltr) " ; 
                        write-verbose $smsg ; 
                    }elseif($hSum.lname){
                        # treat as a -ObjectId                        
                        #if($tmpAADo = get-AzureAdUser -ObjectId $hSum.lname -ea 0 | select -first $MaxRecips){
                        if($tmpAADo = Get-MgUser -userId $hSum.lname -All -ea 0 | select -first $MaxRecips){
                            $smsg = "Matched on:get-AzureAdUser -identity $($hSum.fname)" ; 
                            write-verbose $smsg ; 
                        } ; 
                    }
                    if($tmpAADo){
                        # |?{$_.recipienttypedetails -ne 'MailContact'}){
                        $rno = 0 ; 
                        $tmpAADo | foreach-object {
                            $thisADU = $_ ; 
                            $rno++
                            #$hSum.ADUser +=  $thisADU ; 
                            # formatted dump
                            $hsADU=@"

MGUser #$($rno):DN:$(($thisADU.distinguishedname|out-string).trim())
$(($thisADU | ft -a $prpADU[1..3]|out-string).trim())
$(($thisADU | ft -a  $prpADU[4..7]|out-string).trim()) 
$(($thisADU | ft -a  $prpADU[8..11]|out-string).trim())

"@ ;
                            write-host $hsADU ; 
                       } ; 
                    } ; 
                } 
                #endregion GMGU_NAME ; #*------^ END GMGU_NAME ^------

                $abortReport = $true ; 

            } ; # don't break, doesn't continue loop
            #endregion OP_V_XO_RCPEXPAND ; #*------^ END OP_V_XO_RCPEXPAND ^------

            if($abortReport ){
                $smsg = "(multiple recipients - or no recipients, but ADUsers, or but MGUsers -  found in OnPrem And/Or Cloud, detailed reporting & output aborted)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                BREAK ; 
            } ; 

            #region FORCE_XOMBXINFO ; #*------v FORCE_XOMBXINFO v------
            # 10:42 AM 9/9/2021 force populate the xoMailbox, ALWAYS - need for xbrain ids
            #if($hSum.xoRcp.recipienttypedetails -eq 'UserMailbox' -AND -not($hSum.xoMailbox)){
            # accomodate array xorcp
            #if(($hSum.xoRcp|?{$_.recipienttypedetails -eq 'UserMailbox'}) -AND -not($hSum.xoMailbox)){
            # issue:quota on Shared: above only keys on recipienttypedetails -eq 'UserMailbox', should be *any* mailbox type, if we want quotas etc for shared/room/equipment  switch to rcptype: $hSum.xoRcp.RecipientType
            if(($hSum.xoRcp|?{$_.recipienttype -eq 'UserMailbox'}) -AND -not($hSum.xoMailbox)){
                #write-verbose "$((get-alias ps1GetxMbx).definition) w`n$(($pltGMailObj|out-string).trim())" ;
                write-verbose "get-xomailbox w`n$(($pltGMailObj|out-string).trim())" ;
                if($hSum.xoMailbox += get-xomailbox @pltGMailObj -ea 0| select -first $MaxRecips ){
                    $ino = 0 ;
                    $mapiResults = @() ;
                    foreach($xmbx in $hSum.xoMailbox){
                        $ino++ ;
                        if($hSum.xoMailbox -is [system.array]){
                            $msgprefix = "xmbx$($ino):" ;
                        } else { $msgprefix = $null } ;
                        $smsg = $msgprefix, "`$hSum.xoMailbox:`n$(($xmbx|ft -a |out-string).trim())" -join ' ' ;
                        write-verbose $smsg ;
                        $smsg = $msgprefix,"'xoUserMailbox':Test-exoMAPIConnectivity $($xmbx.userprincipalname)"  -join ' ' ;
                        write-verbose $smsg ;
                       $mapiResults += Test-xoMAPIConnectivity -identity $xmbx.userprincipalname ;
                        $smsg = "Outlook (xoMAPI) Access Test Result:$($mapiResults[$ino - 1].result)" ;
                        if($mapiResults[$ino - 1].result -eq 'Success'){
                            write-host -foregroundcolor green $smsg ;
                        } else {
                            write-WARNING $smsg ;
                        } ;
                    } ;
                    $hSum.xoMapiTest  +=  $mapiResults ;
                } ;
            } ;
            #region xogetMobile ; #*------v xogetMobile v------
            if($getMobile){
                get-xoMobileData ;                 
            } ; 
            #endregion xogetMobile ; #*------^ END xogetMobile ^------
            #region xogetQuotaUsage2 ; #*------v xogetQuotaUsage2 v------
            # 3:42 PM 9/25/2023 bring in new quota support as well - it's not populated in the oprcp first test
            if($getQuotaUsage){
                if(($hSum.xoRcp|?{$_.recipienttypedetails -match 'UserMailbox|SharedMailbox|RoomMailbox|EquipmentMailbox'}) -AND -not($hSum.xoMailboxStats)){
                    $pltGMbxStatX=[ordered]@{
                        identity = $hSum.xoMailbox.exchangeguid ;
                        ErrorAction = 'STOP' ; 
                    } ;
                    $smsg = "Get-xoMailboxStatistics  w`n$(($pltGMbxStatX|out-string).trim())"
                    if($verbose){
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-verbose $smsg } ; 
                    } ; 
                    $hSum.xoMailboxStats  +=  Get-xoMailboxStatistics @pltGMbxStatX | select $prpStat;
                    $smsg = "xoMailboxStats Count:$(($hSum.xoMailboxStats|measure).count)" ;
                    write-host -foregroundcolor green $smsg ;

                    If($hSum.xoMailbox.UseDatabaseQuotaDefaults){
                        $hSum.xoEffectiveQuotas = $hSum.xoMailboxStats | select @{N ='IssueWarningQuotaMB'; e={$_.DBIssueWarningQuotaMB}},
                        @{n='ProhibitSendQuotaMB'; e={$_.DBProhibitSendQuotaMB}},
                        @{n='ProhibitSendReceiveQuotaMB';e={$_.DBProhibitSendReceiveQuotaMB}}; 
                    } else {
                        $hSum.xoEffectiveQuotas = $hSum.xoMailbox | select @{n="IssueWarningQuotaMB";e={[math]::round($_.IssueWarningQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                        @{n="ProhibitSendQuotaMB";e={[math]::round($_.ProhibitSendQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}},
                        @{n="ProhibitSendReceiveQuotaMB";e={[math]::round($_.ProhibitSendReceiveQuota.ToString().Split("(")[1].Split(" ")[0].Replace(",","")/1MB,2)}} ;
                    } ;  
                    $hSum.xoNetOfSendReceiveQuotaMB  +=  $hSum.xoEffectiveQuotas.ProhibitSendQuotaMB - $hSum.xoMailboxStats.TotalMailboxSizeMB ; 

                    $pltGMbxStatX.add('IncludeOldestAndNewestItems',$true) ; 
                    $smsg = "Get-xoMailboxFolderStatistics  w`n$(($pltGMbxStatX|out-string).trim())" ;
                    if($verbose){
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-verbose $smsg } ; 
                    } ; 
                    $smsg = "(-getQuotaUsage:running lengthy Get-xoMailboxFolderStatistics...)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    TRY{
                        $hsum.xoMailboxFolderStats  +=  Get-xoMailboxFolderStatistics @pltGMbxStatX  ;

                        $smsg = "Export FolderStats to`n$(($ofMbxFolderStats|out-string).trim())" ;
                        if($verbose){
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-verbose $smsg } ; 
                        } ; 
                        if($DeletedItems){
                            $hsum.xoMailboxFolderStats |
                                select $prpFldrDeleted | sort TreeSizeMB -desc | export-csv  -path $ofMbxFolderStats -notype ;
                        }else{
                            $hsum.xoMailboxFolderStats | ?{$_.ItemsInFolder -gt 0 -AND $_.identity -notmatch $rgxHiddn } | 
                                select $prpFldr | sort SizeMB -desc | export-csv  -path $ofMbxFolderStats -notype ;
                        }

                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                        write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                    } ; 
                    
                }
            } ; 
            #endregion xogetQuotaUsage2 ; #*------^ END xogetQuotaUsage2 ^------
            #region xogetPerms2 ; #*------v xogetPerms2 v------
            if($getPerms){
                $pltGMbxPermX=[ordered]@{
                    identity = $hSum.xoMailbox.exchangeguid ;
                    ErrorAction = 'STOP' ;
                } ;
                $smsg = "Get-xoMailboxPermission  w`n$(($pltGMbxPermX|out-string).trim())"
                if($verbose){
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose $smsg } ;
                } ;
                TRY{
                    $hSum.xoMailboxPermission  +=  Get-xoMailboxPermission @pltGMbxPermX | ?{$_.user -notmatch 'NT\sAUTHORITY\\SELF'} | select $prpMPerms;
                    $smsg = "xoMailboxPermission Count:$(($hsum.xoMailboxPermission|measure).count)" ;
                    write-host -foregroundcolor green $smsg ;
                    if($hSum.xoMailboxPermission){
                        foreach($grp in ($hSum.xoMailboxPermission.user |
                            get-xorecipient  | ?{$_.recipienttype -eq 'MailUniversalSecurityGroup'}) ){
                            $hshGrpSumm = [ordered]@{
                                Identity = $grp.Identity
                                PrimarySmtpAddress = $grp.PrimarySmtpAddress ;
                                Description = $grp.Description ;
                                RecipientType = $grp.RecipientType ;
                                RecipientTypeDetails = $grp.RecipientTypeDetails ;
                                ManagedBy = ($grp | get-xodistributiongroup | select -expand managedby | get-xorecipient -ea 0) ;
                                Members = ($grp | get-xodistributiongroupmember | get-xorecipient  -ea 0) ;
                            } ; 
                            $hSum.xoMailboxPermissionGroups += [pscustomobject]$hshGrpSumm ;
                        } ;
                    } else {
                        $smsg = "(no non-SELF Get-xoMailboxPermission returned)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    };
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                    write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                } ;
                $smsg = "Get-xoRecipientPermission  w`n$(($pltGMbxPermX|out-string).trim())"
                if($verbose){
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose $smsg } ;
                } ;
                TRY{
                    $hsum.xoRecipientPermission += Get-xoRecipientPermission @pltGMbxPermX | ?{$_.trustee -notmatch 'NT\sAUTHORITY\\SELF'}  | select $prpRPerms;
                    $smsg = "xoRecipientPermission Count:$(($hsum.xoRecipientPermission|measure).count)" ;
                    write-host -foregroundcolor green $smsg ;
                    if($hSum.xoRecipientPermission){
                        foreach($grp in ($hsum.xoRecipientPermission.trustee |
                            get-xorecipient  | ?{$_.recipienttype -eq 'MailUniversalSecurityGroup'}) ){
                            $hshGrpSumm = [ordered]@{
                                Identity = $grp.Identity
                                PrimarySmtpAddress = $grp.PrimarySmtpAddress ;
                                Description = $grp.Description ;
                                RecipientType = $grp.RecipientType ;
                                RecipientTypeDetails = $grp.RecipientTypeDetails ;
                                ManagedBy = ($grp | get-xodistributiongroup | select -expand managedby | get-xorecipient -ea 0) ;
                                Members = ($grp | get-xodistributiongroupmember | get-xorecipient  -ea 0) ;
                            } ; 
                            $hSum.xoRecipientPermissionGroups += [pscustomobject]$hshGrpSumm ;
                        } ;
                    } else {
                        $smsg = "(no non-SELF Get-xoRecipientPermission returned)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    };
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                    write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                } ;
            }
            #endregion xogetPerms2 ; #*------^ END xogetPerms2 ^------
            #endregion FORCE_XOMBXINFO ; #*------^ END FORCE_XOMBXINFO ^------

            #region RV_VIA_GMGU ; #*------v RV_VIA_GMGU v------
            #$pltgMsoUsr=@{UserPrincipalName=$null ; MaxResults= $MaxRecips; ErrorAction= 'STOP' } ;
            # maxresults is documented:
            # but causes a fault with no $error[0], doesn't seem to be functional param, post-filter
            # ren refs of $pltgMsoUsr -> $pltgAADUsr
            $pltgMGUsr=@{UserPrincipalName=$null ; ErrorAction= 'STOP' } ;
            if($hSum.ADUser){$pltgMGUsr.UserPrincipalName  +=  $hSum.ADUser.UserPrincipalName }
            elseif($hSum.xoMailbox){$pltgMGUsr.UserPrincipalName += $hsum.xoMailbox.UserPrincipalName }
            elseif($hSum.xoMUser){$pltgMGUsr.UserPrincipalName  +=  $hSum.xoMUser.UserPrincipalName }
            elseif($hSum.txGuest){$pltgMGUsr.UserPrincipalName  +=  $hSum.txGuest.userprincipalname }
            else{} ;

            if($pltgMGUsr.UserPrincipalName){
                #region FORCE_GMGU ; #*------v FORCE_GMGU v------
                if(-not($hSum.MGUser)){
                    write-host -foregroundcolor yellow "=get-MGUser -userid $($pltgMGUsr.UserPrincipalName)>:" ;
                    TRY{
                        #caad  -Verbose:$false -silent ;
                        #write-verbose "get-AzureAdUser  -objectid $($pltgMGUsr.UserPrincipalName)" ;
                        write-verbose "Get-MgUser -userid  $($pltgMGUsr.UserPrincipalName)" ;
                        # have to postfilter, if want specific count -maxresults catch's with no $error[0]
                        #$hSum.AADUser   +=  get-AzureAdUser  -objectid $pltgMGUsr.UserPrincipalName  | select -first $MaxRecips;  ;
                        # forced migration AAD -> MG
                        $hSum.MGUser   +=  get-MgUserFull -userid $pltgMGUsr.UserPrincipalName | select -first $MaxRecips;  ;
                        <# for remote federated, AADU brings in summary of remote ADUser:
                            $hsum.aaduser.ExtensionProperty
                            Key                                                       Value
                            ---                                                       -----
                            odata.metadata                                            https://graph.windows.net/.../$metadata#directoryObjects/@Element
                            odata.type                                                Microsoft.DirectoryServices.User
                            createdDateTime                                           1/13/2021 4:14:48 PM
                            employeeId
                            onPremisesDistinguishedName                               CN=XXX,OU=XXX,...
                            thumbnailPhoto@odata.mediaEditLink                        directoryObjects/.../Microsoft.DirectoryServices.User/thumbnailPhoto
                            thumbnailPhoto@odata.mediaContentType                     image/Jpeg
                            userIdentities                                            []
                            extension_9d88b2c96135413e88afff067058e860_employeeNumber 1234
                             $hsum.aaduser.ExtensionProperty.onPremisesDistinguishedName
                            CN=XXX,OU=XXX,...

                            # MGUser has these: (unpop'd in some cases)
                            OnPremisesDistinguishedName           : CN=Todd Kadrie,OU=IS,OU=Users,OU=LYN,DC=global,DC=ad,DC=toro,DC=com
                            OnPremisesDomainName                  : global.ad.toro.com
                            OnPremisesExtensionAttributes         : Microsoft.Graph.PowerShell.Models.MicrosoftGraphOnPremisesExtensionAttributes
                            OnPremisesImmutableId                 : UC7OjGZAYUK/qsVZatOR6g==
                            OnPremisesLastSyncDateTime            :
                            OnPremisesProvisioningErrors          :
                            OnPremisesSamAccountName              : kadrits
                            OnPremisesSecurityIdentifier          : S-1-5-21-2222296782-158576315-1096482972-75073
                            OnPremisesSyncEnabled                 : True
                            OnPremisesUserPrincipalName           :

                        #>
                        #write-verbose "`$hSum.AADUser:`n$(($hSum.AADUser|out-string).trim())" ;
                        # ObjectId                             DisplayName   UserPrincipalName      UserType

                        #lic pull: $hSum.AADUser | Get-AzureADUserLicenseDetail -ea STOP | select -exp SkuPartNumber
                        write-verbose "`$hSum.MGUserLics = Get-MgUserLicenseDetail -userid $($hSum.MGUser.userprincipalname) | select -exp SkuPartNumber" ;
                        #$hsum.AADUserLics  +=   $hSum.AADUser | Get-AzureADUserLicenseDetail -ea STOP | select -exp SkuPartNumber ; 
                        # forcedmigr aad -> mg: Get-MgUserLicenseDetail -userid $mgu.userprincipalname
                        #$hsum.MGUserLics  +=   $hSum.MGUser | Get-MgUserLicenseDetail -ea STOP | select -exp SkuPartNumber ; 
                        # errors out, doesen't properly support pipeline (garbage)
                        $hsum.MGUserLics  +=  Get-MgUserLicenseDetail -userid $hSum.MGUser.userprincipalname -ea STOP | select -exp SkuPartNumber ; 

                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Continue ;
                    } ;

                } ;
                #endregion FORCE_GMGU ; #*------^ END FORCE_GMGU ^------
                #region FORCE_MGU_MGR ; #*------v FORCE_MGU_MGR v------
                #if(-not($hSum.AADUserMgr) -AND $hSum.AADUser ){
                if(-not($hSum.MGUserMgr) -AND $hSum.MGUser ){
                    write-host -foregroundcolor yellow "=Get-MgUserManager $($hSum.MGUser.UserPrincipalName)>:" ;
                    TRY{
                        #caad  -Verbose:$false -silent ;
                        write-verbose "Get-MgUserManager  -objectid $($hSum.MGUser.UserPrincipalName)" ;
                        # have to postfilter, if want specific count -maxresults catch's with no $error[0]
                        #$hSum.MGUserMgr   +=  get-AzureAdUserManager  -objectid $hSum.MGUser.UserPrincipalName  | select -first $MaxRecips;  ;
                        # forcedmigr aad -> mg: 
                        # they've buried all but the id property in AdditionalProperties [fk that!]
                        #$hSum.MGUserMgr   +=  (Get-MgUserManager  -userid $hSum.MGUser.UserPrincipalName  -Property $prpMGUser | select -first $MaxRecips).AdditionalProperties                        
                        $hSum.MGUserMgr   +=  (Get-MgUserManager  -userid $hSum.MGUser.UserPrincipalName  -Property $prpMGUser | select -first $MaxRecips).AdditionalProperties                        
                        #write-verbose "`$hSum.MGUserMgr:`n$(($hSum.MGUserMgr|out-string).trim())" ;
                        # (returns a full AADUser obj for the mgr)
                        # we can output the DN: $hSum.MGUserMgr.ExtensionProperty.onPremisesDistinguishedName
                        # useful for determining what 'org' user should be for email address assigns - they get same addr dom as their mgr
                        # |ft -a  $propsaadmgr
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Continue ;
                    } ;

                } ;
                #endregion FORCE_MGU_MGR ; #*------^ END FORCE_MGU_MGR ^------
                #region FORCE_MGU_MEMBEROF ; #*------v FORCE_MGU_MEMBEROF v------
                if(-not $hSum.xoMemberOf -AND $hsum.xoMailbox.DistinguishedName){
                    TRY {
                        write-verbose "get-xorecipient -Filter {Members -eq '$($hsum.xoMailbox.DistinguishedName)'}`n -RecipientTypeDetails GroupMailbox,MailUniversalDistributionGroup,MailUniversalSecurityGroup"
                        $hSum.xoMemberOf  +=  get-xorecipient -Filter "Members -eq '$($hsum.xoMailbox.DistinguishedName)'" -RecipientTypeDetails GroupMailbox,MailUniversalDistributionGroup,MailUniversalSecurityGroup ;
                        write-verbose "`$hSum.xoMemberOf:`n$(($hSum.xoMemberOf|out-string).trim())" ;
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Continue ;
                    } ;
                }else{
                    $smsg = "Unable to: `$hSum.xoMemberOf = Get-MgUserMemberOf -UserId $($hSum.MGUser.UserPrincipalName)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                }
                # as is typical, the MG command is too big a PITA and doesn't return what you want anyway. Use the XO cmdlets. 
                <#
                if(-not $hSum.xoMemberOf -AND $hSum.MGUser.UserPrincipalName){
                    TRY{
                        $hSum.xoMemberOf = (Get-MgUserMemberOf -UserId $hSum.MGUser.UserPrincipalName -Property "DisplayName", "mailNickname" -ConsistencyLevel eventual -ea STOP ).AdditionalProperties.mailNickname
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        Continue ;
                    } ;
                }else{
                    $smsg = "Unable to: `$hSum.xoMemberOf = Get-MgUserMemberOf -UserId $($hSum.MGUser.UserPrincipalName)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                }
                #>
                #endregion FORCE_MGU_MEMBEROF ; #*------^ END FORCE_MGU_MEMBEROF ^------
                # display user info:
                #region OUTPUT_P1 ; #*------v OUTPUT_P1 v------
                if(-not($hSum.ADUser)){
                    if($hSum.MGUser.OnPremisesSyncEnabled -AND $hSum.aaduser.ExtensionProperty.onPremisesDistinguishedName){
                        #region ADU_FEDERATED ; #*------v ADU_FEDERATED v------
                        $pltGadu.Identity = $hSum.MGUser.ExtensionProperty.onPremisesDistinguishedName ; 
                        $hSum.ADUser  += Get-ADUser @pltGadu | select -first $MaxRecips ;
                        if($pltGadu.identity){
                            write-verbose "Get-ADUser w`n$(($pltGadu|out-string).trim())" ;
                            # try a nested local trycatch, against a missing result
                            Try {
                                $hSum.ADUser  += Get-ADUser @pltGadu | select -first $MaxRecips ;
                            } Catch [Microsoft.ActiveDirectory.Management.ADIdentityNotFoundException] {
                                write-warning "(no matching ADuser found:$($pltGadu.identity))" ;
                            } catch {
                                $ErrTrapd=$Error[0] ;
                                $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                Continue ;
                            } ;

                            write-verbose "`$hSum.ADUser:`n$(($hSum.ADUser|fl $propsADU | out-string).trim())" ;
                            $smsg = "(TOR USER, fed:$($TORMeta.adforestname))" ;
                            $hSum.Federator  +=  $TORMeta.adforestname ;
                            write-host -Fore yellow $smsg ;
                            if($hSum.OPRemoteMailbox){
                                $smsg = "$(($hSum.OPRemoteMailbox |fl $propsMailx|out-string).trim())"
                                #$smsg += "`n-Title:$($hSum.ADUser.Title)"
                                #$smsg += "`n$(($hSum.ADUser |fl 'Enabled','Description','whenCreated','whenChanged','Title' |out-string).trim())"
                                $smsg += "`n$(($hSum.ADUser |fl 'Enabled','Description','Info','whenCreated','whenChanged','Title' |out-string).trim())"
                            } ;
                            if($hSum.OPMailbox){
                                $smsg =  "$(($hSum.OPMailbox |fl $propsMailx|out-string).trim())" ;
                                #$smsg += "`n$(($hSum.ADUser |fl 'Enabled','Description','whenCreated','whenChanged','Title' |out-string).trim())"
                                $smsg += "`n$(($hSum.ADUser |fl 'Enabled','Description','Info','whenCreated','whenChanged','Title' |out-string).trim())"
                            } ;
                            write-host $smsg ;
                        } ;
                        #endregion ADU_FEDERATED ; #*------^ END ADU_FEDERATED ^------
                    } else { 
                        #region REMOTE_ADU_FEDERATED ; #*------v REMOTE_ADU_FEDERATED v------
                        # remote fed, use AADU to proxy remote AD hybrid info:
                        write-host -foreground yellow "===`$hSum.MGUser: " #-nonewline;
                        <#
                        $smsg = "$(($hSum.AADUser| select $propsAADL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                        $smsg += "`n$(($hSum.AADUser|select $propsAADL2 |out-markdowntable @MDtbl|out-string).trim())" ;
                        $smsg += "`n$(($hSum.AADUser|select $propsAADL3 |out-markdowntable @MDtbl|out-string).trim())" ;
                        $smsg += "`n$(($hSum.AADUser|select $propsAADL4 |out-markdowntable @MDtbl|out-string).trim())" ;
                        $smsg += "`n$(($hSum.AADUser|select $propsAADL5 |out-markdowntable @MDtbl|out-string).trim())" ;
                        #>
                        # retool for MGU
                        $smsg = "$(($hSum.MGUser| select $propsMGUL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                        $smsg += "`n$(($hSum.MGUser|select $propsMGUL2 |out-markdowntable @MDtbl|out-string).trim())" ;
                        $smsg += "`n$(($hSum.MGUser|select $propsMGUL3 |out-markdowntable @MDtbl|out-string).trim())" ;
                        $smsg += "`n$(($hSum.MGUser|select $propsMGUL4 |out-markdowntable @MDtbl|out-string).trim())" ;
                        $smsg += "`n$(($hSum.MGUser|select $propsMGUL5 |out-markdowntable @MDtbl|out-string).trim())" ;
                        #$hsum.aaduser.ExtensionProperty.onPremisesDistinguishedName
                        if($hSum.Federator -ne $TORMeta.adforestname){
                            $smsg += "`n$($hSum.Federator):Remote ADUser.DN:`n$(($hSum.MGUser.ExtensionProperty.onPremisesDistinguishedName|out-string).trim())" ;
                        }  ;
                        #endregion REMOTE_ADU_FEDERATED ; #*------^ END REMOTE_ADU_FEDERATED ^------
                    }; 

                    write-host $smsg

                    # assert the real names from the user obj
                    $hSum.dname  +=  $hSum.MGUser.DisplayName ;
                    $hSum.fname  +=  $hSum.MGUser.GivenName ;
                    $hSum.lname  +=  $hSum.MGUser.Surname ;

                } else {
                    #region OUTPUT_ADU_INFO ; #*------v OUTPUT_ADU_INFO v------
                    # defer to ADUser details
                    write-host -foreground yellow "===`$hSum.ADUser: " #-nonewline;
                    $smsg = "$(($hSum.ADUser| select $propsADL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                    $smsg += "`n$(($hSum.ADUser|select $propsADL2 |out-markdowntable @MDtbl|out-string).trim())" ;
                    $smsg += "`n$(($hSum.ADUser|select $propsADL3 |out-markdowntable @MDtbl|out-string).trim())" ;
                    $smsg += "`n$(($hSum.ADUser|select $propsADL4 |out-markdowntable @MDtbl|out-string).trim())" ;
                    $smsg += "`n$(($hSum.ADUser|select $propsADL5 |out-markdowntable @MDtbl|out-string).trim())" ;
                    # stick desc on trailing line $propsADL5
                    #$smsg += "`n$(($hSum.ADUser|select $propsADL5 |out-markdowntable @MDtbl|out-string).trim())" ;
                    # flip L5 to fl (suppress crlf wrap)
                    $smsg += "`n$(($hSum.ADUser|select $propsADL6 |Format-List|out-string).trim())" ;
                    if($hsum.ADUser.Info){
                        $smsg += "`n$(($hSum.ADUser|select $propsADL7 |Format-List|out-string).trim())" ;
                    } ;
                    # moved DN into adl4, w enabled
                    #$smsg += "`n`$ADUser.DN:`n$(($hsum.aduser.DistinguishedName|out-string).trim())" ;
                    #$smsg += "`n$($hSum.ADUser|select Enabled,distinguishedname| convertTo-MarkdownTable -NoDashRow -Border) `$ADUser.DN:`n$(($hsum.aduser.DistinguishedName|out-string).trim())" ;
                    write-host $smsg ;

                    # assert the real names from the user obj
                    $hSum.dname  +=  $hSum.ADUser.DisplayName ;
                    $hSum.fname  +=  $hSum.ADUser.GivenName ;
                    $hSum.lname  +=  $hSum.ADUser.Surname ;
                    #endregion OUTPUT_ADU_INFO ; #*------^ END OUTPUT_ADU_INFO ^------
                } ;
                #endregion OUTPUT_P1 ; #*------^ END OUTPUT_P1 ^------
                #region ENABLED_STATUS ; #*------v ENABLED_STATUS v------
                # aduser enabled/disabled: .aduser.Enbabled
                if($hSum.aduser){
                    if($hSum.aduser.Enabled){
                        if($hsum.xoRcp.RecipientTypeDetails -match 'SharedMailbox|RoomMailbox|EquipmentMailbox'){
                            $smsg = "ADUser:$($hSum.ADUser.userprincipalname) AD Account w $($hsum.xoRcp.RecipientTypeDetails) mbx is *ENABLED!*"
                            write-warning $smsg ;
                        } ;
                    } else {
                        if($hsum.xoRcp.RecipientTypeDetails -match 'SharedMailbox|RoomMailbox|EquipmentMailbox'){} else { 
                            $smsg = "ADUser:$($hSum.ADUser.userprincipalname) AD Account w $($hsum.xoRcp.RecipientTypeDetails) is *DISABLED!*"
                            write-warning $smsg ;
                        } ; 
                    } ; 
                } ;
                # AADUser enabled/disabled: .aaduser.AccountEnabled
                if($hSum.MGUser){
                    # 2:31 PM 9/23/2025 fixed typo: .Enabled -> .AccountEnabled
                    if($hSum.MGUser.AccountEnabled){
                        if($hsum.xoRcp.RecipientTypeDetails -match 'SharedMailbox|RoomMailbox|EquipmentMailbox'){
                            $smsg = "ADUser:$($hSum.MGUser.userprincipalname) AD Account w $($hsum.xoRcp.RecipientTypeDetails) mbx is *ENABLED!*"
                            write-warning $smsg ;
                        } ;
                    } else {
                        if($hsum.xoRcp.RecipientTypeDetails -match 'SharedMailbox|RoomMailbox|EquipmentMailbox'){} else { 
                            $smsg = "ADUser:$($hSum.MGUser.userprincipalname) AD Account w $($hsum.xoRcp.RecipientTypeDetails) is *DISABLED!*"
                            write-warning $smsg ;
                        } ; 
                    } ; 
                } ;
                #endregion ENABLED_STATUS ; #*------^ END ENABLED_STATUS ^------
                #region LIC_GRP ; #*------v LIC_GRP v------
                if($hSum.ADUser){$hSum.LicenseGroup  +=  $hSum.ADUser.memberof |?{$_ -match $rgxOPLic }}
                elseif($hSum.xoMemberOf){$hSum.LicenseGroup  +=  $hSum.xoMemberOf.Name |?{$_ -match $rgxXLic}}

                #if(-not ($hSum.LicenseGroup) -AND ($hSum.MsolUser.licenses.AccountSkuId -contains "$($TORMeta.o365_TenantDom.tolower()):ENTERPRISEPACK")){$hSum.LicenseGroup  +=  '(direct-assigned E3)'} ;
                # $hSum.AADUser ; $aadu | Get-AzureADUserLicenseDetail  | select -exp SkuPartNumber
                #if(-not ($hSum.LicenseGroup) -AND ( $hsum.AADUserLics  -contains "$($TORMeta.o365_TenantDom.tolower()):ENTERPRISEPACK")){$hSum.LicenseGroup  +=  '(direct-assigned E3)'} ;
                # no dom, with aadu licenses
                if(-not ($hSum.LicenseGroup) -AND ( $hSum.MGUserLics  -contains "ENTERPRISEPACK")){$hSum.LicenseGroup  +=  '(direct-assigned E3)'} ;
                if($hSum.LicenseGroup){$smsg = "LicenseGroup:$($hSum.LicenseGroup)"}
                else{$smsg = "LicenseGroup:(unresolved, direct-assigned other?)" } ;
                write-host $smsg ;
                #endregion LIC_GRP ; #*------^ END LIC_GRP ^------
                #region OUTPUT_MGUserMgr ; #*------v OUTPUT_MGUserMgr v------
                if($hSum.MGUserMgr){
                    #($hSum.AADUserMgr) |ft -a  $propsaadmgr
                    #$smsg += "`nAADUserMgr:`n$(($hSum.AADUserMgr|select $propsAadMgr |out-markdowntable @MDtbl|out-string).trim())" ;
                    # $propsAADMgrL1, $propsAADMgrL2
                    write-host -foreground yellow "===`$hSum.MGUserMgr: " #-nonewline;
                    #$smsg = "$(($hSum.MGUserMgr| select $propsAADMgrL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                    $smsg = "$(($hSum.MGUserMgr| select $propsMGUMgrL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                    #$smsg += "`n$(($hSum.MGUserMgr|select $propsAADMgrL2 |out-markdowntable @MDtbl|out-string).trim())" ;
                    #$smsg += "`n$(($hSum.MGUserMgr|Format-List $propsAADMgrL2|out-string).trim())" ;
                    #$smsg += "`n$(($hSum.MGUserMgr|Format-List $propsMGUMgrL2|out-string).trim())" ;
                    # for mguser, and it's hash, have to change the syntax:
                    $smsg += "`n$(($hSum.MGUserMgr | select $propsMGUMgrL2|out-string).trim())"
                    #$smsg += "`n$(($hSum.MGUserMgr|select $propsADL3 |out-markdowntable @MDtbl|out-string).trim())" ;
                } else {
                    $smsg = "(AADUserMgr was blank, or unresolved)" ;
                } ;
                write-host $smsg ;
                #endregion OUTPUT_MGUserMgr ; #*------^ END OUTPUT_MGUserMgr ^------
                #region OUTPUT_QUOTA_N_SIZE ; #*------v OUTPUT_QUOTA_N_SIZE v------
                if($getQuotaUsage -AND $hSum.xoMailbox){

                    $smsg += "`n`nLicenses:`n$(($hSum.MGUserLics -join ', ' |out-string).trim())`n`n" ; 
                    $smsg += "`nwhich specify the following size limits:`n$(($hSum.xoEffectiveQuotas| fl |out-string).trim())`n(UseDatabaseQuotaDefaults:$($hSum.xoMailbox.UseDatabaseQuotaDefaults))" ; 
                    $smsg += "`n`nCurrent TotalMailboxSizeMB: $($hSum.xoMailboxStats.TotalMailboxSizeMB)`n`n" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success

                    if($hSum.xoNetOfSendReceiveQuotaMB -lt 0){
                        $smsg = "`n`n*** QuotaStatus: Mailbox is *OVER* mandated SendReceiveQuotaMB by $(($hSum.xoNetOfSendReceiveQuotaMB * -1).tostring("N")) megabytes ***`n`n" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                    } else { 
                        $smsg = "QuotaStatus: Mailbox is below mandated SendReceiveQuotaMB by $(($hSum.xoNetOfSendReceiveQuotaMB).tostring("N")) megabytes" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    } ;

                    if($DeletedItems){
                        $smsg = "`nWith the following non-zero folder metrics`n`n$((import-csv $ofMbxFolderStats  | ?{$_.ItemsInFolder -gt 0 -AND $_.identity -notmatch $rgxHiddn } |select $prpFldr | ft -auto |out-string).trim())" ; 
                        $smsg += "`n`nAnd the Following Deleted-Items-related folder metrics`n`n$((import-csv $ofMbxFolderStats | ?{$_.identity -match $rgxDelItmsShow } |select $prpFldrDeleted | ft -auto |out-string).trim())`n`n" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    }else{
                        $smsg = "`nWith the following non-zero folder metrics`n`n$((import-csv $ofMbxFolderStats | ft -auto |out-string).trim())" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    } ; 

                    $smsg = "`n===`output to:`n$($ofMbxFolderStats)`n" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    
                    # 10:08 AM 2/27/2024: Add: .xoMailboxFolderStats DiscoveryHolds folder only has ItemsInFolder -gt 0 if there's a hold
                    if($hSum.xoMailbox.LitigationHoldEnabled -OR $hSum.xoMailbox.InPlaceHolds -OR $hSum.xoMailbox.ComplianceTagHoldApplied -OR $hSum.xoMailbox.DelayHoldApplied -OR $hSum.xoMailbox.DelayReleaseHoldApplied -OR ($hSum.xoMailboxFolderStats | ?{$_.name -match 'DiscoveryHolds' -AND $_.ItemsInFolder -gt 0})  ){
                        $smsg = "`n`nEVIDENCE OF LEGAL HOLD DETECTED!:`n$(($hSum.xoMailbox | fl $prpMbxHold|out-string).trim())`n`n" ; 
                        if($hSum.xoMailboxFolderStats | ?{$_.name -match 'DiscoveryHolds' -AND $_.ItemsInFolder -gt 0}){
                            $smsg += "`n$(($hSum.xoMailboxFolderStats | ?{$_.name -match '^DiscoveryHolds$'} | ft -a $prpFldrLH|out-string).trim())`n`n" ; 
                            $smsg += "`n- DiscoveryHolds folder: If In-Place Hold is enabled or if a Microsoft 365 or Office 365 retention policy is assigned to the mailbox, this subfolder contains all items that meet the hold query parameters and are hard deleted." ; 
                            $smsg += "`n- DiscoveryHolds folder.NewestItem: Will reflect *last time LegalHold captured an item* (e.g. if/when LH was disabled and stopped holding traffic, if in the past)`n"; 
                        } 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                    } else {
                        $smsg = "`n`n*No* evidence Of Legal Hold detected:`n$(($hSum.xoMailbox | fl $prpMbxHold|out-string).trim())`n`n" ; 
                        $smsg = "`n$(($hSum.xoMailboxFolderStats | ?{$_.name -match 'DiscoveryHolds'} | ft -a $prpFldrLH|out-string).trim())`n`n" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success

                    } ;  

                    

                    $hsInfo = @"

## System Folder Types and purposes:

- Recoverable Items: Items in the Recoverable Items folder aren't calculated toward the user's mailbox quota. In Exchange Online, the Recoverable Items folder has its own quota. In Exchange Online, the quota for the Recoverable Items folder (in the user's primary mailbox) is automatically increased to 100 GB when a mailbox is placed on Litigation Hold or In-Place Hold. 

    ### Subfolders of Recoverable Items:
    
    *  Deletions: This subfolder contains all items deleted from the Deleted Items folder. (In Outlook, a user can soft delete an item by pressing Shift+Delete.) This subfolder is available to users through the Recover Deleted Items feature in Outlook and Outlook on the web.
    
    *  Versions: If In-Place Hold, Litigation Hold, or a Microsoft 365 or Office 365 retention policy is enabled, this subfolder contains the original copy of the item and also if the item is modified multiple times, a copy of the item before modification is saved.
    
    *  Purges: If either Litigation Hold or single item recovery is enabled, this subfolder contains all items that are hard deleted. 
    
    *  Audits: If mailbox audit logging is enabled for a mailbox, this subfolder contains the audit log entries. 
    
    *  DiscoveryHolds: If In-Place Hold is enabled or if a Microsoft 365 or Office 365 retention policy is assigned to the mailbox, this subfolder contains all items that meet the hold query parameters and are hard deleted.

## Deleted item retention
  An item is considered to be soft deleted in the following cases:
    • A user deletes an item or empties all items from the Deleted Items folder.
    • A user presses Shift+Delete to delete an item from any other mailbox folder.
    
  Soft-deleted items are moved to the Deletions subfolder of the Recoverable Items folder. This provides an additional layer of protection so users can recover deleted items without requiring Help desk intervention. Users can use the Recover Deleted Items feature in Outlook or Outlook on the web to recover a deleted item. Users can also use this feature to permanently delete an item. 
  
  Items remain in the Deletions subfolder until the deleted item retention period is reached. The deleted item retention period for Exchange Online is 30 days (Toroco). In addition to a deleted item retention period, the Recoverable Items folder is also subject to quotas. 
  
  When the deleted item retention period expires, the item is completely removed from Exchange Online.

"@ ; 
                    write-host $hsInfo ;   
                    if($hSum.xoMailbox.recipienttypedetails -eq 'SharedMailbox'){
                        $hsInfoSharedMbx = @"

## Shared Mailbox Outlook Handling of Deleted Items & Sent Items. 

*Please note*: The subject mailbox is a _SharedMailbox_-type, which will 
trigger a _Delegate's Outlook client_ to perform special handling of the 
following actions by the Delegate: 

### Deleted Items: 

> When [a Delegated user uses] Microsoft Outlook to delete items from a mailbox folder of another 
> user for whom [the Delegate has] deletion privileges, the deleted items go to *[the Delegate's] own 
> Deleted Items folder* instead of the Deleted Items folder of the mailbox owner. 

Ref: [Items that are deleted from a shared mailbox go to the wrong folder in Outlook - Outlook | Microsoft Learn]
(https://learn.microsoft.com/en-us/troubleshoot/outlook/email-management/deleted-items-go-to-wrong-folder)

The Outlook behavior is controlled through configuring _the Delegate's Legacy Outlook client)_ 
with a custom Registry Key (with Service Desk assistance), that manages the 
Delegate's preference for storage of third-party Sent Items, sent from their Legacy Outlook client.  

The details of workstation registry modification process are covered in the Service Desk kb, and documented by Microsoft at:

[Switch the destination of deleted items - Outlook | Microsoft Learn]
(https://learn.microsoft.com/en-us/troubleshoot/outlook/email-management/deleted-items-go-to-wrong-folder#switch-the-destination-of-deleted-items)

The article above details configuration of the following custom registry key on the 
Delegate's Legacy Outlook workstation: 

    Note: As of October of 2025, Microsoft has not yet delivered an equivelent configurable setting for New Outlook,
    Legacy Outlook is *required* for configuration of Delegate preferences for Outlook mail handling actions.

    HKEY_CURRENT_USER\Software\Microsoft\Office\<x.0>\Outlook\Options\General

    Note: The <x.0> placeholder represents your version of Office (16.0 = Office 2016, Office 2019, Office LTSC 2021, or Microsoft 365, 15.0 = Office 2013).

    DelegateWastebasketStyle, DWORD Value:

    8 = Stores deleted items in [the Delegate's] folder.
    4 = Stores deleted items in the mailbox owner (e.g. the Shared Mailbox) folder 

    Note: Unlike Sent Items behavior (covered below), there is *no* administrator
    configurable setting available, to implement the configuration above 
    directly on a Shared Mailbox.    

### Sent Mail from the Shared Mailbox address:

> [When] using Microsoft Outlook 2016 or a later version, and a user has been delegated 
> permission to send email messages as another user or on behalf of another user from a shared mailbox. 
> ... when [they] send a message as another user or on behalf of the user, the 
> sent message isn't saved to the Sent Items folder of  the shared mailbox. 
> *Instead, _it's saved to the Sent Items folder of [the Delegate's] mailbox*. 

Ref: [Messages sent from a shared mailbox aren't saved to the Sent Items folder - Exchange | Microsoft Learn]
(https://learn.microsoft.com/en-us/troubleshoot/exchange/user-and-shared-mailboxes/sent-mail-is-not-saved?source=recommendations)

The Outlook behavior is controlled through one of two ways:

1. The Delegate's workstation Legacy Outlook client, can be configured 
(with Service Desk assistance), to store 3rd party Sent Items, 
_to the 3rd party mailbox_ by setting the DelegateSentItemsStyle registry key.  

    The details of this process are covered in the Service Desk kb, and documented by Microsoft at:

    [Messages sent from a shared mailbox aren't saved to the Sent Items folder - Exchange | Microsoft Learn]
    (https://learn.microsoft.com/en-us/troubleshoot/exchange/user-and-shared-mailboxes/sent-mail-is-not-saved?source=recommendations)

    The article above details configuration of the following custom registry key on the 
    Delegate's Legacy Outlook workstation: 

        HKEY_CURRENT_USER\Software\Microsoft\Office\16.0\Outlook\Preferences

        DelegateSentItemsStyle,  DWORD 32-bit Value.

    DelegateSentItemsStyle | MessageCopyForSentAsEnabled | Expected behavior
    ---------------------- | --------------------------- | -------------------------------------------------------------------------------------------------
    0                      | True                        | A copy of the email will be saved in 
                           |                             | both the primary mailbox and the 
                           |                             | shared mailbox.
    1                      | True                        | Two copies of the email will be saved
                           |                             | in the shared mailbox and no copies 
                           |                             | in the primary mailbox.
    0                      | False                       | A copy of the email will be saved in 
                           |                             | the primary mailbox and no copies 
                           |                             | in the shared mailbox.
    1                      | False                       | A copy of the email will be saved in 
                           |                             | the shared mailbox and no copies 
                           |                             | in the primary mailbox.

2. Or, the Shared mailbox can be configured by an administrator to save 
messages to the Sharted mailbox through a powershell modification on the Shared 
Mailbox itself : 

 - For emails sent as the shared mailbox, run the following command in Exchange PowerShell:

        set-mailbox <mailbox name> -MessageCopyForSentAsEnabled `$True

 - For emails sent on behalf of the shared mailbox, run the following command in Exchange PowerShell:

        set-mailbox <mailbox name> -MessageCopyForSendOnBehalfEnabled `$True

"@ ; 
                        write-host  $hsInfoSharedMbx ; 
                    } ; 

                } ; 
                #endregion OUTPUT_QUOTA_N_SIZE ; #*------^ END OUTPUT_QUOTA_N_SIZE ^------
                #region OUTPUT_PERMS ; #*------v OUTPUT_PERMS v------
                if($getPerms -AND $hSum.xoMailbox){

                    if($hSum.xoMailboxPermission){
                        $smsg = "`n## xoMailboxPermission:`n$(($hsum.xoMailboxPermission | ft -a $prpMPerms |out-string).trim())`n" ; 
                        if($hSum.xoMailboxPermissionGroups){
                            $smsg += "`n### Expanded Perm Group Summaries:" ; 
                            foreach($grp in $hSum.xoMailboxPermissionGroups){
                                $smsg += "`n-----------" ; 
                                $smsg += "`n$(($grp |select $propsDG[0..1] |out-markdowntable @MDtbl|out-string).trim())" ;
                                $smsg += "`n$(($grp |select $propsDG[3..6] |out-markdowntable @MDtbl|out-string).trim())" ;
                                $smsg += "`n$(($grp |select $propsDG[2] |fl |out-string).trim())" ;
                                $smsg += "`n#### Members:`n$(($grp.members | ft -a $propsRcpTbl|out-string).trim())`n`n" ;
                            } ; 
                        } ; 
                    } ; 
                    if($hSum.xoRecipientPermission){
                        $smsg += "`n## xoRecipientPermission:`n$(($hsum.xoRecipientPermission | ft -a $prpRPerms |out-string).trim())`n`n" ; 
                        if($hSum.xoRecipientPermissionGroups){
                            $smsg += "`n### Expanded Perm Group Summaries:" ; 
                            foreach($grp in $hSum.xoRecipientPermissionGroups){
                                $smsg += "`n-----------" ; 
                                $smsg += "`n$(($grp |select $propsDG[0..1] |out-markdowntable @MDtbl|out-string).trim())" ;
                                $smsg += "`n$(($grp |select $propsDG[3..6] |out-markdow ntable @MDtbl|out-string).trim())" ;
                                $smsg += "`n$(($grp |select $propsDG[2] |fl |out-string).trim())" ;
                                $smsg += "`n#### Members:`n$(($grp.members | ft -a $propsRcpTbl|out-string).trim())`n`n" ;
                            } ; 
                        } ; 
                    } ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                } ;
                #endregion OUTPUT_PERMS ; #*------^ END OUTPUT_PERMS ^------
                #region OUTPUT_MOBILE ; #*------v OUTPUT_MOBILE v------
                if($getMobile){
                    write-host -foreground yellow "===`$hsum.xoMobileDeviceStats: " #-nonewline;

                    $ino = 0 ;
                    if($hsum.xoMobileDeviceStats){
                        foreach($xmob in $hsum.xoMobileDeviceStats){
                            $ino++ ;
                            if($hsum.xoMobileDeviceStats -is [system.array]){
                                    write-host -foreground yellow "=get-xMob$($ino):(ACTIVE)> " #-nonewline;
                            } else {
                                write-host -foreground yellow "=get-xMobileDev:(ACTIVE)> " #-nonewline;
                            } ;
                            $smsg = "$(($xmob | select $propsMobL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                            $smsg += "`n$(($xmob | select $propsMobL2 |out-markdowntable @MDtbl |out-string).trim())" ;
                            write-host $smsg ;
                        } ;
                    } ; 
                    if($hsum.xoMobileDeviceStatsOLD){
                        #$smsg = "INACTIVE:(LastSyncAttemptTime -GT $($xoMobileDeviceOLDThreshold)d)" ; 
                        #write-host -foregroundcolor gray $smsg ;
                        foreach($xmob in $hsum.xoMobileDeviceStatsOLD){
                            $ino++ ;
                            if($hsum.xoMobileDeviceStatsOLD -is [system.array]){
                                    write-host -foreground yellow "=get-xMob$($ino):(inactive)> " #-nonewline;
                            } else {
                                write-host -foreground yellow "=get-xMobileDev:(inactive)> " #-nonewline;
                            } ;
                            $smsg = "$(($xmob | select $propsMobL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                            $smsg += "`n$(($xmob | select $propsMobL2 |out-markdowntable @MDtbl |out-string).trim())" ;
                            write-host -foregroundcolor gray $smsg ;
                        } ;
                    } ; 
                    if($hsum.xoMobileOutlookClients){                        
                        $smsg = "+++Supported Outlook Mobile Clients: $($($hsum.xoMobileOutlookClients|measure).count)" ; 
                        <#
                        foreach($xmob in $hsum.xoMobileOutlookClients){
                            $ino++ ;
                            if($hsum.xoMobileDeviceStats -is [system.array]){
                                    write-host -foreground yellow "=get-xMob$($ino):> " #-nonewline;
                            } else {
                                write-host -foreground yellow "=get-xMobileDev:> " #-nonewline;
                            } ;
                            $smsg = "$(($xmob | select $propsMobL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                            $smsg += "`n$(($xmob | select $propsMobL2 |out-markdowntable @MDtbl |out-string).trim())" ;
                            write-host $smsg ;
                        } ;
                        #>
                        $smsg += "`n$(($hsum.xoMobileOutlookClients| ?{$_.ClientType -eq 'EAS'} | ft -a $prpEASDevs|out-string).trim())" ; 
                        if($hsum.xoMobileOMSyncTypes){
                            $smsg += "`n-----`$hsum.xoMobileOMSyncTypes: $($hsum.xoMobileOMSyncTypes)" ; 
                            #write-host -foregroundcolor green $smsg ;
                            if($hsum.xoMobileOMSyncTypes -match 'REST'){
                                $smsg += "`n+User has one or more *legacy* 'REST' Outlook Mobile clients" ;
                            }elseif($hsum.xoMobileOMSyncTypes -match 'Outlook'){
                                $smsg += "`n++User has has one or more fully compliant 'MS Native Sync'-protocol Outlook Mobile clients" ;
                            } ;
                        } ; 
                        write-host -foregroundcolor green $smsg ;
                    }else{
                        write-verbose "(no Outlook Mobile clients returned)" ; 
                    } ; 
                    if($hsum.xoMobileOtherClients){
                        $smsg = "---NON-Outlook Mobile Clients:(device-vendor-supported): $($($hsum.xoMobileOtherClients|measure).count)" ; 
                        <#
                        foreach($xmob in $hsum.xoMobileOtherClients){
                            $ino++ ;
                            if($hsum.xoMobileDeviceStats -is [system.array]){
                                    write-host -foreground yellow "=get-xMob$($ino):> " #-nonewline;
                            } else {
                                write-host -foreground yellow "=get-xMobileDev:> " #-nonewline;
                            } ;
                            $smsg = "$(($xmob | select $propsMobL1 |out-markdowntable @MDtbl |out-string).trim())" ;
                            $smsg += "`n$(($xmob | select $propsMobL2 |out-markdowntable @MDtbl |out-string).trim())" ;
                            write-host $smsg ;
                        } ;
                        #>
                        $smsg += "`n$(($hsum.xoMobileOtherClients| ft -a $prpEASDevs|out-string).trim())" ;                         
                        write-host -foregroundcolor RED $smsg ;
                        if($hsum.xoMobileOMSyncTypes){
                            $smsg += "`n-----`$hsum.xoMobileOtherSyncTypes: $($hsum.xoMobileOtherSyncTypes)" ;
                            write-host -foregroundcolor yellow $smsg ;
                        }
                        if($hsum.xoMobileOtherClients| ?{$_.ClientType -eq 'EAS'}){ ;
                            $smsg = "`nThe following devices use device-vendor-provided/supported 'ExchangeActiveSync/EAS' Mobile clients!" ;
                            $smsg += "`nPLEASE NOTE: By policy EAS clients are *Best Effort* supported:"
                            $smsg += "`nWhere issues are experienced with legacy EAS/ActiveSync clients," ;
                            $smsg += "`nUsers should be urged to move to _Supported_ Microsoft Outlook Mobile for IOS or Android" ;
                            #$prpEASDevs = 'DeviceFriendlyName','ClientType','LastSyncAttemptTime','LastSuccessSync' ; 
                            $smsg += "`n$(($hsum.xoMobileOtherClients| ?{$_.ClientType -eq 'EAS'} | ft -a $prpEASDevs|out-string).trim())" ; 
                            write-host -foregroundcolor yellow $smsg ;
                        }
                    }else{
                        write-verbose "(no 'non'-Outlook Mobile clients returned)" ; 
                    } ; 

                } ;
                #endregion OUTPUT_MOBILE ; #*------^ END OUTPUT_MOBILE ^------
            } ;
            #endregion RV_VIA_GMGU ; #*------^ END RV_VIA_GMGU ^------
            
            # switch ($hSum.OPRcp.recipienttypedetails){
            <#
            AD - Users (more effective)
            (sAMAccountType=805306368)
            AD - Users - disabled
            (&(sAMAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=2))
            AD - Users - dont require password
            (&(sAMAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=32))
            AD - Users - mail enabled
            (&(sAMAccountType=805306368)(mailNickname=*))
            AD - Users - password never expires
            (&(sAMAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=65536))

            Select ($hSum.ADUser.sAMAccountType){
                '0'  { $SAType = "SAM_DOMAIN_OBJECT"}
                '268435456' { $SAType = "SAM_GROUP_OBJECT"}
                '268435457' { $SAType = "SAM_NON_SECURITY_GROUP_OBJECT"}
                '536870912' { $SAType = "SAM_ALIAS_OBJECT"}
                '536870913' { $SAType = "SAM_NON_SECURITY_ALIAS_OBJECT"}
                '805306368' { $SAType = "SAM_NORMAL_USER_ACCOUNT"}
                '805306369' { $SAType = "SAM_MACHINE_ACCOUNT"}
                '805306370' { $SAType = "SAM_TRUST_ACCOUNT"}
                '1073741824' { $SAType = "SAM_APP_BASIC_GROUP"}
                '1073741825' { $SAType = "SAM_APP_QUERY_GROUP"}
                '2147483647' { $SAType = "SAM_ACCOUNT_TYPE_MAX"}
                default { $SAType = "UNKNOWN" }
            } ;
            #>
            # ($hSum.ADUser.sAMAccountType -eq '805306368')
            #region OUTPUT_ACCT_DISABLED ; #*------v OUTPUT_ACCT_DISABLED v------
            if($hsum.ADUser){
                $hsum.IsADDisabled  +=  [boolean]($hsum.ADUser.Enabled -eq $true) ; 
             } else {
                write-verbose "(no ADUser found)" ;
            } ;
            if($hSum.MGUser){
                $hsum.IsMGDisabled  +=  [boolean]($hSum.MGUser.AccountEnabled -eq $true) ; 
                $hsum.isDirSynced  +=  [boolean]($hSum.MGUser.OnPremisesSyncEnabled  -eq $True)
            } else {
                write-verbose "(no AADUser found)" ;
            } ;
            # shift test to aadu
            if($hSum.MGUser){
                $hsum.IsLicensed  +=  [boolean]($hSum.MGUser.assignedlicenses.count -gt 0)
            } else {
                write-verbose "(no AADUser found)" ;
            } ;
            #endregion OUTPUT_ACCT_DISABLED ; #*------^ END OUTPUT_ACCT_DISABLED ^------

            #region ISSUE_DETECT ; #*------v ISSUE_DETECT v------

            #region SPLITBRAIN_NOBRAIN ; #*------v SPLITBRAIN_NOBRAIN v------
            # do a split-brain/nobrain check
            $smsg = "`n"
            if(($hsum.xoRcp.RecipientTypeDetails -match '(UserMailbox|MailUser)') -AND $hsum.IsLicensed -AND $hSum.xomailbox -AND $hSum.OPMailbox){
                #OPRcp, xorcp, OPMailbox, OPRemoteMailbox, xoMailbox
                $smsg += "SPLITBRAIN!:$($hSum.ADUser.userprincipalname).IsLic'd & has *BOTH* xoMbx & opMbx!" ;
                $hsum.IsSplitBrain  +=  $true ;
            }elseif(($hsum.xoRcp.RecipientTypeDetails -match '(UserMailbox|MailUser)') -AND -not($hsum.IsLicensed) -AND $hSum.xomailbox -AND $hSum.OPMailbox){
                #OPRcp, xorcp, OPMailbox, OPRemoteMailbox, xoMailbox#
                $smsg += "SPLITBRAIN!:$($hSum.ADUser.userprincipalname).IsLic'd & has *BOTH* xoMbx & opMbx!`nAND is *UNLICENSED!*" ;
                $hsum.IsSplitBrain  +=  $true ;
            } elseif(($hsum.xoRcp.RecipientTypeDetails -match '(UserMailbox|MailUser)') -AND $hsum.IsLicensed -AND -not($hSum.xomailbox) -AND -not($hSum.OPMailbox)){
                $smsg += "NOBRAIN! W LICENSE!:$($hSum.ADUser.userprincipalname).IsLic'd &  has *NEITHER* xoMbx OR opMbx!" ;
                $hsum.IsNoBrain  +=  $true ;
            } elseif (($hsum.xoRcp.RecipientTypeDetails -match '(UserMailbox|MailUser)') -AND -not($hsum.IsLicensed) -AND -not($hSum.xomailbox) -AND -not($hSum.OPMailbox)){
                $smsg += "NOBRAIN! *WO* LICENSE! (TERM?):$($hSum.ADUser.userprincipalname) NOT licensed'd &  has *NEITHER* xoMbx OR opMbx!" ;
                $hsum.IsNoBrain  +=  $true ;
            } elseif($hsum.IsLicensed -eq $false){
                # 12:37 PM 12/26/2024 ACCOMOD UNlic'd non-user mbxs (normal)
                if($hsum.xoRcp.RecipientTypeDetails -match 'SharedMailbox|RoomMailbox|EquipmentMailbox'){
                    $smsg += "$($hSum.ADUser.userprincipalname) Is RecipientTypeDetails:$($hsum.xoRcp.RecipientTypeDetails) _expected unlicensed_" ;
                } ELSE { 
                    $smsg += "$($hSum.ADUser.userprincipalname) Is *UNLICENSED*!" ;
                } ; 
                $hsum.IsLicensed  +=  $false ;
            } elseif($hsum | ?{-not $_.ADUser -AND $_.AADUser -AND $_.xomailbox -AND -not $_.opMailbox -AND -not $_.opRemoteMailbox}){
                # 3:54 PM 10/16/2024 add cloud-first VEN|INT|AA|HH detect
                $smsg += "LICENSED AADUSER CLOUD-FIRST XOMAILBOX  (No ADUser, No OPMailbox, No OPRemoteMailbox)~" ; 
            } ELSE { } ;

            # conditional w-w, w-h block on status
            #if($hsum.IsSplitBrain -OR $hsum.IsNoBrain -OR (-not $hsum.IsLicensed -AND $hsum.xoRcp.RecipientTypeDetails -NOTmatch 'SharedMailbox|RoomMailbox|EquipmentMailbox') ){
            [boolean[]]$testArray = @(
                $hsum.IsSplitBrain, 
                $hsum.IsNoBrain, 
                (-not $hsum.IsLicensed -AND $hsum.xoRcp.RecipientTypeDetails -NOTmatch 'SharedMailbox|RoomMailbox|EquipmentMailbox')
            ) ; 
            #write-verbose "Test: All `$true" ; 
            #if(($testArray | Where-Object {$_ -eq $true}).Count -eq $testArray.Count){
            #write-verbose "Test: Count `$true meets threshold" ; 
            #$tTrues = $testArray.count -3 ; # test is 3 less than total elem count
            #if(($testArray | Where-Object {$_ -eq $true}).Count -ge $tTrues){write-host "test:$($tTrues)/$($testArray.count) `$true: PASS" } ; 
            write-verbose "Test: Any `$true above" ; 
            # the $smsg is populated further up, this is just the output format on the $smsg text
            if($testArray -contains $true){
                # w-w
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            } else { 
                # w-h
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            } ;  
            #endregion SPLITBRAIN_NOBRAIN ; #*------^ END SPLITBRAIN_NOBRAIN ^------

            #region NOBRAIN_DETAILS ; #*------v NOBRAIN_DETAILS v------
            if($hsum.IsNoBrain){
                switch ($hSum.Federator) {
                    $TORMeta.adforestname {$rgxTermOU = $TORMeta.rgxTermUserOUs }
                    $CMWMeta.adforestname  {$rgxTermOU = $CMWMeta.rgxTermUserOUs }
                    $VENMETA.o365_TenantLabel  {$rgxTermOU = $NULL }
                    $TORMeta.o365_TenantDom   {$rgxTermOU = $NULL }
                    default {
                        write-warning "UNRECOGNIZED `$hsum.FEDERATOR!:$($hSum.Federator)" ;
                    }
                }

                if($rgxTermOU -AND $hsum.ADUser){
                    if($hsum.ADUser.distinguishedname -match $rgxTermOU){
                        $hsum.IsDisabledOU  +=  $true ;
                        $smsg += "`n--ADUser:$($hsum.ADUser.samaccountname) is within a *DISABLED* OU (likely TERM)" ;
                    } else {
                        $hsum.IsDisabledOU  +=  $false ;
                        $smsg += "`n--ADUser:$($hsum.ADUser.samaccountname) is *NOT* in a DISABLED OU (improperly offboarded TERM?)" ;
                    } ;
                } else {
                    $smsg +=  "`n--Cloud-only or other non-AD-resolvable host" ;
                }
                if($hsum.ADUser){
                    $smsg += "`n----$($hsum.ADUser.distinguishedname)" ;
                    $smsg += "`n--ADUser.Description:$($hsum.ADUser.Description)" ;
                    if($hsum.ADUser.Info){
                        $smsg += "`n--ADUser.Info:$($hsum.ADUser.Info)" ;
                    }
                    if($hsum.IsADDisabled){
                        $smsg += "`n--ADUser:$($hsum.ADUser.samaccountname) is *DISABLED* for logon (likely TERM)" ;
                    } else {
                        $smsg += "`n--ADUser:$($hsum.ADUser.samaccountname) is *UN-DISABLED* for logon (improperly offboarded TERM?)" ;
                    } ;
                } else {
                    write-verbose "(no ADUser found)" ;
                } ;
                if($hsum.IsMGDisabled){
                    $smsg += "`n--AADUser:$($hSum.MGUser.UserPrincipalName) is *DISABLED* for logon (likely TERM)" ;
                } else {
                    $smsg += "`n--AADUser:$($hSum.MGUser.UserPrincipalName) is *UN-DISABLED* for logon (improperly offboarded TERM?)" ;
                } ;
                $smsg += "`n"
                write-warning $smsg ;
            } ;
            #endregion NOBRAIN_DETAILS ; #*------^ END NOBRAIN_DETAILS ^------

            #region RMBX_BLOCKED_XOMBX ; #*------v RMBX_BLOCKED_XOMBX v------
            # 2:34 PM 1/9/2025 test for 886258, blocked license-xoMailbox mount issue
            [boolean[]]$testArray = @(
                ($hsum.oprcp.recipienttypedetails -eq 'RemoteUserMailbox'),
                ($hsum.xorcp.recipienttypedetails -eq 'Mailuser'),
                (-not $hsum.xoMailbox),
                $hSum.MGUser,
                $hsum.ADUser,
                $hsum.isDirSynced,
                ($hsum.IsNoBrain -eq 1),
                (-not $hsum.IsLicensed),
                $hsum.opRemoteMailbox.exchangeguid,
                $hsum.opRemoteMailbox.remoteroutingaddress    
            ) ;  
            # test variants: eval patterns of $true/$false
            #write-verbose "Test: Count `$true meets threshold" ;
            #$nTrues = $testArray.count -3 ; # test is 3 less than total elem count
            #if(($testArray | Where-Object {$_ -eq $true}).Count -ge $nTrues){write-verbose "test:$($nTrues)/$($testArray.count) `$true: PASS" } ;
            #write-verbose "Test: Any `$true above" ;
            #if($testArray -contains $true){ # -OR clause
            write-verbose "Test: All `$true" ; # -AND clause
            if(($testArray | Where-Object {$_ -eq $true}).Count -eq $testArray.Count){
                $hsAlertMsg = @"
User has:
- OPRmbx and no XoMailbox!
- Dirsynced AADUser & ADUser
- Detects as NoBrain (neither OP or xo Mailbox)
- is not Licensed
- And Rmbx has populated ExchangeGuid & RemoteRoutingAddress
(against Mailbox that doesn't currently *exist*
with email address that also doesn't currently *exist)
If this matches Incident # 886258:
- if Licensed, the xoMailbox will never mount
    sits 18h+ in status: `"We are preparing a mailbox for the user.`"
- Fix: in that condition is to:
    1. *Remove* the OpRemoteMailbox
    2. Permit ADC replication to replicate, and wait for xoMailbox to mount
    3. Create a new matched OpRmbx with the RemoteMountingAddress and xoMailbox.ExchangeGuid, copied to the OpRmbx.Exchangeguid
    4. Verify if any CA5 setting is missing/required to properly steer primarysmtpaddress
## Detailed status:
### get-RemoteMailbox:
$(($hsum.opRemoteMailbox | fl 'Name','RecipientTypeDetails','RemoteRecipientType','exchangeguid','PrimarySmtpAddress','RemoteRoutingAddress' | fl |out-string).trim())
### Cloud: get-xoRecipient:
$(($hsum.xorcp | fl 'RecipientType','RecipientTypeDetails','PrimarySmtpAddress','Alias' |out-string).trim())
- SMTP EmailAddresses:
$(($hsum.xorcp | select -expand emailaddresses | ?{$_ -match 'smtp:'} | sort |out-string).trim())
### DirSync-settings:
opRemoteMailbox.exchangeguid.guid:`t$($hsum.opRemoteMailbox.exchangeguid.guid)
opRemoteMailbox.RemoteRoutingAddress:`t$($hsum.opRemoteMailbox.RemoteRoutingAddress.guid)
"@ ;        
                $smsg = $hsAlertMsg ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;  
            }
            #endregion RMBX_BLOCKED_XOMBX ; #*------^ END RMBX_BLOCKED_XOMBX ^------
            #endregion ISSUE_DETECT ; #*------^ END ISSUE_DETECT ^------

            #region WRITE_OUTPUT ; #*------v WRITE_OUTPUT v------
            # 4:11 PM 12/11/2025 with move to MG module for user access, I've wound up with massive export .xml files, that were fine pulling from azuread
            <# even running simple export depth tesets, shows broken xml: 
                $xmlString = $Rpt | ConvertTo-Xml -Depth $dpth -NoTypeInformation ; 
                ConvertTo-Xml : Unexpected end of file has occurred. The following elements are not closed: Property, Property, Object, Objects. Line 10, position 47281.
                At line:1 char:21

                A recommendation is to simplify the object
                - for MGUser, force select just the targete props (again)
                $rpt.mguser = $rpt.mguser | select $prpMGUser
                - for the MGUserMgr hashtable/dict, convert it to pscustomobject
                $rpt.MGUserMgr = [pscustomobject]$rpt.MGUserMgr ;
            #>
            write-verbose "MGUser massive xml export impact: pre strip the objects";
            $hSum.mguser = $hSum.mguser | select $prpMGUser
            $hSum.MGUserMgr = [pscustomobject]$hSum.MGUserMgr
            write-verbose 'Test here'
            if($outObject){
                if($PSCmdlet.MyInvocation.ExpectingInput){
                    write-verbose "(pipeline input, skipping aggregator, dropping into pipeline)" ;
                    New-Object PSObject -Property $hSum | write-output  ;
                } else {
                    $Rpt += New-Object PSObject -Property $hSum ;
                } ;
            } ELSE {
                # 3:59 PM 9/18/2023 else export to report file 
                <#
                $Rpt += New-Object PSObject -Property $hSum ;
                #$Rpt | export-clixml -Path $ofile -Depth 100 ;
                write-verbose "exporting to $($logfile.replace('LOG-BATCH-EXEC',"REPORT").replace('-log',''))"
                $Rpt | export-clixml -Path $logfile.replace('LOG-BATCH-EXEC',"REPORT").replace('-log','') -Depth 100 ;
                #>
                $Rpt += New-Object PSObject -Property $hSum ;
                if($useJson){                    
                    TRY{
                        $ofile = $logfile.replace('LOG-BATCH-EXEC',"REPORT").replace('-log','').replace('.txt','.json')
                        $smsg = "exporting to:`n$($ofile)" ; 
                        $smsg += "-useJson: exporting in .json format " ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        $Rpt | ConvertTo-Json -depth $Depth -ea STOP | 
                            Out-String | Out-File -Encoding utf8 -LiteralPath $ofile -ErrorAction STOP -verbose ; 
                        <# generating:
                            ConvertFrom-Json : Cannot convert the JSON string because a dictionary that was converted from the string contains the duplicated keys 'value' and 'Value'.

                            ...occurs because PowerShell objects and hashtables are **case-insensitive** for property names, while the JSON standard allows keys to be case-sensitive. 
                            The best solutions involve modifying the JSON string _before_ conversion or using an alternative parsing method. 
                        #>
                        # so try 2-staging it, and sub 'value' -> 'Value'?

                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        write-host -foregroundcolor gray "TargetCatch:} CATCH [$($ErrTrapd.Exception.GetType().FullName)] {"  ;
                        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                        write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                     } ;
                    
                }else{
                    $ofile = $logfile.replace('LOG-BATCH-EXEC',"REPORT").replace('-log','').replace('.txt','.xml')
                    $smsg = "exporting to:`n$($ofile)" ;
                    write-host $smsg ; 
                    TRY{
                        # try to pre-detect issues in the source Microsoft.Graph data, by preconverting to xml
                        $xmlString = $Rpt | ConvertTo-Xml -Depth $Depth -NoTypeInformation -ea STOP;
                        write-verbose "`$xmlString.length: $(($xmlString.length|out-string).trim())" ;
                        $xmlString = $NULL ; 
                        #$Rpt | export-clixml -Path $ofile -Depth 100 ;
                        write-verbose "exporting to $($ofile)"
                        $Rpt | export-clixml -Path $ofile -Depth $Depth -ea STOP -verbose ;
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "XML conversion issue: failed attempt:`$Rpt | ConvertTo-Xml -Depth 1" ;
                        $smsg += "`nABORTING XML OUTPUT (STATUS RESULTS IN SEMI-HUNG EXPORTS & MULTI-GB XML FILES!)" ;
                        $smsg += "`nPossibly rerun with -outobject; capture return, and attempt to manually convert/export/workwith wo export" ;
                        $smsg += "`nOr try use of -useJson, and play with the -Depth parameter to tune minimum functional export depth" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        if($ErrTrapd){
                            write-host -foregroundcolor gray "TargetCatch:} CATCH [$($ErrTrapd.Exception.GetType().FullName)] {"  ;
                            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                            write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)"    
                        } ; 
                    } ;
                }
            } ;
            #endregion WRITE_OUTPUT ; #*------^ END WRITE_OUTPUT ^------
            # 10:34 AM 12/22/2025 missing per-user log stop
            $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
            if($stopResults){
                $smsg = "Stop-transcript:$($stopResults)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
                        
            write-host -foregroundcolor green $sBnr.replace('=v','=^').replace('v=','^=') ;

        } ; # loop-E $users
        #endregion PIPELINE_PROCESSINGLOOP ; #*------^ END PIPELINE_PROCESSINGLOOP ^------

    } # PROC-E
    END{
        <## cleanup XO aliases
        get-alias -scope Script |?{$_.name -match '^ps1.*'} | %{Remove-Alias -alias $_.name} ; 
        #>
        if($abortReport){
            $smsg = "(multiple recipients found in OnPrem And/Or Cloud, detailed reporting & output aborted)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        }else{
            if($outObject -AND -not ($PSCmdlet.MyInvocation.ExpectingInput)){
                $Rpt | write-output ;
                write-host "(-outObject: Output summary object to pipeline)"
            }elseif($outObject -AND ($PSCmdlet.MyInvocation.ExpectingInput)){
                write-verbose "(pipeline input, individual objects dropped into pipeline)" ;
            } else {
                $oput = ($Rpt | select-object -unique) -join ',' ;
                $oput | out-clipboard ;
                write-host "(output copied to clipboard)"
                $oput |  write-output ;
            } ;
        } ;  # if-E

     } ;
 }

#*------^ resolve-user.ps1 ^------


#*------v resolve-xoRcps.ps1 v------
function Resolve-xoRcps {
    <#
    .SYNOPSIS
    Resolve-xoRcps.ps1 - run a get-exorecipient to re-resolve an array of Recipients into the matching primarysmtpaddress
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-09-02
    FileName    : Resolve-xoRcps
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite:	URL
    AddedTwitter:	URL
    REVISIONS
    *3:20 PM 12/30/2021 expanded, added params: getGroups, getRecipients, getMailboxPrincipals, PreviewThreshold, UpdateInterval, returnObject;
        expanded verbose echos and reporting, the above -get* params shift the complicated regexes internally, where one of the three types is desired. 
    * 9:16 AM 12/3/2021 added pswlt support
    * 8/30/21 init vers
    .DESCRIPTION
    Resolve-xoRcps.ps1 - run a get-exorecipient to re-resolve an array of Recipients into the matching primarysmtpaddress
    
    Backing out the RecipientTypeDetails combos for various niches (to use on the (Match|Block)RecipientTypeDetails param)

    [Get-Recipient (ExchangePowerShell) | Microsoft Docs - docs.microsoft.com/](https://docs.microsoft.com/en-us/powershell/module/exchange/get-recipient?view=exchange-ps)
    -RecipientType
        The RecipientType parameter filters the results by the specified recipient type. Valid values are:
        'DynamicDistributionGroup','MailContact','MailNonUniversalGroup','MailUniversalDistributionGroup',
            'MailUniversalSecurityGroup','MailUser','PublicFolder','UserMailbox'
    -RecipientTypeDetails
        'DiscoveryMailbox','DynamicDistributionGroup','EquipmentMailbox','GroupMailbox','GuestMailUser',
            'LegacyMailbox','LinkedMailbox','LinkedRoomMailbox','MailContact','MailForestContact','MailNonUniversalGroup',
            'MailUniversalDistributionGroup','MailUniversalSecurityGroup','MailUser','PublicFolder','PublicFolderMailbox',
            'RemoteEquipmentMailbox','RemoteRoomMailbox','RemoteSharedMailbox','RemoteTeamMailbox','RemoteUserMailbox',
            'RoomList','RoomMailbox','SchedulingMailbox','SharedMailbox','TeamMailbox','UserMailbox'

    # run the RTD set, pulling one of each type and dumping back the rt|rtd combos, to build rgxs:
    $rtds = 'DiscoveryMailbox','DynamicDistributionGroup','EquipmentMailbox','GroupMailbox','GuestMailUser',
        'LegacyMailbox','LinkedMailbox','LinkedRoomMailbox','MailContact','MailForestContact','MailNonUniversalGroup',
        'MailUniversalDistributionGroup','MailUniversalSecurityGroup','MailUser','PublicFolder','PublicFolderMailbox',
        'RemoteEquipmentMailbox','RemoteRoomMailbox','RemoteSharedMailbox','RemoteTeamMailbox','RemoteUserMailbox',
        'RoomList','RoomMailbox','SchedulingMailbox','SharedMailbox','TeamMailbox','UserMailbox' ; 
    $rtypes = @() ; 
    foreach($rtd in $rtds){
        write-host "==rtd:$($rtd)" ; 
        $rtypes += get-exorecipient -filter "Recipienttypedetails -eq '$rtd'" -ResultSize 1 ; 
    } ; 
    $rtypes | sort RecipientType,RecipientTypeDetails | ft -auto alias,primarys*,recipientt*

    Sanitized Output: (clearly our Tenant did not have quite a few of the RTD types queried)
    ObjType                                                      RecipientType                  RecipientTypeDetails
    -----                                                        -------------                  --------------------
    [DYNAMICDISTRIBUTIONGROUP]                                   DynamicDistributionGroup       DynamicDistributionGroup
    [MAILCONTACT]                                                MailContact                    MailContact
    [UNIFIEDGROUP]                                               MailUniversalDistributionGroup GroupMailbox
    [DISTRIBUTIONGROUP]                                          MailUniversalDistributionGroup MailUniversalDistributionGroup
    [ROOMLIST-DISTRIBUTIONGROUP]                                 MailUniversalDistributionGroup RoomList
    [MAIL-ENABLED SECURITYGROUP]                                 MailUniversalSecurityGroup     MailUniversalSecurityGroup
    [GUEST]                                                      MailUser                       GuestMailUser
    [MAILUSER]                                                   MailUser                       MailUser
    [DISCOVERYSEARCH MAILBOX]                                    UserMailbox                    DiscoveryMailbox
    [EQUIPMENTMAILBOX]                                           UserMailbox                    EquipmentMailbox
    [ROOMMAILBOX]                                                UserMailbox                    RoomMailbox
    [MS BOOKING APP MBX]                                         UserMailbox                    SchedulingMailbox
    [SHAREDMAILBOX]                                              UserMailbox                    SharedMailbox
    [USERMAILBOX]                                                UserMailbox                    UserMailbox

    # all the variant RTDs for 'group' rt's:
    $rtype = $rtypes |?{$_.RecipientType -like '*group*'} | select -expand RecipientTypeDetails | select -Unique
    [regex]$rgx = ('(' + (($rtype |%{[regex]::escape($_)}) -join '|') + ')') ;
    $rgx.tostring() ;
    # 'groups' rtd rgx : (groupmailbox covers UnifiedGrps)
    $_.RecipientTypeDetails -match '(DynamicDistributionGroup|GroupMailbox|MailUniversalDistributionGroup|MailUniversalSecurityGroup|RoomList)'

    # now do secprins: RecipientType: UserMailbox, MailUser
    $rtype = $rtypes |?{$_.RecipientType -like '*user*'} | select -expand RecipientTypeDetails | select -Unique ;
    [regex]$rgx = ('(' + (($rtype |%{[regex]::escape($_)}) -join '|') + ')') ;
    $rgx.tostring() ;
    # 'core' secprin rtd rgx:
    $_.RecipientTypeDetails -match '(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)' ; 

    # sender/recipients (approved|blocked targets):  Valid values for this parameter are individual senders in your organization (mailboxes, mail users, and mail contacts) 
    # RecipientType: UserMailbox, MailUser, MailContact
    $rtype = $rtypes |?{$_.RecipientType -match '(User|Contact)'} | select -expand RecipientTypeDetails | select -Unique ;
    [regex]$rgx = ('(' + (($rtype |%{[regex]::escape($_)}) -join '|') + ')') ;
    $rgx.tostring() ;
    # sender/recipients rtd rgx:
    $_.RecipientTypeDetails -match '(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailContact|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)'
    - DiscoveryMailbox discovery are for eDisc, not mail delivery
    
    # moderated by:  must be a mailbox, mail user, or mail contact: RecipientType: UserMailbox, MailUser, MailContact (same as above ☝🏻 )

    # mailbox secprins: required to do accessgrant on a mailbox
    [Add-MailboxPermission (ExchangePowerShell) | Microsoft Docs - docs.microsoft.com/](https://docs.microsoft.com/en-us/powershell/module/exchange/add-mailboxpermission?view=exchange-ps)
        You can specify the following types of users or groups (security principals) for this parameter:
            Mailbox users
            Mail users
            Security groups
    
        -- those phrases are RecipientType values, with spaces added - but not sure they really mean "anything of those specific RT's"...?
        -- though you might be able to use a *licensed* sharedmailbox to open another mailbox (?), they won't be able to do it natively, esp with disabled User logon. 
        -- rooms are disabled for logon. like shared, & equipment
        -- prob should exclude non-interactive logon & system in theory: DiscoveryMailbox|SchedulingMailbox|SharedMailbox|EquipmentMailbox|RoomMailbox
        -- CORRECTION: looped through full set of RT:UserMailbox types in the Tenant, *every* one of them added wo complaint using add-mailboxpermission & add-recipientpermission, 
            although many - unlicensed - would likely be unable to actually open another mailbox. 
        -- so technically, it appears should use the entire set, as they *technically* add wo complaint
    $rtype = $rtypes |?{$_.RecipientType -match '(User|MailUniversalSecurityGroup)'} | select -expand RecipientTypeDetails | select -Unique;
    [regex]$rgx = ('(' + (($rtype |%{[regex]::escape($_)}) -join '|') + ')') ;
    $rgx.tostring() ;
    # mailbox secprins (perm grants)
    $_.RecipientTypeDetails -match '(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailUniversalSecurityGroup|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)' 

    .PARAMETER Recipients
    Array of Recipients to be resolved against current Exchange environment [-Recipients `$ModeratedBy ]
    .PARAMETER MatchRecipientTypeDetails
    Regex for RecipientTypeDetails value to require for matched Recipients [-MatchRecipientTypeDetails '(UserMailbox|MailUser)']
    .PARAMETER BlockRecipientTypeDetails
    Regex for RecipientTypeDetails value to filter out of matched Recipients [-Block '(MailContact|GuestUser)']
    .PARAMETER getGroups
    Switch that specifies the return of solely 'group' recipients (RecipientTypeDetails matching:(DynamicDistributionGroup|GroupMailbox|MailUniversalDistributionGroup|MailUniversalSecurityGroup|RoomList)) [-getGroup]
    .PARAMETER getRecipients
    Switch that specifies the return of solely 'recipient' objects (RecipientTypeDetails matching:(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailContact|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)) [-getRecipients]
    .PARAMETER getMailboxPrincipals
    Switch that specifies the return of solely 'Mailbox Security Principal' recipients (RecipientTypeDetails matching:'(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailUniversalSecurityGroup|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)') [-getRecipients]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER PreviewThreshold
    Maximum number of preview resolved to display in console (defaults to 25)[-PreviewThreshold 10]
    .PARAMETER UpdateInterval
    Dot crawl update interval (one dot per `$UpdateInterval processed recipients - defaults to 3)[-UpdateInterval 10]
    .PARAMETER returnObject
    Switch to return full Recipient object to pipeline for each resolved recipient (rather than default, PrimarySmtpAddress property) [-returnObject]
    .EXAMPLE
    PS> $pltSDdg.RejectMessagesFrom = (Resolve-xoRcps -Recipients $srcDg.RejectMessagesFrom -MatchRecipientTypeDetails -MatchRecipientTypeDetails '(UserMailbox|MailUser|GuestMailUser|MailContact)' -Verbose:($VerbosePreference -eq 'Continue') -ErrorAction Continue)  ; 
    Resolve mail sender/recipient recip designators on the RejectMessagesFrom varito EXO recipient objects, with -ErrorAction:Continue (echo lookup fails, continue looping), and return the primarysmtpaddresses as an array
    .EXAMPLE
    PS> $pltSDdg.RejectMessagesFrom = (Resolve-xoRcps -Recipients $srcDg.RejectMessagesFrom -MatchRecipientTypeDetails -MatchRecipientTypeDetails '(UserMailbox|MailUser|GuestMailUser)' -Verbose:($VerbosePreference -eq 'Continue') -ErrorAction Continue)  ; 
    Resolve mail 'Security Principal' recip designators on the RejectMessagesFrom varito EXO recipient objects, with -ErrorAction:Continue (echo lookup fails, continue looping), and return the primarysmtpaddresses as an array
    .EXAMPLE
    PS> $pltSDdg.AcceptMessagesOnlyFromDLMembers = (Resolve-xoRcps -Recipients $ApprovedSenderDLs -MatchRecipientTypeDetails '(MailUniversalDistributionGroup|DynamicDistributionGroup|GroupMailbox)' -Verbose:$($VerbosePreference -eq 'Continue') )  ;
    Resolve mail recipient 'group' objects (covers DG| DDG| UnifiedGrp)
    .EXAMPLE
    PS> if($pltSDdg.RejectMessagesFrom){
            $pltSDdg.RejectMessagesFrom = (Resolve-xoRcps -Recipients $srcDg.RejectMessagesFrom -MatchRecipientTypeDetails '(UserMailbox|MailUser|GuestMailUser|MailContact)' -Verbose:($VerbosePreference -eq 'Continue') )  ; 
        } ;
    Resolve recip designators on the RejectMessagesFrom value, to EXO recipient objects, and return the primarysmtpaddress
    .EXAMPLE
    PS> $pltSDdg.AcceptMessagesOnlyFromDLMembers = (Resolve-xoRcps -Recipients $ApprovedSenderDLs -getGroups -Verbose:$($VerbosePreference -eq 'Continue') )  ;
    Resolve mail recipient 'group' objects using the -getGroups parameter (covers DG| DDG| UnifiedGrp)
    .EXAMPLE
    PS> $pltSDdg.AcceptMessagesOnlyFrom = (Resolve-xoRcps -Recipients $ApprovedSenderDLs -getRecipients -Verbose:$($VerbosePreference -eq 'Continue') )  ;
    Resolve mail recipient 'recipient' objects (senders/recipients) using the -getRecipients parameter.
    .EXAMPLE
    PS> $pltSDdg.AcceptMessagesOnlyFrom = (Resolve-xoRcps -Recipients $ApprovedSenderDLs -getRecipients -Verbose:$($VerbosePreference -eq 'Continue') )  ;
    Resolve mail Security Principal recipients (Those that can be used with add-mailboxpermission & add-recipientpermission) using the -getMailboxPrincipals parameter
    (covers DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailUniversalSecurityGroup|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)
    .EXAMPLE
    PS> $FullRecipientArray = (Resolve-xoRcps -Recipients $ApprovedSenderDLs -getRecipients -returnObject -Verbose:$($VerbosePreference -eq 'Continue') )  ;
    Resolve mail recipient 'recipient' objects (senders/recipients) using the -getRecipients parameter, and return the full Recipient object for each, to the pipeline.                
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory=$True,HelpMessage="Array of Recipients to be resolved against current Exchange environment [-Recipients `$ModeratedBy ]")]
        [array]$Recipients,
        [Parameter(ParameterSetName='MatchRecipients',HelpMessage="Regex for RecipientTypeDetails value to require for matched Recipients [-MatchRecipientTypeDetails '(UserMailbox|MailUser)']")]
        [string]$MatchRecipientTypeDetails,
        [Parameter(HelpMessage="Regex for RecipientTypeDetails value to filter out of matched Recipients [-Block '(MailContact|GuestUser)']")]
        [string]$BlockRecipientTypeDetails,
        [Parameter(ParameterSetName='groups',HelpMessage="Switch that specifies the return of solely 'group' recipients (RecipientTypeDetails matching:(DynamicDistributionGroup|GroupMailbox|MailUniversalDistributionGroup|MailUniversalSecurityGroup|RoomList)) [-getGroup]")]
        [switch] $getGroups,
        [Parameter(ParameterSetName='recipients',HelpMessage="Switch that specifies the return of solely 'recipient' objects (RecipientTypeDetails matching:(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailContact|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)) [-getRecipients]")]
        [switch] $getRecipients,
        [Parameter(ParameterSetName='secprincipals',HelpMessage="Switch that specifies the return of solely 'Mailbox Security Principal' recipients (RecipientTypeDetails matching:(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailUniversalSecurityGroup|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)) [-getRecipients]")]
        [switch] $getMailboxPrincipals,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2,
        [Parameter(HelpMessage="Maximum number of preview resolved to display in console (defaults to 25)[-PreviewThreshold 10]")]
        [int] $PreviewThreshold = 25,
        [Parameter(HelpMessage="Dot crawl update interval (one dot per `$UpdateInterval processed recipients - defaults to 3)[-UpdateInterval 10]")]
        [int] $UpdateInterval = 3,
        [Parameter(HelpMessage="Switch to return full Recipient object to pipeline for each resolved recipient (rather than default, PrimarySmtpAddress property) [-returnObject]")]
        [switch] $returnObject
    ) 
    <# Can capture the ErrorAction (not necessary, just like -verbose, if call is made with -erroraction specified, it auto-applies to *all* cmds run in the advanced function, that support the -ea param 
    - it's effectively setting $ErrorActionPreference for the func)
    Most useful purp would be if you want to echo status back.
    #>
    #$vErrorAction = $PSBoundParameters["ErrorAction"] ; 
    $verbose = ($VerbosePreference -eq "Continue") ;

    if($getGroups){$MatchRecipientTypeDetails = '(DynamicDistributionGroup|GroupMailbox|MailUniversalDistributionGroup|MailUniversalSecurityGroup|RoomList)'} 
    elseif($getRecipients){$MatchRecipientTypeDetails = '(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailContact|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)'} 
    elseif($getMailboxPrincipals){$MatchRecipientTypeDetails = '(DiscoveryMailbox|EquipmentMailbox|GuestMailUser|MailUniversalSecurityGroup|MailUser|RoomMailbox|SchedulingMailbox|SharedMailbox|UserMailbox)'} 
    
    if ($script:useEXOv2) { reconnect-eXO2 }
    [array]$cmdletMaps = 'ps1GetxRcp;get-exorecipient;' ;
    foreach($cmdletMap in $cmdletMaps){
        if($script:useEXOv2){
            if(!($cmdlet= Get-Command $cmdletMap.split(';')[1].replace('-exo','-xo') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
            $nAName = ($cmdletMap.split(';')[0]) ; 
            if(!($nalias = get-alias -name $nAName -ea 0 )){
                $nalias = set-alias -name $nAName -value ($cmdlet.name) -passthru ;
                $smsg = "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            } ;
        } else {
            if(!($cmdlet= Get-Command $cmdletMap.split(';')[1])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
            $nAName = ($cmdletMap.split(';')[0]);
            if(!($nalias = get-alias -name $nAName -ea 0 )){
                $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                $smsg = "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

            } ; 
        } ;
    } ;
    if ($script:useEXOv2) { reconnect-eXO2 }
    else { reconnect-EXO } ;
    if($Recipients){
        $Procd = 0 ; 
        $smsg = "(Resolving recipients...)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        $resolvedRecipients = $Recipients | foreach-object {
            # use the EA if spec'd
            ps1GetxRcp -identity $_ ;
            $Procd ++ ; 
            if(-not($Procd % $UpdateInterval)){
                write-host "." -NoNewline ; 
            } ; 
        } ; 
        write-host "" ; 
        if($MatchRecipientTypeDetails){
            $smsg = "(Resolve-xoRcps:($(($resolvedRecipients|measure).count)) PRE MatchRecipientTypeDetails:"
            if(($resolvedRecipients|measure).count -lt $PreviewThreshold){
                $smsg += "`n$(($resolvedRecipients.primarysmtpaddress|out-string).trim()))" ; 
            } else { 
                $smsg += "`n$(($resolvedRecipients.primarysmtpaddress | select -first $PreviewThreshold |out-string).trim()))`n..." ; 
            } ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            $resolvedRecipients = $resolvedRecipients |?{$_.RecipientTypeDetails -match $MatchRecipientTypeDetails} ; 
            $smsg = "(Resolve-xoRcps:($(($resolvedRecipients|measure).count)) POST MatchRecipientTypeDetails:`n$(($resolvedRecipients.primarysmtpaddress|out-string).trim()))" ; 
            if(($resolvedRecipients|measure).count -lt $PreviewThreshold){
                $smsg += "`n$(($resolvedRecipients.primarysmtpaddress|out-string).trim()))" ; 
            } else { 
                $smsg += "`n$(($resolvedRecipients.primarysmtpaddress | select -first $PreviewThreshold |out-string).trim()))`n..." ; 
            } ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ; 
        if($BlockRecipientTypeDetails){
            $smsg = "(Resolve-xoRcps:($(($resolvedRecipients|measure).count)) PRE BlockRecipientTypeDetails:`n$(($resolvedRecipients.primarysmtpaddress|out-string).trim()))" ; 
            if(($resolvedRecipients|measure).count -lt $PreviewThreshold){
                $smsg += "`n$(($resolvedRecipients.primarysmtpaddress|out-string).trim()))" ; 
            } else { 
                $smsg += "`n$(($resolvedRecipients.primarysmtpaddress | select -first $PreviewThreshold |out-string).trim()))`n..." ; 
            } ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            $resolvedRecipients = $resolvedRecipients |?{$_.RecipientTypeDetails -notmatch $BlockRecipientTypeDetails} ; 
            $smsg = "(Resolve-xoRcps:($(($resolvedRecipients|measure).count)) POST BlockRecipientTypeDetails:`n$(($resolvedRecipients.primarysmtpaddress|out-string).trim()))" ; 
            if(($resolvedRecipients|measure).count -lt $PreviewThreshold){
                $smsg += "`n$(($resolvedRecipients.primarysmtpaddress|out-string).trim()))" ; 
            } else { 
                $smsg += "`n$(($resolvedRecipients.primarysmtpaddress | select -first $PreviewThreshold |out-string).trim()))`n..." ; 
            } ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ; 
        if($returnObject){
            $smsg = "(-Returnobject: returning full recipient object array to pipeline)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            $resolvedRecipients |write-output ;
        } else { 
            $resolvedRecipients.primarysmtpaddress |write-output ;
        } ; 
        $smsg = "(Resolve-xoRcps:returning:($(($resolvedRecipients|measure).count))`n$(($resolvedRecipients.primarysmtpaddress|out-string).trim()))" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
    } else { 
        $smsg = "Resolve-xoRcps:No Recipients specified" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $null | write-output ;
    } ; 
}

#*------^ resolve-xoRcps.ps1 ^------


#*------v rxotol.ps1 v------
function rxoTOL {
    <#
    .SYNOPSIS
    rxoTOL - wrapper for Connect-EXO to connect to specified Tenant
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-07-29
    FileName    : rxoTOL.ps1
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    REVISIONS   :
    * 11:32 AM 4/18/2023 alias into rxoTOL, retiring
    .DESCRIPTION
    rxoTOL - wrapper for Connect-EXO to connect to specified Tenant
    .EXAMPLE
    rxoTOL
    #>
    [CmdletBinding()]
    [Alias('cxo2TOL' )]
    PARAM()
    ReConnect-EXO -cred $credO365TOLCSID -Verbose:$($VerbosePreference -eq 'Continue') ; 
}

#*------^ rxotol.ps1 ^------


#*------v rxotor.ps1 v------
function rxoTOR {
    <#
    .SYNOPSIS
    rxoTOR - wrapper for Connect-EXO to connect to specified Tenant
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-07-29
    FileName    : rxoTOR.ps1
    License     :
    Copyright   :
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    REVISIONS   :
    * 11:32 AM 4/18/2023 alias into rxoTOR, retiring
    .DESCRIPTION
    rxoTOR - wrapper for Connect-EXO to connect to specified Tenant
    .EXAMPLE
    rxoTOR
    #>
    [CmdletBinding()]
    [Alias('cxo2TOR' )]
    PARAM()
    ReConnect-EXO -cred $credO365TORCSID -Verbose:$($VerbosePreference -eq 'Continue') ; 
}

#*------^ rxotor.ps1 ^------


#*------v test-EXOConnectionTDO.ps1 v------
function test-EXOConnectionTDO{
    <#
    .SYNOPSIS
    test-EXOConnectionTDO.ps1 - Evaluate status of existing ExchangeOnlineManagement connections into Exchange Online or Security & Compliance backends. Wraps underlying ExchangeOnlineManagement module's get-ConnectionInformation cmdlet, evaluating and simplying returned info, to make for very easy status evaluation.
    .NOTES
    Version     : 0.0.1
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2024-
    FileName    : test-EXOConnectionTDO.ps1
    License     : MIT License
    Copyright   : (c) 2024 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 11:03 AM 7/9/2024 added txo alias; subbed in silent block for all wv
    * 4:31 PM 7/8/2024 added CBH example demoing variant output ; added blank Org resolution (resolve TenentID into equiv TenantDomain); this should always return a full set of values even if we have to work around the bugs in the MS code.
    * 9:48 AM 7/3/2 add:$AppId to return, need a way to resolve CBA back to identifiable role; resolve-UserNameToUserRole() resolves cert thumb to role, 
    * 3:59 PM 7/2/2024 added TenantID, as the Organization has been coming back blank (post filter -OR against either); 
        added parametersets, as ConnectionID & Prefix are exclusive params in get-ConnectionInformation
        stripped back & simplified, from hybrid all in one summary, 
        to just looping connections profiling each with details, and dumping the 
        results as pscustomobjects into the pipeline, for post filtering on the 
        receiving end (rather than trying to summarize what could be a mixture of 
        differnt types - xo & sc - and Tenant connections). 
    * 4:16 PM 6/28/2024 init
    .DESCRIPTION
    test-EXOConnectionTDO.ps1 - Evaluate status of existing ExchangeOnlineManagement connections into Exchange Online or Security & Compliance backends. Wraps underlying ExchangeOnlineManagement module's get-ConnectionInformation cmdlet, evaluating and simplying returned info, to make for very easy status evaluation.

    Refactoring/simplifying test-EXOv2Connection() into stripped down equiv: get-connectioninformation natively returns a lot of points of comparison, obsoleting bulk of the older EXOv2 & basic-auth'd EOM versions. 

    Because there can be a mixture of EXO & S&C sessions to multiple tenants, this takes the client-side post-filter approach, to filter out an appropriate connection for the client needs, rather than 
    trying to build the logic into this simpler function. 

    Returns the following summary of any Exchange Online or Security & Compliance session connections found via get-connectioninformation:

        Property          | Type/Value                                                               | Description
        ------------------|--------------------------------------------------------------------------|---------------------------------------------
        Connection        |  Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionInformation | array of any sessions found
        Organization      |  TENANTNAME.onmicrosoft.com                                              | Connection Organization name (TenantDomainName)
        Prefix            |  xo                                                                      | ModulePrefix for the connection
        UserPrincipalName |  ACCOUNT@DOMAIN.TLD                                                      | The account that was used to connect
        ConnectionId      |  nabbnncf-nnab-nnnn-nbnn-nnnenncnnaee                                    | A unique GUID value for the connection
        TenantID          |  nnnnnnae-enna-nnbn-nadc-nndncnnbannb                                    | The tenant ID GUID value
        ModuleName        |  C:\Users\LOGON\AppData\Local\Temp\2\tmpEXO_ebmrzk2m.vvp                 | The filename and path of the temporary data for the session. 
        isXO              |  True                                                                    | indicates an EXO connection is present (not necessarily Active)
        isSC              |  True                                                                    | indicates a Security & Compliance connection is present (not necessarily Active)
        isCBA             |  True                                                                    | indicates an EXO connection is present that used Certificate Based Authentication
        isValid           |  True                                                                    | indicates an EXO connection is TokenStatus:'Active'}
        TokenLifeMins     |  22                                                                      | reports the number of minutes remaining until TokenExpiryTimeUTC on the session (blank if expired)
                
        ---

        [Get-ConnectionInformation (ExchangePowerShell) | Microsoft Learn](https://learn.microsoft.com/en-us/powershell/module/exchange/get-connectioninformation?view=exchange-ps)

        The Get-ConnectionInformation cmdlet returns the information about all active REST-based connections with Exchange Online in the current PowerShell instance. This cmdlet is equivalent to the Get-PSSession cmdlet that's used with remote PowerShell sessions.

        The output of the cmdlet contains the following properties:

            ConnectionId: A unique GUID value for the connection. For example, 8b632b3a-a2e2-8ff3-adcd-6d119d07694b.
            State: For example, Connected.
            Id: An integer that identifies the session in the PowerShell window. The first connection is 1, the second is 2, etc.
            Name: A unique name that's based on the PowerShell environment and Id value. For example, ExchangeOnline_1 for Exchange Online PowerShell or ExchangeOnlineProtection_1 for Security & Compliance PowerShell.
            UserPrincipalName: The account that was used to connect. For example, laura@contoso.onmicrosoft.com.
            ConnectionUri: The connection endpoint that was used. For example, https://outlook.office365.com for Exchange Online PowerShell or https://nam12b.ps.compliance.protection.outlook.com for Security & Compliance PowerShell.
            AzureAdAuthorizationEndpointUri : The Microsoft Entra authorization endpoint for the connection. For example, https://login.microsoftonline.com/organizations for Exchange Online PowerShell or https://login.microsoftonline.com/organizations for Security & Compliance PowerShell.
            TokenExpiryTimeUTC: When the connection token expires. For example, 9/30/2023 6:42:24 PM +00:00.
            CertificateAuthentication: Whether certificate based authentication (also known as CBA or app-only authentication) was used to connect. Values are True or False.
            ModuleName: The filename and path of the temporary data for the session. For example, C:\Users\laura\AppData\Local\Temp\tmpEXO_a54z135k.qgv
            ModulePrefix: The value specified using the Prefix parameter in the Connect-ExchangeOnline or Connect-IPPSSession command.
            Organization: The value specified using the Organization parameter in the Connect-ExchangeOnline or Connect-IPPSSession command for CBA or managed identity connections.
            DelegatedOrganization: The value specified using the DelegatedOrganization parameter in the Connect-ExchangeOnline or Connect-IPPSSession command.
            AppId: The value specified using the AppId parameter in the Connect-ExchangeOnline or Connect-IPPSSession command for CBA connections.
            PageSize: The default maximum number of entries per page in the connection. The default value is 1000, or you can use the PageSize parameter in the Connect-ExchangeOnline command to specify a lower number. Individual cmdlets might also have a PageSize parameter.
            TenantID: The tenant ID GUID value. For example, 3750b40b-a68b-4632-9fb3-5b1aff664079.
            TokenStatus: For example, Active.
            ConnectionUsedForInbuiltCmdlets
            IsEopSession: For Exchange Online PowerShell connections, the value is False. For Security & Compliance PowerShell connections, the value is True.

        Examples
        Example 1
        PowerShell

        Get-ConnectionInformation

        This example returns a list of all active REST-based connections with Exchange Online in the current PowerShell instance.
        Example 2
        PowerShell

        Get-ConnectionInformation -ConnectionId 1a9e45e8-e7ec-498f-9ac3-0504e987fa85

        This example returns the active REST-based connection with the specified ConnectionId value.
        Example 3
        PowerShell

        Get-ConnectionInformation -ModulePrefix Contoso,Fabrikam

        This example returns a list of active REST-based connections that are using the specified prefix values.
        Parameters
        -ConnectionId

        Note: This parameter is available in version 3.2.0 or later of the module.

        The ConnectionId parameter filters the connections by ConnectionId. ConnectionId is a GUID value in the output of the Get-ConnectionInformation cmdlet that uniquely identifies a connection, even if you have multiple connections open. You can specify multiple ConnectionId values separated by commas.

        Don't use this parameter with the ModulePrefix parameter.
        Type:	String[]
        Position:	Named
        Default value:	None
        Required:	True
        Accept pipeline input:	False
        Accept wildcard characters:	False
        Applies to:	Exchange Online
        -ModulePrefix

        Note: This parameter is available in version 3.2.0 or later of the module.

        The ModulePrefix parameter filters the connections by ModulePrefix. When you use the Prefix parameter with the Connect-ExchangeOnline cmdlet, the specified text is added to the names of all Exchange Online cmdlets (for example, Get-InboundConnector becomes Get-ContosoInboundConnector). The ModulePrefix value is visible in the output of the Get-ConnectionInformation cmdlet. You can specify multiple ModulePrefix values separated by commas.

        This parameter is meaningful only for connections that were created with the Prefix parameter.

        Don't use this parameter with the ConnectionId parameter.
        Type:	String[]
        Position:	Named
        Default value:	None
        Required:	True
        Accept pipeline input:	False
        Accept wildcard characters:	False
        Applies to:	Exchange Online    

        ---

    .PARAMETER Organization
    Office365 TenantDomain to be referenced for Connection Validation[-Organization 'TenantDomain.onmicrosoft.com']
    .PARAMETER UserPrincipalName
    Optional UPN to be tested against for current connection[-UserPrincipalName 'UPN@domain.com']
    .PARAMETER Silent
    Switch to specify suppression of all but warn/error echos.(unimplemented, here for cross-compat)
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    System.Object returns per connection summary object 
    .EXAMPLE
    PS> if((test-EXOConnectionTDO | ?{$_.isXO -AND $_.isValid}){}{connect-ExchangeOnline} ; get-xomailbox -ResultSize 1 ; 
    Simple pre-connection test/connection trigger prior to running an EXO command
    .EXAMPLE
    PS> if((test-EXOConnectionTDO -prefix cc | ?{$_.isXO -AND $_.isValid}){}{connect-ExchangeOnline} ; get-xomailbox -ResultSize 1 ; 
    Simple pre-connection test/connection trigger prior to running an EXO command
    .EXAMPLE
    PS> $results = test-EXOConnectionTDO ; 
    PS> results ; 

        Connection        : Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionInformation
        Organization      : TENENTDOMAIN.onmicrosoft.com
        Prefix            : xo
        UserPrincipalName : LOGON@DOMAIN.TLD
        ConnectionId      : nabbnncf-nnab-nnnn-nbnn-nnnenncnnaee
        TenantID          : nnnnnnae-enna-nnbn-nadc-nndncnnbannb
        ModuleName        : C:\Users\LOGON\AppData\Local\Temp\2\tmpEXO_uxszgv2h.0r1
        isXO              : True
        isSC              : False
        isCBA             : False
        isValid           : True
        TokenLifeMins     : 0      

    Demo pass, captured into variable, dumping a single EXO connection of returned proeprties.
    .EXAMPLE
    PS> write-verbose "Input Data variable designator" ; 
    PS> $tenorg = 'ABC' ;
    PS> write-verbose "connection summary select properties" ; 
    PS> $prpCXO = 'Organization','Prefix','UserprincipalName','ConnectionID','isXO','isSC','isCBA','isValid','TokenLifeMins' ; 
    PS> disconnect-exchangeonline ; 
    PS> write-verbose "query status specifying explicit prefix 'xo'" ; 
    PS> write-verbose "and postfilter for isXO, and IsValid (TokenStatus: Active)" ; 
    PS> write-verbose "and org match to a local variables with target TenantDomain and TenantID guid" ; 
    PS> if( test-exoconnectiontdo -Prefix 'xo' |
    PS>     ?{$_.isXO -AND $_.IsValid -AND (
    PS>           $_.organization -match ((gv -name "$($TenOrg)Meta").Value.o365_TenantDomain) -OR $_.TenantID -match ((gv -name "$($TenOrg)Meta").Value.o365_TenantID )
    PS>     ) }){}else{
    PS>     connect-ExchangeOnline -Prefix xo -ShowBanner:$false ;
    PS>     write-verbose "above returns no status info; so pull the context again for future checks" ;
    PS>     if($PSXOContext = test-EXOConnectionTDO -prefix xo){
    PS>         $smsg = $PSXOContext | select $prpCXO[0..3] | convertTo-MarkdownTable -border ;
    PS>         $smsg += $PSXOContext | select $prpCXO[4..8] | convertTo-MarkdownTable -border ;
    PS>         write-host -foregroundcolor green $smsg ;
    PS>     } else {
    PS>         write-warning "Not Connected" ;
    PS>     } ;
    PS> } ; get-xomailbox -ResultSize 1 ;
    PS> write-verbose "Refresh Connection Status using cached connectionid guid (more specific than even Prefix" ;
    PS> $PSXOContext = test-EXOConnectionTDO -ConnectionID $PSXOContext.connectionID.guid ; 

        | Organization | Prefix | UserPrincipalName      | ConnectionId                         |
        | ------------ | ------ | ---------------------- | ------------------------------------ |
        |              | xo     | xxxxxx.xxxxxx@DOMO.TLD | nabbnncf-nnab-nnnn-nbnn-nnnenncnnaee |
        | isXO | isSC  | isCBA | isValid | TokenLifeMins |
        | ---- | ----- | ----- | ------- | ------------- |
        | True | False | False | True    | 6             |

    Fancier EXO connectivity pretest, post test, and cached context demo (output prettied up via verb-io:convertto-markdowntabl())
    .EXAMPLE
    PS> write-verbose "$XXXMeta variable designator" ; 
    PS> $tenorg = 'TOR' ;
    PS> write-verbose "connection summary select properties" ; 
    PS> $prpCXO = 'Organization','Prefix','UserprincipalName','ConnectionID','isXO','isSC','isCBA','isValid','TokenLifeMins' ; 
    PS> disconnect-exchangeonline ; 
    PS> write-verbose "query status specifying explicit prefix 'cc'" ; 
    PS> write-verbose "and postfilter for isSC, and IsValid (TokenStatus: Active)" ; 
    PS> write-verbose "and org match to a local variables" ; 
    PS> if( test-exoconnectiontdo -Prefix 'cc' |
    PS>     ?{$_.isSC -AND $_.IsValid -AND (
    PS>           $_.organization -match ((gv -name "$($TenOrg)Meta").Value.o365_TenantDomain) -OR $_.TenantID -match ((gv -name "$($TenOrg)Meta").Value.o365_TenantID )
    PS>     ) }){}else{
    PS>     connect-IPPSSession -Prefix cc  ;
    PS>     write-verbose "above returns no status info; so pull the context again for future checks" ;
    PS>     if($PSSCContext = test-EXOConnectionTDO -prefix cc){
    PS>         $smsg = $PSSCContext | select $prpCXO[0..3] | convertTo-MarkdownTable -border ;
    PS>         $smsg += $PSSCContext | select $prpCXO[4..8] | convertTo-MarkdownTable -border ;
    PS>         write-host -foregroundcolor green $smsg ;
    PS>     } else {
    PS>         write-warning "Not Connected" ;
    PS>     } ;
    PS> } ; 
    PS> write-verbose "Refresh Connection Status using cached connectionid guid (more specific than even Prefix" ;
    PS> $PSSCContext = test-EXOConnectionTDO -ConnectionID $PSSCContext.connectionID.guid -verbose ;   

        | Organization | Prefix | UserPrincipalName      | ConnectionId                         |
        | ------------ | ------ | ---------------------- | ------------------------------------ |
        |              | xo     | xxxxxx.xxxxxx@DOMO.TLD | nnnnnnae-enna-nnbn-nadc-nndncnnbannb |
        | isXO  | isSC | isCBA | isValid | TokenLifeMins |
        | ----- | ---- | ----- | ------- | ------------- |
        | False | True | False | True    | 6             |
  
    Fancier Sec & Compliance connectivity pretest, post test, and cached context demo
    .EXAMPLE
    PS> $results = test-exoconnectiontdo ; 
    PS> write-verbose "output returned CustomObject summary" ; 
    PS> $results ; 

        Connection        : Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionInformation
        Organization      : TENANTDOMAIN.onmicrosoft.com
        Prefix            : xo
        UserPrincipalName : OAuthUser@toroco.onmicrosoft.com
        ConnectionId      : nnnnncfe-fnan-nnbn-nbdn-annnnbnennfn
        AppId             : dannnnad-endn-nnan-nnnn-nenennnnnafe
        TenantID          : nnnnnnae-enna-nnbn-nadc-nndncnnbannb
        ModuleName        : C:\Users\LOGON\AppData\Local\Temp\2\tmpEXO_0imdddz4.3sl
        isXO              : True
        isSC              : False
        isCBA             : True
        isValid           : True
        TokenLifeMins     : 34

        Connection        : Microsoft.Exchange.Management.ExoPowershellSnapin.ConnectionInformation
        Organization      : TENANTDOMAIN.onmicrosoft.com
        Prefix            : cc
        UserPrincipalName : LOGON@DOMAIN.TLD
        ConnectionId      : nnnnnnde-nnnf-nndn-nnff-andbnnnnennn
        AppId             : 
        TenantID          : nnnnnnae-enna-nnbn-nadc-nndncnnbannb
        ModuleName        : C:\Users\LOGON\AppData\Local\Temp\2\tmpEXO_czwcyyvn.mem
        isXO              : False
        isSC              : True
        isCBA             : False
        isValid           : True
        TokenLifeMins     : 43
    PS> write-verbose "output TokenStatus of the connection property of the returned object (which reflects the entire output of the get-connectioninformation cmdlet)" ; 
    PS> ($results | ? isXO).connection.tokenstatus

        Active

    Demo default pass, which returns status info on all types of EXO-based connections. In above case upper return is a CBA-based EXO connection, and the lower is an account logon Sec & Compliance connection.
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    [CmdletBinding(DefaultParameterSetName='Prefix')]
    [Alias('txo')]
    PARAM(
        [Parameter(HelpMessage="Office365 TenantDomain to be filtered on returns[-Organization 'TENANTDOMAIN.onmicrosoft.com']")]
            [string]$Organization,
            # = $TORMeta.o365_TenantDomain,
        [Parameter(ParameterSetName='Prefix',HelpMessage="Prefix value to be filtered against existing connections[-Prefix xo]")]
            [Alias('ModulePrefix')]
            [string[]]$Prefix,
        [Parameter(ParameterSetName='ConnectionID',HelpMessage="The ConnectionId parameter filters the connections by ConnectionId. ConnectionId is a GUID value in the output of the Get-ConnectionInformation cmdlet that uniquely identifies a connection, even if you have multiple connections open. You can specify multiple ConnectionId values separated by commas.[-ConnectionId [guid]]")]
            [ValidateScript({
                [boolean]([guid]$_)
            })]
            [string[]]$ConnectionId,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent
        #,[switch]$isCBA
    ); 
    BEGIN{
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        $rgxExoPsHostName="^(ps\.outlook\.com|outlook\.office365\.com)$" ; 
        $rgxConnectionUriCCMS = 'https://ps\.compliance\.protection\.outlook\.com' ; 
        TRY{
            $pltGConn=[ordered]@{
                erroraction = 'STOP' ;
            } ;
            if($Prefix){
                $pltGConn.add('ModulePrefix',$Prefix) ; 
            } ;
            if($ConnectionID){
                $pltGConn.add('ConnectionID',$ConnectionID) ; 
            } ; 
            $smsg = "get-connectioninformation w`n$(($pltGConn|out-string).trim())" ; 
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;

            $connections = get-connectioninformation @pltGConn ; 
            
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
    } ;  # BEG-E
    PROCESS{
        if($connections){
            $connections|%{
                $sessRet = [ordered]@{
                    Connection = $_ ; 
                    Organization = $_.Organization ; 
                    Prefix = $_.ModulePrefix ;  
                    UserPrincipalName = $_.UserPrincipalName ; 
                    ConnectionId = $_.ConnectionId ; 
                    AppId = $_.AppID ;
                    TenantID = $_.TenantID ; 
                    ModuleName = $_.ModuleName ; 
                    isXO = [boolean](($_.connectionuri -match $rgxConnectionUriEXO) -AND $_.IsEopSession -eq $false)
                    isSC = [boolean](($_.connectionuri -match $rgxConnectionUriCCMS) -AND $_.IsEopSession -eq $true)
                    isCBA = [boolean]($_.CertificateAuthentication); 
                    isValid = [boolean]($_.TokenStatus -eq 'Active') ; 
                    TokenLifeMins = if($_.TokenExpiryTimeUTC){(new-timespan -start (get-date ) -end ($_.TokenExpiryTimeUTC).LocalDateTime).minutes}else{$null} ;  ; 
                    #$null ; 
                } ; 
                if($null -eq $sessRet.Organization -AND $sessRet.TenantID){
                    $Tenantdomain = convert-TenantIdToDomainName -TenantId $sessRet.TenantID ;
                    $smsg = "(coercing blank Session Org, to resolved TenantID equivelent TenantDomain)" ; 
                    if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                    $sessRet.Organization = $Tenantdomain ; 
                } ; 
                if($Organization){
                    # instead of compare test, use it as a post-filter
                    if($sessRet = $sessRet | ?{$_.Organization -match $Organization}){
                        [pscustomobject]$sessRet | Write-Output ;
                    } else {
                        $smsg = "(no existing connection matched: `$_.Organization -match $($Organization))" ; 
                        if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                    } ; 
                } else{ 
                    [pscustomobject]$sessRet | Write-Output ; 
                } ; 
            } ;    
        }else {
            $smsg = "(No EXO EOM connections found)" ; 
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            # get-connectioninformation returns nothing when no connection, even with verbose
            # so we're not going to return a 'faked' summary to indicate a non-connection.
            
        } ; 
    } ;  # PROC-E
    END{} ; 
}

#*------^ test-EXOConnectionTDO.ps1 ^------


#*------v test-ExoDnsRecordTDO.ps1 v------
if(-not (get-command test-ExoDnsRecordTDO -ea 0)){
    function test-ExoDnsRecordTDO{
        <#
        .SYNOPSIS
        test-ExoDnsRecordTDO - Boilerplate wrapper for Resolve-DNSName, that runs tests and validates proper returns, against specified testFalue. for Mail-related DNS Records (MX, TXT Domain Verific, SPF & DKIM; CNAME autodiscover record) 
        .NOTES
        Version     : 0.0.1
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 2024-06-07
        FileName    : test-ExoDnsRecordTDO
        License     : MIT License
        Copyright   : (c) 2024 Todd Kadrie
        Github      : https://github.com/tostka/verb-EXO
        Tags        : Powershell,AzureAD,Authentication,Test
        AddedCredit : 
        AddedWebsite: 
        AddedTwitter: 
        REVISIONS
        * 3:16 PM 7/11/2024 cleaned up CBH params etc
        * 3:40 PM 6/18/2024 ren $fltr -> $filter ; $tvalue -> $testValue ; round out into full function; pull sources from Metas; shift into param intputs
        * 6:16 PM 6/12/2024 init
        .DESCRIPTION
        test-ExoDnsRecordTDO - Boilerplate wrapper for Resolve-DNSName, that runs tests and validates proper returns, against specified testFalue. for Mail-related DNS Records (MX, TXT Domain Verific, SPF & DKIM; CNAME autodiscover record) 
        .PARAMETER Name
        DNS Name[-Name host.domain.tld]
        .PARAMETER Type
        DNS Type[-Type TXT]
        .PARAMETER filter
        TXT type, String property post-filter[-filter '^v=DKIM1']
        .PARAMETER testValue
        Validating value string[-testValue TXT]
        .PARAMETER Server
        DNS Server[-Server 8.8.8.8]
        .INPUTS
        Does not accept piped input
        .OUTPUTS
        System.Object summary
        .EXAMPLE
        write-verbose 'Domain Ownership TXT Validator record test';
        $DomainName = 'somedomain.tld' ; 
        $ret  = test-ExoDnsRecordTDO -Name $domainname -Type TXT -filter '^MS='  -testValue 'MS=msnnnnnnnn' ; 
        if($ret.Validated -eq $true){write-host "Valid MX Record:`n$(($ret.DNSObject|out-string).trim())" } else { write-warning "Failed Validation" } ; 
        Typical pass
        .EXAMPLE
        write-verbose 'mx record test';
        $DomainName = 'somedomain.tld' ; 
        $ret  = test-ExoDnsRecordTDO -Name $domainname -Type MX -testValue 'myturf-com.mail.protection.outlook.com'
        if($ret.Validated -eq $true){write-host "Valid MX Record:`n$(($ret.DNSObject|out-string).trim())" } else { write-warning "Failed Validation" } ; 
        Typical pass
        .EXAMPLE
        write-verbose 'CNAME autodiscover record test';
        $DomainName = 'somedomain.tld' ; 
        $ret  = test-ExoDnsRecordTDO -Name "autodiscover.$($DomainName)" -Type CNAME -testValue 'autodiscover.outlook.com' ; 
        if($ret.Validated -eq $true){write-host "Valid CNAME Record:`n$(($ret.DNSObject|out-string).trim())" } else { write-warning "Failed Validation" } ; 
        Typical pass
        .EXAMPLE
        write-verbose 'TXT SPF DNS record test';
        $DomainName = 'somedomain.tld' ; 
        $ret  = test-ExoDnsRecordTDO -Name $domainname -Type TXT -filter '^v=spf1' -testValue "v=spf1 ip4:148.163.146.158 ip4:148.163.142.153 ip4:170.92.0.0/16 ip4:205.142.232.90 include:spf.protection.outlook.com ~all" ; 
        if($ret.Validated -eq $true){write-host "Valid TXT Record:`n$(($ret.DNSObject|out-string).trim())" } else { write-warning "Failed Validation" } ; 
        Typical pass
        .EXAMPLE
        write-verbose 'CNAME DKIM selector records test (with referred TXT key NameHost resolution)';
        $DomainName = 'somedomain.tld' ; 
        foreach($sel in @('selector1','selector2')){
            $pltTDN=[ordered]@{
                Name = "$($sel)._domainkey.$($DomainName)" ; 
                Type = 'CNAME' ; 
                filter = ''
                testValue = "$($sel)-$($domainname.replace('.','-'))._domainkey.toroco.onmicrosoft.com" ; 
            } ;
            $smsg = "test-ExoDnsRecordTDO w`n$(($pltTDN|out-string).trim())" ; 
            write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):$($smsg)"  ;
            $ret  = test-ExoDnsRecordTDO @pltTDN ; 
            if($ret.Validated -eq $true){write-host "Valid CNAME DKIM Selector Record:`n$(($ret.DNSObject|out-string).trim())" } else { write-warning "Failed Validation" } ; 
            write-host "--> Re-resolve expanded CNAME target NameHost" 
            $pltTDN=[ordered]@{
                Name = $ret.dnsobject.namehost ; 
                Type = 'TXT' ; 
                filter = '^v=DKIM1' ; # set filter for string match post filter
                testValue = "" ; 
            } ;
            $smsg = "test-ExoDnsRecordTDO w`n$(($pltTDN|out-string).trim())" ; 
            write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):$($smsg)"  ;
            $ret  = test-ExoDnsRecordTDO @pltTDN ; 
            if($ret.Validated -eq $true){write-host "Valid TXT target DKIM key Record:`n$(($ret.DNSObject|out-string).trim())" } else { write-warning "Failed Validation" } ; 
        } ; 
        Typical pass
        .EXAMPLE
        write-verbose 'CNAME DKIM selector records test (with referred TXT key NameHost resolution)';
        $DomainName = 'somedomain.tld' ; 
        foreach($sel in @('dkim1','dkim2')){
            $pltTDN=[ordered]@{
                Name = "$($sel)._domainkey.$($DomainName)" ; 
                Type = 'CNAME' ; 
                filter = ''
                testValue = "$($sel)-$($domainname.replace('.','-'))._domainkey.toroco.onmicrosoft.com" ; 
            } ;
            $smsg = "test-ExoDnsRecordTDO w`n$(($pltTDN|out-string).trim())" ; 
            write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):$($smsg)"  ;
            $ret  = test-ExoDnsRecordTDO @pltTDN ; 
            if($ret.Validated -eq $true){write-host "Valid CNAME DKIM Selector Record:`n$(($ret.DNSObject|out-string).trim())" } else { write-warning "Failed Validation" } ; 
            write-host "--> Re-resolve expanded CNAME target NameHost" 
            $pltTDN=[ordered]@{
                Name = $ret.dnsobject.namehost ; 
                Type = 'TXT' ; 
                filter = '^v=DKIM1' ; # set filter for string match post filter
                testValue = "" ; 
            } ;
            $smsg = "test-ExoDnsRecordTDO w`n$(($pltTDN|out-string).trim())" ; 
            write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):$($smsg)"  ;
            $ret  = test-ExoDnsRecordTDO @pltTDN ; 
            if($ret.Validated -eq $true){write-host "Valid TXT target DKIM key Record:`n$(($ret.DNSObject|out-string).trim())" } else { write-warning "Failed Validation" } ; 
        } ; 
        Typical pass using non-o365 custom selictor specs
    .EXAMPLE
    $DomainName = 'somedomain.tld' ;
    $sBnr3="`n#*~~~~~~v CHECK:$($DomainName): Domain Ownership Verification 'TXT' DNS record v~~~~~~" ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3)" ;
    $pltTDN=[ordered]@{
        Name = $DomainName ;
        Type = 'TXT' ;
        filter = '^MS=' ;
        testValue = MS=msnnnnnnnn
    } ;
    $smsg = "test-ExoDnsRecordTDO w`n$(($pltTDN|out-string).trim())" ;
    write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):$($smsg)"  ;
    $ret  = test-ExoDnsRecordTDO @pltTDN ;
    if($ret.Validated -eq $true){write-host "Valid TXT DomAuth Record:`n$(($ret.DNSObject|out-string).trim())" } else { write-warning "Failed Validation" } ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3.replace('~v','~^').replace('v~','^~'))`n" ;
    $sBnr3="`n#*~~~~~~v CHECK:$($DomainName): Domain 'MX' DNS record v~~~~~~" ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3)" ;
    $pltTDN=[ordered]@{
        Name = $DomainName ;
        Type =  'MX' ;
        filter = '' ; # set filter for string match post filter
        testValue = 'myturf-com.mail.protection.outlook.com'
    } ;
    $smsg = "test-ExoDnsRecordTDO w`n$(($pltTDN|out-string).trim())" ;
    write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):$($smsg)"  ;
    $ret  = test-ExoDnsRecordTDO @pltTDN ;
    if($ret.Validated -eq $true){write-host "Valid MX Record:`n$(($ret.DNSObject|out-string).trim())" } else { write-warning "Failed Validation" } ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3.replace('~v','~^').replace('v~','^~'))`n" ;
    $sBnr3="`n#*~~~~~~v CHECK:$($DomainName): Autodiscover CNAME DNS record v~~~~~~" ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3)" ;
    $pltTDN=[ordered]@{
        Name = "autodiscover.$($DomainName)" ;
        Type = 'CNAME' ;
        filter = '' ; # set filter for string match post filter
        testValue = 'autodiscover.outlook.com' ;
    } ;
    $smsg = "test-ExoDnsRecordTDO w`n$(($pltTDN|out-string).trim())" ;
    write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):$($smsg)"  ;
    $ret  = test-ExoDnsRecordTDO @pltTDN ;
    if($ret.Validated -eq $true){write-host "Valid CNAME Autodiscover Record:`n$(($ret.DNSObject|out-string).trim())" } else { write-warning "Failed Validation" } ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3.replace('~v','~^').replace('v~','^~'))`n" ;
    $sBnr3="`n#*~~~~~~v CHECK:$($DomainName): Domain SPF 'TXT' DNS record v~~~~~~" ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3)" ;
    $pltTDN=[ordered]@{
        Name = $DomainName ;
        Type = 'TXT' ;
        filter = '^v=spf1' ; # set filter for string match post filter
        testValue = "v=spf1 ip4:148.163.146.158 ip4:148.163.142.153 ip4:170.92.0.0/16 ip4:205.142.232.90 include:spf.protection.outlook.com ~all" ;
    } ;
    $smsg = "test-ExoDnsRecordTDO w`n$(($pltTDN|out-string).trim())" ;
    write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):$($smsg)"  ;
    $ret  = test-ExoDnsRecordTDO @pltTDN ;
    if($ret.Validated -eq $true){write-host "Valid TXT SPF Record:`n$(($ret.DNSObject|out-string).trim())" } else { write-warning "Failed Validation" } ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3.replace('~v','~^').replace('v~','^~'))`n" ;
    $sBnr3="`n#*~~~~~~v CHECK:$($DomainName):'CNAME' DKIM DNS records v~~~~~~" ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3)" ;
    foreach($sel in @('selector1','selector2')){
        $pltTDN=[ordered]@{
            Name = "$($sel)._domainkey.$($DomainName)" ;
            Type = 'CNAME' ;
            filter = ''
            testValue = "$($sel)-$($domainname.replace('.','-'))._domainkey.toroco.onmicrosoft.com" ;
        } ;
        $smsg = "test-ExoDnsRecordTDO w`n$(($pltTDN|out-string).trim())" ;
        write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):$($smsg)"  ;
        $ret  = test-ExoDnsRecordTDO @pltTDN ;
        if($ret.Validated -eq $true){write-host "Valid CNAME DKIM Selector Record:`n$(($ret.DNSObject|out-string).trim())" } else { write-warning "Failed Validation" } ;
        write-host "--> Re-resolve expanded CNAME target NameHost"
        $pltTDN=[ordered]@{
            Name = $ret.dnsobject.namehost ;
            Type = 'TXT' ;
            filter = '^v=DKIM1' ; # set filter for string match post filter
            testValue = "" ;
        } ;
        $smsg = "test-ExoDnsRecordTDO w`n$(($pltTDN|out-string).trim())" ;
        write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):$($smsg)"  ;
        $ret  = test-ExoDnsRecordTDO @pltTDN ;
        if($ret.Validated -eq $true){write-host "Valid TXT target DKIM key Record:`n$(($ret.DNSObject|out-string).trim())" } else { write-warning "Failed Validation" } ;
    } ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr3.replace('~v','~^').replace('v~','^~'))`n" ;
    Big all inclusive test of the range of DNS records required for O365 EXO domains.
        .LINK
        https://bitbucket.org/tostka/powershell/
        #>  
        [CmdletBinding()]
        Param(
            [Parameter(Mandatory=$True,HelpMessage="DNS Name[-Name host.domain.tld]")]
            [string]$Name,
            [Parameter(Mandatory=$True,HelpMessage="DNS Type[-Type TXT]")]
                [ValidateSet('MX','TXT','CNAME')]
                [string]$Type,
            [Parameter(HelpMessage="TXT type, String property post-filter[-filter '^v=DKIM1']")]
                [string]$filter,
            [Parameter(HelpMessage="Validating value string[-testValue TXT]")]
                [string]$testValue,
            [Parameter(Mandatory=$false,HelpMessage="DNS Server[-Server 8.8.8.8]")]
                [string]$Server = '1.1.1.1'
        ) ; 
        $pltRvDN=[ordered]@{
            Name = $Name ; 
            Server = $Server ; 
            Type = $type ; 
            erroraction = 'STOP' ;
        } ;
        $oReturn = [ordered]@{
            DNSObject = $null ; 
            Type = $Type ; 
            Validated = $false ; 
        } ; 
        if($testValue){$oReturn.add('testValue',$testValue)} ; 
        if($filter){$oReturn.add('filter',$filter)} ; 
        $smsg = "resolve-DNSName w`n$(($pltRvDN|out-string).trim())" ; 
        write-host -foregroundcolor gray "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
        TRY{
            if($rec = resolve-DNSName @pltRvDN ){
                switch($pltRvDN.Type){
                    'MX' {
                        if($rec.NameExchange -eq $testValue ){
                            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):==> NameExchange value matches spec: $($testValue)" ; 
                            $oReturn.DNSObject = $rec ; 
                            $oReturn.Validated = $true ;
                            [pscustomobject]$oReturn | write-output  ; 
                        } else{
                            write-warning "$((get-date).ToString('HH:mm:ss')):String value DOES NOT MATCH MS specified validator!: $($testValue)" ; 
                            $oReturn.DNSObject = $rec ; 
                            $oReturn.Validated = $false ;
                            [pscustomobject]$oReturn | write-output  ; 
                        }; 
                    } ; 
                    'TXT' {
                        $oReturn.add('strings',$null)
                        if($filter -AND ($rec| ? strings -match $filter)){
                            $rec = $rec| ? strings -match $filter ; 
                        } ; 
                        write-host -foregroundcolor green "`n$(($rec | ft -a |out-string).trim())" ; 
                        if($testValue -AND (($rec| select -expand strings) -eq $testValue)){
                            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):==> String value matches MS specified validator: $($testValue)" ; 
                            $oReturn.DNSObject = $rec ; 
                            $oReturn.Strings = ($rec| select -expand strings) ; 
                            $oReturn.Validated = $true ;
                            [pscustomobject]$oReturn | write-output  ; 
                        }elseif($testValue -AND (($rec| select -expand strings) -ne $testValue)){
                            write-warning "$((get-date).ToString('HH:mm:ss')):String value DOES NOT MATCH MS specified validator!: $($testValue)" ; 
                            $oReturn.DNSObject = $rec ; 
                            $oReturn.Strings = ($rec| select -expand strings) ; 
                            $oReturn.Validated = $false ;
                            [pscustomobject]$oReturn | write-output  ; 
                        }elseif($filter -AND $rec){
                            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):No comparison `$testValue, but matched `$filter:$($filter): ==> String value matches specification" ; 
                            $oReturn.DNSObject = $rec ; 
                            $oReturn.Strings = ($rec| select -expand strings) ; 
                            $oReturn.Validated = $true ;
                            [pscustomobject]$oReturn | write-output  ; 
                        } else{
                            write-warning "$((get-date).ToString('HH:mm:ss')):String value DOES NOT MATCH MS specified validator!: $($testValue)" ; 
                            $oReturn.DNSObject = $rec ; 
                            $oReturn.Strings = ($rec| select -expand strings) ; 
                            $oReturn.Validated = $false ;
                            [pscustomobject]$oReturn | write-output  ; 
                        }; 
                    } 
                    'CNAME' {
                        if($rec.NameHost -eq $testValue ){
                            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):NameHost value matches spec: $($testValue)" ; 
                            $oReturn.DNSObject = $rec ; 
                            $oReturn.Validated = $true ;
                            [pscustomobject]$oReturn | write-output  ;
                        } else{
                            write-warning "$((get-date).ToString('HH:mm:ss')):value DOES NOT MATCH specification!: $($testValue)" ; 
                            $oReturn.DNSObject = $rec ; 
                            $oReturn.Validated = $false ;
                            [pscustomobject]$oReturn | write-output  ;
                        }; 
                    }
                    default {
                        $smsg = "unrecognized Type: $($type) !" ; 
                        write-warning $smsg ; 
                        $oReturn.DNSObject = $rec ; 
                        $oReturn.Validated = $false ;
                        [pscustomobject]$oReturn | write-output  ;
                        throw $smsg ; 
                    } ;
                } 
            }else{
                write-warning "Unable to resolve-DNSName w`n$(($pltRvDN|out-string).trim())!" ; 
            } ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
            $oReturn.DNSObject = $rec ; 
            $oReturn.Validated = $false ;
            [pscustomobject]$oReturn | write-output  ;
            #throw $smsg ;
            #Continue
        } ; 
    } ; 
}

#*------^ test-ExoDnsRecordTDO.ps1 ^------


#*------v test-EXOIsLicensed.ps1 v------
function test-EXOIsLicensed {
    <#
    .SYNOPSIS
    test-EXOIsLicensed.ps1 - Evaluate IsLicensed status, to indicate license support for Exchange online UserMailbox type, on passed in AzureADUser object
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2022-03-22
    FileName    : test-EXOIsLicensed.ps1
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-exo
    Tags        : Powershell
    REVISIONS
    * 2:36 PM 1/12/2026 wip: updated calls to use vmg\get-MGLicensePlanlist
    * 1:30 PM 1/7/2026 WIP unupdated port from AADLicense -> MGUDLicense
    * 9:26 AM 6/17/2024 needs cred resolution splice over latest get-exomailboxlicenses
    * 3:52 PM 5/23/2023 implemented @rxo @rxoc split, (silence all connectivity, non-silent feedback of functions); flipped all r|cxo to @pltrxoC, and left all function calls as @pltrxo; 
    * 9:13 AM 5/22/2023 added Silent back, for broad call compatibility (pltrxo consistency); 
    * 2:39 PM 5/17/2023 add pltrxo support
    * 3:15 PM 5/15/2023:test-EXOIsLicensed() works w latest aad/exo-eom updates
    * 1:06 PM 4/4/2022 updated CBH example to reflect $AADU obj, not UPN input
    3:08 PM 3/23/2022 init
    .DESCRIPTION
    test-EXOIsLicensed.ps1 - Evaluate IsLicensed status, to indicate license support for Exchange online UserMailbox type, on passed in AzureADUser object
    Coordinates with verb-exo:get-ExoMailboxLicenses() to retrieve a static list of UserMailbox -supporting license names & sku's in our Tenant. 

    The get-EXOMailboxLicenses list is *not* interactive with AzureAD or EXO, 
    -- CORRECTION: the dependant get-AADlicensePlanList() includes an AAD call to pull the sku's: Connect-AAD -Credential:$Credential -verbose:$($verbose) -silent ;
    but that func needs working access, not the code w/in this.
    ...and it *will* have to be tuned for local Tenants, and maintained for currency over time. 

    It's a simple test, but it beats..
        ...the prior get-Msoluser |?{$_.islicensed} (which indicates:*some* license is assigned - could be a worthless 'FREEFLOW'!) 
        
        ... or testing |?{$_.LicenseReconciliationNeeded } 
        ( which used to indicate a mailbox *exists* but lacks a suitable mailbox-supporting license, 
        and continues to be mounted, *solely* due to being within 30days of onboarding to cloud.).  

    Not to mention get-AzureADuser's complete lack of any native evaluation on either front. [facepalm]
    Nor any similar native support in the gap from the ExchangeOnlineManagement module. 

    <rant>
        I *love* coding coverage for slipshod MS module providers that write to replace *force*-deprecated critical infra tools, 
        but can't be bothered to deliver equiv function, equiv parameters, or even similar outputs, 
        for long-standing higher-functioning tools, when they write the half-implemented *new* ones.

        And no, "Just make calls to GraphAPI!", is not a viable answer, for *working* admins, mandated to deliver working solutions on tight schedules. 
        If we wanted to be REST web devs, we wouldn't be running o365 services!
    </rant>

    .PARAMETER  User
    AzureADUser [Microsoft.Open.AzureAD.Model.User] object
    .PARAMETER TenOrg
    Tenant Tag (3-letter abbrebiation)[-TenOrg 'XYZ']
    .PARAMETER Credential
    Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]
    .PARAMETER UserRole
    Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER Silent
    Switch to specify suppression of all but warn/error echos.(unimplemented, here for cross-compat)
    .OUTPUT
    System.Boolean
    .EXAMPLE
    PS> $isEXOLicensed = test-EXOIsLicensed -User $AADUser -verbose
    PS> if($isEXOLicensed){write-host 'Has EXO Usermailbox Type License'} else { write-warning 'NO EXO USERMAILBOX TYPE LICENSE!'} ; 
    Evaluate IsLicensed status on passed UPN object
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    #Requires -Version 3
    ##Requires -Modules AzureAD, verb-Text
    ##Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\sregex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    [CmdletBinding()]
    
     Param(
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,HelpMessage="Either Msoluser object or UserPrincipalName for user[-User upn@domain.com|`$msoluserobj ]")]
            #[Microsoft.Open.AzureAD.Model.User]
            # updated to mguser
            [Microsoft.Graph.PowerShell.Models.MicrosoftGraphUser]$User,
        # Service Connection Supporting Varis (AAD, EXO, EXOP)
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
            [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ;
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ;
                return $true ;
            })]
            [string[]]$UserRole = @('ESvcCBA','CSvcCBA','SIDCBA','SID'),
            #@('SID','CSVC'),
            # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
            [switch] $useEXOv2=$true,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent
    )
    BEGIN {
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        
        <# recycling the inbound above into next call in the chain
        $pltRXO = [ordered]@{
            Credential = $Credential ; 
            verbose = $($VerbosePreference -eq "Continue")  ; 
            silent = $silent ; 
        } ;
        # default connectivity cmds - force silent false
        $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$true) ;
        if((gcm Reconnect-EXO).Parameters.keys -notcontains 'silent'){ $pltRxo.remove('Silent') } ; 
        #>
        # 9:26 AM 6/17/2024 this needs cred resolution splice over latest get-exomailboxlicenses
        $o365Cred = $null ;
        if($Credential){
            $smsg = "`Credential:Explicit credentials specified, deferring to use..." ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                # get-TenantCredentials() return format: (emulating)
                $o365Cred = [ordered]@{
                Cred=$Credential ;
                credType=$null ;
            } ;
            $uRoleReturn = resolve-UserNameToUserRole -UserName $Credential.username -verbose:$($VerbosePreference -eq "Continue") ; # Username
            #$uRoleReturn = resolve-UserNameToUserRole -Credential $Credential -verbose = $($VerbosePreference -eq "Continue") ;   # full Credential support
            if($uRoleReturn.UserRole){
                $o365Cred.credType = $uRoleReturn.UserRole ;
            } else {
                $smsg = "Unable to resolve `$credential.username ($($credential.username))"
                $smsg += "`nto a usable 'UserRole' spec!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ;
                Break ;
            } ;
        } else {
            $pltGTCred=@{TenOrg=$TenOrg ; UserRole=$null; verbose=$($verbose)} ;
            if($UserRole){
                $smsg = "(`$UserRole specified:$($UserRole -join ','))" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $pltGTCred.UserRole = $UserRole;
            } else {
                $smsg = "(No `$UserRole found, defaulting to:'CSVC','SID' " ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                $pltGTCred.UserRole = 'CSVC','SID' ;
            } ;
            $smsg = "get-TenantCredentials w`n$(($pltGTCred|out-string).trim())" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            $o365Cred = get-TenantCredentials @pltGTCred
        } ;
        if($o365Cred.credType -AND $o365Cred.Cred -AND $o365Cred.Cred.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
            $smsg = "(validated `$o365Cred contains .credType:$($o365Cred.credType) & `$o365Cred.Cred.username:$($o365Cred.Cred.username)" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            # 9:58 AM 6/13/2024 populate $credential with return, if not populated (may be required for follow-on calls that pass common $Credentials through)
            if((gv Credential) -AND $Credential -eq $null){
                $credential = $o365Cred.Cred ;
            }elseif($credential.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                $smsg = "(`$Credential is properly populated; explicit -Credential was in initial call)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else {
                $smsg = "`$Credential is `$NULL, AND $o365Cred.Cred is unusable to populate!" ;
                $smsg = "downstream commands will *not* properly pass through usable credentials!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ;
                break ;
            } ;
        } else {
            $smsg = "UNABLE TO RESOLVE FUNCTIONAL CredType/UserRole from specified explicit -Credential:$($Credential.username)!" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            break ;
        } ; 

        # downstream commands
        $pltRXO = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
        } ;
        if((get-command Reconnect-EXO).Parameters.keys -contains 'silent'){
            $pltRxo.add('Silent',$silent) ;
        } ;
        # default connectivity cmds - force silent false
        $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$true) ; 
        if((get-command Reconnect-EXO).Parameters.keys -notcontains 'silent'){
            $pltRxo.remove('Silent') ;
        } ; 

        # 3:22 PM 1/7/2026 MG CODE
        #region cMG_SCAFFOLD ; #*------v cMG_SCAFFOLD v------
        if(-not (get-command  test-mgconnection)){
            if(-not (get-module -list Microsoft.Graph -ea 0)){
                $smsg = "MISSING Microsoft.Graph!" ;
                $smsg += "`nUse: install-module Microsoft.Graph -scope CurrentUser" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
        } ;
        $MGCntxt = test-mgconnection -Verbose:($VerbosePreference -eq 'Continue') ;
        $o365Cred = $null ;
        if($Credential -AND $MGCntxt.isConnected){
            $smsg = "Explicit -Credential:$($Credential.username) -AND `$MGCntxt.isConnected: running pre:Disconnect-MgGraph" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            # Dmg returns a get-mgcontext into pipe, if you don't cap it corrupts the pipe on your current flow
            $dOut = Disconnect-MgGraph -Verbose:($VerbosePreference -eq 'Continue')
            $MGCntxt = test-mgconnection -Verbose:($VerbosePreference -eq 'Continue') ;
        };
        if($Credential){
            $smsg = "`Credential:Explicit credentials specified, deferring to use..." ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            write-verbose "get-TenantCredentials() return format: (emulating)" ;
            $o365Cred = [ordered]@{
                Cred=$Credential ;
                credType=$null ;
            } ;
            $uRoleReturn = resolve-UserNameToUserRole -UserName $Credential.username -verbose:$($VerbosePreference -eq "Continue") ; # Username
            write-verbose "w full cred opt: $uRoleReturn = resolve-UserNameToUserRole -Credential $Credential -verbose = $($VerbosePreference -eq 'Continue')"  ;
            if($uRoleReturn.UserRole){
                $o365Cred.credType = $uRoleReturn.UserRole ;
            } else {
                $smsg = "Unable to resolve `$credential.username ($($credential.username))"
                $smsg += "`nto a usable 'UserRole' spec!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ;
                Break ;
            } ;
        } else {
            if($MGCntxt.isConnected){
                if($MgCntxt.isUser){
                    $TenantTag = $TenOrg = get-TenantTag -Credential $MgCntxt.Account ;
                    $uRoleReturn = resolve-UserNameToUserRole -UserName $MgCntxt.CertificateThumbprint -verbose:$($VerbosePreference -eq "Continue") ;
                    $credential = get-TenantCredentials -TenOrg $TenOrg -UserRole $uRoleReturn.UserRole -verbose:$($VerbosePreference -eq "Continue") ;
                } elseif($MgCntxt.isCBA -AND $MgCntxt.AppName -match 'CBACert-(\w{3})'){
                        #$MgCntxt.AppName.split('-')[-1]
                        $TenantTag = $TenOrg = $matches[1]
                        # also need credential
                        $uRoleReturn = resolve-UserNameToUserRole -UserName $MgCntxt.CertificateThumbprint -verbose:$($VerbosePreference -eq "Continue") ;
                        write-verbose "ret'd obj:$uRoleReturn = [ordered]@{     UserRole = $null ;     Service = $null ;     TenOrg = $null ; } " ;
                        $credRet = get-TenantCredentials -TenOrg $TenOrg -UserRole $uRoleReturn.UserRole -verbose:$($VerbosePreference -eq "Continue")
                        $credential = $credRet.Cred ;
                }else{
                    $smsg = "UNABLE TO RESOLVE mgContext to a working TenOrg!" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                }
            } ;
            $pltGTCred=@{TenOrg=$TenOrg ; UserRole=$null; verbose=$($verbose)} ;
            if($UserRole){
                $smsg = "(`$UserRole specified:$($UserRole -join ','))" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $pltGTCred.UserRole = $UserRole;
            } else {
                $smsg = "(No `$UserRole found, defaulting to:'CSVC','SID' " ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $pltGTCred.UserRole = 'CSVC','SID' ;
            } ;
            $smsg = "get-TenantCredentials w`n$(($pltGTCred|out-string).trim())" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            $o365Cred = get-TenantCredentials @pltGTCred
        } ;
        if($o365Cred.credType -AND $o365Cred.Cred -AND $o365Cred.Cred.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
            $smsg = "(validated `$o365Cred contains .credType:$($o365Cred.credType) & `$o365Cred.Cred.username:$($o365Cred.Cred.username)" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            write-verbose "populate $credential with return, if not populated (may be required for follow-on calls that pass common $Credentials through)" ;
            if((gv Credential) -AND $Credential -eq $null){
                $credential = $o365Cred.Cred ;
            }elseif($credential.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                $smsg = "(`$Credential is properly populated; explicit -Credential was in initial call)" ;
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            } else {
                $smsg = "`$Credential is `$NULL, AND $o365Cred.Cred is unusable to populate!" ;
                $smsg = "downstream commands will *not* properly pass through usable credentials!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ;
                break ;
            } ;
        } else {
            $smsg = "UNABLE TO RESOLVE FUNCTIONAL CredType/UserRole from specified explicit -Credential:$($Credential.username)!" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            break ;
        } ;
        $pltCMG = [ordered]@{
            Credential = $Credential ;
            verbose = $($VerbosePreference -eq "Continue")  ;
        } ;
        if((get-command Connect-MG).Parameters.keys -contains 'silent'){
            $pltCMG.add('Silent',$silent) ;
        } ;
        #endregion cMG_SCAFFOLD ; #*------^ END cMG_SCAFFOLD ^------

        #$ExMbxLicenses = get-ExoMailboxLicenses -verbose:$($VerbosePreference -eq "Continue")  ;
        # add outdetail & unfiltered support
        $ExMbxLicenses = get-ExoMailboxLicenses -Unfiltered -OutDetail -credential $pltRXO.Credential -verbose:$($VerbosePreference -eq "Continue")  ;
        # pull the full Tenant list, for performing sku-> name conversions
        #$lplist =  get-AADlicensePlanList -verbose -IndexOnName ;

        $pltGLPList=[ordered]@{ 
            TenOrg= $TenOrg;
            IndexOnName=$false ;
            Credential = $pltRXO.Credential ; 
            verbose = $pltRXO.verbose  ; 
            silent = $false ; 
        } ; 
        $smsg = "get-MGlicensePlanList w`n$(($pltGLPList|out-string).trim())" ; 
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

        # this *does* require working MG access logon. 
        $skus  = get-MGlicensePlanList @pltGLPList ;

        # check if using Pipeline input or explicit params:
        if ($PSCmdlet.MyInvocation.ExpectingInput) {
            write-verbose "Data received from pipeline input: '$($InputObject)'" ;
        } else {
            # doesn't actually return an obj in the echo
            write-verbose "Data received from parameter input:" # '$($InputObject)'" ;
        } ;
    } 
    PROCESS {
        if($ExMbxLicenses){
            $IsExoLicensed = $false ;
            foreach($pLic in $User.AssignedLicenses.skuid){
                $smsg = "(resolving $($plic) for EXO support)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                if($tsku = $skus[$pLic]){
                    if($xlic = $ExMbxLicenses[$tsku.SkuPartNumber]){
                        $IsExoLicensed = $true ;
                        $smsg = "$($User.userprincipalname) HAS EXO UserMailbox-supporting License:$($xlic.SKU)|$($xlic.Label)|$($tsku.skuid)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        break ; 
                    } ;
                } else { 
                    $smsg = "($($plic):mbx support no match)" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                } ; 
            } ;
        } else { 
            $smsg = "Unable to resolve get-ExoMailboxLicenses!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            throw $smsg ;
            Break ; 
        } ; 

    }  # PROC-E
    END{
        $IsExoLicensed | write-output ; 
    } ;
}

#*------^ test-EXOIsLicensed.ps1 ^------


#*------v test-EXOv2Connection.ps1 v------
function test-EXOv2Connection {
    <#
    .SYNOPSIS
    test-EXOv2Connection.ps1 - Validate EXO connection, and that the proper Tenant is connected (as per provided Credential)
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2022-06-24
    FileName    : test-EXOv2Connection.ps1
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-EXO
    Tags        : Powershell
    REVISIONS
    * 1:44 PM 7/9/2024 100% obsoleted by verb-EXO, test-EXOConnectionTDO(), which isn't a full emulation of this, so I'll leave this in place against obsolete calls to it.
    * 1:55 PM 3/1/2024 added code to repop empty $TenOrg, prior to AcceptedDom caching (came through empty in testing, when no preexisting conn)
    * 2:51 PM 2/26/2024 add | sort version | select -last 1  on gmos, LF installed 3.4.0 parallel to 3.1.0 and broke auth: caused mult versions to come back and conflict with the assignement of [version] type (would require [version[]] to accom both, and then you get to code everything for mult handling)
    * 3:26 PM 5/30/2023 updated CBH, demos ; # reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not
    * 11:20 AM 4/25/2023 added -CertTag param (passed by connect-exo; used for validating credential alignment w Tenant)
    * 10:28 AM 4/18/2023 #372: added -ea 0 to gv calls (not found error suppress)
    * 2:02 PM 4/17/2023 rev: $MinNoWinRMVersion from 2.0.6 => 3.0.0.
    * 3:58 PM 4/4/2023 reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not; 
    fixed flipped $IsNoWinRM ; supports EMOv2 v EMOv3 pss/no-pss connections, adds support for get-connectioninformation()
    * 3:14 pm 3/29/2023: REN'D $modname => $EOMModName
    * 3:54 PM 11/29/2022:  force the $MinNoWinRMVersion value to the currnet highest loaded:; 
    * 3:59 PM 8/2/2022 got through dbugging EOM v205 SID interactive pass, working ; fully works from mybox w v206p6, cEOM connection, with functional prefix. need to code in divert on cxo2 etc to avoid redundant tests and just do them here.
    * 3:30 PM 7/25/2022 fixed missing else for if #152; works in tests against CBA & SID interactive creds on EOM v205, need to debug now against EOM v206p6, to accomodate PSSession-less connect & test code.
    * 10:18 AM 6/24/2022 init ; ren test-EXOConnection -> test-EXOv2Connection, as this only validates EXOversion2 connections, not basic-auth-based EXOv1
    .DESCRIPTION
    test-EXOv2Connection.ps1 - Validate EXO connection, and that the proper Tenant is connected (as per provided Credential)
    .PARAMETER  Prefix
    [verb]-PREFIX[command] PREFIX string for clearly marking cmdlets sourced in this connection [-Prefix tag]
    .PARAMETER Credential
    Credential to be used for connection
    .PARAMETER CertTag
    Cert FriendlyName Suffix to be used for validating credential alignment(Optional but required for CBA calls)[-CertTag `$certtag]
    .PARAMETER MinNoWinRMVersion
    MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']
    .OUTPUT
    System.Boolean
    .EXAMPLE
    PS> $oRet = test-EXOv2Connection -Credential $cred -verbose ; 
    PS> if($oRet.Valid){
    PS>     $pssEXOv2 = $oRet.PsSession ; 
    PS>     write-host 'Validated EXOv2 Connected to Tenant aligned with specified Credential'
    PS> } else { 
    PS>     write-warning 'NO EXO USERMAILBOX TYPE LICENSE!'
    PS> } ; 
    Evaluate EXOv2 connection status & Tenant Credential alignment, (on defalt Xo Prefix connection) with verbose output
    .EXAMPLE
    PS> $TenOrg = get-TenantTag -Credential $Credential ;
    PS> if($Credential){
    PS>     $uRoleReturn = resolve-UserNameToUserRole -Credential $Credential
    PS> } elseif($UserPrincipalName){
    PS>     $uRoleReturn = resolve-UserNameToUserRole -UserName $UserPrincipalName
    PS> } ; 
    PS> if($uRoleReturn.TenOrg){
    PS>     $CertTag = $uRoleReturn.TenOrg
    PS> } ; 
    PS> if($CertTag -ne $null){
    PS>     $smsg = "(specifying detected `$CertTag:$($CertTag))" ;
    PS>     if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
    PS>     else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
    PS>     $oRet = test-EXOv2Connection -Credential $credential -CertTag $CertTag -verbose:$($verbose) ;
    PS> } else {
    PS>     $oRet = test-EXOv2Connection -Credential $credential -verbose:$($verbose) ;
    PS> } ;
    PS> if($oRet.Valid){
    PS>     $pssEXOv2 = $oRet.PsSession ;
    PS>     $IsNoWinRM = $oRet.IsNoWinRM ;
    PS>     $smsg = "(Validated EXOv2 Connected to Tenant aligned with specified Credential)" ;
    PS>     if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
    PS>     else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
    PS> } else {
    PS>     $smsg = "NO VALID EXOV2/3 PSSESSION FOUND! (DISCONNECTING...)"
    PS>     if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
    PS>     else{ write-host -ForegroundColor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    PS>     # capture outlier: shows a session wo the test cmdlet, force reset
    PS>     DisConnect-EXO ;
    PS>     $bExistingEXOGood = $false ;
    PS> } ;    
    Fancier demo using a variety of verb-Auth & verb-xo cmdlets (on defalt Xo Prefix connection)
    .EXAMPLE 
    PS>     $oRet = test-EXOv2Connection -Credential $credential -Prefix xo -verbose:$($verbose) ; 
    Demo connection test for explicit XO sessions (indicated by use of -Prefix xo, to focus on those prefixed sessions, default Prefix, but this demos explicitng the param).
    .EXAMPLE 
    PS>     $oRet = test-EXOv2Connection -Credential $credential -Prefix cc -verbose:$($verbose) ; 
    Demo connection test for CCMS sessions (indicated by use of -Prefix cc, to focus on those prefixed sessions).
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    #Requires -Version 3
    ##Requires -Modules AzureAD, verb-Text
    ##Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\sregex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    [CmdletBinding()]
     Param(
        [Parameter(HelpMessage = "[verb]-PREFIX[command] PREFIX string for clearly marking cmdlets sourced in this connection [-Prefix tag]")]
            [string]$Prefix = 'xo',
        #[Parameter(Mandatory=$True,HelpMessage="Credentials [-Credentials [credential object]]")]
        [Parameter(Mandatory=$false,HelpMessage="Credentials [-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential = $global:credo365TORSID,
        [Parameter(HelpMessage = "Cert FriendlyName Suffix to be used for validating credential alignment(Optional but required for CBA calls)[-CertTag `$certtag]")]
            [string]$CertTag,
        [Parameter(HelpMessage = "MinimumVersion required for Non-WinRM connections (of ExchangeOnlineManagement module (defaults to '3.0.0')[-MinimumVersion '2.0.6']")]
            [version] $MinNoWinRMVersion = '3.0.0'
    )
    BEGIN {
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        if(-not $rgxCertFNameSuffix){$rgxCertFNameSuffix = '-([A-Z]{3})$' } ; 
        #*------v PSS & GMO VARIS v------
        # get-pssession session varis
        # select key differentiating properties:
        $pssprops = 'Id','ComputerName','ComputerType','State','ConfigurationName','Availability', 
            'Description','Guid','Name','Path','PrivateData','RootModuleModule', 
            @{name='runspace.ConnectionInfo.ConnectionUri';Expression={$_.runspace.ConnectionInfo.ConnectionUri} },  
            @{name='runspace.ConnectionInfo.ComputerName';Expression={$_.runspace.ConnectionInfo.ComputerName} },  
            @{name='runspace.ConnectionInfo.Port';Expression={$_.runspace.ConnectionInfo.Port} },  
            @{name='runspace.ConnectionInfo.AppName';Expression={$_.runspace.ConnectionInfo.AppName} },  
            @{name='runspace.ConnectionInfo.Credentialusername';Expression={$_.runspace.ConnectionInfo.Credential.username} },  
            @{name='runspace.ConnectionInfo.AuthenticationMechanism';Expression={$_.runspace.ConnectionInfo.AuthenticationMechanism } },  
            @{name='runspace.ExpiresOn';Expression={$_.runspace.ExpiresOn} } ; 
        $EOMmodname = 'ExchangeOnlineManagement' ;
        $EXOv1ConfigurationName = $EXOv2ConfigurationName = $EXoPConfigurationName = "Microsoft.Exchange" ;

        if(-not $EXOv1ConfigurationName){$EXOv1ConfigurationName = "Microsoft.Exchange" };
        if(-not $EXOv2ConfigurationName){$EXOv2ConfigurationName = "Microsoft.Exchange" };
        if(-not $EXoPConfigurationName){$EXoPConfigurationName = "Microsoft.Exchange" };

        if(-not $EXOv1ComputerName){$EXOv1ComputerName = 'ps.outlook.com' };
        if(-not $EXOv1runspaceConnectionInfoAppName){$EXOv1runspaceConnectionInfoAppName = '/PowerShell-LiveID'  };
        if(-not $EXOv1runspaceConnectionInfoPort){$EXOv1runspaceConnectionInfoPort = '443' };

        if(-not $EXOv2ComputerName){$EXOv2ComputerName = 'outlook.office365.com' ;}
        if(-not $EXOv2Name){$EXOv2Name = "ExchangeOnlineInternalSession*" ; }
        if(-not $rgxEXoPrunspaceConnectionInfoAppName){$rgxEXoPrunspaceConnectionInfoAppName = '^/(exadmin|powershell)$'}; 
        if(-not $EXoPrunspaceConnectionInfoPort){$EXoPrunspaceConnectionInfoPort = '80' } ; 
        # gmo varis
        if(-not $rgxEXOv1gmoDescription){$rgxEXOv1gmoDescription = "^Implicit\sremoting\sfor\shttps://ps\.outlook\.com/PowerShell" }; 
        if(-not $EXOv1gmoprivatedataImplicitRemoting){$EXOv1gmoprivatedataImplicitRemoting = $true };
        if(-not $rgxEXOv2gmoDescription){$rgxEXOv2gmoDescription = "^Implicit\sremoting\sfor\shttps://outlook\.office365\.com/PowerShell" }; 
        if(-not $EXOv2gmoprivatedataImplicitRemoting){$EXOv2gmoprivatedataImplicitRemoting = $true } ;
        if(-not $rgxExoPsessionstatemoduleDescription){$rgxExoPsessionstatemoduleDescription = '/(exadmin|powershell)$' };
        if(-not $PSSStateOK){$PSSStateOK = 'Opened' };
        if(-not $PSSAvailabilityOK){$PSSAvailabilityOK = 'Available' };
        if(-not $EXOv1GmoFilter){$EXOv1GmoFilter = 'tmp_*' } ; 
        if(-not $EXOv2GmoNoWinRMFilter){$EXOv2GmoNoWinRMFilter = 'tmpEXO_*' };
        # add get-connectioninformation.ConnectionURI targeting rgxs for CCMS vs EXO
        if(-not $rgxConnectionUriEXO){$rgxConnectionUriEXO = 'https://outlook\.office365\.com'} ; 
        if(-not $rgxConnectionUriCCMS){$rgxConnectionUriCCMS = 'https://ps\.compliance\.protection\.outlook\.com'} ; 
        if(-not $prpConnInf){$prpConnInf = 'ModulePrefix','ConnectionId','ConnectionUri','State','TokenStatus'} ; 
        #*------^ END PSS & GMO VARIS ^------
        # reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not
        #region EOMREV ; #*------v EOMREV Check v------
        # reduced the ipmo and vers chk block, removed the lengthy gmo -list; and any autoinstall. Assume EOM is installed, & break if it's not
        $pltIMod = @{Name = $EOMmodname ; ErrorAction = 'Stop' ; verbose=$false} ;
        if($xmod = Get-Module $EOMmodname -ErrorAction Stop| sort version | select -last 1 ){ } else {
            $smsg = "Import-Module w`n$(($pltIMod|out-string).trim())" ;
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            Try {
                Import-Module @pltIMod | out-null ;
                $xmod = Get-Module $EOMmodname -ErrorAction Stop | sort version | select -last 1 ;
            } Catch {
                $ErrTrapd=$Error[0] ;
                $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $smsg = $ErrTrapd.Exception.Message ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Break ;
            } ;
        } ; # IsImported
        if([version]$xmod.version -ge $MinNoWinRMVersion){
            $MinNoWinRMVersion = $xmod.version.tostring() ;
            $IsNoWinRM = $true ; 
        }
        [boolean]$UseConnEXO = [boolean]([version]$xmod.version -ge $MinNoWinRMVersion) ; 
        #endregion EOMREV ; #*------^ END EOMREV Check  ^------

    } ;  # if-E BEGIN    
    PROCESS {
        # handling concurrent CCMS & EXO, there will be multiple conns returned by get-connectionstatus, so aggreg what comes back and return it
        $oReturnEXO = [ordered]@{
            PSSession = $null ; 
            IsNoWinRM = $false ; 
            Valid = $false ; 
            Prefix = $Prefix ; 
            isEXO = $false ; 
            isCCMS = $false ;
            ConnectionUri = $null ; 
        } ; 
        $oReturnCCMS = [ordered]@{
            PSSession = $null ; 
            IsNoWinRM = $false ; 
            Valid = $false ; 
            Prefix = $Prefix ; 
            isEXO = $false ; 
            isCCMS = $false ;
            ConnectionUri = $null ; 
        } ; 
        $oRetAggr = @() ; 
        $isEXOValid = $false ;
        # corrected $EXoPConfigurationName -> $EXOv2ConfigurationName; same value, but vari name should indicate purpose, as well as contents
        if($pssEXOv2 = Get-PSSession | 
                where-object {$_.ConfigurationName -like $EXOv2ConfigurationName -AND (
                    $_.Name -like $EXOv2Name) -AND (
                    $_.ComputerName -eq $EXOv2ComputerName) } ){
                    <# rem'd state/avail tests, run separately below: -AND (
                    $_.State -eq $PSSStateOK)  -AND (
                    $_.Availability -eq $PSSAvailabilityOK)
                    #>
            $smsg = "`n`nEXOv2 PSSessions:`n$(($pssEXOv2 | fl $pssprops|out-string).trim())" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

            if($pssEXOv2 | ?{ ($_.State -eq $PSSStateOK)  -AND (
                    $_.Availability -eq $PSSAvailabilityOK)}){

                # verify the exov2 cmdlets actually imported as a tmp_ module w specifid prefix & 1st cmdlet
                # below won't work with updated token support/MFA & loss of test|clear-ActiveToken from EOM (breaking change)
                # but it's needed when using EOM205, which still falls to basicauth! (readded down below)
                # revise for exov2 -cred support (where get-msaltoken gets used)
                # test-EXOToken & it's dependancy EOM:test-ActiveToken, *doesn't exist* after EOM v205!, if out the block
                if(-not $IsNoWinRM){
                    # Credential
                    $plttXT=[ordered]@{
                        Credential = $Credential ;
                        verbose = $($VerbosePreference -eq "Continue") ;
                    } ;
                    $smsg = "test-EXOToken w`n$(($plttXT|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ; 
                if ( (get-module -name $EXOv1GmoFilter | ForEach-Object {
                     Get-Command -module $_.name -name 'Add-xoAvailabilityAddressSpace' -ea 0 }) -AND (
                        test-EXOToken @plttXT)) {
                    $smsg = "(EXOv1Gmo Basic-Auth PSSession module detected)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $bExistingEXOGood = $true ;
                    # need as well, to get through if/then ahead of credential/tenant align check
                    $isEXOValid = $true ; 
                }elseif ( (get-module -name $EXOv2GmoNoWinRMFilter | ForEach-Object {
                    Get-Command -module $_.name -name 'Add-xoAvailabilityAddressSpace' -ea 0 }) -AND (
                        test-EXOToken @plttXT)) {
                    $smsg = "(EXOv2GmoNoWinRM module detected)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $bExistingEXOGood = $true ;
                    # need as well, to get through if/then ahead of credential/tenant align check
                    $isEXOValid = $true ; 
                } else { $bExistingEXOGood = $false ; }
                
                
            } else{
                # pss but disconnected state
                rxo2 ; 
            } ; 
            
        } elseif($IsNoWinRM -AND ((get-module $EXOv2GmoNoWinRMFilter) -AND (get-module $EOMmodname))){
            # no PSS and IsNoWinRM == v206+ PSS-less connection
            # verify the exov2 cmdlets actually imported as a tmp_ module w specifid prefix & 1st cmdlet

            # test-EXOToken() won't work with PSSession-less - it obtains the critical TokenExpireTime from the open PSSession
            # need to recode for these using get-aadtoken

            # 12:22 PM 8/1/2022 issue with get-msaltoken: it will auth EXO client app (by guid), but it doesn't support the key -prefix param, to make them verb-XOnoun; so you can't use it with hybrid onprem connections.
            # => looks like I'll have to either skip it, or test for cmdlets loaded, to verify. get-msaltoken actually runs an auth session, doesn't just validate one's present. 
            <# [PowerShell Gallery | MSAL.PS.psd1 4.1.0.2 - www.powershellgallery.com/](https://www.powershellgallery.com/packages/MSAL.PS/4.1.0.2/Content/MSAL.PS.psd1)
             nope, it's referring to 'virtual network address prefix'f
            #>
            # EOM v3 adds Get-ConnectionInformation, which has .tokenStatus -eq 'Active'

            if(-not (get-command -mod $EOMmodname -name Get-ConnectionInformation -ea 0 )){
                $smsg = "(found txo, *not* sourced from EOM: ipmo -forcing EOM)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                remove-module -Name $EOMmodname -force ; 
                import-module -Name $EOMmodname -force -RequiredVersion $MinNoWinRMVersion ; 
            } ; 

            #if($xmod | Where-Object {$_.version -ge 3} ){ # won't resolve to version, have to 
            #if(($xmod.version -ge [version]("{0}.{1}.{2}" -f 3, 0, 0))){
            #if($xmod | Where-Object {$_.version.major -ge 3} ){
            if($xmod | where-object {$_.version -ge $MinNoWinRMVersion} ){
                $smsg = "EOM v3+ connection detected" ;
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                TRY{
                    $conns = Get-ConnectionInformation -ea STOP ;
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    throw $smsg ;
                    BREAK ;
                } ;
                if($Prefix){
                    $conns = $conns | ?{$_.ModulePrefix -eq $Prefix} ;
                } ;
                # 3:48 PM 6/27/2024there's two connection uri's there; it's possible both would be connected, need to accomodate the combo: need to loop them:
                # exo should never connect with -prefix 'cc', but still should loop them


                foreach($conn in $conns){

                    foreach($CUri in $conn.ConnectionUri){
                        switch -regex ($CUri){
                            $rgxConnectionUriEXO {
                                #if ($oRet.Valid -AND $oRet.isEXO){
                                    $oReturnEXO.isexo = $true ; 
                                    $oReturnEXO.ConnectionUri = $CUri ;
                                    $smsg = "connected to EXO" ;
                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                    $bExistingEXOGood = $isEXOValid = $true ;
                                #} ;
                            }
                            $rgxConnectionUriCCMS {
                                #if ($oRet.Valid -AND $oRet.isCCMS){
                                    $smsg = "connected to CCMS" ;
                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                    $oReturnCCMS.isCCMS = $true ; 
                                    $oReturnCCMS.ConnectionUri = $CUri ; 
                                    $bExistingCCMSGood = $isCCMSValid = $true ;
                                #} ;
                            }
                            default {
                                $bExistingEXOGood = $isEXOValid = $bExistingCCMSGood = $isCCMSValid = $FALSE ;
                                $smsg = "unreconized test-EXOv2Connection returned:`$oRet.ConnectionUri:$($oRet.ConnectionUri)!"
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            }
                        } ; 
                    } ; 
                    $oRetAggr += $oReturn
                } ; 
                
            } else {  
                $smsg = "EOM v205p6+ connection detected" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                # it seamlessly reauths, wo prompts, so just validate a core cmdlet is loaded, plust the above
                if([boolean](get-command -name Get-xoOrganizationConfig)){
                    $smsg = "(`IsNoWinRM:`$true`nget-module:$($EXOv2GmoNoWinRMFilter)`nget-module:$($EOMmodname)`ngcm:Get-xoOrganizationConfig`n=>Appears Valid)" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

                    $bExistingEXOGood = $isEXOValid = $true ;
                    #$IsNoWinRM = $true ; # already tested above
                } else { 
                    $bExistingEXOGood = $isEXOValid = $false ;
                } ; 

            } ;
        } else { 
            $smsg = "Unable to detect EXOv2 or EXOv3 PSSession!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-host -ForegroundColor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            #throw $smsg ;
            #Break ; 
            $bExistingEXOGood = $isEXOValid = $false ; 
        } ; 

        if( ($bExistingEXOGood -ANd $isEXOValid) -OR ($bExistingCCMSGood -eq $isCCMSValid)){
            #if($conns.ConnectionUri){
            #    $oReturn.ConnectionUri = $conns.ConnectionUri ; 
            #} ;
            foreach($conn in $conns){ 
                switch -regex ($conns.ConnectionUri){
                    $rgxConnectionUriEXO {
                        
                        #$oReturn.isEXO = $true ;
                        # implement caching of accepteddoms into the XXXMeta, in the session (cut back on queries to EXO on acceptedom)
                        if( get-command Get-xoAcceptedDomain -ea 0) {
                                #$TenOrg = get-TenantTag -Credential $Credential ;
                                # 1:10 PM 3/1/2024 Tenorg coming through unpopulated (after pulling legacy code), conditionally re-use the above rem:
                                if( (-not $TenOrg) -AND $Credential){ $TenOrg = get-TenantTag -Credential $Credential } ; 
                            if(-not (Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_AcceptedDomains){
                                set-Variable  -name "$($TenOrg)Meta" -value ( (Get-Variable  -name "$($TenOrg)Meta" -ea 0).value += @{'o365_AcceptedDomains' = (Get-xoAcceptedDomain).domainname} )
                            } ;
                        } ;
                    }
                    $rgxConnectionUriCCMS {
                        #$oReturn.isCCMS = $true ;
                        $smsg = "(No accdom caching on CCMS)" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    }
                    default {
                        #$bExistingEXOGood = $isEXOValid = $bExistingCCMSGood = $isCCMSValid = $FALSE ; 
                    }
                } ; 
            } ; 
    `       $smsg = "(validating Tenant:Credential alignment)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            
            if($credential.username -match $rgxCertThumbprint -AND $certTag -eq $null){
                $smsg = "CBA Certificate Thumprint cred uname detected, but -CertTag was *not* pass thru in call!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                break ; 
            } 
            if( ($credential.username -match $rgxCertThumbprint) -AND ((Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_Prefix -eq $certTag )){
                # 9:59 AM 6/24/2022 need a case for CBA cert (thumbprint username)
                # compare cert fname suffix to $xxxMeta.o365_Prefix
                # validate that the connected EXO is to the CBA Cert tenant

                foreach($conn in $conns){
                    switch -regex ($conn.ConnectionUri){
                        $rgxConnectionUriEXO {
                            $bExistingEXOGood = $isEXOValid = $true ;
                            $smsg = "(EXO Authenticated & Functional CBA cert:$($certTag),($($certUname)))" ;
                            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        }
                        $rgxConnectionUriCCMS {
                            $bExistingCCMSGood = $isCCMSValid = $true ; 
                            $smsg = "(CCMS Authenticated & Functional CBA cert:$($certTag),($($certUname)))" ;
                            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        }
                        default {
                            $bExistingEXOGood = $isEXOValid = $bExistingCCMSGood = $isCCMSValid = $FALSE ; 
                        }
                    } ;
                } ; 
            #}elseif((Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_AcceptedDomains.contains($Credential.username.split('@')[1].tostring())){
            # pretest that accdoms is populated before trying to parse it
            }elseif( (Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_AcceptedDomains -AND (Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_AcceptedDomains.contains($Credential.username.split('@')[1].tostring()) ){
                # validate that the connected EXO is to the $Credential tenant
                $smsg = "(EXO Authenticated & Functional:$($Credential.username.split('@')[1].tostring())),($($Credential.username))" ;
                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $bExistingEXOGood = $isEXOValid = $true ;
            # issue: found fresh bug in cxo: svcacct UPN suffix @tenantname.onmicrosoft.com, but testing against AccepteDomain, it's not in there (tho @DOMAIN.mail.onmicrosoft.comis)
            #}elseif((Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_TenantDomain -eq ($Credential.username.split('@')[1].tostring())){
            # SID comes through with non onmicrosoft domain, need to test the o365_OPDomain as well, to get through these
            }elseif( ( (Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_TenantDomain -eq ($Credential.username.split('@')[1].tostring()) ) -OR ((Get-Variable  -name "$($TenOrg)Meta" -ea 0).value.o365_OPDomain -eq ($Credential.username.split('@')[1].tostring())) ){
                $smsg = "(EXO Authenticated & Functional(TenDom):$($Credential.username.split('@')[1].tostring()))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $bExistingEXOGood = $isEXOValid = $true ;
            } else {
                $smsg = "(Credential mismatch:disconnecting from existing EXO:$($eEXO.Identity) tenant)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $tIn = '4/18/2024;D:\scripts\Disconnect-exo_func.ps1' ;
                $tdt,$tsrc =  $tIn.split(';') ;
                $tdt=[datetime]$tdt ;
                if($psise -and (get-date ).date -eq $tdt){
                    $gcm = gcm (split-path $tsrc -leaf).replace('_func.ps1','') ;
                    if( $gcm -AND $gcm.source -ne ''){
                            gci function:$((split-path $tsrc -leaf).replace('_func.ps1','')) -ea 0| remove-item -force ;
                            ipmo -fo -verb $tsrc;
                    } else {write-host "(non-Mod vers loaded)"} ;
                } ; 
                Disconnect-exo ;
                $bExistingEXOGood = $isEXOValid = $false ;
            } ;

            if($bExistingEXOGood -AND $isEXOValid){
                $oReturnEXO.PSSession = $pssEXOv2 ; 
                if( ($IsNoWinRM -eq $true) -AND -not $pssEXOv2){
                    $smsg = "IsNoWinRM & no detected EXO PsSession:" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    $oReturnEXO.IsNoWinRM = $IsNoWinRM
                }
                $oReturnEXO.Valid = $isEXOValid ; 
            }elseif($bExistingCCMSGood -AND $isCCMSValid){
                $oReturnCCMS.PSSession = $pssEXOv2 ; 
                if( ($IsNoWinRM -eq $true) -AND -not $pssEXOv2){
                    $smsg = "IsNoWinRM & no detected EXO PsSession:" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    $oReturnCCMS.IsNoWinRM = $IsNoWinRM
                }
                $oReturnCCMS.Valid = $isEXOValid ;
            } else {
                $pltDXO=[ordered]@{
                    #erroraction = 'STOP' ;
                } ;
                if($Prefix){
                    $pltDXO.Prefix = $Prefix
                } ; 
                $smsg = "Disconnect-exo w`n$(($pltDXO|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $smsg = "(invalid session `$bExistingEXOGood:$($bExistingEXOGood) -OR `$isEXOValid:$($isEXOValid))" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $tIn = '4/18/2024;D:\scripts\Disconnect-exo_func.ps1' ;
                $tdt,$tsrc =  $tIn.split(';') ;
                $tdt=[datetime]$tdt ;
                if($psise -and (get-date ).date -eq $tdt){
                    $gcm = gcm (split-path $tsrc -leaf).replace('_func.ps1','') ;
                    if( $gcm -AND $gcm.source -ne ''){
                        gci function:$((split-path $tsrc -leaf).replace('_func.ps1','')) -ea 0| remove-item -force ;
                        ipmo -fo -verb $tsrc;
                    } else {write-host "(non-Mod vers loaded)"} ;
                } ; 
                Disconnect-exo @pltDXO ; 
            } ;  ; 
        } else { 
            #$oReturn.PSSession = $pssEXOv2 ; 
            #$oReturn.Valid = $isEXOValid ; 
            $oReturnEXO.PSSession = $pssEXOv2 ; 
            if( ($IsNoWinRM -eq $true) -AND -not $pssEXOv2){
                $smsg = "IsNoWinRM & no detected EXO PsSession:" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $oReturnEXO.IsNoWinRM = $IsNoWinRM
            }
            $oReturnEXO.Valid = $isEXOValid ; 
        } ; 

    }  # PROC-E
    END{
        <# $oReturn = [ordered]@{
            PSSession = $null ; 
            Valid = $false ; 
        } ; 
        #>
        if($oReturnEXO.ConnectionUri){
            $oRetAggr += New-Object PSObject -Property $oReturnEXO
        } ; 
        if($oReturnCCMS.ConnectionUri){
            $oRetAggr += New-Object PSObject -Property $oReturnCCMS
        } ; 
        if(-not $oReturnEXO.ConnectionUri -AND -not $oReturnCCMS.ConnectionUri){
            # send a stock dummy back

            $oRetAggr += New-Object PSObject -Property @{
                PSSession = $null ;
                IsNoWinRM = $false ;
                Valid = $false ;
                Prefix = $Prefix ;
                isEXO = $false ;
                isCCMS = $false ;
                ConnectionUri = $null ;
            } ;
        } ; 
        #$smsg = "Returning `$oReturn:`n$(($oReturn|out-string).trim())" ; 
        $smsg = "Returning `$oRetAggr:`n$(($oRetAggr|out-string).trim())" ; 
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        #New-Object PSObject -Property $oReturn | write-output ; 
        $oRetAggr | write-output ; 
    } ;
}

#*------^ test-EXOv2Connection.ps1 ^------


#*------v test-xoMailbox.ps1 v------
Function test-xoMailbox {
    <#
    .SYNOPSIS
    test-xoMailbox.ps1 - Run quick mailbox function validation and metrics gathering, to streamline, 'Is it working?' questions. 
    .NOTES
    Version     : 10.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-04-21
    FileName    : test-xoMailbox.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell,ExchangeOnline,Exchange,Resource,MessageTrace
    REVISIONS
    # 2:49 PM 3/8/2022 pull Requires -modules ...verb-ex2010 ref - it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    * 2:40 PM 12/10/2021 more cleanup 
    * 8:41 AM 8/27/2021 cleanup comments
    * 1:51 PM 5/19/2021 expanded $pltGHOpCred= to include 'ESVC','SID'; verbose=$($verbose)} ;
    # 12:27 PM 5/11/2021 updated to cover Room|Shared|Equipment mbx types, along with UserMailbox
    # 3:47 PM 5/6/2021 recoded start-log switching, was writing logs into AllUsers profile dir ; swapped out 'Fail' msgtrace expansion, and have it do all non-Delivery statuses, up to the $MsgTraceNonDeliverDetailsLimit = 10; tested, appears functional
    # 3:15 PM 5/4/2021 added trailing |?{$_.length} bug workaround for get-gcfastxo.ps1
    * 4:20 PM 4/29/2021 debugged, looks functional - could benefit from moving the msgtrk summary down into the output block, but [shrug]
    * 7:56 AM 4/28/2021 init
    .DESCRIPTION
    test-xoMailbox.ps1 - Run quick mailbox function validation and metrics gathering, to streamline, 'Is it working?' questions. 
    .PARAMETER Mailboxes
    Array of Mailbox email addresses [-Mailboxes mbx1@domain.com]
    .PARAMETER Ticket
    Ticket # [-Ticket nnnnn]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    .EXAMPLE
    test-xoMailbox.ps1 -TenOrg TOR -Mailboxes 'Fname.LName@domain.com','FName2.Lname2@domain.com' -Ticket 610706 -verbose ;
    .EXAMPLE
    .\test-xoMailbox.ps1
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    ##Requires -Modules ActiveDirectory,verb-Auth,verb-IO,verb-Mods,verb-Text,verb-Network,verb-AAD,verb-ADMS,verb-Ex2010,verb-logging
    # 2:49 PM 3/8/2022 pull verb-ex2010 ref - I think it's generating nested errors, when ex2010 requires exo requires ex2010 == loop.
    #Requires -Modules ActiveDirectory,verb-Auth,verb-IO,verb-Mods,verb-Text,verb-Network,verb-AAD,verb-ADMS,verb-logging
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
        [ValidateNotNullOrEmpty()]
        $TenOrg = 'TOR',
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Array of EXO Mailbox identifiers to be processed [-mailboxes 'xxx','yyy']")]
        [ValidateNotNullOrEmpty()]$Mailboxes,
        [Parameter(Mandatory = $True, HelpMessage = "Ticket # [-Ticket nnnnn]")]
        [array]$Tickets,
        [Parameter(Position=0,Mandatory=$False,HelpMessage="Specific ResourceDelegate address to be confirmed for detailed delivery [emailaddr]")]
        [ValidateNotNullOrEmpty()][string]$TargetDelegate,
        [Parameter(Mandatory=$false,HelpMessage="Days back to search (defaults to 10)[-Days 10]")]
        [int]$Days=10,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2
    ) ;
    BEGIN {
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        #*======v SCRIPT/DOMAIN/MACHINE/INITIALIZATION-DECLARE-BOILERPLATE v======
        # SCRIPT-CONFIG MATERIAL TO SET THE UNDERLYING $DBGPREF:
        if ($ShowDebug) { $DebugPreference = "Continue" ; write-debug "(`$showDebug:$showDebug ;`$DebugPreference:$DebugPreference)" ; };
        if ($Whatif) { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):`$Whatif is TRUE (`$whatif:$($whatif))" ; };
        # If using WMI calls, push any cred into WMI:
        #if ($Credential -ne $Null) {$WmiParameters.Credential = $Credential }  ;

        <# scriptname with extension
        $ScriptDir = (Split-Path -parent $MyInvocation.MyCommand.Definition) + "\" ;
        $ScriptBaseName = (Split-Path -Leaf ((& { $myInvocation }).ScriptName))  ;
        $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
        #>
        # 11:24 AM 6/21/2019 UPDATED HYBRID VERS
        if($showDebug){
            write-host -foregroundcolor green "`SHOWDEBUG: `$PSScriptRoot:$($PSScriptRoot)`n`$PSCommandPath:$($PSCommandPath)" ;
        } ;
        if ($psISE){
                $ScriptDir = Split-Path -Path $psISE.CurrentFile.FullPath ;
                $ScriptBaseName = split-path -leaf $psise.currentfile.fullpath ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($psise.currentfile.fullpath) ;
                        $PSScriptRoot = $ScriptDir ;
                if($PSScriptRoot -ne $ScriptDir){ write-warning "UNABLE TO UPDATE BLANK `$PSScriptRoot TO CURRENT `$ScriptDir!"} ;
                $PSCommandPath = $psise.currentfile.fullpath ;
                if($PSCommandPath -ne $psise.currentfile.fullpath){ write-warning "UNABLE TO UPDATE BLANK `$PSCommandPath TO CURRENT `$psise.currentfile.fullpath!"} ;
        } else {
            if($host.version.major -lt 3){
                $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                $PSCommandPath = $myInvocation.ScriptName ;
                $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
            } elseif($PSScriptRoot) {
                $ScriptDir = $PSScriptRoot ;
                if($PSCommandPath){
                    $ScriptBaseName = split-path -leaf $PSCommandPath ;
                    $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($PSCommandPath) ;
                } else {
                    $PSCommandPath = $myInvocation.ScriptName ;
                    $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                    $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
                } ;
            } else {
                if($MyInvocation.MyCommand.Path) {
                    $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                    $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                    $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
                } else {
                    throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" ;
                } ;
            } ;
        } ;
        if($showDebug){
            write-host -foregroundcolor green "`SHOWDEBUG: `$ScriptDir:$($ScriptDir)`n`$ScriptBaseName:$($ScriptBaseName)`n`$ScriptNameNoExt:$($ScriptNameNoExt)`n`$PSScriptRoot:$($PSScriptRoot)`n`$PSCommandPath:$($PSCommandPath)" ;
        } ;
    
        $ComputerName = $env:COMPUTERNAME ;
        $sQot = [char]34 ; $sQotS = [char]39 ;
        $NoProf = [bool]([Environment]::GetCommandLineArgs() -like '-noprofile'); # if($NoProf){# do this};
        #$ProgInterval= 500 ; # write-progress wait interval in ms
        # 12:23 PM 2/20/2015 add gui vb prompt support
        #[System.Reflection.Assembly]::LoadWithPartialName('Microsoft.VisualBasic') | Out-Null ;
        # 11:00 AM 3/19/2015 should use Windows.Forms where possible, more stable

        switch -regex ($env:COMPUTERNAME) {
            ($rgxMyBox) { $LocalInclDir = "c:\usr\work\exch\scripts" ; }
            ($rgxProdEx2010Servers) { $LocalInclDir = "c:\scripts" ; }
            ($rgxLabEx2010Servers) { $LocalInclDir = "c:\scripts" ; }
            #($rgxProdL13Servers) { $LocalInclDir = "c:\scripts" ; }
            # ($rgxLabL13Servers) { $LocalInclDir = "c:\scripts" ; }
            ($rgxAdminJumpBoxes) { $LocalInclDir = (split-path $profile) ; }
        } ;

        $Retries = 4 ;
        $RetrySleep = 5 ;
        $DawdleWait = 30 ; # wait time (secs) between dawdle checks
        $DirSyncInterval = 30 ; # AADConnect dirsync interval 

        # email trigger vari, it will be semi-delimd list of mail-triggering events
        $PassStatus = $null ;


        $bMaintainEquipementLists = $false ; 
        $MsgTraceNonDeliverDetailsLimit = 10 ; # number of non status:Delivered messages to check/dump
    
        $ModMsgWindowMins = 5 ;
        if(!$Retries){$Retries = 4 } ;
        if(!$RetrySleep){$RetrySleep = 5} ;

         #$rgxOnMSAddr='.*.mail\.onmicrosoft\.com' ;
        # cover either mail. or not
        $rgxOnMSAddr = '.*@\w*((\.mail)*)\.onmicrosoft.com'
        $rgxExoSysFolders = '.*\\(Recipient\sCache|PersonMetadata|Audits|Calendar\sLogging|Purges)$'
            #'.*\\(Recipient\sCache|PersonMetadata|Audits|Calendar\sLogging|Purges|GAL\sContacts|Yammer\sRoot|Recoverable\sItems|Deletions|Versions)'
        #$rgxExcl = '.*\\(Recipient\sCache|PersonMetadata|Audits|Calendar\sLogging|Purges)$' ;

        $rgxSID = "^S-\d-\d+-(\d+-){1,14}\d+$" ;
        $rgxEntLicGrps = $TORMeta.rgxLicGrpDN ; 

        $propsXmbx = 'UserPrincipalName','Alias','ExchangeGuid','Database','ExternalDirectoryObjectId','RemoteRecipientType'
        $propsOPmbx = 'UserPrincipalName','SamAccountName','RecipientType','RecipientTypeDetails' ; 
        $propsRmbx = 'UserPrincipalName','ExchangeGuid','RemoteRoutingAddress','RemoteRecipientType' ;
        #$propNames = "SamAccountName","UserPrincipalName","name","mailNickname","msExchHomeServerName","mail","msRTCSIP-UserEnabled","msRTCSIP-PrimaryUserAddress","msRTCSIP-Line","DistinguishedName","Description","info","Enabled","LastLogonDate","userAccountControl","manager","whenChanged","whenCreated","msExchRecipientDisplayType","msExchRecipientTypeDetails","City","Company","Country","countryCode","Office","Department","Division","EmailAddress","employeeType","State","StreetAddress","surname","givenname","telephoneNumber" ;
        #$propNames = "SamAccountName","UserPrincipalName","name","mailNickname","msExchHomeServerName","mail","msRTCSIP-UserEnabled","msRTCSIP-PrimaryUserAddress","msRTCSIP-Line","DistinguishedName","Description","info","Enabled","LastLogonDate","userAccountControl","manager","whenChanged","whenCreated","msExchRecipientDisplayType","msExchRecipientTypeDetails","City","Company","Country","countryCode","Office","Department","Division","EmailAddress","employeeType","State","StreetAddress","surname","givenname","telephoneNumber" ;
        #$adprops = "samaccountname", "msExchRemoteRecipientType", "msExchRecipientDisplayType", "msExchRecipientTypeDetails", "userprincipalname" ;
        $adprops = "samaccountname","UserPrincipalName","memberof","msExchMailboxGuid","msexchrecipientdisplaytype","msExchRecipientTypeDetails","msExchRemoteRecipientType"
        $propsmbxfldrs = @{Name='Folder'; Expression={$_.Identity.tostring()}},@{Name='Items'; Expression={$_.ItemsInFolder}}, @{n='SizeMB'; e={($_.FolderSize.tostring().split('(')[1].split(' ')[0].replace(',','')/1MB).ToString('0.000')}}, @{Name='OldestItem'; Expression={get-date $_.OldestItemReceivedDate -f 'yyyy/MM/dd'}},@{Name='NewestItem'; Expression={get-date $_.NewestItemReceivedDate -f 'yyyy/MM/dd'}} ;
        $propsMsgTrc = @{N='ReceivedLocal';E={$_.Received.ToLocalTime()}},'SenderAddress','RecipientAddress','Subject','Status','ToIP','FromIP','Size','MessageId','MessageTraceId','Index' ; 
        $propsMsgTrcDtl = 'Date','Event','Action','Detail','Data' ;  
        $msgprops = 'Received','SenderAddress','RecipientAddress','Subject','Status' # ,'MessageId','MessageTraceId' ;
        $mtdprops = 'Date','Event','Detail','data' ;
    
        #*======v HELPER FUNCTIONS v======

        #-------v Function _cleanup v-------
        function _cleanup {
            # clear all objects and exit
            # Clear-item doesn't seem to work as a variable release

            # 12:58 PM 7/23/2019 spliced in chunks from same in maintain-restrictedothracctsmbxs.ps1
            # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
            # 8:45 AM 10/13/2015 reset $DebugPreference to default SilentlyContinue, if on
            # # 8:46 AM 3/11/2015 at some time from then to 1:06 PM 3/26/2015 added ISE Transcript
            # 8:39 AM 12/10/2014 shifted to stop-transcriptLog function
            # 7:43 AM 1/24/2014 always stop the running transcript before exiting

            write-verbose "_cleanup" ; 
            <# transcript/log are handled in the mbx loop
            #stop-transcript
            # 11:16 AM 1/14/2015 aha! does this return a value!??
            if ($host.Name -eq "Windows PowerShell ISE Host") {
                # 8:46 AM 3/11/2015 shift the logfilename gen out here, so that we can arch it
                #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -uformat "%Y%m%d-%H%M" ) + "-ISEtrans.log")) ;
                # 2:16 PM 4/27/2015 shift to static timestamp $timeStampNow
                #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + $timeStampNow + "-ISEtrans.log")) ;
                # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
                $Logname = (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -format 'yyyyMMdd-HHmmtt') + "-ISEtrans.log")) ;
                write-host "`$Logname: $Logname";
                Start-iseTranscript -logname $Logname ;
                #Archive-Log $Logname ;
                # 1:23 PM 4/23/2015 standardize processing file so that we can send a link to open the transcript for review
                $transcript = $Logname
            } else {
                write-verbose "$(get-timestamp):Stop Transcript" ;
                Stop-TranscriptLog ;
                #write-verbose "$(get-timestamp):Archive Transcript" ;
                #Archive-Log $transcript ;
            } # if-E
            
            # also echo the log:
            if ($logging) { 
                # Write-Log -LogContent $smsg -Path $logfile
                $smsg = "`$logging:`$true:written to:`n$($logfile)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
            #>

            # need to email transcript before archiving it
            
            #$smtpSubj= "Proc Rpt:$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"   ;

            #Load as an attachment into the body text:
            #$body = (Get-Content "path-to-file\file.html" ) | converto-html ;
            #$SmtpBody += ("Pass Completed "+ [System.DateTime]::Now + "`nResults Attached: " +$transcript) ;
            # 4:07 PM 10/11/2018 giant transcript, no send
            #$SmtpBody += "Pass Completed $([System.DateTime]::Now)`nResults Attached:($transcript)" ;
            $SmtpBody += "Pass Completed $([System.DateTime]::Now)`nTranscript:($transcript)" ;
            # 12:55 PM 2/13/2019 append the $PassStatus in for reference
            if($PassStatus ){
                $SmtpBody += "`n`$PassStatus triggers:: $($PassStatus)`n" ;
            } ;
            $SmtpBody += "`n$('-'*50)" ;
            #$SmtpBody += (gc $outtransfile | ConvertTo-Html) ;
            # name $attachment for the actual $SmtpAttachment expected by Send-EmailNotif
            #$SmtpAttachment=$transcript ;
            # 1:33 PM 4/28/2017 test for ERROR|CHANGE - actually non-blank, only gets appended to with one or the other
            if($PassStatus ){
                Send-EmailNotif ;
            } else {
                write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):No Email Report: `$Passstatus is `$null ; " ;
            } ;

            
            #$smsg= "#*======^ END PASS:$($ScriptBaseName) ^======" ;
            #this is now a function, use: ${CmdletName}
            $smsg= "#*======^ END PASS:$(${CmdletName}) ^======" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn

            Break
        } #*------^ END Function _cleanup ^------


        #*======^ END HELPER FUNCTIONS ^======

        #*======v SUB MAIN v======

        # email trigger vari, it will be semi-delimd list of mail-triggering events
        $script:PassStatus = $null ;
        $Alltranscripts = @() ;

        # defer transcript until mbx loop
    
        #-=-=configure EXO EMS aliases to cover useEXOv2 requirements-=-=-=-=-=-=
        # have to preconnect, as it gcm's the targets
        if ($script:useEXOv2) { reconnect-eXO2 }
        else { reconnect-EXO } ;
        # in this case, we need an alias for EXO, and non-alias for EXOP
        [array]$cmdletMaps = 'ps1GetxRcp;get-exorecipient;','ps1GetxMbx;get-exomailbox;','ps1SetxMbx;Set-exoMailbox;','ps1GetxUser;get-exoUser;',
            'ps1SetxCalProc;set-exoCalendarprocessing;','ps1GetxCalProc;get-exoCalendarprocessing;','ps1GetxMbxFldrPerm;get-exoMailboxfolderpermission;',
            'ps1GetxAccDom;Get-exoAcceptedDomain;','ps1GetXRetPol;Get-exoRetentionPolicy','ps1GetxDistGrp;get-exoDistributionGroup;',
            'ps1GetxDistGrpMbr;get-exoDistributionGroupmember;','ps1GetxMsgTrc;get-exoMessageTrace;','ps1GetxMsgTrcDtl;get-exoMessageTraceDetail;',
            'ps1GetxMbxFldrStats;get-exoMailboxfolderStatistics','ps1GetxMContact;Get-exomailcontact;','ps1SetxMContact;Set-exomailcontact;',
            'ps1NewxMContact;New-exomailcontact;' ,'ps1TestxMapi;Test-exoMAPIConnectivity' ;
        foreach($cmdletMap in $cmdletMaps){
            if($script:useEXOv2){
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1].replace('-exo','-xo') )){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;
                write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
            } else {
                if(!($cmdlet= Get-Command $cmdletMap.split(';')[1])){ throw "unable to gcm Alias definition!:$($cmdletMap.split(';')[1])" ; break }
                $nalias = set-alias -name ($cmdletMap.split(';')[0]) -value ($cmdlet.name) -passthru ;                
                write-verbose "$($nalias.Name) -> $($nalias.ResolvedCommandName)" ;
            } ;
        } ;
    
        # shifting from ps1 to a function: need updates self-name:
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;

        #$sBnr="#*======v START PASS:$($ScriptBaseName) v======" ; 
        $sBnr="#*======v START PASS:$(${CmdletName}) v======" ; 
        $smsg= $sBnr ;   
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;


        # steer all onprem code on $XXXMeta.ExOPAccessFromToro & Ex10Server values
        $UseOP=$false ; 
        if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
            $UseOP = $true ; 
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ; 
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } else { 
            $UseOP = $false ; 
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ; 
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; 

        $useEXO = $true ; # non-dyn setting, drives variant EXO reconnect & query code
        if($useEXO){
            #*------v GENERIC EXO CREDS & SVC CONN BP v------
            # o365/EXO creds
            <### Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile* 
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
            Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
            Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred=get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
            Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            ###>
            $o365Cred=$null ;
            
            if($o365Cred=(get-TenantCredentials -TenOrg $TenOrg -UserRole 'CSVC','SID' -verbose:$($verbose))){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
                $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                Break ;
            } ;
            <### CALLS ARE IN FORM: (cred$($tenorg))
            $pltRXO = @{Credential = $Credential ; verbose = $($verbose) ; }
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                verbose = $($verbose) ; } ; 
            if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
            else { reconnect-EXO @pltRXO } ;
            # or with Tenant-specific cred($Tenorg) lookup
            #$pltRXO creds & .username can also be used for AzureAD connections 
            Connect-AAD @pltRXO ; 
            ###>
            # configure splat for connections: (see above useage)
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                verbose = $($verbose) ; } ; 
            #*------^ END GENERIC EXO CREDS & SVC CONN BP ^------
        } # if-E $useEXO

        if($UseOP){
            #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
            # do the OP creds too
            $OPCred=$null ;
            # default to the onprem svc acct
            $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC','SID'; verbose=$($verbose)} ;
            if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                Break ;
            } ;
            $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;  
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            <# CALLS ARE IN FORM: (cred$($tenorg))
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                verbose = $($verbose) ; }
            ReConnect-Ex2010XO @pltRX10 ; # cross-prem conns
            Reconnect-Ex2010 @pltRX10 ; # local org conns
            #$pltRx10 creds & .username can also be used for local ADMS connections
            #>
            $pltRX10 = @{
                Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                verbose = $($verbose) ; } ;     
            # TEST
        
            # defer cx10/rx10, until just before get-recipients qry
            #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
            # connect to ExOP X10
            if($pltRX10){
                #ReConnect-Ex2010XO @pltRX10 ;
                ReConnect-Ex2010 @pltRX10 ;
            } else { Reconnect-Ex2010 ; } ; 
        } ;  # if-E $useEXOP

        <# already confirmed in modloads
        # load ADMS
        $reqMods += "load-ADMS".split(";") ;
        if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
        #>
        write-host -foregroundcolor gray  "(loading ADMS...)" ;
        #write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):MSG" ; 

        load-ADMS ;

        if($UseOP){
            # resolve $domaincontroller dynamic, cross-org
            # setup ADMS PSDrives per tenant 
            if(!$global:ADPsDriveNames){
                $smsg = "(connecting X-Org AD PSDrives)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $global:ADPsDriveNames = mount-ADForestDrives -verbose:$($verbose) ;
            } ; 
            if(($global:ADPsDriveNames|measure).count){
                $useEXOforGroups = $false ; 
                $smsg = "Confirming ADMS PSDrives:`n$(($global:ADPsDriveNames.Name|%{get-psdrive -Name $_ -PSProvider ActiveDirectory} | ft -auto Name,Root,Provider|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                # returned object
                #         $ADPsDriveNames
                #         UserName                Status Name        
                #         --------                ------ ----        
                #         DOM\Samacctname   True  [forestname wo punc] 
                #         DOM\Samacctname   True  [forestname wo punc]
                #         DOM\Samacctname   True  [forestname wo punc]
        
            } else { 
                #-=-record a STATUS=-=-=-=-=-=-=
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                #-=-=-=-=-=-=-=-=
                $smsg = "Unable to detect POPULATED `$global:ADPsDriveNames!`n(should have multiple values, resolved to $()"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                Break ;
            } ; 
        } ; 
        #if (!$domaincontroller) { $domaincontroller = get-gcfast } ;
        #if(!$domaincontroller){ if(test-path function:get-gcfast){$domaincontroller=get-gcfast} else { throw "no get-gcfast()!" } ;} else {"(existing `$domaincontroller:$($domaincontroller))"} ;
        # use new get-GCFastXO cross-org dc finde
        # default to Op_ExADRoot forest from $TenOrg Meta
        $domaincontroller = get-GCFastXO -TenOrg $TenOrg -subdomain ((gv -name "$($TenOrg)Meta").value['OP_ExADRoot']) -verbose:$($verbose) |?{$_.length};


        <# MSOL CONNECTION
        $reqMods += "connect-msol".split(";") ;
        if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
        write-host -foregroundcolor gray  "(loading AAD...)" ;
        #connect-msol ;
        connect-msol @pltRXO ; 
        #>

        # AZUREAD CONNECTION
        $reqMods += "Connect-AAD".split(";") ;
        if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
        write-host -foregroundcolor gray  "(loading AAD...)" ;
        #connect-msol ;
        Connect-AAD @pltRXO ; 
        #


        #
        # EXO connection
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            verbose = $($verbose) ; } ; 
        if($VerbosePreference = "Continue"){
            $VerbosePrefPrior = $VerbosePreference ;
            $VerbosePreference = "SilentlyContinue" ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ; 
        disconnect-exo ;
        if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
        else { reconnect-EXO @pltRXO } ;
        # reenable VerbosePreference:Continue, if set, during mod loads 
        if($VerbosePrefPrior -eq "Continue"){
            $VerbosePreference = $VerbosePrefPrior ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        #

        
        # 3:00 PM 9/12/2018 shift this to 1x in the script ; - this would need to be customized per tenant, not used (would normally be for forcing UPNs, but CMW uses brand UPN doms)
        

        # Clear error variable
        $Error.Clear() ;
        

    } ;  # BEGIN-E
    PROCESS {
        $rMailboxes = @() ;
        $Error.Clear() ;
        $SearchesRun = 0 ;
        $smsg = "Net:$(($Mailboxes|measure).count) mailboxes" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $ttl = ($Mailboxes | measure).count ;
        $Procd = 0 ;

        # 9:20 AM 2/25/2019 Tickets will be an array of nnn's to match the mbxs, so use $Procd-1 as the index for tick# in the array
        if((($Mailboxes|measure).count -gt 1) -AND (($Tickets|measure).count -eq 1)){
            # Mult mbxs with single Ticket, expand ticket count to match # of mbxes
            foreach($mbx in $Mailboxes){
                $Tickets+=$Tickets[0] ; 
            } ; 
        } ; 
        foreach($Mailbox in $Mailboxes){
            $Procd++ ;
        
            if ($Ticket = $Tickets[($Procd - 1)]) {
                $sBnr = "#*======v `$Ticket:$($ticket):`$Mailbox:($($Procd)/$($ttl)):$($Mailbox) v======" ;
                $ofileroot = ".\logs\$($ticket)-" ;
                $lTag = "$($ticket)-$($Mailbox)-" ; 
            }else {
                $sBnr = "#*======v `$Ticket:(not spec'd):`$Mailbox:($($Procd)/$($ttl)):$($Mailbox) v======" ;
                $ofileroot = ".\logs\" ;
                $lTag = "$($Mailbox)-" ; 
            } ;

            # detect profile installs (installed mod or script), and redir to stock location
            $dPref = 'd','c' ; foreach($budrv in $dpref){ if(test-path -path "$($budrv):\scripts" -ea 0 ){ break ;  } ;  } ;
            [regex]$rgxScriptsModsAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)" ;
            [regex]$rgxScriptsModsCurrUserScope="^$([regex]::escape([environment]::getfolderpath('Mydocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)" ;
            # -Tag "($TenOrg)-LASTPASS" 
            $pltSLog = [ordered]@{ NoTimeStamp=$false ; Tag=$lTag  ; showdebug=$($showdebug) ;whatif=$($whatif) ;} ;
            if($PSCommandPath){
                if(($PSCommandPath -match $rgxScriptsModsAllUsersScope) -OR ($PSCommandPath -match $rgxScriptsModsCurrUserScope) ){
                    # AllUsers or CU installed script, divert into [$budrv]:\scripts (don't write logs into allusers context folder)
                    if($PSCommandPath -match '\.ps(d|m)1$'){
                        # module function: use the ${CmdletName} for childpath
                        $pltSLog.Path= (join-path -Path "$($budrv):\scripts" -ChildPath "$(${CmdletName}).ps1" )  ;
                    } else { 
                        $pltSLog.Path=(join-path -Path "$($budrv):\scripts" -ChildPath (split-path $PSCommandPath -leaf)) ;
                    } ; 
                }else {
                    $pltSLog.Path=$PSCommandPath ;
                } ;
            } else {
                if( ($MyInvocation.MyCommand.Definition -match $rgxScriptsModsAllUsersScope) -OR ($MyInvocation.MyCommand.Definition -match $rgxScriptsModsCurrUserScope) ){
                    $pltSLog.Path=(join-path -Path "$($budrv):\scripts" -ChildPath (split-path $PSCommandPath -leaf)) ;
                } else {
                    $pltSLog.Path=$MyInvocation.MyCommand.Definition ;
                } ;
            } ;
            $smsg = "start-Log w`n$(($pltSLog|out-string).trim())" ;
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            $logspec = start-Log @pltSLog ;

            if($logspec){
                $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                $logging=$logspec.logging ;
                $logfile=$logspec.logfile ;
                $transcript=$logspec.transcript ;
                #Configure default logging from parent script name
                # logfile                        C:\usr\work\o365\scripts\logs\move-MailboxToXo-(TOR)-LASTPASS-LOG-BATCH-WHATIF-log.txt
                # transcript                     C:\usr\work\o365\scripts\logs\move-MailboxToXo-(TOR)-LASTPASS-Transcript-BATCH-WHATIF-trans-log.txt
                #$logfile = $logfile.replace('-LASTPASS','').replace('BATCH',(Remove-InvalidFileNameChars -name $BatchName )) ;
                $logfile = $logfile.replace('-LASTPASS','').replace('BATCH','') ;
                #$transcript = $transcript.replace('-LASTPASS','').replace('BATCH',(Remove-InvalidFileNameChars -name $BatchName )) ;
                $transcript = $transcript.replace('-LASTPASS','').replace('BATCH','') ;
                if(Test-TranscriptionSupported){start-transcript -Path $transcript }
                else { write-warning "$($host.name) v$($host.version.major) does *not* support Transcription!" } ;
            } else {throw "Unable to configure logging!" } ;
    
            $smsg = "$($sBnr)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            $sBnr="#*======v MAILBOX:$($Mailbox) v======" ;
            $smsg = "$((get-date).ToString('HH:mm:ss')):$($sBnr)" ;
            $pltXcsv = [ordered]@{Path=$null; NoTypeInformation=$true ; } ;
            $error.clear() ;

            $rcp = $null ; $exorcp = $null ;
            $exombx = $null ; $opombx = $null ;  $rmbx = $null ;
            $targetUPN = $NULL ;
            $adu = $null ; $msolu = $null ;
            $bMissingMbx = $false ;
            $exolicdetails = $null ;
            $obj = $null ;
            $grantgroup = $null ;
            $tuser = $null ;
            $UPN = $null ;
            $MailboxFoldersExo = $null ;

            $Exit = 0 ;

            if($pltRXO){
                if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
                else { reconnect-EXO @pltRXO } ;
            } else {reconnect-exo ;} ; 
            #Reconnect-Ex2010 ;
            if($pltRX10){
                #ReConnect-Ex2010XO @pltRX10 ;
                ReConnect-Ex2010 @pltRX10 ;
            } else { Reconnect-Ex2010 ; } ; 

            $Exit = 0 ; $error.clear() ;
            Do {
                Try {
                    $rcp = get-recipient -id $Mailbox -domaincontroller $domaincontroller -ea stop ;
                
                    $smsg= "(successful get-recipient -id $($Mailbox))" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else { write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $Exit = $Retries ;
                }
                Catch {
                    $errTrpd=$_ ; 
                    if( $errtrpd -match "\scouldn't\sbe\sfound\son\s" ){
                        $smsg = "(no EXOP recicpient found)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $Exit = $Retries ;
                    } else { 
                        $smsg=": Error Details: $($errTrpd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        Start-Sleep -Seconds $RetrySleep ;
                        if($pltRX10){
                            #ReConnect-Ex2010XO @pltRX10 ;
                            ReConnect-Ex2010 @pltRX10 ;
                        } else { ReConnect-Ex2010  } ; 
                        $Exit ++ ;
                        Write-Verbose "Failed to exec cmd because: $($Error[0])" ;
                        Write-Verbose "Try #: $Exit" ;                    
                    } ; 
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;
            } Until ($Exit -eq $Retries) ;

            $Exit = 0 ; $error.clear() ;
            Do {
                Try {
                    $pltgxrcp=[ordered]@{identity=$Mailbox ; erroraction='stop'; } ; 

                    $smsg= "$((get-alias ps1GetxRcp).definition) w`n$(($pltgxrcp|out-string).trim())" ; 
                    if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

                    $exorcp = ps1GetxRcp @pltgxrcp ;
                
                    $smsg= "(successful get-exorecipient -id $($Mailbox))" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                
                    $Exit = $Retries ;
                }
                Catch {
                    # get fails go here with: The operation couldn't be performed because object 'ACCOUNT@DOMAIN.com' couldn't be found on 'CY4PR04A008DC10.NAMPR04A008.PROD.OUTLOOK.COM'.
                    $errTrpd=$_ ; 
                    if( $errtrpd -match "\scouldn't\sbe\sfound\son\s" ){
                        $smsg = "(no EXO recipient found)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $Exit = $Retries ;
                    } else { 
                        $smsg=": Error Details: $($errTrpd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        Start-Sleep -Seconds $RetrySleep ;
                        if($pltRXO){
                            if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
                            else { reconnect-EXO @pltRXO } ;
                        } else {reconnect-exo ;} ; 
                        $Exit ++ ;
                        Write-Verbose "Failed to exec cmd because: $($Error[0])" ;
                        Write-Verbose "Try #: $Exit" ;                    
                    } ; 
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;
            } Until ($Exit -eq $Retries) ;


            $Exit = 0 ; $error.clear() ;
            Do {
                Try {
                    $pltgxmbx=[ordered]@{identity=$Mailbox ; erroraction='stop'; } ; 
                    $smsg= "$((get-alias ps1GetxMbx).definition) w`n$(($pltgxmbx|out-string).trim())" ; 
                    if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

                
                    $exombx = ps1GetxMbx @pltgxmbx ; 

                    $smsg= "(successful get-exomailbox -id $($Mailbox))" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;


                    if ($exombx) {
                        $pltGetxMbxFldrStats=[ordered]@{Identity=$exombx.identity ;IncludeOldestAndNewestItems=$true; erroraction='stop'; } ; 
                        #$smsg= "(collecting get-exomailboxfolderstatistics...)" ;
                        $smsg= "$((get-alias ps1GetxMbxFldrStats).definition) w`n$(($pltGetxMbxFldrStats|out-string).trim())" ; 
                        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        $exofldrs = ps1GetxMbxFldrStats @pltGetxMbxFldrStats | 
                            ?{($_.ItemsInFolder -gt 0 ) -AND ($_.identity -notmatch $rgxExoSysFolders)} ;
                        #$fldrs = get-exomailboxfolderstatistics -id ID -IncludeOldestAndNewestItems ;
                        #$fldrs = $fldrs |?{($_.ItemsInFolder -gt 0 ) -AND ($_.identity -notmatch $rgxExoSysFolders)} ;
                        #$fldrs | ft -auto $propsmbxfldrs ;

                        # do a 7day msgtrc
                        #-=-=-=-=-=-=-=-=
                        $isplt=@{    
                            ticket=$ticket ;
                            uid=$Mailbox;
                            days=$Days ;
                            StartDate='' ;
                            EndDate='' ;
                            Sender="" ;
                            Recipients=$exombx.PrimarySmtpAddress ;
                            MessageSubject="" ;
                            Status='' ;
                            MessageTraceId='' ;
                            MessageId='' ;
                        }  ;
                        $msgtrk=@{ PageSize=1000 ; Page=$null ; StartDate=$null ; EndDate=$null ; } ;

                        if($isplt.days){  
                            $msgtrk.StartDate=(get-date ([datetime]::Now)).adddays(-1*$isplt.days);
                            $msgtrk.EndDate=(get-date) ;
                        } ;
                        if($isplt.StartDate -and !($isplt.days)){$msgtrk.StartDate=$(get-date $isplt.StartDate)} ;
                        if($isplt.EndDate -and !($isplt.days)){$msgtrkEndDate=$(get-date $isplt.EndDate)} 
                        elseif($isplt.StartDate -and !($isplt.EndDate)){
                            $smsg = '(StartDate w *NO* Enddate, asserting currenttime)' ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $msgtrkEndDate=(get-date) ;
                        } ;

                        TRY{$tendoms=Get-AzureADDomain }CATCH{
                            #write-warning "NOT AAD CONNECTED!" ;BREAK ;
                            $smsg = "Not AAD connected, reconnect..." ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Connect-AAD @pltRXO ; 
                        } ;

                        $Ten = ($tendoms |?{$_.name -like '*.mail.onmicrosoft.com'}).name.split('.')[0] ;
                        $ofile ="$($isplt.ticket)-$($Ten)-$($isplt.uid)-EXOMsgTrk" ;
                        if($isplt.Sender){
                            if($isplt.Sender -match '\*'){
                                $smsg = "(wild-card Sender detected)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                $msgtrk.add("SenderAddress",$isplt.Sender) ;
                            } else {
                                $msgtrk.add("SenderAddress",$isplt.Sender) ;
                            } ;
                            $ofile+=",From-$($isplt.Sender.replace("*","ANY"))" ;
                        } ;
                        if($isplt.Recipients){
                            if($isplt.Recipients -match '\*'){
                                $smsg = "(wild-card Recipient detected)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                $msgtrk.add("RecipientAddress",$isplt.Recipients) ;
                            } else {
                                $msgtrk.add("RecipientAddress",$isplt.Recipients) ;
                            } ;
                            $ofile+=",To-$($isplt.Recipients.replace("*","ANY"))" ;
                        } ;

                        if($isplt.MessageId){
                            $msgtrk.add("MessageId",$isplt.MessageId) ;
                            $ofile+=",MsgId-$($isplt.MessageId.replace('<','').replace('>',''))" ;
                        } ;
                        if($isplt.MessageTraceId){
                            $msgtrk.add("MessageTraceId",$isplt.MessageTraceId) ;
                            $ofile+=",MsgId-$($isplt.MessageTraceId.replace('<','').replace('>',''))" ;
                        } ;
                        if($isplt.MessageSubject){
                            $ofile+=",Subj-$($isplt.MessageSubject.substring(0,[System.Math]::Min(10,$isplt.MessageSubject.Length)))..." ;
                        } ;
                        if($isplt.Status){
                            $msgtrk.add("Status",$isplt.Status)  ;
                            $ofile+=",Status-$($isplt.Status)" ;
                        } ;
                        if($isplt.days){$ofile+= "-$($isplt.days)d-" } ;
                        if($isplt.StartDate){$ofile+= "-$(get-date $isplt.StartDate -format 'yyyyMMdd-HHmmtt')-" } ;
                        if($isplt.EndDate){$ofile+= "$(get-date $isplt.EndDate -format 'yyyyMMdd-HHmmtt')" } ;

                        $smsg = "Running MsgTrk:$($Ten)" ;
                        $smsg += "`n$(($msgtrk|out-string).trim()|out-default)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        $Page = 1  ;
                        $Msgs=$null ;
                        do {
                            $smsg = "Collecting - Page $($Page)..."  ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            $msgtrk.Page=$Page ;
                            $PageMsgs = ps1GetxMsgTrc @msgtrk |  ?{$_.SenderAddress -notlike '*micro*' -or $_.SenderAddress -notlike '*root*' }  ;
                            $Page++  ;
                            $Msgs += @($PageMsgs)  ;
                        } until ($PageMsgs -eq $null) ;
                        $Msgs=$Msgs| Sort Received ;
                    
                        $smsg = "==Msgs Returned:$(($Msgs|measure).count)`nRaw matches:$(($Msgs|measure).Count)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        if($isplt.MessageSubject){
                            $smsg = "Post-Filtering on Subject:$($isplt.MessageSubject)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            $Msgs = $Msgs | ?{$_.Subject -like $isplt.MessageSubject} ;
                            $ofile+="-Subj-$($isplt.MessageSubject.replace("*"," ").replace("\"," "))" ;
                            $smsg = "Post Subj filter matches:$(($Msgs|measure).Count)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                        } ;
                        $ofile+= "-run$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
                        #$ofile=[RegEx]::Replace($ofile, "[{0}]" -f ([RegEx]::Escape(-join [System.IO.Path]::GetInvalidFileNameChars())), '') ;
                        $ofile = Remove-InvalidFileNameChars -name $ofile ; 
                        $ofile=".\logs\$($ofile)" ;
                     
                        if($Msgs){
                            $Msgs | select  | export-csv -notype -path $ofile  ;
                            "Status Distrib:" ;
                            $smsg = "`n#*------v MOST RECENT MATCH v------" ;
                            $smsg += "`n$(($msgs[-1]| format-list ReceivedLocal,StatusSenderAddress,RecipientAddress,Subject|out-string).trim())";
                            $smsg += "`n#*------^ MOST RECENT MATCH ^------" ;
                            $smsg += "`n#*------v Status DISTRIB v------" ;
                            $smsg += "`n$(($Msgs | select -expand Status | group | sort count,count -desc | select count,name |out-string).trim())";
                            $smsg += "`n#*------^ Status DISTRIB ^------" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            <# Count Name                      Group
                            ----- ----                      -----
                              448 Delivered                 {@{PSComputerName=ps.outlook.com; RunspaceId=25f3aa28-9437-4e30-aa8f-8d83d2d2fc5a; PSShowComputerName=False; Organization=DOMAIN.onmicrosoft.com; MessageId=<BN8PR12MB33158F1D07B3862078D758E6EB499@BN8PR12MB3315.namprd12.prod.o...
                                1 Failed                    {@{PSComputerName=ps.outlook.com; RunspaceId=25f3aa28-9437-4e30-aa8f-8d83d2d2fc5a; PSShowComputerName=False; Organization=DOMAIN.onmicrosoft.com; MessageId=<5bc2055fed4d43d3827cf7f61d37a4c9@CH2PR04MB7062.namprd04.prod.outlook...
                                1 Quarantined               {@{PSComputerName=ps.outlook.com; RunspaceId=25f3aa28-9437-4e30-aa8f-8d83d2d2fc5a; PSShowComputerName=False; Organization=DOMAIN.onmicrosoft.com; MessageId=<threatsim-5f0bc0101d-c200b2590d@app.emaildistro.com>; Received=4/28/...
                                1 FilteredAsSpam            {@{PSComputerName=ps.outlook.com; RunspaceId=25f3aa28-9437-4e30-aa8f-8d83d2d2fc5a; PSShowComputerName=False; Organization=DOMAIN.onmicrosoft.com; MessageId=<SA0PR01MB61858E3C6111672E081373C1E45F9@SA0PR01MB6185.prod.exchangela...
                            #>
                            $nonDelivStats = $msgs | ?{$_.status -ne 'Delivered'} | group status | select-object -expand name ; 
                            
                            foreach ($status in $nonDelivStats){
                                $smsg = "Enumerating Status:$($status) messages" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                if($StatMsgs  = $msgs|?{$_.status -eq $status}){
                                    if(($StatMsgs |measure).count -gt 10){
                                        $smsg = "(over $($MsgTraceNonDeliverDetailsLimit) $($status) msgs: processing a sample of last $($MsgTraceNonDeliverDetailsLimit)...)" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        $StatMsgs = $StatMsgs | select-object -Last $MsgTraceNonDeliverDetailsLimit ;
                                    } ; 
                                    $statTtl = ($StatMsgs |measure).count ; $fProcd=0 ; 
                                    $smsg = "$($statTtl) Status:'$($status)' messages returned. Expanding detailed processing..." ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        foreach($fmsg in $StatMsgs ){
                                            $fProcd++ ; 
                                            $sBnrS="`n#*------v PROCESSING $($status)#$($fProcd)/$($statTtl): v------" ; 
                                            $smsg= "$($sBnrS)" ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                                            $pltGetxMsgTrcDtl = [ordered]@{MessageTraceId=$fmsg.MessageTraceId ;RecipientAddress=$fmsg.RecipientAddress} ; 
                                            $smsg= "$((get-alias ps1GetxMsgTrcDtl).definition) w`n$(($pltGetxMsgTrcDtl|out-string).trim())" ; 
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                
                                            # this is nested in a try already
                                            $MsgTrkDtl = ps1GetxMsgTrcDtl @pltGetxMsgTrcDtl ; 

                                            if($MsgTrkDtl){
                                                $smsg = "`n-----`n$(( $MsgTrkDtl | fl $propsMsgTrcDtl|out-string).trim())`n-----`n" ; 
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                            } else { 
                                                $smsg = "(no matching MessageTraceDetail was returned by MS for MsgTrcID:$($pltGetxMsgTrcDtl.MessageTraceId), aged out of availability already)" ; 
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                                $smsg = "$($status)#$($fProcd)/$($statTtl):DETAILS`n----`n$(($fmsg|fl | out-string).trim())`n----`n" ; 
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                            } ; 

                                            $smsg= "$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        } ; 
                                
                                }
                            } ; #nonDelivStats
                            if(test-path -path $ofile){
                                $smsg = "(log file confirmed)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                Resolve-Path -Path $ofile | select -expand Path | out-clipboard ;
                                $smsg = "$($Msgs.count) matches output to:`n'$($ofile)'`n(copied to CB)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            } else { 
                                $smsg = "MISSING LOG FILE!"  ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } ;
                        } else {
                            $smsg = "NO MATCHES FOUND from::`n$(($msgtrk|out-string).trim()|out-default)`n(with any relevant ConnectorId postfilter)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ;

                        #-=-=-=-=-=-=-=-=


                    } else {
                        $smsg = "(no EXO mailbox found, skipping $((get-alias ps1GetxMbxFldrStats).definition) )" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $Retries ;
                }
                Catch {
                    # get fails go here with: The operation couldn't be performed because object 'ACCOUNT@DOMAIN.com' couldn't be found on 'CY4PR04A008DC10.NAMPR04A008.PROD.OUTLOOK.COM'.
                    $errTrpd=$_ ; 
                    if( $errtrpd -match "\scouldn't\sbe\sfound\son\s" ){
                        $smsg = "(no EXO mailbox found)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $Exit = $Retries ;
                    } else { 
                        $smsg=": Error Details: $($errTrpd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        Start-Sleep -Seconds $RetrySleep ;
                        if($pltRXO){
                            if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
                            else { reconnect-EXO @pltRXO } ;
                        } else {reconnect-exo ;} ; 
                        $Exit ++ ;
                        Write-Verbose "Failed to exec cmd because: $($Error[0])" ;
                        Write-Verbose "Try #: $Exit" ;                    
                    } ; 
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;
            } Until ($Exit -eq $Retries) ;

            $Exit = 0 ; $error.clear() ;
            Do {
                Try {
                    $pltgRmbx=@{identity=$Mailbox ; domaincontroller=$domaincontroller ; erroraction='stop'; } ; 
                    $smsg= "get-RemoteMailbox w`n$(($pltgRmbx|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    $rmbx = get-remotemailbox @pltgRmbx ;

                    if($rmbx){
                        $smsg= "(successful get-remotemailbox  -id $($Mailbox))" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $Retries ;
                }
                Catch {
                    # get fails go here with: The operation couldn't be performed because object 'blahblah' couldn't be found on DC.domain.ccc
                    $errTrpd=$_ ; 
                    if( $errtrpd -match "\scouldn't\sbe\sfound\son\s" ){
                        $smsg = "(no EXOP remotemailbox found)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else { write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $Exit = $Retries ;
                    } else { 
                        $smsg=": Error Details: $($errTrpd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        Start-Sleep -Seconds $RetrySleep ;
                        if($pltRX10){
                            #ReConnect-Ex2010XO @pltRX10 ;
                            ReConnect-Ex2010 @pltRX10 ;
                        } else { ReConnect-Ex2010  } ; 
                        $Exit ++ ;
                        Write-Verbose "Failed to exec cmd because: $($Error[0])" ;
                        Write-Verbose "Try #: $Exit" ;                    
                    } ; 
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;
            } Until ($Exit -eq $Retries) ;


            if ($exombx ) {
                $targetUPN = $exombx.userprincipalname ;
            }
            elseif ($rmbx) {
                $targetUPN = $rmbx.userprincipalname ;
            }
            else {
                throw "Unable to locate either an EXO mailbox or an on-prem RemoteMailbox. ABORTING!"
                Break ;
            } ;


            $Exit = 0 ; $error.clear() ;
            Do {
                Try {
                    $pltgMbx=[ordered]@{identity=$targetUPN ;domaincontroller=$domaincontroller ;erroraction='SilentlyContinue';  };
                    $smsg = "get-mailbox w`n$(($pltgMbx|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    $opmbx = get-mailbox @pltgMbx ; 
                    if($opmbx){
                        $smsg= "(successful get-mailbox -id $($targetUPN))" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $Retries ;

                }
                Catch {
                    # get fails go here with: The operation couldn't be performed because object 'blahblah' couldn't be found on dc.domain...
                    $errTrpd=$_ ; 
                    if( $errtrpd -match "\scouldn't\sbe\sfound\son\s" ){
                        $smsg = "(no EXOP mailbox found)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else { write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $Exit = $Retries ;
                    } else { 
                        $smsg=": Error Details: $($errTrpd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        Start-Sleep -Seconds $RetrySleep ;
                        if($pltRX10){
                            #ReConnect-Ex2010XO @pltRX10 ;
                            ReConnect-Ex2010 @pltRX10 ;
                        } else { ReConnect-Ex2010  } ; 
                        $Exit ++ ;
                        Write-Verbose "Failed to exec cmd because: $($Error[0])" ;
                        Write-Verbose "Try #: $Exit" ;                    
                    } ; 
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;
            } Until ($Exit -eq $Retries) ;


            $Exit = 0 ; $error.clear() ;
            Do {
                Try {
                    connect-msol @pltRXO ;
                    $pltgMSOLU = [ordered]@{userprincipalname=$targetUPN  ;erroraction='SilentlyContinue';} ; 
                    $smsg = "get-msoluser w`n$(($pltgMSOLU|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    $msolu = get-msoluser @pltgMSOLU ;
                    if($msolu){
                        $smsg= "(successful get-msoluser -userprincipalname $($targetUPN))" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $Retries ;
                }
                Catch {
                    # get fails go here with: get-msoluser : User Not Found.  User: blah@DOMAIN.com.
                    $errTrpd=$_ ; 
                    if( $errtrpd -match "User\sNot\sFound" ){
                        $smsg = "(no EXOP mailbox found)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $Exit = $Retries ;
                    } else { 
                        $smsg=": Error Details: $($errTrpd)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        Start-Sleep -Seconds $RetrySleep ;
                        if($pltRXO){
                            if ($script:useEXOv2) { reconnect-eXO2 @pltRXO }
                            else { reconnect-EXO @pltRXO } ;
                        } else {reconnect-exo ;} ; 
                        $Exit ++ ;
                        Write-Verbose "Failed to exec cmd because: $($Error[0])" ;
                        Write-Verbose "Try #: $Exit" ;                    
                    } ; 
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;
            } Until ($Exit -eq $Retries) ;

            if ($msolu) {
                connect-msol @pltRXO;
               # to find group, check user's membership
                # do the full lookup first

                if ($msolu.IsLicensed -AND !($msolu.LicenseReconciliationNeeded)) {
                    $smsg = "USER HAS *NO* LICENSING ISSUES:" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                }
                else {
                    $smsg = "USER *HAS* LICENSING ISSUES:" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else { write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;

                $smsg = "Get-MsolUser:`n$(($msolu | select userprin*,*Error*,*status*,softdel*,lic*,islic*|out-string).trim())`n" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                if ($null -eq $msolu.SoftDeleteTimestamp) {
                    $smsg = "$($msol.userprincipalname) has a BLANK SoftDeleteTimestamp`n=>If mailbox missing it would indicate the user wasn't properly de-licensed (or would have fallen into dumpster at >30d).`n That scenario would reflect a replic break (AAD sync loss wo proper update)`n" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;

                if ($EXOLicDetails = get-MsolUserLicenseDetails -UPNs $targetUPN -showdebug:$($showdebug) ) {
                    $smsg = "Returned License Details`n$(($EXOLicDetails|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
                }
                else {
                    $smsg = "UNABLE TO RETURN License Details FOR `n$(($targetUPN|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } ; #Error|Warn
                };

                # 2:12 PM 1/27/2020 rough in Pull-AADSignInReports.ps1 syntax
                $AADSigninSyntax=@"

---------------------------------------------------------------------------------
If you would like to retrieve user AAD Sign On Reports, use the following command:

A. Query the events into json outputs:

.\Pull-AADSignInReports.ps1 -UPNs "$($targetUPN)" -ticket "$($Ticket)" -StartDate (Get-Date).AddDays(-30) -showdebug ;

B. Process & Profile the output .json file from the above:
.\profile-AAD-Signons.ps1 -Files PATH-TO-FILE.json ;

---------------------------------------------------------------------------------

"@ ;

            }
            else {
                $smsg = "$($targetUPN):NO MATCHING MSOLUSER RETURNED!" ; ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;

        
            $Exit = 0 ; $error.clear() ;
            Do {
                Try {
                    $aduFilter = { UserPrincipalName -eq $targetUPN }  ;
                    $pltgADU=[ordered]@{filter=$aduFilter;Properties=$adprops ;server=$domaincontroller  ;erroraction='SilentlyContinue'; } ; 
                    $smsg = "get-aduser w`n$(($pltgADU|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    #$adu = get-aduser -filter { UserPrincipalName -eq $targetUPN } -Properties $adprops -server $domaincontroller -ea 0  ; 
                    $adu = get-aduser @pltgADU  ; 
                    if($adu){
                        $smsg= "(successful get-aduser -filter { UserPrincipalName -eq $($targetUPN) }" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $Retries ;
                }
                Catch {
                    $errTrpd=$_ ;
                    $smsg = "Failed processing $($errTrpd.Exception.ItemName). `nError Message: $($errTrpd.Exception.Message)`nError Details: $($errTrpd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } #Error|Warn|Debug
                    else { write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Start-Sleep -Seconds $RetrySleep ;
                    $Exit ++ ;
                    $smsg = "Failed to exec cmd because: $($Error[0])`nTry #: $($Exit)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } #Error|Warn|Debug
                    else { write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;
            } Until ($Exit -eq $Retries) ;

            # DETERMINE LIC GRANT GROUP
            if ($GrantGroupDN = $adu | select -expand memberof | ? { $_ -match $rgxEntLicGrps } ) {
                Try {
                    # 8:47 AM 3/1/2019 #626:expand the name, (was coming out a hash)
                    $GrantGroup = get-adgroup -id $grantgroupDN | select -expand name ;
                }
                catch {
                    $grantgroup = "(NOT RESOLVABLE)"
                } ;
            }
            else {
                $grantgroup = "(NOT RESOLVABLE)"
            } ;

            # TRIAGE RESULTS
            if ($exombx -AND $opmbx) {
                # SPLIT BRAIN
                $smsg = "USER HAS SPLIT-BRAIN MAILBOX (MBX IN EXO & EXOP)!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else { write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            }elseif (($rcp.RecipientTypeDetails -eq 'RemoteUserMailbox') -AND ($exorcp.RecipientTypeDetails -eq 'MailUser') ) {
                # NO BRAIN
                $smsg = "USER HAS NO-BRAIN MAILBOX (*NO* MBX IN *EITHER* EXO & EXOP)!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else { write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

             }
            elseif ( ($rcp.RecipientTypeDetails -match '(User|Shared|Room|Equipment)Mailbox') -AND ($exorcp.RecipientTypeDetails -eq 'MailUser') ) {
                # ON PREM MAILBOX
                #$mapiTest = Test-MAPIConnectivity -id $Mailbox ;
                $pltTMapi=[ordered]@{identity=$Mailbox;domaincontroller=$domaincontroller  ;erroraction='SilentlyContinue'; } ; 
                $smsg = "Test-MAPIConnectivity w`n$(($pltTMapi|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                Try {
                    $mapiTest = Test-MAPIConnectivity @pltTMapi  ; 
                    if ($mapiTest.Result -eq 'Success') {
                        $smsg= "(successful Outlook Mbx MAPI validate: Test-MAPIConnectivity -id $($Mailbox) }" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $Retries ;
                } Catch {
                    $errTrpd=$_ ;
                    $smsg = "Failed processing $($errTrpd.Exception.ItemName). `nError Message: $($errTrpd.Exception.Message)`nError Details: $($errTrpd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } #Error|Warn|Debug
                    else { write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Start-Sleep -Seconds $RetrySleep ;
                    $Exit ++ ;
                    $smsg = "Failed to exec cmd because: $($Error[0])`nTry #: $($Exit)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } #Error|Warn|Debug
                    else { write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;


                $FixText = @"
========================================
Problem User:`t "$($adu.UserPrincipalName)"
Has an *ONPREM* mailbox:Type:$($exombx.recipienttypedetails) hosted in $($opmbx.database)
"@ ;
                if ($mapiTest.Result -eq 'Success') {
                    $FixText2 = @"
*with *NO* detected issues*
Mailbox Outlook connectivity tested and validated functional...
"@ ;
                } else {
                    $FixText2 = @"
*FAILED Test-MAPIConnectivity*
Mailbox Outlook connectivity test failed to connect!...
"@ ;
                }

                $FixText3 = @"

$(($mapiTest|out-string).trim())

The user's o365 LICENSESKUs:                     "$($exolicdetails.LicAccountSkuID)"
With DisplayNames:                               "$($exolicdetails.LicenseFriendlyName)"
The user's o365 Licensing group appears to be:  "$($grantgroup)"

OnPrem RecipientTypeDetails:`t "$($rcp.RecipientTypeDetails)"
OnPrem WhenCreated:`t "$($rcp.WhenCreated)"
EXO RecipientTypeDetails:`t "$($exorcp.RecipientTypeDetails)"
EXO WhenMailboxCreated:`t "$($exombx.WhenMailboxCreated)"
"@

                $smsg = "$($FixText)`n$($FixText2)`n$($FixText3)"  ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                #output the AAD Signon Profile info: $AADSigninSyntax
                $smsg = "$($AADSigninSyntax)"  ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            }elseif ( ($rcp.RecipientTypeDetails -match 'Remote(User|Shared|Room|Equipment)Mailbox' ) -AND ($exorcp.RecipientTypeDetails -match '(User|Shared|Room|Equipment)Mailbox') ) {
                # EXO MAILBOX
                $pltTxmc=@{identity=$Mailbox ;erroraction='SilentlyContinue'; } ;
                Try {
                    $mapiTest = ps1TestXMapi @pltTxmc ; 
                    if ($mapiTest.Result -eq 'Success') {
                        $smsg= "(successful Outlook Mbx MAPI validate: Test-MAPIConnectivity -id $($Mailbox) }" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $Exit = $Retries ;
                } Catch {
                    $errTrpd=$_ ;
                    $smsg = "Failed processing $($errTrpd.Exception.ItemName). `nError Message: $($errTrpd.Exception.Message)`nError Details: $($errTrpd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } #Error|Warn|Debug
                    else { write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Start-Sleep -Seconds $RetrySleep ;
                    $Exit ++ ;
                    $smsg = "Failed to exec cmd because: $($Error[0])`nTry #: $($Exit)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } #Error|Warn|Debug
                    else { write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    If ($Exit -eq $Retries) { Write-Warning "Unable to exec cmd!" } ;
                }  ;
                $FixText = @"
========================================
User:`t "$($adu.UserPrincipalName)"
Has an *EXO* mailbox:Type:$($exombx.recipienttypedetails) in db:$($exombx.database)
"@ ;
                if ($mapiTest.Result -eq 'Success') {
                $FixText2 = @"
*with *NO* detected issues*
Mailbox Outlook connectivity tested and validated functional...
"@ ;
                } else {
                    $FixText2 = @"
*FAILED Test-exoMAPIConnectivity*
Mailbox Outlook connectivity test failed to connect!...
"@ ;
                } ; 

                $FixText3 = @"

$(($mapiTest|out-string).trim())

The user's o365 LICENSESKUs:                     "$($exolicdetails.LicAccountSkuID)"
With DisplayNames:                               "$($exolicdetails.LicenseFriendlyName)"
The user's o365 Licensing group appears to be:  "$($grantgroup)"
$(if($rcp.recipienttypedetails -ne 'RemoteUserMailbox'){
    '(non-usermailbox, *non*-licensed is typical status)'
})

OnPrem RecipientTypeDetails:`t "$($rcp.RecipientTypeDetails)"
OnPrem WhenCreated:`t "$($rcp.WhenCreated)"
EXO RecipientTypeDetails:`t "$($exorcp.RecipientTypeDetails)"
EXO WhenMailboxCreated:`t "$($exombx.WhenMailboxCreated)"

Mailbox content:
$(($exofldrs | ft -auto $propsmbxfldrs|out-string).trim())

"@


                $smsg = "$($FixText)`n$($FixText2)`n$($FixText3)"  ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                #output the AAD Signon Profile info: $AADSigninSyntax
                $smsg = "$($AADSigninSyntax)"  ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            } else {
                # UNRECOGNIZED RECIPIENTTYPE COMBO
                # ($rcp.RecipientTypeDetails -eq 'RemoteUserMailbox'), ($exorcp.RecipientTypeDetails -eq 'UserMailbox')
                $smsg= "UNRECOGNIZED RECIPIENTTYPE COMBO:`nOPREM:RecipientTypeDetails:$($rcp.RecipientTypeDetails)`nEXO:RecipientTypeDetails:$($exorcp.RecipientTypeDetails)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            } ; 

            
            if($host.Name -eq "Windows PowerShell ISE Host" -and $host.version.major -lt 5){
                # 11:51 AM 9/22/2020 isev5 supports transcript, anything prior has to fake it
                # 8:46 AM 3/11/2015 shift the logfilename gen out here, so that we can arch it
                #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -uformat "%Y%m%d-%H%M" ) + "-ISEtrans.log")) ;
                # 2:16 PM 4/27/2015 shift to static timestamp $timeStampNow
                #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + $timeStampNow + "-ISEtrans.log")) ;
                # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
                #$Logname=(join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -format 'yyyyMMdd-HHmmtt') + "-ISEtrans.log")) ;
                # maintain-ExoUsrMbxFreeBusyDetails-TOR-ForceAll-Transcript-BATCH-EXEC-20200921-1539PM-trans-log.txt
                $Logname=$transcript.replace('-trans-log.txt','-ISEtrans-log.txt') ;
                write-host "`$Logname: $Logname";
                Start-iseTranscript -logname $Logname  -Verbose:($VerbosePreference -eq 'Continue') ;
                #Archive-Log $Logname ;
                # 1:23 PM 4/23/2015 standardize processing file so that we can send a link to open the transcript for review
                $transcript = $Logname ;
                if($host.version.Major -ge 5){ stop-transcript  -Verbose:($VerbosePreference -eq 'Continue')} # ISE in psV5 actually supports transcription. If you don't stop it, it just keeps rolling
            } else {
                write-verbose "$((get-date).ToString('HH:mm:ss')):Stop Transcript" ;
                Stop-TranscriptLog -Transcript $transcript -verbose:$($VerbosePreference -eq "Continue") ;
            } # if-E
            
            # also trailing echo the log:
            $smsg = "`$logging:`$true:written to:`n$($logfile)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $smsg = "$((get-date).ToString('HH:mm:ss')):$($sBnr.replace('=v','=^').replace('v=','^='))" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            
            $logging = $false ;  # reset logging for next pass

        } ; # loop-E $mailboxes
    } ;  # PROC-E
    END {
        # =========== wrap up Tenant connections
        # suppress VerbosePreference:Continue, if set, during mod loads (VERY NOISEY)
        if($VerbosePreference = "Continue"){
            $VerbosePrefPrior = $VerbosePreference ;
            $VerbosePreference = "SilentlyContinue" ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        if($script:useEXOv2){
            disconnect-exo2 -verbose:$($verbose) ;
        } else {
            disconnect-exo -verbose:$($verbose) ;
        } ;
        # aad mod *does* support disconnect (msol doesen't!)
        #Disconnect-AzureAD -verbose:$($verbose) ;
        # reenable VerbosePreference:Continue, if set, during mod loads
        if($VerbosePrefPrior -eq "Continue"){
            $VerbosePreference = $VerbosePrefPrior ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;

        $pltCleanup=@{
            LogPath=$tmpcopy
            summarizeStatus=$false ;
            NoTranscriptStop=$true ;
            showDebug=$($showDebug) ;
            whatif=$($whatif) ;
            Verbose = ($VerbosePreference -eq 'Continue') ;
        } ;
        $smsg = "_cleanup():w`n$(($pltCleanup|out-string).trim())" ;
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        #_cleanup -LogPath $tmpcopy ;
        _cleanup @pltCleanup ;
        # prod is still showing a running unstopped transcript, kill it again
        $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;

        $smsg = "$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        # clear the script aliases
        write-verbose "clearing ps1* aliases in Script scope" ; 
        get-alias -scope Script |Where-Object{$_.name -match '^ps1.*'} | ForEach-Object{Remove-Alias -alias $_.name} ;

        write-verbose "(explicit EXIT...)" ;
        Break ;

    } ;  # END-E
}

#*------^ test-xoMailbox.ps1 ^------


#*------v test-xoMailboxHasEWSAccess.ps1 v------
function test-xoMailboxHasEWSAccess {
    <#
    .SYNOPSIS
    test-xoMailboxHasEWSAccess .ps1 - Test mailbox against MS's o365 updated Org v CASMailbox EWSEnabled specification, under revised Feb 2025 logic.
    .NOTES
    Version     : 0.0.1
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2024-
    FileName    : test-xoMailboxHasEWSAccess .ps1
    License     : MIT License
    Copyright   : (c) 2024 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 9:43 AM 2/25/2025 init
    .DESCRIPTION
    test-xoMailboxHasEWSAccess .ps1 - Test mailbox against MS's o365 updated Org v CASMailbox EWSEnabled specification, under revised Feb 2025 logic.
    Encapsulates following logic table from linked article:

    > The_Exchange_Team
    > Icon for Microsoft rank
    > Microsoft
    > Feb 20, 2025
    > ...
    > Current Behavior
    > Organization Level | User Level      | EWS Requests
    > ------------------ | --------------- | ------------
    > True or <null>     | True or <null>  | Allowed
    > True or <null>     | False           | Not Allowed
    > False              | True            | Allowed
    > False              | False or <null> | Not Allowed
    >
    > New Behavior 
    > To address these issues, we are altering the behavior so that EWS will only be allowed if both the organization-level and user-level EWSEnabled flags are true. Here's a simplified view of the new logic:
    > 
    > Organization Level | User Level     | EWS Requests
    > ------------------ | -------------- | ------------
    > True or <null>     | True or <null> | Allowed
    > True or <null>     | False          | Not Allowed
    > False              | True or <null> | Not Allowed
    > False              | False          | Not Allowed
    > 
    > In short, EWS will be permitted only if both the organization and user-level allow it. This change ensures that administrators have better control over EWS access and can enforce policies more consistently across their entire organization
    > 
    .PARAMETER mailbox
    Mailbox identifier
    .INPUTS
    None. Does not accepted piped input.
    .EXAMPLE 
    test-xoMailboxHasEWSAccess lynctest14@toro.com
    Simple mailbox test
    .LINK
    https://techcommunity.microsoft.com/blog/Exchange/the-way-to-control-ews-usage-in-exchange-online-is-changing/4383083
    #>    
    PARAM([Parameter(Position=0,Mandatory=$True)]$mailbox) ; 
    $orgEWSEnable =  (Get-xoOrganizationConfig).ewsenabled ; 
    $usrEWSEnable = (Get-xoCASMailbox -id $mailbox).ewsenabled ; 
    if(($null -eq $orgEWSEnable -OR $true -eq $orgEWSEnable) -AND ($null -eq $usrEWSEnable -OR $true -eq $usrEWSEnable)){write-host "Org:'$($orgEWSEnable)'&Usr:'$($usrEWSEnable)': Mailbox has EWSEnable function"} ; 
    if(($null -eq $orgEWSEnable -OR $true -eq $orgEWSEnable) -AND ($false -eq $usrEWSEnable)){write-host "Org:'$($orgEWSEnable)':Usr:'$($usrEWSEnable)': Mailbox HAS NO EWSEnable function"} ; 
    if(($false -eq $orgEWSEnable) -AND ($null -eq $usrEWSEnable -OR $true -eq $usrEWSEnable)){write-host "Org:'$($orgEWSEnable)':Usr:'$($usrEWSEnable)': Mailbox HAS NO EWSEnable function"} ; 
    if(($false -eq $orgEWSEnable) -AND ($false -eq $usrEWSEnable)){write-host "Org:'$($orgEWSEnable)':Usr:'$($usrEWSEnable)': Mailbox HAS NO EWSEnable function"} ; 
}

#*------^ test-xoMailboxHasEWSAccess.ps1 ^------


#*======^ END FUNCTIONS ^======

Export-ModuleMember -Function add-EXOLicense,check-EXOLegalHold,Connect-EXO,Test-Uri,connect-O365Services,get-CodeProfileAST,get-MGCodeCmdletPermissionsTDO,2b4,2b4c,fb4,convert-ADUserRecipientTypeRemoteSharedMailbox,convert-ADUserRecipientTypeRemoteUserMailbox,convert-exoMailboxTypeSharedMailbox,convert-exoMailboxTypeUserMailbox,convert-HistoricalSearchCSV,copy-XPermissionGroupToCloudOnly,cxoTOL,cxoTOR,Disconnect-EXO,get-AADlicensePlanList,get-ADUsersWithSoftDeletedxoMailboxes,get-ExoGxMTEventType,get-ExoMailboxLicenses,2b4,2b4c,fb4,get-ExoMessageTraceEventType,Get-EXOMessageTraceExportedTDO,Remove-InvalidVariableNameChars,Initialize-exoStatusTable,pull-GetxoMessageTraceDetail,2b4,2b4c,fb4,get-ExoMessageTraceSourceType,get-EXOMsgTraceDetailed,Remove-InvalidVariableNameChars,get-MailboxFolderStats,get-MsgTrace,Get-OrgNameFromUPN,get-xoHistSearch,_cleanup,get-XOMailboxFolderList,Get-xoMailboxFolderPermissionsRecursive,get-XOMailboxFolderPermissionsSummary,move-MailboxToXo,check-ReqMods,new-DgTor,_cleanup,new-xoDGFromProperty,remove-EXOLicense,Reset-xoMailboxFolderPermissionsRecursive,resolve-AppIDToCBAFriendlyName,resolve-Name,resolve-user,2b4,2b4c,fb4,resolve-RMbxForwards,get-xoMobileData,get-MgUserFull,Resolve-xoRcps,rxoTOL,rxoTOR,test-EXOConnectionTDO,test-ExoDnsRecordTDO,test-EXOIsLicensed,test-EXOv2Connection,test-xoMailbox,_cleanup,test-xoMailboxHasEWSAccess -Alias *




# SIG # Begin signature block
# MIIELgYJKoZIhvcNAQcCoIIEHzCCBBsCAQExCzAJBgUrDgMCGgUAMGkGCisGAQQB
# gjcCAQSgWzBZMDQGCisGAQQBgjcCAR4wJgIDAQAABBAfzDtgWUsITrck0sYpfvNR
# AgEAAgEAAgEAAgEAAgEAMCEwCQYFKw4DAhoFAAQUjPsK35dLLWgDYIUtAQ/9ntlQ
# 6FmgggI4MIICNDCCAaGgAwIBAgIQWsnStFUuSIVNR8uhNSlE6TAJBgUrDgMCHQUA
# MCwxKjAoBgNVBAMTIVBvd2VyU2hlbGwgTG9jYWwgQ2VydGlmaWNhdGUgUm9vdDAe
# Fw0xNDEyMjkxNzA3MzNaFw0zOTEyMzEyMzU5NTlaMBUxEzARBgNVBAMTClRvZGRT
# ZWxmSUkwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBALqRVt7uNweTkZZ+16QG
# a+NnFYNRPPa8Bnm071ohGe27jNWKPVUbDfd0OY2sqCBQCEFVb5pqcIECRRnlhN5H
# +EEJmm2x9AU0uS7IHxHeUo8fkW4vm49adkat5gAoOZOwbuNntBOAJy9LCyNs4F1I
# KKphP3TyDwe8XqsEVwB2m9FPAgMBAAGjdjB0MBMGA1UdJQQMMAoGCCsGAQUFBwMD
# MF0GA1UdAQRWMFSAEL95r+Rh65kgqZl+tgchMuKhLjAsMSowKAYDVQQDEyFQb3dl
# clNoZWxsIExvY2FsIENlcnRpZmljYXRlIFJvb3SCEGwiXbeZNci7Rxiz/r43gVsw
# CQYFKw4DAh0FAAOBgQB6ECSnXHUs7/bCr6Z556K6IDJNWsccjcV89fHA/zKMX0w0
# 6NefCtxas/QHUA9mS87HRHLzKjFqweA3BnQ5lr5mPDlho8U90Nvtpj58G9I5SPUg
# CspNr5jEHOL5EdJFBIv3zI2jQ8TPbFGC0Cz72+4oYzSxWpftNX41MmEsZkMaADGC
# AWAwggFcAgEBMEAwLDEqMCgGA1UEAxMhUG93ZXJTaGVsbCBMb2NhbCBDZXJ0aWZp
# Y2F0ZSBSb290AhBaydK0VS5IhU1Hy6E1KUTpMAkGBSsOAwIaBQCgeDAYBgorBgEE
# AYI3AgEMMQowCKACgAChAoAAMBkGCSqGSIb3DQEJAzEMBgorBgEEAYI3AgEEMBwG
# CisGAQQBgjcCAQsxDjAMBgorBgEEAYI3AgEVMCMGCSqGSIb3DQEJBDEWBBS7t4ql
# n8elNfAHRf/NuyGruU3f0TANBgkqhkiG9w0BAQEFAASBgKb8JY4LkmcbC0Rz0dUR
# RAsqn9YMzEl0cObeA6CXO9TtY0CDL9t2zpBoqPhj6ODKJPJCM/PYUEvYschv03p2
# 1I3IuBzCOUDOYPqZGa9mKho/OP9RywuuDnYGtAXIzA/40ml/GfNARSvXfwVmsG4b
# W7g8gK4jvT7ZL0eU4Crk6aSv
# SIG # End signature block
